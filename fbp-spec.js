
/**
 * Require the given path.
 *
 * @param {String} path
 * @return {Object} exports
 * @api public
 */

function require(path, parent, orig) {
  var resolved = require.resolve(path);

  // lookup failed
  if (null == resolved) {
    orig = orig || path;
    parent = parent || 'root';
    var err = new Error('Failed to require "' + orig + '" from "' + parent + '"');
    err.path = orig;
    err.parent = parent;
    err.require = true;
    throw err;
  }

  var module = require.modules[resolved];

  // perform real require()
  // by invoking the module's
  // registered function
  if (!module._resolving && !module.exports) {
    var mod = {};
    mod.exports = {};
    mod.client = mod.component = true;
    module._resolving = true;
    module.call(this, mod.exports, require.relative(resolved), mod);
    delete module._resolving;
    module.exports = mod.exports;
  }

  return module.exports;
}

/**
 * Registered modules.
 */

require.modules = {};

/**
 * Registered aliases.
 */

require.aliases = {};

/**
 * Resolve `path`.
 *
 * Lookup:
 *
 *   - PATH/index.js
 *   - PATH.js
 *   - PATH
 *
 * @param {String} path
 * @return {String} path or null
 * @api private
 */

require.resolve = function(path) {
  if (path.charAt(0) === '/') path = path.slice(1);

  var paths = [
    path,
    path + '.js',
    path + '.json',
    path + '/index.js',
    path + '/index.json'
  ];

  for (var i = 0; i < paths.length; i++) {
    var path = paths[i];
    if (require.modules.hasOwnProperty(path)) return path;
    if (require.aliases.hasOwnProperty(path)) return require.aliases[path];
  }
};

/**
 * Normalize `path` relative to the current path.
 *
 * @param {String} curr
 * @param {String} path
 * @return {String}
 * @api private
 */

require.normalize = function(curr, path) {
  var segs = [];

  if ('.' != path.charAt(0)) return path;

  curr = curr.split('/');
  path = path.split('/');

  for (var i = 0; i < path.length; ++i) {
    if ('..' == path[i]) {
      curr.pop();
    } else if ('.' != path[i] && '' != path[i]) {
      segs.push(path[i]);
    }
  }

  return curr.concat(segs).join('/');
};

/**
 * Register module at `path` with callback `definition`.
 *
 * @param {String} path
 * @param {Function} definition
 * @api private
 */

require.register = function(path, definition) {
  require.modules[path] = definition;
};

/**
 * Alias a module definition.
 *
 * @param {String} from
 * @param {String} to
 * @api private
 */

require.alias = function(from, to) {
  if (!require.modules.hasOwnProperty(from)) {
    throw new Error('Failed to alias "' + from + '", it does not exist');
  }
  require.aliases[to] = from;
};

/**
 * Return a require function relative to the `parent` path.
 *
 * @param {String} parent
 * @return {Function}
 * @api private
 */

require.relative = function(parent) {
  var p = require.normalize(parent, '..');

  /**
   * lastIndexOf helper.
   */

  function lastIndexOf(arr, obj) {
    var i = arr.length;
    while (i--) {
      if (arr[i] === obj) return i;
    }
    return -1;
  }

  /**
   * The relative require() itself.
   */

  function localRequire(path) {
    var resolved = localRequire.resolve(path);
    return require(resolved, parent, path);
  }

  /**
   * Resolve relative to the parent.
   */

  localRequire.resolve = function(path) {
    var c = path.charAt(0);
    if ('/' == c) return path.slice(1);
    if ('.' == c) return require.normalize(p, path);

    // resolve deps by returning
    // the dep in the nearest "deps"
    // directory
    var segs = parent.split('/');
    var i = lastIndexOf(segs, 'deps') + 1;
    if (!i) i = 0;
    path = segs.slice(0, i + 1).join('/') + '/deps/' + path;
    return path;
  };

  /**
   * Check if module is defined at `path`.
   */

  localRequire.exists = function(path) {
    return require.modules.hasOwnProperty(localRequire.resolve(path));
  };

  return localRequire;
};
require.register("bergie-emitter/index.js", function(exports, require, module){

/**
 * Expose `Emitter`.
 */

module.exports.EventEmitter = Emitter;

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks[event] = this._callbacks[event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  var self = this;
  this._callbacks = this._callbacks || {};

  function on() {
    self.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks[event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks[event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks[event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks[event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

});
require.register("jashkenas-underscore/underscore.js", function(exports, require, module){
//     Underscore.js 1.8.3
//     http://underscorejs.org
//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind,
    nativeCreate       = Object.create;

  // Naked function reference for surrogate-prototype-swapping.
  var Ctor = function(){};

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.8.3';

  // Internal function that returns an efficient (for current engines) version
  // of the passed-in callback, to be repeatedly applied in other Underscore
  // functions.
  var optimizeCb = function(func, context, argCount) {
    if (context === void 0) return func;
    switch (argCount == null ? 3 : argCount) {
      case 1: return function(value) {
        return func.call(context, value);
      };
      case 2: return function(value, other) {
        return func.call(context, value, other);
      };
      case 3: return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
    }
    return function() {
      return func.apply(context, arguments);
    };
  };

  // A mostly-internal function to generate callbacks that can be applied
  // to each element in a collection, returning the desired result — either
  // identity, an arbitrary callback, a property matcher, or a property accessor.
  var cb = function(value, context, argCount) {
    if (value == null) return _.identity;
    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
    if (_.isObject(value)) return _.matcher(value);
    return _.property(value);
  };
  _.iteratee = function(value, context) {
    return cb(value, context, Infinity);
  };

  // An internal function for creating assigner functions.
  var createAssigner = function(keysFunc, undefinedOnly) {
    return function(obj) {
      var length = arguments.length;
      if (length < 2 || obj == null) return obj;
      for (var index = 1; index < length; index++) {
        var source = arguments[index],
            keys = keysFunc(source),
            l = keys.length;
        for (var i = 0; i < l; i++) {
          var key = keys[i];
          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
        }
      }
      return obj;
    };
  };

  // An internal function for creating a new object that inherits from another.
  var baseCreate = function(prototype) {
    if (!_.isObject(prototype)) return {};
    if (nativeCreate) return nativeCreate(prototype);
    Ctor.prototype = prototype;
    var result = new Ctor;
    Ctor.prototype = null;
    return result;
  };

  var property = function(key) {
    return function(obj) {
      return obj == null ? void 0 : obj[key];
    };
  };

  // Helper for collection methods to determine whether a collection
  // should be iterated as an array or as an object
  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  var getLength = property('length');
  var isArrayLike = function(collection) {
    var length = getLength(collection);
    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
  };

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.
  _.each = _.forEach = function(obj, iteratee, context) {
    iteratee = optimizeCb(iteratee, context);
    var i, length;
    if (isArrayLike(obj)) {
      for (i = 0, length = obj.length; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var keys = _.keys(obj);
      for (i = 0, length = keys.length; i < length; i++) {
        iteratee(obj[keys[i]], keys[i], obj);
      }
    }
    return obj;
  };

  // Return the results of applying the iteratee to each element.
  _.map = _.collect = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length);
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Create a reducing function iterating left or right.
  function createReduce(dir) {
    // Optimized iterator function as using arguments.length
    // in the main function will deoptimize the, see #1991.
    function iterator(obj, iteratee, memo, keys, index, length) {
      for (; index >= 0 && index < length; index += dir) {
        var currentKey = keys ? keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }
      return memo;
    }

    return function(obj, iteratee, memo, context) {
      iteratee = optimizeCb(iteratee, context, 4);
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length,
          index = dir > 0 ? 0 : length - 1;
      // Determine the initial value if none is provided.
      if (arguments.length < 3) {
        memo = obj[keys ? keys[index] : index];
        index += dir;
      }
      return iterator(obj, iteratee, memo, keys, index, length);
    };
  }

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.
  _.reduce = _.foldl = _.inject = createReduce(1);

  // The right-associative version of reduce, also known as `foldr`.
  _.reduceRight = _.foldr = createReduce(-1);

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var key;
    if (isArrayLike(obj)) {
      key = _.findIndex(obj, predicate, context);
    } else {
      key = _.findKey(obj, predicate, context);
    }
    if (key !== void 0 && key !== -1) return obj[key];
  };

  // Return all the elements that pass a truth test.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);
    _.each(obj, function(value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, _.negate(cb(predicate)), context);
  };

  // Determine whether all of the elements match a truth test.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
  };

  // Determine if at least one element in the object matches a truth test.
  // Aliased as `any`.
  _.some = _.any = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
  };

  // Determine if the array or object contains a given item (using `===`).
  // Aliased as `includes` and `include`.
  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
    if (!isArrayLike(obj)) obj = _.values(obj);
    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
    return _.indexOf(obj, item, fromIndex) >= 0;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      var func = isFunc ? method : value[method];
      return func == null ? func : func.apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matcher(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matcher(attrs));
  };

  // Return the maximum element (or element-based computation).
  _.max = function(obj, iteratee, context) {
    var result = -Infinity, lastComputed = -Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value > result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iteratee, context) {
    var result = Infinity, lastComputed = Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value < result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed < lastComputed || computed === Infinity && result === Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Shuffle a collection, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
  _.shuffle = function(obj) {
    var set = isArrayLike(obj) ? obj : _.values(obj);
    var length = set.length;
    var shuffled = Array(length);
    for (var index = 0, rand; index < length; index++) {
      rand = _.random(0, index);
      if (rand !== index) shuffled[index] = shuffled[rand];
      shuffled[rand] = set[index];
    }
    return shuffled;
  };

  // Sample **n** random values from a collection.
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (!isArrayLike(obj)) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // Sort the object's values by a criterion produced by an iteratee.
  _.sortBy = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iteratee(value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, iteratee, context) {
      var result = {};
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index) {
        var key = iteratee(value, index, obj);
        behavior(result, value, key);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, value, key) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key]++; else result[key] = 1;
  });

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (isArrayLike(obj)) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
  };

  // Split a collection into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var pass = [], fail = [];
    _.each(obj, function(value, key, obj) {
      (predicate(value, key, obj) ? pass : fail).push(value);
    });
    return [pass, fail];
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[0];
    return _.initial(array, array.length - n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[array.length - 1];
    return _.rest(array, Math.max(0, array.length - n));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, strict, startIndex) {
    var output = [], idx = 0;
    for (var i = startIndex || 0, length = getLength(input); i < length; i++) {
      var value = input[i];
      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
        //flatten current level of array or arguments object
        if (!shallow) value = flatten(value, shallow, strict);
        var j = 0, len = value.length;
        output.length += len;
        while (j < len) {
          output[idx++] = value[j++];
        }
      } else if (!strict) {
        output[idx++] = value;
      }
    }
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, false);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
    if (!_.isBoolean(isSorted)) {
      context = iteratee;
      iteratee = isSorted;
      isSorted = false;
    }
    if (iteratee != null) iteratee = cb(iteratee, context);
    var result = [];
    var seen = [];
    for (var i = 0, length = getLength(array); i < length; i++) {
      var value = array[i],
          computed = iteratee ? iteratee(value, i, array) : value;
      if (isSorted) {
        if (!i || seen !== computed) result.push(value);
        seen = computed;
      } else if (iteratee) {
        if (!_.contains(seen, computed)) {
          seen.push(computed);
          result.push(value);
        }
      } else if (!_.contains(result, value)) {
        result.push(value);
      }
    }
    return result;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(flatten(arguments, true, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var result = [];
    var argsLength = arguments.length;
    for (var i = 0, length = getLength(array); i < length; i++) {
      var item = array[i];
      if (_.contains(result, item)) continue;
      for (var j = 1; j < argsLength; j++) {
        if (!_.contains(arguments[j], item)) break;
      }
      if (j === argsLength) result.push(item);
    }
    return result;
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = flatten(arguments, true, true, 1);
    return _.filter(array, function(value){
      return !_.contains(rest, value);
    });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    return _.unzip(arguments);
  };

  // Complement of _.zip. Unzip accepts an array of arrays and groups
  // each array's elements on shared indices
  _.unzip = function(array) {
    var length = array && _.max(array, getLength).length || 0;
    var result = Array(length);

    for (var index = 0; index < length; index++) {
      result[index] = _.pluck(array, index);
    }
    return result;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    var result = {};
    for (var i = 0, length = getLength(list); i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // Generator function to create the findIndex and findLastIndex functions
  function createPredicateIndexFinder(dir) {
    return function(array, predicate, context) {
      predicate = cb(predicate, context);
      var length = getLength(array);
      var index = dir > 0 ? 0 : length - 1;
      for (; index >= 0 && index < length; index += dir) {
        if (predicate(array[index], index, array)) return index;
      }
      return -1;
    };
  }

  // Returns the first index on an array-like that passes a predicate test
  _.findIndex = createPredicateIndexFinder(1);
  _.findLastIndex = createPredicateIndexFinder(-1);

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iteratee, context) {
    iteratee = cb(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0, high = getLength(array);
    while (low < high) {
      var mid = Math.floor((low + high) / 2);
      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
    }
    return low;
  };

  // Generator function to create the indexOf and lastIndexOf functions
  function createIndexFinder(dir, predicateFind, sortedIndex) {
    return function(array, item, idx) {
      var i = 0, length = getLength(array);
      if (typeof idx == 'number') {
        if (dir > 0) {
            i = idx >= 0 ? idx : Math.max(idx + length, i);
        } else {
            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
        }
      } else if (sortedIndex && idx && length) {
        idx = sortedIndex(array, item);
        return array[idx] === item ? idx : -1;
      }
      if (item !== item) {
        idx = predicateFind(slice.call(array, i, length), _.isNaN);
        return idx >= 0 ? idx + i : -1;
      }
      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
        if (array[idx] === item) return idx;
      }
      return -1;
    };
  }

  // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (stop == null) {
      stop = start || 0;
      start = 0;
    }
    step = step || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);

    for (var idx = 0; idx < length; idx++, start += step) {
      range[idx] = start;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Determines whether to execute a function as a constructor
  // or a normal function with the provided arguments
  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
    var self = baseCreate(sourceFunc.prototype);
    var result = sourceFunc.apply(self, args);
    if (_.isObject(result)) return result;
    return self;
  };

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
    var args = slice.call(arguments, 2);
    var bound = function() {
      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
    };
    return bound;
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder, allowing any combination of arguments to be pre-filled.
  _.partial = function(func) {
    var boundArgs = slice.call(arguments, 1);
    var bound = function() {
      var position = 0, length = boundArgs.length;
      var args = Array(length);
      for (var i = 0; i < length; i++) {
        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return executeBound(func, bound, this, this, args);
    };
    return bound;
  };

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = function(obj) {
    var i, length = arguments.length, key;
    if (length <= 1) throw new Error('bindAll must be passed function names');
    for (i = 1; i < length; i++) {
      key = arguments[i];
      obj[key] = _.bind(obj[key], obj);
    }
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memoize = function(key) {
      var cache = memoize.cache;
      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
      return cache[address];
    };
    memoize.cache = {};
    return memoize;
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){
      return func.apply(null, args);
    }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = _.partial(_.delay, _, 1);

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    if (!options) options = {};
    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };
    return function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;

    var later = function() {
      var last = _.now() - timestamp;

      if (last < wait && last >= 0) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        }
      }
    };

    return function() {
      context = this;
      args = arguments;
      timestamp = _.now();
      var callNow = immediate && !timeout;
      if (!timeout) timeout = setTimeout(later, wait);
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a negated version of the passed-in predicate.
  _.negate = function(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var args = arguments;
    var start = args.length - 1;
    return function() {
      var i = start;
      var result = args[start].apply(this, arguments);
      while (i--) result = args[i].call(this, result);
      return result;
    };
  };

  // Returns a function that will only be executed on and after the Nth call.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Returns a function that will only be executed up to (but not including) the Nth call.
  _.before = function(times, func) {
    var memo;
    return function() {
      if (--times > 0) {
        memo = func.apply(this, arguments);
      }
      if (times <= 1) func = null;
      return memo;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = _.partial(_.before, 2);

  // Object Functions
  // ----------------

  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

  function collectNonEnumProps(obj, keys) {
    var nonEnumIdx = nonEnumerableProps.length;
    var constructor = obj.constructor;
    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;

    // Constructor is a special case.
    var prop = 'constructor';
    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

    while (nonEnumIdx--) {
      prop = nonEnumerableProps[nonEnumIdx];
      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
        keys.push(prop);
      }
    }
  }

  // Retrieve the names of an object's own properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve all the property names of an object.
  _.allKeys = function(obj) {
    if (!_.isObject(obj)) return [];
    var keys = [];
    for (var key in obj) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Returns the results of applying the iteratee to each element of the object
  // In contrast to _.map it returns an object
  _.mapObject = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys =  _.keys(obj),
          length = keys.length,
          results = {},
          currentKey;
      for (var index = 0; index < length; index++) {
        currentKey = keys[index];
        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
      }
      return results;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = createAssigner(_.allKeys);

  // Assigns a given object with all the own properties in the passed-in object(s)
  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
  _.extendOwn = _.assign = createAssigner(_.keys);

  // Returns the first key on an object that passes a predicate test
  _.findKey = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = _.keys(obj), key;
    for (var i = 0, length = keys.length; i < length; i++) {
      key = keys[i];
      if (predicate(obj[key], key, obj)) return key;
    }
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(object, oiteratee, context) {
    var result = {}, obj = object, iteratee, keys;
    if (obj == null) return result;
    if (_.isFunction(oiteratee)) {
      keys = _.allKeys(obj);
      iteratee = optimizeCb(oiteratee, context);
    } else {
      keys = flatten(arguments, false, false, 1);
      iteratee = function(value, key, obj) { return key in obj; };
      obj = Object(obj);
    }
    for (var i = 0, length = keys.length; i < length; i++) {
      var key = keys[i];
      var value = obj[key];
      if (iteratee(value, key, obj)) result[key] = value;
    }
    return result;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj, iteratee, context) {
    if (_.isFunction(iteratee)) {
      iteratee = _.negate(iteratee);
    } else {
      var keys = _.map(flatten(arguments, false, false, 1), String);
      iteratee = function(value, key) {
        return !_.contains(keys, key);
      };
    }
    return _.pick(obj, iteratee, context);
  };

  // Fill in a given object with default properties.
  _.defaults = createAssigner(_.allKeys, true);

  // Creates an object that inherits from the given prototype object.
  // If additional properties are provided then they will be added to the
  // created object.
  _.create = function(prototype, props) {
    var result = baseCreate(prototype);
    if (props) _.extendOwn(result, props);
    return result;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Returns whether an object has a given set of `key:value` pairs.
  _.isMatch = function(object, attrs) {
    var keys = _.keys(attrs), length = keys.length;
    if (object == null) return !length;
    var obj = Object(object);
    for (var i = 0; i < length; i++) {
      var key = keys[i];
      if (attrs[key] !== obj[key] || !(key in obj)) return false;
    }
    return true;
  };


  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
      case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return '' + a === '' + b;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive.
        // Object(NaN) is equivalent to NaN
        if (+a !== +a) return +b !== +b;
        // An `egal` comparison is performed for other numeric values.
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a === +b;
    }

    var areArrays = className === '[object Array]';
    if (!areArrays) {
      if (typeof a != 'object' || typeof b != 'object') return false;

      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
                               _.isFunction(bCtor) && bCtor instanceof bCtor)
                          && ('constructor' in a && 'constructor' in b)) {
        return false;
      }
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] === a) return bStack[length] === b;
    }

    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);

    // Recursively compare objects and arrays.
    if (areArrays) {
      // Compare array lengths to determine if a deep comparison is necessary.
      length = a.length;
      if (length !== b.length) return false;
      // Deep compare the contents, ignoring non-numeric properties.
      while (length--) {
        if (!eq(a[length], b[length], aStack, bStack)) return false;
      }
    } else {
      // Deep compare objects.
      var keys = _.keys(a), key;
      length = keys.length;
      // Ensure that both objects contain the same number of properties before comparing deep equality.
      if (_.keys(b).length !== length) return false;
      while (length--) {
        // Deep compare each member
        key = keys[length];
        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
    return _.keys(obj).length === 0;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) === '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) === '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE < 9), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return _.has(obj, 'callee');
    };
  }

  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
  // IE 11 (#1621), and in Safari 8 (#1929).
  if (typeof /./ != 'function' && typeof Int8Array != 'object') {
    _.isFunction = function(obj) {
      return typeof obj == 'function' || false;
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj !== +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return obj != null && hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iteratees.
  _.identity = function(value) {
    return value;
  };

  // Predicate-generating functions. Often useful outside of Underscore.
  _.constant = function(value) {
    return function() {
      return value;
    };
  };

  _.noop = function(){};

  _.property = property;

  // Generates a function for a given object that returns a given property.
  _.propertyOf = function(obj) {
    return obj == null ? function(){} : function(key) {
      return obj[key];
    };
  };

  // Returns a predicate for checking whether an object has a given set of
  // `key:value` pairs.
  _.matcher = _.matches = function(attrs) {
    attrs = _.extendOwn({}, attrs);
    return function(obj) {
      return _.isMatch(obj, attrs);
    };
  };

  // Run a function **n** times.
  _.times = function(n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = optimizeCb(iteratee, context, 1);
    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() {
    return new Date().getTime();
  };

   // List of HTML entities for escaping.
  var escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };
  var unescapeMap = _.invert(escapeMap);

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  var createEscaper = function(map) {
    var escaper = function(match) {
      return map[match];
    };
    // Regexes for identifying a key that needs to be escaped
    var source = '(?:' + _.keys(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function(string) {
      string = string == null ? '' : '' + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  };
  _.escape = createEscaper(escapeMap);
  _.unescape = createEscaper(unescapeMap);

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property, fallback) {
    var value = object == null ? void 0 : object[property];
    if (value === void 0) {
      value = fallback;
    }
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

  var escapeChar = function(match) {
    return '\\' + escapes[match];
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  // NB: `oldSettings` only exists for backwards compatibility.
  _.template = function(text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escaper, escapeChar);
      index = offset + match.length;

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }

      // Adobe VMs need the match returned to produce the correct offest.
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + 'return __p;\n';

    try {
      var render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled source as a convenience for precompilation.
    var argument = settings.variable || 'obj';
    template.source = 'function(' + argument + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function. Start chaining a wrapped Underscore object.
  _.chain = function(obj) {
    var instance = _(obj);
    instance._chain = true;
    return instance;
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(instance, obj) {
    return instance._chain ? _(obj).chain() : obj;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    _.each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result(this, func.apply(_, args));
      };
    });
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
      return result(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  _.each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result(this, method.apply(this._wrapped, arguments));
    };
  });

  // Extracts the result from a wrapped and chained object.
  _.prototype.value = function() {
    return this._wrapped;
  };

  // Provide unwrapping proxy for some methods used in engine operations
  // such as arithmetic and JSON stringification.
  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

  _.prototype.toString = function() {
    return '' + this._wrapped;
  };

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (typeof define === 'function' && define.amd) {
    define('underscore', [], function() {
      return _;
    });
  }
}.call(this));

});
require.register("noflo-noflo/component.json", function(exports, require, module){
module.exports = JSON.parse('{"name":"noflo","description":"Flow-Based Programming environment for JavaScript","keywords":["fbp","workflow","flow"],"repo":"noflo/noflo","version":"0.5.22","dependencies":{"bergie/emitter":"*","jashkenas/underscore":"1.8.3","flowbased/fbp":"*"},"remotes":["https://raw.githubusercontent.com"],"development":{},"license":"MIT","main":"src/lib/NoFlo.js","scripts":["src/lib/Graph.js","src/lib/InternalSocket.js","src/lib/IP.js","src/lib/BasePort.js","src/lib/InPort.js","src/lib/OutPort.js","src/lib/Ports.js","src/lib/Port.js","src/lib/ArrayPort.js","src/lib/Component.js","src/lib/AsyncComponent.js","src/lib/ComponentLoader.js","src/lib/NoFlo.js","src/lib/Network.js","src/lib/Platform.js","src/lib/Journal.js","src/lib/Utils.js","src/lib/Helpers.js","src/lib/Streams.js","src/components/Graph.js"],"json":["component.json"],"noflo":{"components":{"Graph":"src/components/Graph.js"}}}');
});
require.register("noflo-noflo/src/lib/Graph.js", function(exports, require, module){
var EventEmitter, Graph, clone, mergeResolveTheirsNaive, platform, resetGraph,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

EventEmitter = require('events').EventEmitter;

clone = require('./Utils').clone;

platform = require('./Platform');

Graph = (function(superClass) {
  extend(Graph, superClass);

  Graph.prototype.name = '';

  Graph.prototype.properties = {};

  Graph.prototype.nodes = [];

  Graph.prototype.edges = [];

  Graph.prototype.initializers = [];

  Graph.prototype.exports = [];

  Graph.prototype.inports = {};

  Graph.prototype.outports = {};

  Graph.prototype.groups = [];

  function Graph(name1) {
    this.name = name1 != null ? name1 : '';
    this.properties = {};
    this.nodes = [];
    this.edges = [];
    this.initializers = [];
    this.exports = [];
    this.inports = {};
    this.outports = {};
    this.groups = [];
    this.transaction = {
      id: null,
      depth: 0
    };
  }

  Graph.prototype.startTransaction = function(id, metadata) {
    if (this.transaction.id) {
      throw Error("Nested transactions not supported");
    }
    this.transaction.id = id;
    this.transaction.depth = 1;
    return this.emit('startTransaction', id, metadata);
  };

  Graph.prototype.endTransaction = function(id, metadata) {
    if (!this.transaction.id) {
      throw Error("Attempted to end non-existing transaction");
    }
    this.transaction.id = null;
    this.transaction.depth = 0;
    return this.emit('endTransaction', id, metadata);
  };

  Graph.prototype.checkTransactionStart = function() {
    if (!this.transaction.id) {
      return this.startTransaction('implicit');
    } else if (this.transaction.id === 'implicit') {
      return this.transaction.depth += 1;
    }
  };

  Graph.prototype.checkTransactionEnd = function() {
    if (this.transaction.id === 'implicit') {
      this.transaction.depth -= 1;
    }
    if (this.transaction.depth === 0) {
      return this.endTransaction('implicit');
    }
  };

  Graph.prototype.setProperties = function(properties) {
    var before, item, val;
    this.checkTransactionStart();
    before = clone(this.properties);
    for (item in properties) {
      val = properties[item];
      this.properties[item] = val;
    }
    this.emit('changeProperties', this.properties, before);
    return this.checkTransactionEnd();
  };

  Graph.prototype.addExport = function(publicPort, nodeKey, portKey, metadata) {
    var exported;
    if (metadata == null) {
      metadata = {
        x: 0,
        y: 0
      };
    }
    if (!this.getNode(nodeKey)) {
      return;
    }
    this.checkTransactionStart();
    exported = {
      "public": publicPort.toLowerCase(),
      process: nodeKey,
      port: portKey.toLowerCase(),
      metadata: metadata
    };
    this.exports.push(exported);
    this.emit('addExport', exported);
    return this.checkTransactionEnd();
  };

  Graph.prototype.removeExport = function(publicPort) {
    var exported, found, i, idx, len, ref;
    publicPort = publicPort.toLowerCase();
    found = null;
    ref = this.exports;
    for (idx = i = 0, len = ref.length; i < len; idx = ++i) {
      exported = ref[idx];
      if (exported["public"] === publicPort) {
        found = exported;
      }
    }
    if (!found) {
      return;
    }
    this.checkTransactionStart();
    this.exports.splice(this.exports.indexOf(found), 1);
    this.emit('removeExport', found);
    return this.checkTransactionEnd();
  };

  Graph.prototype.addInport = function(publicPort, nodeKey, portKey, metadata) {
    if (!this.getNode(nodeKey)) {
      return;
    }
    publicPort = publicPort.toLowerCase();
    this.checkTransactionStart();
    this.inports[publicPort] = {
      process: nodeKey,
      port: portKey.toLowerCase(),
      metadata: metadata
    };
    this.emit('addInport', publicPort, this.inports[publicPort]);
    return this.checkTransactionEnd();
  };

  Graph.prototype.removeInport = function(publicPort) {
    var port;
    publicPort = publicPort.toLowerCase();
    if (!this.inports[publicPort]) {
      return;
    }
    this.checkTransactionStart();
    port = this.inports[publicPort];
    this.setInportMetadata(publicPort, {});
    delete this.inports[publicPort];
    this.emit('removeInport', publicPort, port);
    return this.checkTransactionEnd();
  };

  Graph.prototype.renameInport = function(oldPort, newPort) {
    oldPort = oldPort.toLowerCase();
    newPort = newPort.toLowerCase();
    if (!this.inports[oldPort]) {
      return;
    }
    this.checkTransactionStart();
    this.inports[newPort] = this.inports[oldPort];
    delete this.inports[oldPort];
    this.emit('renameInport', oldPort, newPort);
    return this.checkTransactionEnd();
  };

  Graph.prototype.setInportMetadata = function(publicPort, metadata) {
    var before, item, val;
    publicPort = publicPort.toLowerCase();
    if (!this.inports[publicPort]) {
      return;
    }
    this.checkTransactionStart();
    before = clone(this.inports[publicPort].metadata);
    if (!this.inports[publicPort].metadata) {
      this.inports[publicPort].metadata = {};
    }
    for (item in metadata) {
      val = metadata[item];
      if (val != null) {
        this.inports[publicPort].metadata[item] = val;
      } else {
        delete this.inports[publicPort].metadata[item];
      }
    }
    this.emit('changeInport', publicPort, this.inports[publicPort], before);
    return this.checkTransactionEnd();
  };

  Graph.prototype.addOutport = function(publicPort, nodeKey, portKey, metadata) {
    if (!this.getNode(nodeKey)) {
      return;
    }
    publicPort = publicPort.toLowerCase();
    this.checkTransactionStart();
    this.outports[publicPort] = {
      process: nodeKey,
      port: portKey.toLowerCase(),
      metadata: metadata
    };
    this.emit('addOutport', publicPort, this.outports[publicPort]);
    return this.checkTransactionEnd();
  };

  Graph.prototype.removeOutport = function(publicPort) {
    var port;
    publicPort = publicPort.toLowerCase();
    if (!this.outports[publicPort]) {
      return;
    }
    this.checkTransactionStart();
    port = this.outports[publicPort];
    this.setOutportMetadata(publicPort, {});
    delete this.outports[publicPort];
    this.emit('removeOutport', publicPort, port);
    return this.checkTransactionEnd();
  };

  Graph.prototype.renameOutport = function(oldPort, newPort) {
    oldPort = oldPort.toLowerCase();
    newPort = newPort.toLowerCase();
    if (!this.outports[oldPort]) {
      return;
    }
    this.checkTransactionStart();
    this.outports[newPort] = this.outports[oldPort];
    delete this.outports[oldPort];
    this.emit('renameOutport', oldPort, newPort);
    return this.checkTransactionEnd();
  };

  Graph.prototype.setOutportMetadata = function(publicPort, metadata) {
    var before, item, val;
    publicPort = publicPort.toLowerCase();
    if (!this.outports[publicPort]) {
      return;
    }
    this.checkTransactionStart();
    before = clone(this.outports[publicPort].metadata);
    if (!this.outports[publicPort].metadata) {
      this.outports[publicPort].metadata = {};
    }
    for (item in metadata) {
      val = metadata[item];
      if (val != null) {
        this.outports[publicPort].metadata[item] = val;
      } else {
        delete this.outports[publicPort].metadata[item];
      }
    }
    this.emit('changeOutport', publicPort, this.outports[publicPort], before);
    return this.checkTransactionEnd();
  };

  Graph.prototype.addGroup = function(group, nodes, metadata) {
    var g;
    this.checkTransactionStart();
    g = {
      name: group,
      nodes: nodes,
      metadata: metadata
    };
    this.groups.push(g);
    this.emit('addGroup', g);
    return this.checkTransactionEnd();
  };

  Graph.prototype.renameGroup = function(oldName, newName) {
    var group, i, len, ref;
    this.checkTransactionStart();
    ref = this.groups;
    for (i = 0, len = ref.length; i < len; i++) {
      group = ref[i];
      if (!group) {
        continue;
      }
      if (group.name !== oldName) {
        continue;
      }
      group.name = newName;
      this.emit('renameGroup', oldName, newName);
    }
    return this.checkTransactionEnd();
  };

  Graph.prototype.removeGroup = function(groupName) {
    var group, i, len, ref;
    this.checkTransactionStart();
    ref = this.groups;
    for (i = 0, len = ref.length; i < len; i++) {
      group = ref[i];
      if (!group) {
        continue;
      }
      if (group.name !== groupName) {
        continue;
      }
      this.setGroupMetadata(group.name, {});
      this.groups.splice(this.groups.indexOf(group), 1);
      this.emit('removeGroup', group);
    }
    return this.checkTransactionEnd();
  };

  Graph.prototype.setGroupMetadata = function(groupName, metadata) {
    var before, group, i, item, len, ref, val;
    this.checkTransactionStart();
    ref = this.groups;
    for (i = 0, len = ref.length; i < len; i++) {
      group = ref[i];
      if (!group) {
        continue;
      }
      if (group.name !== groupName) {
        continue;
      }
      before = clone(group.metadata);
      for (item in metadata) {
        val = metadata[item];
        if (val != null) {
          group.metadata[item] = val;
        } else {
          delete group.metadata[item];
        }
      }
      this.emit('changeGroup', group, before);
    }
    return this.checkTransactionEnd();
  };

  Graph.prototype.addNode = function(id, component, metadata) {
    var node;
    this.checkTransactionStart();
    if (!metadata) {
      metadata = {};
    }
    node = {
      id: id,
      component: component,
      metadata: metadata
    };
    this.nodes.push(node);
    this.emit('addNode', node);
    this.checkTransactionEnd();
    return node;
  };

  Graph.prototype.removeNode = function(id) {
    var edge, exported, group, i, index, initializer, j, k, l, len, len1, len2, len3, len4, len5, len6, len7, len8, m, n, node, o, p, priv, pub, q, ref, ref1, ref2, ref3, ref4, ref5, toRemove;
    node = this.getNode(id);
    if (!node) {
      return;
    }
    this.checkTransactionStart();
    toRemove = [];
    ref = this.edges;
    for (i = 0, len = ref.length; i < len; i++) {
      edge = ref[i];
      if ((edge.from.node === node.id) || (edge.to.node === node.id)) {
        toRemove.push(edge);
      }
    }
    for (j = 0, len1 = toRemove.length; j < len1; j++) {
      edge = toRemove[j];
      this.removeEdge(edge.from.node, edge.from.port, edge.to.node, edge.to.port);
    }
    toRemove = [];
    ref1 = this.initializers;
    for (k = 0, len2 = ref1.length; k < len2; k++) {
      initializer = ref1[k];
      if (initializer.to.node === node.id) {
        toRemove.push(initializer);
      }
    }
    for (l = 0, len3 = toRemove.length; l < len3; l++) {
      initializer = toRemove[l];
      this.removeInitial(initializer.to.node, initializer.to.port);
    }
    toRemove = [];
    ref2 = this.exports;
    for (m = 0, len4 = ref2.length; m < len4; m++) {
      exported = ref2[m];
      if (id.toLowerCase() === exported.process) {
        toRemove.push(exported);
      }
    }
    for (n = 0, len5 = toRemove.length; n < len5; n++) {
      exported = toRemove[n];
      this.removeExport(exported["public"]);
    }
    toRemove = [];
    ref3 = this.inports;
    for (pub in ref3) {
      priv = ref3[pub];
      if (priv.process === id) {
        toRemove.push(pub);
      }
    }
    for (o = 0, len6 = toRemove.length; o < len6; o++) {
      pub = toRemove[o];
      this.removeInport(pub);
    }
    toRemove = [];
    ref4 = this.outports;
    for (pub in ref4) {
      priv = ref4[pub];
      if (priv.process === id) {
        toRemove.push(pub);
      }
    }
    for (p = 0, len7 = toRemove.length; p < len7; p++) {
      pub = toRemove[p];
      this.removeOutport(pub);
    }
    ref5 = this.groups;
    for (q = 0, len8 = ref5.length; q < len8; q++) {
      group = ref5[q];
      if (!group) {
        continue;
      }
      index = group.nodes.indexOf(id);
      if (index === -1) {
        continue;
      }
      group.nodes.splice(index, 1);
    }
    this.setNodeMetadata(id, {});
    if (-1 !== this.nodes.indexOf(node)) {
      this.nodes.splice(this.nodes.indexOf(node), 1);
    }
    this.emit('removeNode', node);
    return this.checkTransactionEnd();
  };

  Graph.prototype.getNode = function(id) {
    var i, len, node, ref;
    ref = this.nodes;
    for (i = 0, len = ref.length; i < len; i++) {
      node = ref[i];
      if (!node) {
        continue;
      }
      if (node.id === id) {
        return node;
      }
    }
    return null;
  };

  Graph.prototype.renameNode = function(oldId, newId) {
    var edge, exported, group, i, iip, index, j, k, l, len, len1, len2, len3, node, priv, pub, ref, ref1, ref2, ref3, ref4, ref5;
    this.checkTransactionStart();
    node = this.getNode(oldId);
    if (!node) {
      return;
    }
    node.id = newId;
    ref = this.edges;
    for (i = 0, len = ref.length; i < len; i++) {
      edge = ref[i];
      if (!edge) {
        continue;
      }
      if (edge.from.node === oldId) {
        edge.from.node = newId;
      }
      if (edge.to.node === oldId) {
        edge.to.node = newId;
      }
    }
    ref1 = this.initializers;
    for (j = 0, len1 = ref1.length; j < len1; j++) {
      iip = ref1[j];
      if (!iip) {
        continue;
      }
      if (iip.to.node === oldId) {
        iip.to.node = newId;
      }
    }
    ref2 = this.inports;
    for (pub in ref2) {
      priv = ref2[pub];
      if (priv.process === oldId) {
        priv.process = newId;
      }
    }
    ref3 = this.outports;
    for (pub in ref3) {
      priv = ref3[pub];
      if (priv.process === oldId) {
        priv.process = newId;
      }
    }
    ref4 = this.exports;
    for (k = 0, len2 = ref4.length; k < len2; k++) {
      exported = ref4[k];
      if (exported.process === oldId) {
        exported.process = newId;
      }
    }
    ref5 = this.groups;
    for (l = 0, len3 = ref5.length; l < len3; l++) {
      group = ref5[l];
      if (!group) {
        continue;
      }
      index = group.nodes.indexOf(oldId);
      if (index === -1) {
        continue;
      }
      group.nodes[index] = newId;
    }
    this.emit('renameNode', oldId, newId);
    return this.checkTransactionEnd();
  };

  Graph.prototype.setNodeMetadata = function(id, metadata) {
    var before, item, node, val;
    node = this.getNode(id);
    if (!node) {
      return;
    }
    this.checkTransactionStart();
    before = clone(node.metadata);
    if (!node.metadata) {
      node.metadata = {};
    }
    for (item in metadata) {
      val = metadata[item];
      if (val != null) {
        node.metadata[item] = val;
      } else {
        delete node.metadata[item];
      }
    }
    this.emit('changeNode', node, before);
    return this.checkTransactionEnd();
  };

  Graph.prototype.addEdge = function(outNode, outPort, inNode, inPort, metadata) {
    var edge, i, len, ref;
    if (metadata == null) {
      metadata = {};
    }
    outPort = outPort.toLowerCase();
    inPort = inPort.toLowerCase();
    ref = this.edges;
    for (i = 0, len = ref.length; i < len; i++) {
      edge = ref[i];
      if (edge.from.node === outNode && edge.from.port === outPort && edge.to.node === inNode && edge.to.port === inPort) {
        return;
      }
    }
    if (!this.getNode(outNode)) {
      return;
    }
    if (!this.getNode(inNode)) {
      return;
    }
    this.checkTransactionStart();
    edge = {
      from: {
        node: outNode,
        port: outPort
      },
      to: {
        node: inNode,
        port: inPort
      },
      metadata: metadata
    };
    this.edges.push(edge);
    this.emit('addEdge', edge);
    this.checkTransactionEnd();
    return edge;
  };

  Graph.prototype.addEdgeIndex = function(outNode, outPort, outIndex, inNode, inPort, inIndex, metadata) {
    var edge;
    if (metadata == null) {
      metadata = {};
    }
    if (!this.getNode(outNode)) {
      return;
    }
    if (!this.getNode(inNode)) {
      return;
    }
    outPort = outPort.toLowerCase();
    inPort = inPort.toLowerCase();
    if (inIndex === null) {
      inIndex = void 0;
    }
    if (outIndex === null) {
      outIndex = void 0;
    }
    if (!metadata) {
      metadata = {};
    }
    this.checkTransactionStart();
    edge = {
      from: {
        node: outNode,
        port: outPort,
        index: outIndex
      },
      to: {
        node: inNode,
        port: inPort,
        index: inIndex
      },
      metadata: metadata
    };
    this.edges.push(edge);
    this.emit('addEdge', edge);
    this.checkTransactionEnd();
    return edge;
  };

  Graph.prototype.removeEdge = function(node, port, node2, port2) {
    var edge, i, index, j, k, len, len1, len2, ref, ref1, toKeep, toRemove;
    this.checkTransactionStart();
    port = port.toLowerCase();
    port2 = port2.toLowerCase();
    toRemove = [];
    toKeep = [];
    if (node2 && port2) {
      ref = this.edges;
      for (index = i = 0, len = ref.length; i < len; index = ++i) {
        edge = ref[index];
        if (edge.from.node === node && edge.from.port === port && edge.to.node === node2 && edge.to.port === port2) {
          this.setEdgeMetadata(edge.from.node, edge.from.port, edge.to.node, edge.to.port, {});
          toRemove.push(edge);
        } else {
          toKeep.push(edge);
        }
      }
    } else {
      ref1 = this.edges;
      for (index = j = 0, len1 = ref1.length; j < len1; index = ++j) {
        edge = ref1[index];
        if ((edge.from.node === node && edge.from.port === port) || (edge.to.node === node && edge.to.port === port)) {
          this.setEdgeMetadata(edge.from.node, edge.from.port, edge.to.node, edge.to.port, {});
          toRemove.push(edge);
        } else {
          toKeep.push(edge);
        }
      }
    }
    this.edges = toKeep;
    for (k = 0, len2 = toRemove.length; k < len2; k++) {
      edge = toRemove[k];
      this.emit('removeEdge', edge);
    }
    return this.checkTransactionEnd();
  };

  Graph.prototype.getEdge = function(node, port, node2, port2) {
    var edge, i, index, len, ref;
    port = port.toLowerCase();
    port2 = port2.toLowerCase();
    ref = this.edges;
    for (index = i = 0, len = ref.length; i < len; index = ++i) {
      edge = ref[index];
      if (!edge) {
        continue;
      }
      if (edge.from.node === node && edge.from.port === port) {
        if (edge.to.node === node2 && edge.to.port === port2) {
          return edge;
        }
      }
    }
    return null;
  };

  Graph.prototype.setEdgeMetadata = function(node, port, node2, port2, metadata) {
    var before, edge, item, val;
    edge = this.getEdge(node, port, node2, port2);
    if (!edge) {
      return;
    }
    this.checkTransactionStart();
    before = clone(edge.metadata);
    if (!edge.metadata) {
      edge.metadata = {};
    }
    for (item in metadata) {
      val = metadata[item];
      if (val != null) {
        edge.metadata[item] = val;
      } else {
        delete edge.metadata[item];
      }
    }
    this.emit('changeEdge', edge, before);
    return this.checkTransactionEnd();
  };

  Graph.prototype.addInitial = function(data, node, port, metadata) {
    var initializer;
    if (!this.getNode(node)) {
      return;
    }
    port = port.toLowerCase();
    this.checkTransactionStart();
    initializer = {
      from: {
        data: data
      },
      to: {
        node: node,
        port: port
      },
      metadata: metadata
    };
    this.initializers.push(initializer);
    this.emit('addInitial', initializer);
    this.checkTransactionEnd();
    return initializer;
  };

  Graph.prototype.addInitialIndex = function(data, node, port, index, metadata) {
    var initializer;
    if (!this.getNode(node)) {
      return;
    }
    if (index === null) {
      index = void 0;
    }
    port = port.toLowerCase();
    this.checkTransactionStart();
    initializer = {
      from: {
        data: data
      },
      to: {
        node: node,
        port: port,
        index: index
      },
      metadata: metadata
    };
    this.initializers.push(initializer);
    this.emit('addInitial', initializer);
    this.checkTransactionEnd();
    return initializer;
  };

  Graph.prototype.addGraphInitial = function(data, node, metadata) {
    var inport;
    inport = this.inports[node];
    if (!inport) {
      return;
    }
    return this.addInitial(data, inport.process, inport.port, metadata);
  };

  Graph.prototype.addGraphInitialIndex = function(data, node, index, metadata) {
    var inport;
    inport = this.inports[node];
    if (!inport) {
      return;
    }
    return this.addInitialIndex(data, inport.process, inport.port, index, metadata);
  };

  Graph.prototype.removeInitial = function(node, port) {
    var edge, i, index, j, len, len1, ref, toKeep, toRemove;
    port = port.toLowerCase();
    this.checkTransactionStart();
    toRemove = [];
    toKeep = [];
    ref = this.initializers;
    for (index = i = 0, len = ref.length; i < len; index = ++i) {
      edge = ref[index];
      if (edge.to.node === node && edge.to.port === port) {
        toRemove.push(edge);
      } else {
        toKeep.push(edge);
      }
    }
    this.initializers = toKeep;
    for (j = 0, len1 = toRemove.length; j < len1; j++) {
      edge = toRemove[j];
      this.emit('removeInitial', edge);
    }
    return this.checkTransactionEnd();
  };

  Graph.prototype.removeGraphInitial = function(node) {
    var inport;
    inport = this.inports[node];
    if (!inport) {
      return;
    }
    return this.removeInitial(inport.process, inport.port);
  };

  Graph.prototype.toDOT = function() {
    var cleanID, cleanPort, data, dot, edge, i, id, initializer, j, k, len, len1, len2, node, ref, ref1, ref2;
    cleanID = function(id) {
      return id.replace(/\s*/g, "");
    };
    cleanPort = function(port) {
      return port.replace(/\./g, "");
    };
    dot = "digraph {\n";
    ref = this.nodes;
    for (i = 0, len = ref.length; i < len; i++) {
      node = ref[i];
      dot += "    " + (cleanID(node.id)) + " [label=" + node.id + " shape=box]\n";
    }
    ref1 = this.initializers;
    for (id = j = 0, len1 = ref1.length; j < len1; id = ++j) {
      initializer = ref1[id];
      if (typeof initializer.from.data === 'function') {
        data = 'Function';
      } else {
        data = initializer.from.data;
      }
      dot += "    data" + id + " [label=\"'" + data + "'\" shape=plaintext]\n";
      dot += "    data" + id + " -> " + (cleanID(initializer.to.node)) + "[headlabel=" + (cleanPort(initializer.to.port)) + " labelfontcolor=blue labelfontsize=8.0]\n";
    }
    ref2 = this.edges;
    for (k = 0, len2 = ref2.length; k < len2; k++) {
      edge = ref2[k];
      dot += "    " + (cleanID(edge.from.node)) + " -> " + (cleanID(edge.to.node)) + "[taillabel=" + (cleanPort(edge.from.port)) + " headlabel=" + (cleanPort(edge.to.port)) + " labelfontcolor=blue labelfontsize=8.0]\n";
    }
    dot += "}";
    return dot;
  };

  Graph.prototype.toYUML = function() {
    var edge, i, initializer, j, len, len1, ref, ref1, yuml;
    yuml = [];
    ref = this.initializers;
    for (i = 0, len = ref.length; i < len; i++) {
      initializer = ref[i];
      yuml.push("(start)[" + initializer.to.port + "]->(" + initializer.to.node + ")");
    }
    ref1 = this.edges;
    for (j = 0, len1 = ref1.length; j < len1; j++) {
      edge = ref1[j];
      yuml.push("(" + edge.from.node + ")[" + edge.from.port + "]->(" + edge.to.node + ")");
    }
    return yuml.join(",");
  };

  Graph.prototype.toJSON = function() {
    var connection, edge, exported, group, groupData, i, initializer, j, json, k, l, len, len1, len2, len3, len4, m, node, priv, property, pub, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, value;
    json = {
      properties: {},
      inports: {},
      outports: {},
      groups: [],
      processes: {},
      connections: []
    };
    if (this.name) {
      json.properties.name = this.name;
    }
    ref = this.properties;
    for (property in ref) {
      value = ref[property];
      json.properties[property] = value;
    }
    ref1 = this.inports;
    for (pub in ref1) {
      priv = ref1[pub];
      json.inports[pub] = priv;
    }
    ref2 = this.outports;
    for (pub in ref2) {
      priv = ref2[pub];
      json.outports[pub] = priv;
    }
    ref3 = this.exports;
    for (i = 0, len = ref3.length; i < len; i++) {
      exported = ref3[i];
      if (!json.exports) {
        json.exports = [];
      }
      json.exports.push(exported);
    }
    ref4 = this.groups;
    for (j = 0, len1 = ref4.length; j < len1; j++) {
      group = ref4[j];
      groupData = {
        name: group.name,
        nodes: group.nodes
      };
      if (Object.keys(group.metadata).length) {
        groupData.metadata = group.metadata;
      }
      json.groups.push(groupData);
    }
    ref5 = this.nodes;
    for (k = 0, len2 = ref5.length; k < len2; k++) {
      node = ref5[k];
      json.processes[node.id] = {
        component: node.component
      };
      if (node.metadata) {
        json.processes[node.id].metadata = node.metadata;
      }
    }
    ref6 = this.edges;
    for (l = 0, len3 = ref6.length; l < len3; l++) {
      edge = ref6[l];
      connection = {
        src: {
          process: edge.from.node,
          port: edge.from.port,
          index: edge.from.index
        },
        tgt: {
          process: edge.to.node,
          port: edge.to.port,
          index: edge.to.index
        }
      };
      if (Object.keys(edge.metadata).length) {
        connection.metadata = edge.metadata;
      }
      json.connections.push(connection);
    }
    ref7 = this.initializers;
    for (m = 0, len4 = ref7.length; m < len4; m++) {
      initializer = ref7[m];
      json.connections.push({
        data: initializer.from.data,
        tgt: {
          process: initializer.to.node,
          port: initializer.to.port,
          index: initializer.to.index
        }
      });
    }
    return json;
  };

  Graph.prototype.save = function(file, callback) {
    var json;
    json = JSON.stringify(this.toJSON(), null, 4);
    return require('fs').writeFile(file + ".json", json, "utf-8", function(err, data) {
      if (err) {
        throw err;
      }
      return callback(file);
    });
  };

  return Graph;

})(EventEmitter);

exports.Graph = Graph;

exports.createGraph = function(name) {
  return new Graph(name);
};

exports.loadJSON = function(definition, callback, metadata) {
  var conn, def, exported, graph, group, i, id, j, k, len, len1, len2, portId, priv, processId, properties, property, pub, ref, ref1, ref2, ref3, ref4, ref5, ref6, split, value;
  if (metadata == null) {
    metadata = {};
  }
  if (typeof definition === 'string') {
    definition = JSON.parse(definition);
  }
  if (!definition.properties) {
    definition.properties = {};
  }
  if (!definition.processes) {
    definition.processes = {};
  }
  if (!definition.connections) {
    definition.connections = [];
  }
  graph = new Graph(definition.properties.name);
  graph.startTransaction('loadJSON', metadata);
  properties = {};
  ref = definition.properties;
  for (property in ref) {
    value = ref[property];
    if (property === 'name') {
      continue;
    }
    properties[property] = value;
  }
  graph.setProperties(properties);
  ref1 = definition.processes;
  for (id in ref1) {
    def = ref1[id];
    if (!def.metadata) {
      def.metadata = {};
    }
    graph.addNode(id, def.component, def.metadata);
  }
  ref2 = definition.connections;
  for (i = 0, len = ref2.length; i < len; i++) {
    conn = ref2[i];
    metadata = conn.metadata ? conn.metadata : {};
    if (conn.data !== void 0) {
      if (typeof conn.tgt.index === 'number') {
        graph.addInitialIndex(conn.data, conn.tgt.process, conn.tgt.port.toLowerCase(), conn.tgt.index, metadata);
      } else {
        graph.addInitial(conn.data, conn.tgt.process, conn.tgt.port.toLowerCase(), metadata);
      }
      continue;
    }
    if (typeof conn.src.index === 'number' || typeof conn.tgt.index === 'number') {
      graph.addEdgeIndex(conn.src.process, conn.src.port.toLowerCase(), conn.src.index, conn.tgt.process, conn.tgt.port.toLowerCase(), conn.tgt.index, metadata);
      continue;
    }
    graph.addEdge(conn.src.process, conn.src.port.toLowerCase(), conn.tgt.process, conn.tgt.port.toLowerCase(), metadata);
  }
  if (definition.exports && definition.exports.length) {
    ref3 = definition.exports;
    for (j = 0, len1 = ref3.length; j < len1; j++) {
      exported = ref3[j];
      if (exported["private"]) {
        split = exported["private"].split('.');
        if (split.length !== 2) {
          continue;
        }
        processId = split[0];
        portId = split[1];
        for (id in definition.processes) {
          if (id.toLowerCase() === processId.toLowerCase()) {
            processId = id;
          }
        }
      } else {
        processId = exported.process;
        portId = exported.port.toLowerCase();
      }
      graph.addExport(exported["public"], processId, portId, exported.metadata);
    }
  }
  if (definition.inports) {
    ref4 = definition.inports;
    for (pub in ref4) {
      priv = ref4[pub];
      graph.addInport(pub, priv.process, priv.port.toLowerCase(), priv.metadata);
    }
  }
  if (definition.outports) {
    ref5 = definition.outports;
    for (pub in ref5) {
      priv = ref5[pub];
      graph.addOutport(pub, priv.process, priv.port.toLowerCase(), priv.metadata);
    }
  }
  if (definition.groups) {
    ref6 = definition.groups;
    for (k = 0, len2 = ref6.length; k < len2; k++) {
      group = ref6[k];
      graph.addGroup(group.name, group.nodes, group.metadata || {});
    }
  }
  graph.endTransaction('loadJSON');
  return callback(null, graph);
};

exports.loadFBP = function(fbpData, callback) {
  var definition, e, error;
  try {
    definition = require('fbp').parse(fbpData);
  } catch (error) {
    e = error;
    return callback(e);
  }
  return exports.loadJSON(definition, callback);
};

exports.loadHTTP = function(url, callback) {
  var req;
  req = new XMLHttpRequest;
  req.onreadystatechange = function() {
    if (req.readyState !== 4) {
      return;
    }
    if (req.status !== 200) {
      return callback(new Error("Failed to load " + url + ": HTTP " + req.status));
    }
    return callback(null, req.responseText);
  };
  req.open('GET', url, true);
  return req.send();
};

exports.loadFile = function(file, callback, metadata) {
  var definition, e, error;
  if (metadata == null) {
    metadata = {};
  }
  if (platform.isBrowser()) {
    try {
      definition = require(file);
    } catch (error) {
      e = error;
      exports.loadHTTP(file, function(err, data) {
        if (err) {
          return callback(err);
        }
        if (file.split('.').pop() === 'fbp') {
          return exports.loadFBP(data, callback, metadata);
        }
        definition = JSON.parse(data);
        return exports.loadJSON(definition, callback, metadata);
      });
      return;
    }
    exports.loadJSON(definition, callback, metadata);
    return;
  }
  return require('fs').readFile(file, "utf-8", function(err, data) {
    if (err) {
      return callback(err);
    }
    if (file.split('.').pop() === 'fbp') {
      return exports.loadFBP(data, callback);
    }
    definition = JSON.parse(data);
    return exports.loadJSON(definition, callback);
  });
};

resetGraph = function(graph) {
  var edge, exp, group, i, iip, j, k, l, len, len1, len2, len3, len4, m, node, port, ref, ref1, ref2, ref3, ref4, ref5, ref6, results, v;
  ref = (clone(graph.groups)).reverse();
  for (i = 0, len = ref.length; i < len; i++) {
    group = ref[i];
    if (group != null) {
      graph.removeGroup(group.name);
    }
  }
  ref1 = clone(graph.outports);
  for (port in ref1) {
    v = ref1[port];
    graph.removeOutport(port);
  }
  ref2 = clone(graph.inports);
  for (port in ref2) {
    v = ref2[port];
    graph.removeInport(port);
  }
  ref3 = clone(graph.exports.reverse());
  for (j = 0, len1 = ref3.length; j < len1; j++) {
    exp = ref3[j];
    graph.removeExport(exp["public"]);
  }
  graph.setProperties({});
  ref4 = (clone(graph.initializers)).reverse();
  for (k = 0, len2 = ref4.length; k < len2; k++) {
    iip = ref4[k];
    graph.removeInitial(iip.to.node, iip.to.port);
  }
  ref5 = (clone(graph.edges)).reverse();
  for (l = 0, len3 = ref5.length; l < len3; l++) {
    edge = ref5[l];
    graph.removeEdge(edge.from.node, edge.from.port, edge.to.node, edge.to.port);
  }
  ref6 = (clone(graph.nodes)).reverse();
  results = [];
  for (m = 0, len4 = ref6.length; m < len4; m++) {
    node = ref6[m];
    results.push(graph.removeNode(node.id));
  }
  return results;
};

mergeResolveTheirsNaive = function(base, to) {
  var edge, exp, group, i, iip, j, k, l, len, len1, len2, len3, len4, m, node, priv, pub, ref, ref1, ref2, ref3, ref4, ref5, ref6, results;
  resetGraph(base);
  ref = to.nodes;
  for (i = 0, len = ref.length; i < len; i++) {
    node = ref[i];
    base.addNode(node.id, node.component, node.metadata);
  }
  ref1 = to.edges;
  for (j = 0, len1 = ref1.length; j < len1; j++) {
    edge = ref1[j];
    base.addEdge(edge.from.node, edge.from.port, edge.to.node, edge.to.port, edge.metadata);
  }
  ref2 = to.initializers;
  for (k = 0, len2 = ref2.length; k < len2; k++) {
    iip = ref2[k];
    base.addInitial(iip.from.data, iip.to.node, iip.to.port, iip.metadata);
  }
  ref3 = to.exports;
  for (l = 0, len3 = ref3.length; l < len3; l++) {
    exp = ref3[l];
    base.addExport(exp["public"], exp.node, exp.port, exp.metadata);
  }
  base.setProperties(to.properties);
  ref4 = to.inports;
  for (pub in ref4) {
    priv = ref4[pub];
    base.addInport(pub, priv.process, priv.port, priv.metadata);
  }
  ref5 = to.outports;
  for (pub in ref5) {
    priv = ref5[pub];
    base.addOutport(pub, priv.process, priv.port, priv.metadata);
  }
  ref6 = to.groups;
  results = [];
  for (m = 0, len4 = ref6.length; m < len4; m++) {
    group = ref6[m];
    results.push(base.addGroup(group.name, group.nodes, group.metadata));
  }
  return results;
};

exports.equivalent = function(a, b, options) {
  var A, B;
  if (options == null) {
    options = {};
  }
  A = JSON.stringify(a);
  B = JSON.stringify(b);
  return A === B;
};

exports.mergeResolveTheirs = mergeResolveTheirsNaive;

});
require.register("noflo-noflo/src/lib/InternalSocket.js", function(exports, require, module){
var EventEmitter, InternalSocket,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

EventEmitter = require('events').EventEmitter;

InternalSocket = (function(superClass) {
  extend(InternalSocket, superClass);

  InternalSocket.prototype.regularEmitEvent = function(event, data) {
    return this.emit(event, data);
  };

  InternalSocket.prototype.debugEmitEvent = function(event, data) {
    var error, error1;
    try {
      return this.emit(event, data);
    } catch (error1) {
      error = error1;
      if (this.listeners('error').length === 0) {
        throw error;
      }
      return this.emit('error', {
        id: this.to.process.id,
        error: error,
        metadata: this.metadata
      });
    }
  };

  function InternalSocket(metadata) {
    this.metadata = metadata != null ? metadata : {};
    this.connected = false;
    this.groups = [];
    this.dataDelegate = null;
    this.debug = false;
    this.emitEvent = this.regularEmitEvent;
  }

  InternalSocket.prototype.connect = function() {
    if (this.connected) {
      return;
    }
    this.connected = true;
    return this.emitEvent('connect', this);
  };

  InternalSocket.prototype.disconnect = function() {
    if (!this.connected) {
      return;
    }
    this.connected = false;
    return this.emitEvent('disconnect', this);
  };

  InternalSocket.prototype.isConnected = function() {
    return this.connected;
  };

  InternalSocket.prototype.send = function(data) {
    if (!this.connected) {
      this.connect();
    }
    if (data === void 0 && typeof this.dataDelegate === 'function') {
      data = this.dataDelegate();
    }
    return this.emitEvent('data', data);
  };

  InternalSocket.prototype.post = function(data) {
    if (data === void 0 && typeof this.dataDelegate === 'function') {
      data = this.dataDelegate();
    }
    return this.emitEvent('data', data);
  };

  InternalSocket.prototype.beginGroup = function(group) {
    this.groups.push(group);
    return this.emitEvent('begingroup', group);
  };

  InternalSocket.prototype.endGroup = function() {
    if (!this.groups.length) {
      return;
    }
    return this.emitEvent('endgroup', this.groups.pop());
  };

  InternalSocket.prototype.setDataDelegate = function(delegate) {
    if (typeof delegate !== 'function') {
      throw Error('A data delegate must be a function.');
    }
    return this.dataDelegate = delegate;
  };

  InternalSocket.prototype.setDebug = function(active) {
    this.debug = active;
    return this.emitEvent = this.debug ? this.debugEmitEvent : this.regularEmitEvent;
  };

  InternalSocket.prototype.getId = function() {
    var fromStr, toStr;
    fromStr = function(from) {
      return from.process.id + "() " + (from.port.toUpperCase());
    };
    toStr = function(to) {
      return (to.port.toUpperCase()) + " " + to.process.id + "()";
    };
    if (!(this.from || this.to)) {
      return "UNDEFINED";
    }
    if (this.from && !this.to) {
      return (fromStr(this.from)) + " -> ANON";
    }
    if (!this.from) {
      return "DATA -> " + (toStr(this.to));
    }
    return (fromStr(this.from)) + " -> " + (toStr(this.to));
  };

  return InternalSocket;

})(EventEmitter);

exports.InternalSocket = InternalSocket;

exports.createSocket = function() {
  return new InternalSocket;
};

});
require.register("noflo-noflo/src/lib/IP.js", function(exports, require, module){
var IP;

module.exports = IP = (function() {
  IP.types = ['data', 'openBracket', 'closeBracket'];

  function IP(type, data, options) {
    var key, val;
    this.type = type != null ? type : 'data';
    this.data = data != null ? data : null;
    if (options == null) {
      options = {};
    }
    this.groups = [];
    this.scope = null;
    this.owner = null;
    this.clonable = false;
    this.index = null;
    for (key in options) {
      val = options[key];
      this[key] = val;
    }
  }

  IP.prototype.clone = function() {
    var ip, key, val;
    ip = new IP(this.type);
    for (key in this) {
      val = this[key];
      if (['owner'].indexOf(key) !== -1) {
        continue;
      }
      if (val === null) {
        continue;
      }
      if (typeof val === 'object') {
        ip[key] = JSON.parse(JSON.stringify(val));
      } else {
        ip[key] = val;
      }
    }
    return ip;
  };

  IP.prototype.move = function(owner) {
    this.owner = owner;
  };

  IP.prototype.drop = function() {
    var key, results, val;
    results = [];
    for (key in this) {
      val = this[key];
      results.push(delete this[key]);
    }
    return results;
  };

  return IP;

})();

});
require.register("noflo-noflo/src/lib/BasePort.js", function(exports, require, module){
var BasePort, EventEmitter, validTypes,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

EventEmitter = require('events').EventEmitter;

validTypes = ['all', 'string', 'number', 'int', 'object', 'array', 'boolean', 'color', 'date', 'bang', 'function', 'buffer'];

BasePort = (function(superClass) {
  extend(BasePort, superClass);

  function BasePort(options) {
    this.handleOptions(options);
    this.sockets = [];
    this.node = null;
    this.name = null;
  }

  BasePort.prototype.handleOptions = function(options) {
    if (!options) {
      options = {};
    }
    if (!options.datatype) {
      options.datatype = 'all';
    }
    if (options.required === void 0) {
      options.required = false;
    }
    if (options.datatype === 'integer') {
      options.datatype = 'int';
    }
    if (validTypes.indexOf(options.datatype) === -1) {
      throw new Error("Invalid port datatype '" + options.datatype + "' specified, valid are " + (validTypes.join(', ')));
    }
    if (options.type && options.type.indexOf('/') === -1) {
      throw new Error("Invalid port type '" + options.type + "' specified. Should be URL or MIME type");
    }
    return this.options = options;
  };

  BasePort.prototype.getId = function() {
    if (!(this.node && this.name)) {
      return 'Port';
    }
    return this.node + " " + (this.name.toUpperCase());
  };

  BasePort.prototype.getDataType = function() {
    return this.options.datatype;
  };

  BasePort.prototype.getDescription = function() {
    return this.options.description;
  };

  BasePort.prototype.attach = function(socket, index) {
    if (index == null) {
      index = null;
    }
    if (!this.isAddressable() || index === null) {
      index = this.sockets.length;
    }
    this.sockets[index] = socket;
    this.attachSocket(socket, index);
    if (this.isAddressable()) {
      this.emit('attach', socket, index);
      return;
    }
    return this.emit('attach', socket);
  };

  BasePort.prototype.attachSocket = function() {};

  BasePort.prototype.detach = function(socket) {
    var index;
    index = this.sockets.indexOf(socket);
    if (index === -1) {
      return;
    }
    this.sockets[index] = void 0;
    if (this.isAddressable()) {
      this.emit('detach', socket, index);
      return;
    }
    return this.emit('detach', socket);
  };

  BasePort.prototype.isAddressable = function() {
    if (this.options.addressable) {
      return true;
    }
    return false;
  };

  BasePort.prototype.isBuffered = function() {
    if (this.options.buffered) {
      return true;
    }
    return false;
  };

  BasePort.prototype.isRequired = function() {
    if (this.options.required) {
      return true;
    }
    return false;
  };

  BasePort.prototype.isAttached = function(socketId) {
    if (socketId == null) {
      socketId = null;
    }
    if (this.isAddressable() && socketId !== null) {
      if (this.sockets[socketId]) {
        return true;
      }
      return false;
    }
    if (this.sockets.length) {
      return true;
    }
    return false;
  };

  BasePort.prototype.listAttached = function() {
    var attached, i, idx, len, ref, socket;
    attached = [];
    ref = this.sockets;
    for (idx = i = 0, len = ref.length; i < len; idx = ++i) {
      socket = ref[idx];
      if (!socket) {
        continue;
      }
      attached.push(idx);
    }
    return attached;
  };

  BasePort.prototype.isConnected = function(socketId) {
    var connected;
    if (socketId == null) {
      socketId = null;
    }
    if (this.isAddressable()) {
      if (socketId === null) {
        throw new Error((this.getId()) + ": Socket ID required");
      }
      if (!this.sockets[socketId]) {
        throw new Error((this.getId()) + ": Socket " + socketId + " not available");
      }
      return this.sockets[socketId].isConnected();
    }
    connected = false;
    this.sockets.forEach((function(_this) {
      return function(socket) {
        if (!socket) {
          return;
        }
        if (socket.isConnected()) {
          return connected = true;
        }
      };
    })(this));
    return connected;
  };

  BasePort.prototype.canAttach = function() {
    return true;
  };

  return BasePort;

})(EventEmitter);

module.exports = BasePort;

});
require.register("noflo-noflo/src/lib/InPort.js", function(exports, require, module){
var BasePort, IP, InPort,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

BasePort = require('./BasePort');

IP = require('./IP');

InPort = (function(superClass) {
  extend(InPort, superClass);

  function InPort(options, process) {
    this.process = null;
    if (!process && typeof options === 'function') {
      process = options;
      options = {};
    }
    if (options == null) {
      options = {};
    }
    if (options.buffered == null) {
      options.buffered = false;
    }
    if (options.control == null) {
      options.control = false;
    }
    if (options.triggering == null) {
      options.triggering = true;
    }
    if (!process && options && options.process) {
      process = options.process;
      delete options.process;
    }
    if (process) {
      if (typeof process !== 'function') {
        throw new Error('process must be a function');
      }
      this.process = process;
    }
    if (options.handle) {
      if (typeof options.handle !== 'function') {
        throw new Error('handle must be a function');
      }
      this.handle = options.handle;
      delete options.handle;
    }
    InPort.__super__.constructor.call(this, options);
    this.prepareBuffer();
  }

  InPort.prototype.attachSocket = function(socket, localId) {
    if (localId == null) {
      localId = null;
    }
    if (this.hasDefault()) {
      if (this.handle) {
        socket.setDataDelegate((function(_this) {
          return function() {
            return new IP('data', _this.options["default"]);
          };
        })(this));
      } else {
        socket.setDataDelegate((function(_this) {
          return function() {
            return _this.options["default"];
          };
        })(this));
      }
    }
    socket.on('connect', (function(_this) {
      return function() {
        return _this.handleSocketEvent('connect', socket, localId);
      };
    })(this));
    socket.on('begingroup', (function(_this) {
      return function(group) {
        return _this.handleSocketEvent('begingroup', group, localId);
      };
    })(this));
    socket.on('data', (function(_this) {
      return function(data) {
        _this.validateData(data);
        return _this.handleSocketEvent('data', data, localId);
      };
    })(this));
    socket.on('endgroup', (function(_this) {
      return function(group) {
        return _this.handleSocketEvent('endgroup', group, localId);
      };
    })(this));
    return socket.on('disconnect', (function(_this) {
      return function() {
        return _this.handleSocketEvent('disconnect', socket, localId);
      };
    })(this));
  };

  InPort.prototype.handleSocketEvent = function(event, payload, id) {
    var buf, ip;
    if (this.isBuffered()) {
      this.buffer.push({
        event: event,
        payload: payload,
        id: id
      });
      if (this.isAddressable()) {
        if (this.process) {
          this.process(event, id, this.nodeInstance);
        }
        this.emit(event, id);
      } else {
        if (this.process) {
          this.process(event, this.nodeInstance);
        }
        this.emit(event);
      }
      return;
    }
    if (event === 'data' && typeof payload === 'object' && IP.types.indexOf(payload.type) !== -1) {
      ip = payload;
    } else {
      switch (event) {
        case 'connect':
        case 'begingroup':
          ip = new IP('openBracket', payload);
          break;
        case 'disconnect':
        case 'endgroup':
          ip = new IP('closeBracket');
          break;
        default:
          ip = new IP('data', payload);
      }
    }
    ip.owner = this.nodeInstance;
    ip.index = id;
    if (!(this.process || this.handle || this.options.buffered)) {
      if (ip.scope) {
        if (!(ip.scope in this.scopedBuffer)) {
          this.scopedBuffer[ip.scope] = [];
        }
        buf = this.scopedBuffer[ip.scope];
      } else {
        buf = this.buffer;
      }
      buf.push(ip);
      if (this.options.control && buf.length > 1) {
        buf.shift();
      }
    }
    if (this.handle) {
      this.handle(ip, this.nodeInstance);
    }
    if (this.process) {
      if (!this.braceCount) {
        this.braceCount = [];
      }
      if (!this.braceCount[id]) {
        this.braceCount[id] = 0;
      }
      this.isUnwrapped = false;
      if (event === 'data' && typeof payload === 'object' && IP.types.indexOf(payload.type) !== -1) {
        switch (payload.type) {
          case 'openBracket':
            event = this.braceCount[id] === 0 ? 'connect' : 'begingroup';
            payload = payload.data;
            this.braceCount[id]++;
            break;
          case 'closeBracket':
            this.braceCount[id]--;
            event = this.braceCount[id] === 0 ? 'disconnect' : 'endgroup';
            payload = null;
            break;
          default:
            event = 'data';
            payload = payload.data;
            if (this.braceCount[id] === 0) {
              this.isUnwrapped = true;
            }
        }
      }
      if (this.isAddressable()) {
        if (this.isUnwrapped) {
          this.process('connect', null, id, this.nodeInstance);
        }
        this.process(event, payload, id, this.nodeInstance);
        if (this.isUnwrapped) {
          this.process('disconnect', null, id, this.nodeInstance);
        }
      } else {
        if (this.isUnwrapped) {
          this.process('connect', null, this.nodeInstance);
        }
        this.process(event, payload, this.nodeInstance);
        if (this.isUnwrapped) {
          this.process('disconnect', null, this.nodeInstance);
        }
      }
    }
    if (this.isAddressable()) {
      return this.emit(event, payload, id);
    }
    this.emit(event, payload);
    return this.emit('ip', ip);
  };

  InPort.prototype.hasDefault = function() {
    return this.options["default"] !== void 0;
  };

  InPort.prototype.prepareBuffer = function() {
    this.buffer = [];
    return this.scopedBuffer = {};
  };

  InPort.prototype.validateData = function(data) {
    if (!this.options.values) {
      return;
    }
    if (this.options.values.indexOf(data) === -1) {
      throw new Error("Invalid data='" + data + "' received, not in [" + this.options.values + "]");
    }
  };

  InPort.prototype.receive = function() {
    if (!this.isBuffered()) {
      throw new Error('Receive is only possible on buffered ports');
    }
    return this.buffer.shift();
  };

  InPort.prototype.contains = function() {
    if (!this.isBuffered()) {
      throw new Error('Contains query is only possible on buffered ports');
    }
    return this.buffer.filter(function(packet) {
      if (packet.event === 'data') {
        return true;
      }
    }).length;
  };

  InPort.prototype.get = function(scope) {
    var buf;
    if (scope) {
      if (!(scope in this.scopedBuffer)) {
        return void 0;
      }
      buf = this.scopedBuffer[scope];
    } else {
      buf = this.buffer;
    }
    if (this.options.control) {
      return buf[buf.length - 1];
    } else {
      return buf.shift();
    }
  };

  InPort.prototype.length = function(scope) {
    if (scope) {
      if (!(scope in this.scopedBuffer)) {
        return 0;
      }
      return this.scopedBuffer[scope].length;
    }
    return this.buffer.length;
  };

  InPort.prototype.ready = function(scope) {
    return this.length(scope) > 0;
  };

  return InPort;

})(BasePort);

module.exports = InPort;

});
require.register("noflo-noflo/src/lib/OutPort.js", function(exports, require, module){
var BasePort, IP, OutPort,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

BasePort = require('./BasePort');

IP = require('./IP');

OutPort = (function(superClass) {
  extend(OutPort, superClass);

  function OutPort(options) {
    this.cache = {};
    OutPort.__super__.constructor.call(this, options);
  }

  OutPort.prototype.attach = function(socket, index) {
    if (index == null) {
      index = null;
    }
    OutPort.__super__.attach.call(this, socket, index);
    if (this.isCaching() && (this.cache[index] != null)) {
      return this.send(this.cache[index], index);
    }
  };

  OutPort.prototype.connect = function(socketId) {
    var i, len, results, socket, sockets;
    if (socketId == null) {
      socketId = null;
    }
    sockets = this.getSockets(socketId);
    this.checkRequired(sockets);
    results = [];
    for (i = 0, len = sockets.length; i < len; i++) {
      socket = sockets[i];
      if (!socket) {
        continue;
      }
      results.push(socket.connect());
    }
    return results;
  };

  OutPort.prototype.beginGroup = function(group, socketId) {
    var sockets;
    if (socketId == null) {
      socketId = null;
    }
    sockets = this.getSockets(socketId);
    this.checkRequired(sockets);
    return sockets.forEach(function(socket) {
      if (!socket) {
        return;
      }
      if (socket.isConnected()) {
        return socket.beginGroup(group);
      }
      socket.once('connect', function() {
        return socket.beginGroup(group);
      });
      return socket.connect();
    });
  };

  OutPort.prototype.send = function(data, socketId) {
    var sockets;
    if (socketId == null) {
      socketId = null;
    }
    sockets = this.getSockets(socketId);
    this.checkRequired(sockets);
    if (this.isCaching() && data !== this.cache[socketId]) {
      this.cache[socketId] = data;
    }
    return sockets.forEach(function(socket) {
      if (!socket) {
        return;
      }
      if (socket.isConnected()) {
        return socket.send(data);
      }
      socket.once('connect', function() {
        return socket.send(data);
      });
      return socket.connect();
    });
  };

  OutPort.prototype.endGroup = function(socketId) {
    var i, len, results, socket, sockets;
    if (socketId == null) {
      socketId = null;
    }
    sockets = this.getSockets(socketId);
    this.checkRequired(sockets);
    results = [];
    for (i = 0, len = sockets.length; i < len; i++) {
      socket = sockets[i];
      if (!socket) {
        continue;
      }
      results.push(socket.endGroup());
    }
    return results;
  };

  OutPort.prototype.disconnect = function(socketId) {
    var i, len, results, socket, sockets;
    if (socketId == null) {
      socketId = null;
    }
    sockets = this.getSockets(socketId);
    this.checkRequired(sockets);
    results = [];
    for (i = 0, len = sockets.length; i < len; i++) {
      socket = sockets[i];
      if (!socket) {
        continue;
      }
      results.push(socket.disconnect());
    }
    return results;
  };

  OutPort.prototype.sendIP = function(type, data, options, socketId) {
    var i, ip, len, pristine, ref, socket, sockets;
    if (typeof type === 'object' && IP.types.indexOf(type).type !== -1) {
      ip = type;
      socketId = ip.index;
    } else {
      ip = new IP(type, data, options);
    }
    sockets = this.getSockets(socketId);
    this.checkRequired(sockets);
    if (this.isCaching() && data !== ((ref = this.cache[socketId]) != null ? ref.data : void 0)) {
      this.cache[socketId] = ip;
    }
    pristine = true;
    for (i = 0, len = sockets.length; i < len; i++) {
      socket = sockets[i];
      if (!socket) {
        continue;
      }
      if (pristine) {
        socket.post(ip);
        pristine = false;
      } else {
        socket.post(ip.clonable ? ip.clone() : ip);
      }
    }
    return this;
  };

  OutPort.prototype.openBracket = function(data, options, socketId) {
    if (data == null) {
      data = null;
    }
    if (options == null) {
      options = {};
    }
    if (socketId == null) {
      socketId = null;
    }
    return this.sendIP('openBracket', data, options, socketId);
  };

  OutPort.prototype.data = function(data, options, socketId) {
    if (options == null) {
      options = {};
    }
    if (socketId == null) {
      socketId = null;
    }
    return this.sendIP('data', data, options, socketId);
  };

  OutPort.prototype.closeBracket = function(data, options, socketId) {
    if (data == null) {
      data = null;
    }
    if (options == null) {
      options = {};
    }
    if (socketId == null) {
      socketId = null;
    }
    return this.sendIP('closeBracket', data, options, socketId);
  };

  OutPort.prototype.checkRequired = function(sockets) {
    if (sockets.length === 0 && this.isRequired()) {
      throw new Error((this.getId()) + ": No connections available");
    }
  };

  OutPort.prototype.getSockets = function(socketId) {
    if (this.isAddressable()) {
      if (socketId === null) {
        throw new Error((this.getId()) + " Socket ID required");
      }
      if (!this.sockets[socketId]) {
        return [];
      }
      return [this.sockets[socketId]];
    }
    return this.sockets;
  };

  OutPort.prototype.isCaching = function() {
    if (this.options.caching) {
      return true;
    }
    return false;
  };

  return OutPort;

})(BasePort);

module.exports = OutPort;

});
require.register("noflo-noflo/src/lib/Ports.js", function(exports, require, module){
var EventEmitter, InPort, InPorts, OutPort, OutPorts, Ports,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

EventEmitter = require('events').EventEmitter;

InPort = require('./InPort');

OutPort = require('./OutPort');

Ports = (function(superClass) {
  extend(Ports, superClass);

  Ports.prototype.model = InPort;

  function Ports(ports) {
    var name, options;
    this.ports = {};
    if (!ports) {
      return;
    }
    for (name in ports) {
      options = ports[name];
      this.add(name, options);
    }
  }

  Ports.prototype.add = function(name, options, process) {
    if (name === 'add' || name === 'remove') {
      throw new Error('Add and remove are restricted port names');
    }
    if (!name.match(/^[a-z0-9_\.\/]+$/)) {
      throw new Error("Port names can only contain lowercase alphanumeric characters and underscores. '" + name + "' not allowed");
    }
    if (this.ports[name]) {
      this.remove(name);
    }
    if (typeof options === 'object' && options.canAttach) {
      this.ports[name] = options;
    } else {
      this.ports[name] = new this.model(options, process);
    }
    this[name] = this.ports[name];
    this.emit('add', name);
    return this;
  };

  Ports.prototype.remove = function(name) {
    if (!this.ports[name]) {
      throw new Error("Port " + name + " not defined");
    }
    delete this.ports[name];
    delete this[name];
    this.emit('remove', name);
    return this;
  };

  return Ports;

})(EventEmitter);

exports.InPorts = InPorts = (function(superClass) {
  extend(InPorts, superClass);

  function InPorts() {
    return InPorts.__super__.constructor.apply(this, arguments);
  }

  InPorts.prototype.on = function(name, event, callback) {
    if (!this.ports[name]) {
      throw new Error("Port " + name + " not available");
    }
    return this.ports[name].on(event, callback);
  };

  InPorts.prototype.once = function(name, event, callback) {
    if (!this.ports[name]) {
      throw new Error("Port " + name + " not available");
    }
    return this.ports[name].once(event, callback);
  };

  return InPorts;

})(Ports);

exports.OutPorts = OutPorts = (function(superClass) {
  extend(OutPorts, superClass);

  function OutPorts() {
    return OutPorts.__super__.constructor.apply(this, arguments);
  }

  OutPorts.prototype.model = OutPort;

  OutPorts.prototype.connect = function(name, socketId) {
    if (!this.ports[name]) {
      throw new Error("Port " + name + " not available");
    }
    return this.ports[name].connect(socketId);
  };

  OutPorts.prototype.beginGroup = function(name, group, socketId) {
    if (!this.ports[name]) {
      throw new Error("Port " + name + " not available");
    }
    return this.ports[name].beginGroup(group, socketId);
  };

  OutPorts.prototype.send = function(name, data, socketId) {
    if (!this.ports[name]) {
      throw new Error("Port " + name + " not available");
    }
    return this.ports[name].send(data, socketId);
  };

  OutPorts.prototype.endGroup = function(name, socketId) {
    if (!this.ports[name]) {
      throw new Error("Port " + name + " not available");
    }
    return this.ports[name].endGroup(socketId);
  };

  OutPorts.prototype.disconnect = function(name, socketId) {
    if (!this.ports[name]) {
      throw new Error("Port " + name + " not available");
    }
    return this.ports[name].disconnect(socketId);
  };

  return OutPorts;

})(Ports);

});
require.register("noflo-noflo/src/lib/Port.js", function(exports, require, module){
var EventEmitter, Port,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

EventEmitter = require('events').EventEmitter;

Port = (function(superClass) {
  extend(Port, superClass);

  Port.prototype.description = '';

  Port.prototype.required = true;

  function Port(type) {
    this.type = type;
    if (!this.type) {
      this.type = 'all';
    }
    if (this.type === 'integer') {
      this.type = 'int';
    }
    this.sockets = [];
    this.from = null;
    this.node = null;
    this.name = null;
  }

  Port.prototype.getId = function() {
    if (!(this.node && this.name)) {
      return 'Port';
    }
    return this.node + " " + (this.name.toUpperCase());
  };

  Port.prototype.getDataType = function() {
    return this.type;
  };

  Port.prototype.getDescription = function() {
    return this.description;
  };

  Port.prototype.attach = function(socket) {
    this.sockets.push(socket);
    return this.attachSocket(socket);
  };

  Port.prototype.attachSocket = function(socket, localId) {
    if (localId == null) {
      localId = null;
    }
    this.emit("attach", socket, localId);
    this.from = socket.from;
    if (socket.setMaxListeners) {
      socket.setMaxListeners(0);
    }
    socket.on("connect", (function(_this) {
      return function() {
        return _this.emit("connect", socket, localId);
      };
    })(this));
    socket.on("begingroup", (function(_this) {
      return function(group) {
        return _this.emit("begingroup", group, localId);
      };
    })(this));
    socket.on("data", (function(_this) {
      return function(data) {
        return _this.emit("data", data, localId);
      };
    })(this));
    socket.on("endgroup", (function(_this) {
      return function(group) {
        return _this.emit("endgroup", group, localId);
      };
    })(this));
    return socket.on("disconnect", (function(_this) {
      return function() {
        return _this.emit("disconnect", socket, localId);
      };
    })(this));
  };

  Port.prototype.connect = function() {
    var i, len, ref, results, socket;
    if (this.sockets.length === 0) {
      throw new Error((this.getId()) + ": No connections available");
    }
    ref = this.sockets;
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      socket = ref[i];
      results.push(socket.connect());
    }
    return results;
  };

  Port.prototype.beginGroup = function(group) {
    if (this.sockets.length === 0) {
      throw new Error((this.getId()) + ": No connections available");
    }
    return this.sockets.forEach(function(socket) {
      if (socket.isConnected()) {
        return socket.beginGroup(group);
      }
      socket.once('connect', function() {
        return socket.beginGroup(group);
      });
      return socket.connect();
    });
  };

  Port.prototype.send = function(data) {
    if (this.sockets.length === 0) {
      throw new Error((this.getId()) + ": No connections available");
    }
    return this.sockets.forEach(function(socket) {
      if (socket.isConnected()) {
        return socket.send(data);
      }
      socket.once('connect', function() {
        return socket.send(data);
      });
      return socket.connect();
    });
  };

  Port.prototype.endGroup = function() {
    var i, len, ref, results, socket;
    if (this.sockets.length === 0) {
      throw new Error((this.getId()) + ": No connections available");
    }
    ref = this.sockets;
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      socket = ref[i];
      results.push(socket.endGroup());
    }
    return results;
  };

  Port.prototype.disconnect = function() {
    var i, len, ref, results, socket;
    if (this.sockets.length === 0) {
      throw new Error((this.getId()) + ": No connections available");
    }
    ref = this.sockets;
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      socket = ref[i];
      results.push(socket.disconnect());
    }
    return results;
  };

  Port.prototype.detach = function(socket) {
    var index;
    if (this.sockets.length === 0) {
      return;
    }
    if (!socket) {
      socket = this.sockets[0];
    }
    index = this.sockets.indexOf(socket);
    if (index === -1) {
      return;
    }
    if (this.isAddressable()) {
      this.sockets[index] = void 0;
      this.emit('detach', socket, index);
      return;
    }
    this.sockets.splice(index, 1);
    return this.emit("detach", socket);
  };

  Port.prototype.isConnected = function() {
    var connected;
    connected = false;
    this.sockets.forEach((function(_this) {
      return function(socket) {
        if (socket.isConnected()) {
          return connected = true;
        }
      };
    })(this));
    return connected;
  };

  Port.prototype.isAddressable = function() {
    return false;
  };

  Port.prototype.isRequired = function() {
    return this.required;
  };

  Port.prototype.isAttached = function() {
    if (this.sockets.length > 0) {
      return true;
    }
    return false;
  };

  Port.prototype.listAttached = function() {
    var attached, i, idx, len, ref, socket;
    attached = [];
    ref = this.sockets;
    for (idx = i = 0, len = ref.length; i < len; idx = ++i) {
      socket = ref[idx];
      if (!socket) {
        continue;
      }
      attached.push(idx);
    }
    return attached;
  };

  Port.prototype.canAttach = function() {
    return true;
  };

  return Port;

})(EventEmitter);

exports.Port = Port;

});
require.register("noflo-noflo/src/lib/ArrayPort.js", function(exports, require, module){
var ArrayPort, port,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

port = require("./Port");

ArrayPort = (function(superClass) {
  extend(ArrayPort, superClass);

  function ArrayPort(type) {
    this.type = type;
    ArrayPort.__super__.constructor.call(this, this.type);
  }

  ArrayPort.prototype.attach = function(socket, socketId) {
    if (socketId == null) {
      socketId = null;
    }
    if (socketId === null) {
      socketId = this.sockets.length;
    }
    this.sockets[socketId] = socket;
    return this.attachSocket(socket, socketId);
  };

  ArrayPort.prototype.connect = function(socketId) {
    if (socketId == null) {
      socketId = null;
    }
    if (socketId === null) {
      if (!this.sockets.length) {
        throw new Error((this.getId()) + ": No connections available");
      }
      this.sockets.forEach(function(socket) {
        if (!socket) {
          return;
        }
        return socket.connect();
      });
      return;
    }
    if (!this.sockets[socketId]) {
      throw new Error((this.getId()) + ": No connection '" + socketId + "' available");
    }
    return this.sockets[socketId].connect();
  };

  ArrayPort.prototype.beginGroup = function(group, socketId) {
    if (socketId == null) {
      socketId = null;
    }
    if (socketId === null) {
      if (!this.sockets.length) {
        throw new Error((this.getId()) + ": No connections available");
      }
      this.sockets.forEach((function(_this) {
        return function(socket, index) {
          if (!socket) {
            return;
          }
          return _this.beginGroup(group, index);
        };
      })(this));
      return;
    }
    if (!this.sockets[socketId]) {
      throw new Error((this.getId()) + ": No connection '" + socketId + "' available");
    }
    if (this.isConnected(socketId)) {
      return this.sockets[socketId].beginGroup(group);
    }
    this.sockets[socketId].once("connect", (function(_this) {
      return function() {
        return _this.sockets[socketId].beginGroup(group);
      };
    })(this));
    return this.sockets[socketId].connect();
  };

  ArrayPort.prototype.send = function(data, socketId) {
    if (socketId == null) {
      socketId = null;
    }
    if (socketId === null) {
      if (!this.sockets.length) {
        throw new Error((this.getId()) + ": No connections available");
      }
      this.sockets.forEach((function(_this) {
        return function(socket, index) {
          if (!socket) {
            return;
          }
          return _this.send(data, index);
        };
      })(this));
      return;
    }
    if (!this.sockets[socketId]) {
      throw new Error((this.getId()) + ": No connection '" + socketId + "' available");
    }
    if (this.isConnected(socketId)) {
      return this.sockets[socketId].send(data);
    }
    this.sockets[socketId].once("connect", (function(_this) {
      return function() {
        return _this.sockets[socketId].send(data);
      };
    })(this));
    return this.sockets[socketId].connect();
  };

  ArrayPort.prototype.endGroup = function(socketId) {
    if (socketId == null) {
      socketId = null;
    }
    if (socketId === null) {
      if (!this.sockets.length) {
        throw new Error((this.getId()) + ": No connections available");
      }
      this.sockets.forEach((function(_this) {
        return function(socket, index) {
          if (!socket) {
            return;
          }
          return _this.endGroup(index);
        };
      })(this));
      return;
    }
    if (!this.sockets[socketId]) {
      throw new Error((this.getId()) + ": No connection '" + socketId + "' available");
    }
    return this.sockets[socketId].endGroup();
  };

  ArrayPort.prototype.disconnect = function(socketId) {
    var i, len, ref, socket;
    if (socketId == null) {
      socketId = null;
    }
    if (socketId === null) {
      if (!this.sockets.length) {
        throw new Error((this.getId()) + ": No connections available");
      }
      ref = this.sockets;
      for (i = 0, len = ref.length; i < len; i++) {
        socket = ref[i];
        if (!socket) {
          return;
        }
        socket.disconnect();
      }
      return;
    }
    if (!this.sockets[socketId]) {
      return;
    }
    return this.sockets[socketId].disconnect();
  };

  ArrayPort.prototype.isConnected = function(socketId) {
    var connected;
    if (socketId == null) {
      socketId = null;
    }
    if (socketId === null) {
      connected = false;
      this.sockets.forEach((function(_this) {
        return function(socket) {
          if (!socket) {
            return;
          }
          if (socket.isConnected()) {
            return connected = true;
          }
        };
      })(this));
      return connected;
    }
    if (!this.sockets[socketId]) {
      return false;
    }
    return this.sockets[socketId].isConnected();
  };

  ArrayPort.prototype.isAddressable = function() {
    return true;
  };

  ArrayPort.prototype.isAttached = function(socketId) {
    var i, len, ref, socket;
    if (socketId === void 0) {
      ref = this.sockets;
      for (i = 0, len = ref.length; i < len; i++) {
        socket = ref[i];
        if (socket) {
          return true;
        }
      }
      return false;
    }
    if (this.sockets[socketId]) {
      return true;
    }
    return false;
  };

  return ArrayPort;

})(port.Port);

exports.ArrayPort = ArrayPort;

});
require.register("noflo-noflo/src/lib/Component.js", function(exports, require, module){
var Component, EventEmitter, IP, ProcessInput, ProcessOutput, ports,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

EventEmitter = require('events').EventEmitter;

ports = require('./Ports');

IP = require('./IP');

Component = (function(superClass) {
  extend(Component, superClass);

  Component.prototype.description = '';

  Component.prototype.icon = null;

  Component.prototype.started = false;

  Component.prototype.load = 0;

  Component.prototype.ordered = false;

  Component.prototype.outputQ = [];

  Component.prototype.activateOnInput = true;

  function Component(options) {
    this.error = bind(this.error, this);
    if (!options) {
      options = {};
    }
    if (!options.inPorts) {
      options.inPorts = {};
    }
    if (options.inPorts instanceof ports.InPorts) {
      this.inPorts = options.inPorts;
    } else {
      this.inPorts = new ports.InPorts(options.inPorts);
    }
    if (!options.outPorts) {
      options.outPorts = {};
    }
    if (options.outPorts instanceof ports.OutPorts) {
      this.outPorts = options.outPorts;
    } else {
      this.outPorts = new ports.OutPorts(options.outPorts);
    }
    if (options.icon) {
      this.icon = options.icon;
    }
    if (options.description) {
      this.description = options.description;
    }
    if ('ordered' in options) {
      this.ordered = options.ordered;
    }
    if ('activateOnInput' in options) {
      this.activateOnInput = options.activateOnInput;
    }
    if (typeof options.process === 'function') {
      this.process(options.process);
    }
  }

  Component.prototype.getDescription = function() {
    return this.description;
  };

  Component.prototype.isReady = function() {
    return true;
  };

  Component.prototype.isSubgraph = function() {
    return false;
  };

  Component.prototype.setIcon = function(icon) {
    this.icon = icon;
    return this.emit('icon', this.icon);
  };

  Component.prototype.getIcon = function() {
    return this.icon;
  };

  Component.prototype.error = function(e, groups, errorPort) {
    var group, i, j, len, len1;
    if (groups == null) {
      groups = [];
    }
    if (errorPort == null) {
      errorPort = 'error';
    }
    if (this.outPorts[errorPort] && (this.outPorts[errorPort].isAttached() || !this.outPorts[errorPort].isRequired())) {
      for (i = 0, len = groups.length; i < len; i++) {
        group = groups[i];
        this.outPorts[errorPort].beginGroup(group);
      }
      this.outPorts[errorPort].send(e);
      for (j = 0, len1 = groups.length; j < len1; j++) {
        group = groups[j];
        this.outPorts[errorPort].endGroup();
      }
      this.outPorts[errorPort].disconnect();
      return;
    }
    throw e;
  };

  Component.prototype.shutdown = function() {
    return this.started = false;
  };

  Component.prototype.start = function() {
    this.started = true;
    return this.started;
  };

  Component.prototype.isStarted = function() {
    return this.started;
  };

  Component.prototype.process = function(handle) {
    var name, port, ref;
    if (typeof handle !== 'function') {
      throw new Error("Process handler must be a function");
    }
    if (!this.inPorts) {
      throw new Error("Component ports must be defined before process function");
    }
    this.handle = handle;
    ref = this.inPorts.ports;
    for (name in ref) {
      port = ref[name];
      if (!port.name) {
        port.name = name;
      }
      port.on('ip', (function(_this) {
        return function(ip) {
          return _this.handleIP(ip, port);
        };
      })(this));
    }
    return this;
  };

  Component.prototype.handleIP = function(ip, port) {
    var input, output, result;
    if (!port.options.triggering) {
      return;
    }
    result = {};
    input = new ProcessInput(this.inPorts, ip, this, port, result);
    output = new ProcessOutput(this.outPorts, ip, this, result);
    this.load++;
    return this.handle(input, output, function() {
      return output.done();
    });
  };

  return Component;

})(EventEmitter);

exports.Component = Component;

ProcessInput = (function() {
  function ProcessInput(ports1, ip1, nodeInstance, port1, result1) {
    this.ports = ports1;
    this.ip = ip1;
    this.nodeInstance = nodeInstance;
    this.port = port1;
    this.result = result1;
    this.scope = this.ip.scope;
  }

  ProcessInput.prototype.activate = function() {
    this.result.__resolved = false;
    if (this.nodeInstance.ordered) {
      return this.nodeInstance.outputQ.push(this.result);
    }
  };

  ProcessInput.prototype.has = function() {
    var i, len, port, res;
    res = true;
    for (i = 0, len = arguments.length; i < len; i++) {
      port = arguments[i];
      res && (res = this.ports[port].ready(this.scope));
    }
    return res;
  };

  ProcessInput.prototype.get = function() {
    var port, res;
    if (this.nodeInstance.ordered && this.nodeInstance.activateOnInput && !('__resolved' in this.result)) {
      this.activate();
    }
    res = (function() {
      var i, len, results;
      results = [];
      for (i = 0, len = arguments.length; i < len; i++) {
        port = arguments[i];
        results.push(this.ports[port].get(this.scope));
      }
      return results;
    }).apply(this, arguments);
    if (arguments.length === 1) {
      return res[0];
    } else {
      return res;
    }
  };

  ProcessInput.prototype.getData = function() {
    var i, ip, ips, len, results;
    ips = this.get.apply(this, arguments);
    if (arguments.length === 1) {
      return ips.data;
    }
    results = [];
    for (i = 0, len = ips.length; i < len; i++) {
      ip = ips[i];
      results.push(ip.data);
    }
    return results;
  };

  return ProcessInput;

})();

ProcessOutput = (function() {
  function ProcessOutput(ports1, ip1, nodeInstance, result1) {
    this.ports = ports1;
    this.ip = ip1;
    this.nodeInstance = nodeInstance;
    this.result = result1;
    this.scope = this.ip.scope;
  }

  ProcessOutput.prototype.activate = function() {
    this.result.__resolved = false;
    if (this.nodeInstance.ordered) {
      return this.nodeInstance.outputQ.push(this.result);
    }
  };

  ProcessOutput.prototype.isError = function(err) {
    return err instanceof Error || Array.isArray(err) && err.length > 0 && err[0] instanceof Error;
  };

  ProcessOutput.prototype.error = function(err) {
    var e, i, j, len, len1, multiple, results;
    multiple = Array.isArray(err);
    if (!multiple) {
      err = [err];
    }
    if ('error' in this.ports && (this.ports.error.isAttached() || !this.ports.error.isRequired())) {
      if (multiple) {
        this.sendIP('error', new IP('openBracket'));
      }
      for (i = 0, len = err.length; i < len; i++) {
        e = err[i];
        this.sendIP('error', e);
      }
      if (multiple) {
        return this.sendIP('error', new IP('closeBracket'));
      }
    } else {
      results = [];
      for (j = 0, len1 = err.length; j < len1; j++) {
        e = err[j];
        throw e;
      }
      return results;
    }
  };

  ProcessOutput.prototype.sendIP = function(port, packet) {
    var ip;
    if (typeof packet !== 'object' || IP.types.indexOf(packet.type) === -1) {
      ip = new IP('data', packet);
    } else {
      ip = packet;
    }
    if (this.scope !== null && ip.scope === null) {
      ip.scope = this.scope;
    }
    if (this.nodeInstance.ordered) {
      if (!(port in this.result)) {
        this.result[port] = [];
      }
      return this.result[port].push(ip);
    } else {
      return this.nodeInstance.outPorts[port].sendIP(ip);
    }
  };

  ProcessOutput.prototype.send = function(outputMap) {
    var packet, port, results;
    if (this.nodeInstance.ordered && !('__resolved' in this.result)) {
      this.activate();
    }
    if (this.isError(outputMap)) {
      return this.error(outputMap);
    }
    results = [];
    for (port in outputMap) {
      packet = outputMap[port];
      results.push(this.sendIP(port, packet));
    }
    return results;
  };

  ProcessOutput.prototype.sendDone = function(outputMap) {
    this.send(outputMap);
    return this.done();
  };

  ProcessOutput.prototype.done = function(error) {
    var i, ip, ips, len, port, result;
    if (error) {
      this.error(error);
    }
    if (this.nodeInstance.ordered) {
      this.result.__resolved = true;
      while (this.nodeInstance.outputQ.length > 0) {
        result = this.nodeInstance.outputQ[0];
        if (!result.__resolved) {
          break;
        }
        for (port in result) {
          ips = result[port];
          if (port === '__resolved') {
            continue;
          }
          for (i = 0, len = ips.length; i < len; i++) {
            ip = ips[i];
            this.nodeInstance.outPorts[port].sendIP(ip);
          }
        }
        this.nodeInstance.outputQ.shift();
      }
    }
    return this.nodeInstance.load--;
  };

  return ProcessOutput;

})();

});
require.register("noflo-noflo/src/lib/AsyncComponent.js", function(exports, require, module){
var AsyncComponent, component, port,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

port = require("./Port");

component = require("./Component");

AsyncComponent = (function(superClass) {
  extend(AsyncComponent, superClass);

  function AsyncComponent(inPortName, outPortName, errPortName) {
    this.inPortName = inPortName != null ? inPortName : "in";
    this.outPortName = outPortName != null ? outPortName : "out";
    this.errPortName = errPortName != null ? errPortName : "error";
    if (!this.inPorts[this.inPortName]) {
      throw new Error("no inPort named '" + this.inPortName + "'");
    }
    if (!this.outPorts[this.outPortName]) {
      throw new Error("no outPort named '" + this.outPortName + "'");
    }
    this.load = 0;
    this.q = [];
    this.errorGroups = [];
    this.outPorts.load = new port.Port();
    this.inPorts[this.inPortName].on("begingroup", (function(_this) {
      return function(group) {
        if (_this.load > 0) {
          return _this.q.push({
            name: "begingroup",
            data: group
          });
        }
        _this.errorGroups.push(group);
        return _this.outPorts[_this.outPortName].beginGroup(group);
      };
    })(this));
    this.inPorts[this.inPortName].on("endgroup", (function(_this) {
      return function() {
        if (_this.load > 0) {
          return _this.q.push({
            name: "endgroup"
          });
        }
        _this.errorGroups.pop();
        return _this.outPorts[_this.outPortName].endGroup();
      };
    })(this));
    this.inPorts[this.inPortName].on("disconnect", (function(_this) {
      return function() {
        if (_this.load > 0) {
          return _this.q.push({
            name: "disconnect"
          });
        }
        _this.outPorts[_this.outPortName].disconnect();
        _this.errorGroups = [];
        if (_this.outPorts.load.isAttached()) {
          return _this.outPorts.load.disconnect();
        }
      };
    })(this));
    this.inPorts[this.inPortName].on("data", (function(_this) {
      return function(data) {
        if (_this.q.length > 0) {
          return _this.q.push({
            name: "data",
            data: data
          });
        }
        return _this.processData(data);
      };
    })(this));
  }

  AsyncComponent.prototype.processData = function(data) {
    this.incrementLoad();
    return this.doAsync(data, (function(_this) {
      return function(err) {
        if (err) {
          _this.error(err, _this.errorGroups, _this.errPortName);
        }
        return _this.decrementLoad();
      };
    })(this));
  };

  AsyncComponent.prototype.incrementLoad = function() {
    this.load++;
    if (this.outPorts.load.isAttached()) {
      this.outPorts.load.send(this.load);
    }
    if (this.outPorts.load.isAttached()) {
      return this.outPorts.load.disconnect();
    }
  };

  AsyncComponent.prototype.doAsync = function(data, callback) {
    return callback(new Error("AsyncComponents must implement doAsync"));
  };

  AsyncComponent.prototype.decrementLoad = function() {
    if (this.load === 0) {
      throw new Error("load cannot be negative");
    }
    this.load--;
    if (this.outPorts.load.isAttached()) {
      this.outPorts.load.send(this.load);
    }
    if (this.outPorts.load.isAttached()) {
      this.outPorts.load.disconnect();
    }
    if (typeof process !== 'undefined' && process.execPath && process.execPath.indexOf('node') !== -1) {
      return process.nextTick((function(_this) {
        return function() {
          return _this.processQueue();
        };
      })(this));
    } else {
      return setTimeout((function(_this) {
        return function() {
          return _this.processQueue();
        };
      })(this), 0);
    }
  };

  AsyncComponent.prototype.processQueue = function() {
    var event, processedData;
    if (this.load > 0) {
      return;
    }
    processedData = false;
    while (this.q.length > 0) {
      event = this.q[0];
      switch (event.name) {
        case "begingroup":
          if (processedData) {
            return;
          }
          this.outPorts[this.outPortName].beginGroup(event.data);
          this.errorGroups.push(event.data);
          this.q.shift();
          break;
        case "endgroup":
          if (processedData) {
            return;
          }
          this.outPorts[this.outPortName].endGroup();
          this.errorGroups.pop();
          this.q.shift();
          break;
        case "disconnect":
          if (processedData) {
            return;
          }
          this.outPorts[this.outPortName].disconnect();
          if (this.outPorts.load.isAttached()) {
            this.outPorts.load.disconnect();
          }
          this.errorGroups = [];
          this.q.shift();
          break;
        case "data":
          this.processData(event.data);
          this.q.shift();
          processedData = true;
      }
    }
  };

  AsyncComponent.prototype.shutdown = function() {
    this.q = [];
    return this.errorGroups = [];
  };

  return AsyncComponent;

})(component.Component);

exports.AsyncComponent = AsyncComponent;

});
require.register("noflo-noflo/src/lib/ComponentLoader.js", function(exports, require, module){
var ComponentLoader, EventEmitter, internalSocket, nofloGraph, utils,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

internalSocket = require('./InternalSocket');

nofloGraph = require('./Graph');

utils = require('./Utils');

EventEmitter = require('events').EventEmitter;

ComponentLoader = (function(superClass) {
  extend(ComponentLoader, superClass);

  function ComponentLoader(baseDir, options) {
    this.baseDir = baseDir;
    this.options = options != null ? options : {};
    this.components = null;
    this.componentLoaders = [];
    this.checked = [];
    this.revalidate = false;
    this.libraryIcons = {};
    this.processing = false;
    this.ready = false;
  }

  ComponentLoader.prototype.getModulePrefix = function(name) {
    if (!name) {
      return '';
    }
    if (name === 'noflo') {
      return '';
    }
    if (name[0] === '@') {
      name = name.replace(/\@[a-z\-]+\//, '');
    }
    return name.replace('noflo-', '');
  };

  ComponentLoader.prototype.getModuleComponents = function(moduleName) {
    var cPath, definition, dependency, e, error, loader, loaderPath, name, prefix, ref, ref1, results;
    if (this.checked.indexOf(moduleName) !== -1) {
      return;
    }
    this.checked.push(moduleName);
    try {
      definition = require("/" + moduleName + "/component.json");
    } catch (error) {
      e = error;
      if (moduleName.substr(0, 1) === '/') {
        return this.getModuleComponents("noflo-" + (moduleName.substr(1)));
      }
      return;
    }
    for (dependency in definition.dependencies) {
      this.getModuleComponents(dependency.replace('/', '-'));
    }
    if (!definition.noflo) {
      return;
    }
    prefix = this.getModulePrefix(definition.name);
    if (definition.noflo.icon) {
      this.libraryIcons[prefix] = definition.noflo.icon;
    }
    if (moduleName[0] === '/') {
      moduleName = moduleName.substr(1);
    }
    if (definition.noflo.loader) {
      loaderPath = "/" + moduleName + "/" + definition.noflo.loader;
      this.componentLoaders.push(loaderPath);
      loader = require(loaderPath);
      this.registerLoader(loader, function() {});
    }
    if (definition.noflo.components) {
      ref = definition.noflo.components;
      for (name in ref) {
        cPath = ref[name];
        if (cPath.indexOf('.js') !== -1) {
          cPath = cPath.replace('.js', '.js');
        }
        if (cPath.substr(0, 2) === './') {
          cPath = cPath.substr(2);
        }
        this.registerComponent(prefix, name, "/" + moduleName + "/" + cPath);
      }
    }
    if (definition.noflo.graphs) {
      ref1 = definition.noflo.graphs;
      results = [];
      for (name in ref1) {
        cPath = ref1[name];
        results.push(this.registerGraph(prefix, name, "/" + moduleName + "/" + cPath));
      }
      return results;
    }
  };

  ComponentLoader.prototype.listComponents = function(callback) {
    if (this.processing) {
      this.once('ready', (function(_this) {
        return function() {
          return callback(_this.components);
        };
      })(this));
      return;
    }
    if (this.components) {
      return callback(this.components);
    }
    this.ready = false;
    this.processing = true;
    return setTimeout((function(_this) {
      return function() {
        _this.components = {};
        _this.getModuleComponents(_this.baseDir);
        _this.processing = false;
        _this.ready = true;
        _this.emit('ready', true);
        if (callback) {
          return callback(_this.components);
        }
      };
    })(this), 1);
  };

  ComponentLoader.prototype.load = function(name, callback, metadata) {
    var component, componentName;
    if (!this.ready) {
      this.listComponents((function(_this) {
        return function() {
          return _this.load(name, callback, metadata);
        };
      })(this));
      return;
    }
    component = this.components[name];
    if (!component) {
      for (componentName in this.components) {
        if (componentName.split('/')[1] === name) {
          component = this.components[componentName];
          break;
        }
      }
      if (!component) {
        callback(new Error("Component " + name + " not available with base " + this.baseDir));
        return;
      }
    }
    if (this.isGraph(component)) {
      if (typeof process !== 'undefined' && process.execPath && process.execPath.indexOf('node') !== -1) {
        process.nextTick((function(_this) {
          return function() {
            return _this.loadGraph(name, component, callback, metadata);
          };
        })(this));
      } else {
        setTimeout((function(_this) {
          return function() {
            return _this.loadGraph(name, component, callback, metadata);
          };
        })(this), 0);
      }
      return;
    }
    return this.createComponent(name, component, metadata, (function(_this) {
      return function(err, instance) {
        if (err) {
          return callback(err);
        }
        if (!instance) {
          callback(new Error("Component " + name + " could not be loaded."));
          return;
        }
        if (name === 'Graph') {
          instance.baseDir = _this.baseDir;
        }
        _this.setIcon(name, instance);
        return callback(null, instance);
      };
    })(this));
  };

  ComponentLoader.prototype.createComponent = function(name, component, metadata, callback) {
    var e, error, implementation, instance;
    implementation = component;
    if (typeof implementation === 'string') {
      try {
        implementation = require(implementation);
      } catch (error) {
        e = error;
        return callback(e);
      }
    }
    if (typeof implementation.getComponent === 'function') {
      instance = implementation.getComponent(metadata);
    } else if (typeof implementation === 'function') {
      instance = implementation(metadata);
    } else {
      callback(new Error("Invalid type " + (typeof implementation) + " for component " + name + "."));
      return;
    }
    if (typeof name === 'string') {
      instance.componentName = name;
    }
    return callback(null, instance);
  };

  ComponentLoader.prototype.isGraph = function(cPath) {
    if (typeof cPath === 'object' && cPath instanceof nofloGraph.Graph) {
      return true;
    }
    if (typeof cPath !== 'string') {
      return false;
    }
    return cPath.indexOf('.fbp') !== -1 || cPath.indexOf('.json') !== -1;
  };

  ComponentLoader.prototype.loadGraph = function(name, component, callback, metadata) {
    var graph, graphImplementation, graphSocket;
    graphImplementation = require(this.components['Graph']);
    graphSocket = internalSocket.createSocket();
    graph = graphImplementation.getComponent(metadata);
    graph.loader = this;
    graph.baseDir = this.baseDir;
    graph.inPorts.graph.attach(graphSocket);
    if (typeof name === 'string') {
      graph.componentName = name;
    }
    graphSocket.send(component);
    graphSocket.disconnect();
    graph.inPorts.remove('graph');
    this.setIcon(name, graph);
    return callback(null, graph);
  };

  ComponentLoader.prototype.setIcon = function(name, instance) {
    var componentName, library, ref;
    if (!instance.getIcon || instance.getIcon()) {
      return;
    }
    ref = name.split('/'), library = ref[0], componentName = ref[1];
    if (componentName && this.getLibraryIcon(library)) {
      instance.setIcon(this.getLibraryIcon(library));
      return;
    }
    if (instance.isSubgraph()) {
      instance.setIcon('sitemap');
      return;
    }
    instance.setIcon('square');
  };

  ComponentLoader.prototype.getLibraryIcon = function(prefix) {
    if (this.libraryIcons[prefix]) {
      return this.libraryIcons[prefix];
    }
    return null;
  };

  ComponentLoader.prototype.normalizeName = function(packageId, name) {
    var fullName, prefix;
    prefix = this.getModulePrefix(packageId);
    fullName = prefix + "/" + name;
    if (!packageId) {
      fullName = name;
    }
    return fullName;
  };

  ComponentLoader.prototype.registerComponent = function(packageId, name, cPath, callback) {
    var fullName;
    fullName = this.normalizeName(packageId, name);
    this.components[fullName] = cPath;
    if (callback) {
      return callback();
    }
  };

  ComponentLoader.prototype.registerGraph = function(packageId, name, gPath, callback) {
    return this.registerComponent(packageId, name, gPath, callback);
  };

  ComponentLoader.prototype.registerLoader = function(loader, callback) {
    return loader(this, callback);
  };

  ComponentLoader.prototype.setSource = function(packageId, name, source, language, callback) {
    var e, error, error1, error2, implementation;
    if (!this.ready) {
      this.listComponents((function(_this) {
        return function() {
          return _this.setSource(packageId, name, source, language, callback);
        };
      })(this));
      return;
    }
    if (language === 'coffeescript') {
      if (!window.CoffeeScript) {
        return callback(new Error('CoffeeScript compiler not available'));
      }
      try {
        source = CoffeeScript.compile(source, {
          bare: true
        });
      } catch (error) {
        e = error;
        return callback(e);
      }
    } else if (language === 'es6' || language === 'es2015') {
      if (!window.babel) {
        return callback(new Error('Babel compiler not available'));
      }
      try {
        source = babel.transform(source).code;
      } catch (error1) {
        e = error1;
        return callback(e);
      }
    }
    try {
      source = source.replace("require('noflo')", "require('./NoFlo')");
      source = source.replace('require("noflo")', 'require("./NoFlo")');
      implementation = eval("(function () { var exports = {}; " + source + "; return exports; })()");
    } catch (error2) {
      e = error2;
      return callback(e);
    }
    if (!(implementation || implementation.getComponent)) {
      return callback(new Error('Provided source failed to create a runnable component'));
    }
    return this.registerComponent(packageId, name, implementation, function() {
      return callback(null);
    });
  };

  ComponentLoader.prototype.getSource = function(name, callback) {
    var component, componentName, nameParts, path;
    if (!this.ready) {
      this.listComponents((function(_this) {
        return function() {
          return _this.getSource(name, callback);
        };
      })(this));
      return;
    }
    component = this.components[name];
    if (!component) {
      for (componentName in this.components) {
        if (componentName.split('/')[1] === name) {
          component = this.components[componentName];
          name = componentName;
          break;
        }
      }
      if (!component) {
        return callback(new Error("Component " + name + " not installed"));
      }
    }
    if (typeof component !== 'string') {
      return callback(new Error("Can't provide source for " + name + ". Not a file"));
    }
    nameParts = name.split('/');
    if (nameParts.length === 1) {
      nameParts[1] = nameParts[0];
      nameParts[0] = '';
    }
    if (this.isGraph(component)) {
      nofloGraph.loadFile(component, function(err, graph) {
        if (err) {
          return callback(err);
        }
        if (!graph) {
          return callback(new Error('Unable to load graph'));
        }
        return callback(null, {
          name: nameParts[1],
          library: nameParts[0],
          code: JSON.stringify(graph.toJSON()),
          language: 'json'
        });
      });
      return;
    }
    path = window.require.resolve(component);
    if (!path) {
      return callback(new Error("Component " + name + " is not resolvable to a path"));
    }
    return callback(null, {
      name: nameParts[1],
      library: nameParts[0],
      code: window.require.modules[path].toString(),
      language: utils.guessLanguageFromFilename(component)
    });
  };

  ComponentLoader.prototype.clear = function() {
    this.components = null;
    this.checked = [];
    this.revalidate = true;
    this.ready = false;
    return this.processing = false;
  };

  return ComponentLoader;

})(EventEmitter);

exports.ComponentLoader = ComponentLoader;

});
require.register("noflo-noflo/src/lib/NoFlo.js", function(exports, require, module){
var ports;

exports.graph = require('./Graph');

exports.Graph = exports.graph.Graph;

exports.journal = require('./Journal');

exports.Journal = exports.journal.Journal;

exports.Network = require('./Network').Network;

exports.isBrowser = require('./Platform').isBrowser;

if (!exports.isBrowser()) {
  exports.ComponentLoader = require('./nodejs/ComponentLoader').ComponentLoader;
} else {
  exports.ComponentLoader = require('./ComponentLoader').ComponentLoader;
}

exports.Component = require('./Component').Component;

exports.AsyncComponent = require('./AsyncComponent').AsyncComponent;

exports.helpers = require('./Helpers');

ports = require('./Ports');

exports.InPorts = ports.InPorts;

exports.OutPorts = ports.OutPorts;

exports.InPort = require('./InPort');

exports.OutPort = require('./OutPort');

exports.Port = require('./Port').Port;

exports.ArrayPort = require('./ArrayPort').ArrayPort;

exports.internalSocket = require('./InternalSocket');

exports.createNetwork = function(graph, callback, options) {
  var network, networkReady;
  if (typeof options !== 'object') {
    options = {
      delay: options
    };
  }
  if (typeof callback !== 'function') {
    callback = function(err) {
      if (err) {
        throw err;
      }
    };
  }
  network = new exports.Network(graph, options);
  networkReady = function(network) {
    return network.start(function(err) {
      if (err) {
        return callback(err);
      }
      return callback(null, network);
    });
  };
  network.loader.listComponents(function() {
    if (graph.nodes.length === 0) {
      return networkReady(network);
    }
    if (options.delay) {
      callback(null, network);
      return;
    }
    return network.connect(function(err) {
      if (err) {
        return callback(err);
      }
      return networkReady(network);
    });
  });
  return network;
};

exports.loadFile = function(file, options, callback) {
  var baseDir;
  if (!callback) {
    callback = options;
    baseDir = null;
  }
  if (callback && typeof options !== 'object') {
    options = {
      baseDir: options
    };
  }
  return exports.graph.loadFile(file, function(err, net) {
    if (err) {
      return callback(err);
    }
    if (options.baseDir) {
      net.baseDir = options.baseDir;
    }
    return exports.createNetwork(net, callback, options);
  });
};

exports.saveFile = function(graph, file, callback) {
  return exports.graph.save(file, function() {
    return callback(file);
  });
};

});
require.register("noflo-noflo/src/lib/Network.js", function(exports, require, module){
var EventEmitter, Network, _, componentLoader, graph, internalSocket,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require("underscore");

internalSocket = require("./InternalSocket");

graph = require("./Graph");

EventEmitter = require('events').EventEmitter;

if (!require('./Platform').isBrowser()) {
  componentLoader = require("./nodejs/ComponentLoader");
} else {
  componentLoader = require('./ComponentLoader');
}

Network = (function(superClass) {
  extend(Network, superClass);

  Network.prototype.processes = {};

  Network.prototype.connections = [];

  Network.prototype.initials = [];

  Network.prototype.defaults = [];

  Network.prototype.graph = null;

  Network.prototype.startupDate = null;

  Network.prototype.portBuffer = {};

  function Network(graph, options) {
    this.options = options != null ? options : {};
    this.processes = {};
    this.connections = [];
    this.initials = [];
    this.nextInitials = [];
    this.defaults = [];
    this.graph = graph;
    this.started = false;
    this.debug = true;
    if (typeof process !== 'undefined' && process.execPath && process.execPath.indexOf('node') !== -1) {
      this.baseDir = graph.baseDir || process.cwd();
    } else {
      this.baseDir = graph.baseDir || '/';
    }
    this.startupDate = new Date();
    if (graph.componentLoader) {
      this.loader = graph.componentLoader;
    } else {
      this.loader = new componentLoader.ComponentLoader(this.baseDir, this.options);
    }
  }

  Network.prototype.uptime = function() {
    return new Date() - this.startupDate;
  };

  Network.prototype.connectionCount = 0;

  Network.prototype.increaseConnections = function() {
    if (this.connectionCount === 0) {
      this.emit('start', {
        start: this.startupDate
      });
    }
    return this.connectionCount++;
  };

  Network.prototype.decreaseConnections = function() {
    var ender;
    this.connectionCount--;
    if (this.connectionCount === 0) {
      ender = _.debounce((function(_this) {
        return function() {
          if (_this.connectionCount) {
            return;
          }
          return _this.emit('end', {
            start: _this.startupDate,
            end: new Date,
            uptime: _this.uptime()
          });
        };
      })(this), 10);
      return ender();
    }
  };

  Network.prototype.load = function(component, metadata, callback) {
    return this.loader.load(component, callback, metadata);
  };

  Network.prototype.addNode = function(node, callback) {
    var process;
    if (this.processes[node.id]) {
      if (callback) {
        callback(null, this.processes[node.id]);
      }
      return;
    }
    process = {
      id: node.id
    };
    if (!node.component) {
      this.processes[process.id] = process;
      if (callback) {
        callback(null, process);
      }
      return;
    }
    return this.load(node.component, node.metadata, (function(_this) {
      return function(err, instance) {
        var name, port, ref, ref1;
        if (err) {
          return callback(err);
        }
        instance.nodeId = node.id;
        process.component = instance;
        ref = process.component.inPorts;
        for (name in ref) {
          port = ref[name];
          if (!port || typeof port === 'function' || !port.canAttach) {
            continue;
          }
          port.node = node.id;
          port.nodeInstance = instance;
          port.name = name;
        }
        ref1 = process.component.outPorts;
        for (name in ref1) {
          port = ref1[name];
          if (!port || typeof port === 'function' || !port.canAttach) {
            continue;
          }
          port.node = node.id;
          port.nodeInstance = instance;
          port.name = name;
        }
        if (instance.isSubgraph()) {
          _this.subscribeSubgraph(process);
        }
        _this.subscribeNode(process);
        _this.processes[process.id] = process;
        if (callback) {
          return callback(null, process);
        }
      };
    })(this));
  };

  Network.prototype.removeNode = function(node, callback) {
    if (!this.processes[node.id]) {
      return callback(new Error("Node " + node.id + " not found"));
    }
    this.processes[node.id].component.shutdown();
    delete this.processes[node.id];
    if (callback) {
      return callback(null);
    }
  };

  Network.prototype.renameNode = function(oldId, newId, callback) {
    var name, port, process, ref, ref1;
    process = this.getNode(oldId);
    if (!process) {
      return callback(new Error("Process " + oldId + " not found"));
    }
    process.id = newId;
    ref = process.component.inPorts;
    for (name in ref) {
      port = ref[name];
      port.node = newId;
    }
    ref1 = process.component.outPorts;
    for (name in ref1) {
      port = ref1[name];
      port.node = newId;
    }
    this.processes[newId] = process;
    delete this.processes[oldId];
    if (callback) {
      return callback(null);
    }
  };

  Network.prototype.getNode = function(id) {
    return this.processes[id];
  };

  Network.prototype.connect = function(done) {
    var callStack, edges, initializers, nodes, serialize, setDefaults, subscribeGraph;
    if (done == null) {
      done = function() {};
    }
    callStack = 0;
    serialize = (function(_this) {
      return function(next, add) {
        return function(type) {
          return _this["add" + type](add, function(err) {
            if (err) {
              console.log(err);
            }
            if (err) {
              return done(err);
            }
            callStack++;
            if (callStack % 100 === 0) {
              setTimeout(function() {
                return next(type);
              }, 0);
              return;
            }
            return next(type);
          });
        };
      };
    })(this);
    subscribeGraph = (function(_this) {
      return function() {
        _this.subscribeGraph();
        return done();
      };
    })(this);
    setDefaults = _.reduceRight(this.graph.nodes, serialize, subscribeGraph);
    initializers = _.reduceRight(this.graph.initializers, serialize, function() {
      return setDefaults("Defaults");
    });
    edges = _.reduceRight(this.graph.edges, serialize, function() {
      return initializers("Initial");
    });
    nodes = _.reduceRight(this.graph.nodes, serialize, function() {
      return edges("Edge");
    });
    return nodes("Node");
  };

  Network.prototype.connectPort = function(socket, process, port, index, inbound) {
    if (inbound) {
      socket.to = {
        process: process,
        port: port,
        index: index
      };
      if (!(process.component.inPorts && process.component.inPorts[port])) {
        throw new Error("No inport '" + port + "' defined in process " + process.id + " (" + (socket.getId()) + ")");
        return;
      }
      if (process.component.inPorts[port].isAddressable()) {
        return process.component.inPorts[port].attach(socket, index);
      }
      return process.component.inPorts[port].attach(socket);
    }
    socket.from = {
      process: process,
      port: port,
      index: index
    };
    if (!(process.component.outPorts && process.component.outPorts[port])) {
      throw new Error("No outport '" + port + "' defined in process " + process.id + " (" + (socket.getId()) + ")");
      return;
    }
    if (process.component.outPorts[port].isAddressable()) {
      return process.component.outPorts[port].attach(socket, index);
    }
    return process.component.outPorts[port].attach(socket);
  };

  Network.prototype.subscribeGraph = function() {
    var graphOps, processOps, processing, registerOp;
    graphOps = [];
    processing = false;
    registerOp = function(op, details) {
      return graphOps.push({
        op: op,
        details: details
      });
    };
    processOps = (function(_this) {
      return function(err) {
        var cb, op;
        if (err) {
          if (_this.listeners('process-error').length === 0) {
            throw err;
          }
          _this.emit('process-error', err);
        }
        if (!graphOps.length) {
          processing = false;
          return;
        }
        processing = true;
        op = graphOps.shift();
        cb = processOps;
        switch (op.op) {
          case 'renameNode':
            return _this.renameNode(op.details.from, op.details.to, cb);
          default:
            return _this[op.op](op.details, cb);
        }
      };
    })(this);
    this.graph.on('addNode', (function(_this) {
      return function(node) {
        registerOp('addNode', node);
        if (!processing) {
          return processOps();
        }
      };
    })(this));
    this.graph.on('removeNode', (function(_this) {
      return function(node) {
        registerOp('removeNode', node);
        if (!processing) {
          return processOps();
        }
      };
    })(this));
    this.graph.on('renameNode', (function(_this) {
      return function(oldId, newId) {
        registerOp('renameNode', {
          from: oldId,
          to: newId
        });
        if (!processing) {
          return processOps();
        }
      };
    })(this));
    this.graph.on('addEdge', (function(_this) {
      return function(edge) {
        registerOp('addEdge', edge);
        if (!processing) {
          return processOps();
        }
      };
    })(this));
    this.graph.on('removeEdge', (function(_this) {
      return function(edge) {
        registerOp('removeEdge', edge);
        if (!processing) {
          return processOps();
        }
      };
    })(this));
    this.graph.on('addInitial', (function(_this) {
      return function(iip) {
        registerOp('addInitial', iip);
        if (!processing) {
          return processOps();
        }
      };
    })(this));
    return this.graph.on('removeInitial', (function(_this) {
      return function(iip) {
        registerOp('removeInitial', iip);
        if (!processing) {
          return processOps();
        }
      };
    })(this));
  };

  Network.prototype.subscribeSubgraph = function(node) {
    var emitSub;
    if (!node.component.isReady()) {
      node.component.once('ready', (function(_this) {
        return function() {
          return _this.subscribeSubgraph(node);
        };
      })(this));
      return;
    }
    if (!node.component.network) {
      return;
    }
    node.component.network.setDebug(this.debug);
    emitSub = (function(_this) {
      return function(type, data) {
        if (type === 'process-error' && _this.listeners('process-error').length === 0) {
          throw data;
        }
        if (type === 'connect') {
          _this.increaseConnections();
        }
        if (type === 'disconnect') {
          _this.decreaseConnections();
        }
        if (!data) {
          data = {};
        }
        if (data.subgraph) {
          if (!data.subgraph.unshift) {
            data.subgraph = [data.subgraph];
          }
          data.subgraph = data.subgraph.unshift(node.id);
        } else {
          data.subgraph = [node.id];
        }
        return _this.emit(type, data);
      };
    })(this);
    node.component.network.on('connect', function(data) {
      return emitSub('connect', data);
    });
    node.component.network.on('begingroup', function(data) {
      return emitSub('begingroup', data);
    });
    node.component.network.on('data', function(data) {
      return emitSub('data', data);
    });
    node.component.network.on('endgroup', function(data) {
      return emitSub('endgroup', data);
    });
    node.component.network.on('disconnect', function(data) {
      return emitSub('disconnect', data);
    });
    return node.component.network.on('process-error', function(data) {
      return emitSub('process-error', data);
    });
  };

  Network.prototype.subscribeSocket = function(socket) {
    socket.on('connect', (function(_this) {
      return function() {
        _this.increaseConnections();
        return _this.emit('connect', {
          id: socket.getId(),
          socket: socket,
          metadata: socket.metadata
        });
      };
    })(this));
    socket.on('begingroup', (function(_this) {
      return function(group) {
        return _this.emit('begingroup', {
          id: socket.getId(),
          socket: socket,
          group: group,
          metadata: socket.metadata
        });
      };
    })(this));
    socket.on('data', (function(_this) {
      return function(data) {
        return _this.emit('data', {
          id: socket.getId(),
          socket: socket,
          data: data,
          metadata: socket.metadata
        });
      };
    })(this));
    socket.on('endgroup', (function(_this) {
      return function(group) {
        return _this.emit('endgroup', {
          id: socket.getId(),
          socket: socket,
          group: group,
          metadata: socket.metadata
        });
      };
    })(this));
    socket.on('disconnect', (function(_this) {
      return function() {
        _this.decreaseConnections();
        return _this.emit('disconnect', {
          id: socket.getId(),
          socket: socket,
          metadata: socket.metadata
        });
      };
    })(this));
    return socket.on('error', (function(_this) {
      return function(event) {
        if (_this.listeners('process-error').length === 0) {
          throw event;
        }
        return _this.emit('process-error', event);
      };
    })(this));
  };

  Network.prototype.subscribeNode = function(node) {
    if (!node.component.getIcon) {
      return;
    }
    return node.component.on('icon', (function(_this) {
      return function() {
        return _this.emit('icon', {
          id: node.id,
          icon: node.component.getIcon()
        });
      };
    })(this));
  };

  Network.prototype.addEdge = function(edge, callback) {
    var from, socket, to;
    socket = internalSocket.createSocket(edge.metadata);
    socket.setDebug(this.debug);
    from = this.getNode(edge.from.node);
    if (!from) {
      return callback(new Error("No process defined for outbound node " + edge.from.node));
    }
    if (!from.component) {
      return callback(new Error("No component defined for outbound node " + edge.from.node));
    }
    if (!from.component.isReady()) {
      from.component.once("ready", (function(_this) {
        return function() {
          return _this.addEdge(edge, callback);
        };
      })(this));
      return;
    }
    to = this.getNode(edge.to.node);
    if (!to) {
      return callback(new Error("No process defined for inbound node " + edge.to.node));
    }
    if (!to.component) {
      return callback(new Error("No component defined for inbound node " + edge.to.node));
    }
    if (!to.component.isReady()) {
      to.component.once("ready", (function(_this) {
        return function() {
          return _this.addEdge(edge, callback);
        };
      })(this));
      return;
    }
    this.subscribeSocket(socket);
    this.connectPort(socket, to, edge.to.port, edge.to.index, true);
    this.connectPort(socket, from, edge.from.port, edge.from.index, false);
    this.connections.push(socket);
    if (callback) {
      return callback();
    }
  };

  Network.prototype.removeEdge = function(edge, callback) {
    var connection, i, len, ref, results;
    ref = this.connections;
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      connection = ref[i];
      if (!connection) {
        continue;
      }
      if (!(edge.to.node === connection.to.process.id && edge.to.port === connection.to.port)) {
        continue;
      }
      connection.to.process.component.inPorts[connection.to.port].detach(connection);
      if (edge.from.node) {
        if (connection.from && edge.from.node === connection.from.process.id && edge.from.port === connection.from.port) {
          connection.from.process.component.outPorts[connection.from.port].detach(connection);
        }
      }
      this.connections.splice(this.connections.indexOf(connection), 1);
      if (callback) {
        results.push(callback());
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  Network.prototype.addDefaults = function(node, callback) {
    var key, port, process, ref, socket;
    process = this.processes[node.id];
    if (!process.component.isReady()) {
      if (process.component.setMaxListeners) {
        process.component.setMaxListeners(0);
      }
      process.component.once("ready", (function(_this) {
        return function() {
          return _this.addDefaults(process, callback);
        };
      })(this));
      return;
    }
    ref = process.component.inPorts.ports;
    for (key in ref) {
      port = ref[key];
      if (typeof port.hasDefault === 'function' && port.hasDefault() && !port.isAttached()) {
        socket = internalSocket.createSocket();
        socket.setDebug(this.debug);
        this.subscribeSocket(socket);
        this.connectPort(socket, process, key, void 0, true);
        this.connections.push(socket);
        this.defaults.push(socket);
      }
    }
    if (callback) {
      return callback();
    }
  };

  Network.prototype.addInitial = function(initializer, callback) {
    var init, socket, to;
    socket = internalSocket.createSocket(initializer.metadata);
    socket.setDebug(this.debug);
    this.subscribeSocket(socket);
    to = this.getNode(initializer.to.node);
    if (!to) {
      return callback(new Error("No process defined for inbound node " + initializer.to.node));
    }
    if (!(to.component.isReady() || to.component.inPorts[initializer.to.port])) {
      if (to.component.setMaxListeners) {
        to.component.setMaxListeners(0);
      }
      to.component.once("ready", (function(_this) {
        return function() {
          return _this.addInitial(initializer, callback);
        };
      })(this));
      return;
    }
    this.connectPort(socket, to, initializer.to.port, initializer.to.index, true);
    this.connections.push(socket);
    init = {
      socket: socket,
      data: initializer.from.data
    };
    this.initials.push(init);
    this.nextInitials.push(init);
    if (this.isStarted()) {
      this.sendInitials();
    }
    if (callback) {
      return callback();
    }
  };

  Network.prototype.removeInitial = function(initializer, callback) {
    var connection, i, init, j, k, len, len1, len2, ref, ref1, ref2;
    ref = this.connections;
    for (i = 0, len = ref.length; i < len; i++) {
      connection = ref[i];
      if (!connection) {
        continue;
      }
      if (!(initializer.to.node === connection.to.process.id && initializer.to.port === connection.to.port)) {
        continue;
      }
      connection.to.process.component.inPorts[connection.to.port].detach(connection);
      this.connections.splice(this.connections.indexOf(connection), 1);
      ref1 = this.initials;
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        init = ref1[j];
        if (!init) {
          continue;
        }
        if (init.socket !== connection) {
          continue;
        }
        this.initials.splice(this.initials.indexOf(init), 1);
      }
      ref2 = this.nextInitials;
      for (k = 0, len2 = ref2.length; k < len2; k++) {
        init = ref2[k];
        if (!init) {
          continue;
        }
        if (init.socket !== connection) {
          continue;
        }
        this.nextInitials.splice(this.nextInitials.indexOf(init), 1);
      }
    }
    if (callback) {
      return callback();
    }
  };

  Network.prototype.sendInitial = function(initial) {
    initial.socket.connect();
    initial.socket.send(initial.data);
    return initial.socket.disconnect();
  };

  Network.prototype.sendInitials = function(callback) {
    var send;
    if (!callback) {
      callback = function() {};
    }
    send = (function(_this) {
      return function() {
        var i, initial, len, ref;
        ref = _this.initials;
        for (i = 0, len = ref.length; i < len; i++) {
          initial = ref[i];
          _this.sendInitial(initial);
        }
        _this.initials = [];
        return callback();
      };
    })(this);
    if (typeof process !== 'undefined' && process.execPath && process.execPath.indexOf('node') !== -1) {
      return process.nextTick(send);
    } else {
      return setTimeout(send, 0);
    }
  };

  Network.prototype.isStarted = function() {
    return this.started;
  };

  Network.prototype.isRunning = function() {
    if (!this.started) {
      return false;
    }
    return this.connectionCount > 0;
  };

  Network.prototype.startComponents = function(callback) {
    var id, process, ref;
    if (!callback) {
      callback = function() {};
    }
    ref = this.processes;
    for (id in ref) {
      process = ref[id];
      process.component.start();
    }
    return callback();
  };

  Network.prototype.sendDefaults = function(callback) {
    var i, len, ref, results, socket;
    if (!callback) {
      callback = function() {};
    }
    ref = this.defaults;
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      socket = ref[i];
      if (socket.to.process.component.inPorts[socket.to.port].sockets.length !== 1) {
        continue;
      }
      socket.connect();
      socket.send();
      socket.disconnect();
      results.push(callback());
    }
    return results;
  };

  Network.prototype.start = function(callback) {
    if (!callback) {
      callback = function() {};
    }
    if (this.started) {
      this.stop();
    }
    this.initials = this.nextInitials.slice(0);
    return this.startComponents((function(_this) {
      return function(err) {
        if (err) {
          return callback(err);
        }
        return _this.sendInitials(function(err) {
          if (err) {
            return callback(err);
          }
          _this.started = true;
          return _this.sendDefaults(callback);
        });
      };
    })(this));
  };

  Network.prototype.stop = function() {
    var connection, i, id, len, process, ref, ref1;
    ref = this.connections;
    for (i = 0, len = ref.length; i < len; i++) {
      connection = ref[i];
      if (!connection.isConnected()) {
        continue;
      }
      connection.disconnect();
    }
    ref1 = this.processes;
    for (id in ref1) {
      process = ref1[id];
      process.component.shutdown();
    }
    return this.started = false;
  };

  Network.prototype.getDebug = function() {
    return this.debug;
  };

  Network.prototype.setDebug = function(active) {
    var i, instance, len, process, processId, ref, ref1, results, socket;
    if (active === this.debug) {
      return;
    }
    this.debug = active;
    ref = this.connections;
    for (i = 0, len = ref.length; i < len; i++) {
      socket = ref[i];
      socket.setDebug(active);
    }
    ref1 = this.processes;
    results = [];
    for (processId in ref1) {
      process = ref1[processId];
      instance = process.component;
      if (instance.isSubgraph()) {
        results.push(instance.network.setDebug(active));
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  return Network;

})(EventEmitter);

exports.Network = Network;

});
require.register("noflo-noflo/src/lib/Platform.js", function(exports, require, module){
exports.isBrowser = function() {
  if (typeof process !== 'undefined' && process.execPath && process.execPath.match(/node|iojs/)) {
    return false;
  }
  return true;
};

});
require.register("noflo-noflo/src/lib/Journal.js", function(exports, require, module){
var EventEmitter, Journal, JournalStore, MemoryJournalStore, calculateMeta, clone, entryToPrettyString,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

EventEmitter = require('events').EventEmitter;

clone = require('./Utils').clone;

entryToPrettyString = function(entry) {
  var a;
  a = entry.args;
  switch (entry.cmd) {
    case 'addNode':
      return a.id + "(" + a.component + ")";
    case 'removeNode':
      return "DEL " + a.id + "(" + a.component + ")";
    case 'renameNode':
      return "RENAME " + a.oldId + " " + a.newId;
    case 'changeNode':
      return "META " + a.id;
    case 'addEdge':
      return a.from.node + " " + a.from.port + " -> " + a.to.port + " " + a.to.node;
    case 'removeEdge':
      return a.from.node + " " + a.from.port + " -X> " + a.to.port + " " + a.to.node;
    case 'changeEdge':
      return "META " + a.from.node + " " + a.from.port + " -> " + a.to.port + " " + a.to.node;
    case 'addInitial':
      return "'" + a.from.data + "' -> " + a.to.port + " " + a.to.node;
    case 'removeInitial':
      return "'" + a.from.data + "' -X> " + a.to.port + " " + a.to.node;
    case 'startTransaction':
      return ">>> " + entry.rev + ": " + a.id;
    case 'endTransaction':
      return "<<< " + entry.rev + ": " + a.id;
    case 'changeProperties':
      return "PROPERTIES";
    case 'addGroup':
      return "GROUP " + a.name;
    case 'renameGroup':
      return "RENAME GROUP " + a.oldName + " " + a.newName;
    case 'removeGroup':
      return "DEL GROUP " + a.name;
    case 'changeGroup':
      return "META GROUP " + a.name;
    case 'addInport':
      return "INPORT " + a.name;
    case 'removeInport':
      return "DEL INPORT " + a.name;
    case 'renameInport':
      return "RENAME INPORT " + a.oldId + " " + a.newId;
    case 'changeInport':
      return "META INPORT " + a.name;
    case 'addOutport':
      return "OUTPORT " + a.name;
    case 'removeOutport':
      return "DEL OUTPORT " + a.name;
    case 'renameOutport':
      return "RENAME OUTPORT " + a.oldId + " " + a.newId;
    case 'changeOutport':
      return "META OUTPORT " + a.name;
    default:
      throw new Error("Unknown journal entry: " + entry.cmd);
  }
};

calculateMeta = function(oldMeta, newMeta) {
  var k, setMeta, v;
  setMeta = {};
  for (k in oldMeta) {
    v = oldMeta[k];
    setMeta[k] = null;
  }
  for (k in newMeta) {
    v = newMeta[k];
    setMeta[k] = v;
  }
  return setMeta;
};

JournalStore = (function(superClass) {
  extend(JournalStore, superClass);

  JournalStore.prototype.lastRevision = 0;

  function JournalStore(graph1) {
    this.graph = graph1;
    this.lastRevision = 0;
  }

  JournalStore.prototype.putTransaction = function(revId, entries) {
    if (revId > this.lastRevision) {
      this.lastRevision = revId;
    }
    return this.emit('transaction', revId);
  };

  JournalStore.prototype.fetchTransaction = function(revId, entries) {};

  return JournalStore;

})(EventEmitter);

MemoryJournalStore = (function(superClass) {
  extend(MemoryJournalStore, superClass);

  function MemoryJournalStore(graph) {
    MemoryJournalStore.__super__.constructor.call(this, graph);
    this.transactions = [];
  }

  MemoryJournalStore.prototype.putTransaction = function(revId, entries) {
    MemoryJournalStore.__super__.putTransaction.call(this, revId, entries);
    return this.transactions[revId] = entries;
  };

  MemoryJournalStore.prototype.fetchTransaction = function(revId) {
    return this.transactions[revId];
  };

  return MemoryJournalStore;

})(JournalStore);

Journal = (function(superClass) {
  extend(Journal, superClass);

  Journal.prototype.graph = null;

  Journal.prototype.entries = [];

  Journal.prototype.subscribed = true;

  function Journal(graph, metadata, store) {
    this.endTransaction = bind(this.endTransaction, this);
    this.startTransaction = bind(this.startTransaction, this);
    var edge, group, iip, j, k, l, len, len1, len2, len3, m, n, node, ref, ref1, ref2, ref3, ref4, ref5, v;
    this.graph = graph;
    this.entries = [];
    this.subscribed = true;
    this.store = store || new MemoryJournalStore(this.graph);
    if (this.store.transactions.length === 0) {
      this.currentRevision = -1;
      this.startTransaction('initial', metadata);
      ref = this.graph.nodes;
      for (j = 0, len = ref.length; j < len; j++) {
        node = ref[j];
        this.appendCommand('addNode', node);
      }
      ref1 = this.graph.edges;
      for (l = 0, len1 = ref1.length; l < len1; l++) {
        edge = ref1[l];
        this.appendCommand('addEdge', edge);
      }
      ref2 = this.graph.initializers;
      for (m = 0, len2 = ref2.length; m < len2; m++) {
        iip = ref2[m];
        this.appendCommand('addInitial', iip);
      }
      if (Object.keys(this.graph.properties).length > 0) {
        this.appendCommand('changeProperties', this.graph.properties, {});
      }
      ref3 = this.graph.inports;
      for (k in ref3) {
        v = ref3[k];
        this.appendCommand('addInport', {
          name: k,
          port: v
        });
      }
      ref4 = this.graph.outports;
      for (k in ref4) {
        v = ref4[k];
        this.appendCommand('addOutport', {
          name: k,
          port: v
        });
      }
      ref5 = this.graph.groups;
      for (n = 0, len3 = ref5.length; n < len3; n++) {
        group = ref5[n];
        this.appendCommand('addGroup', group);
      }
      this.endTransaction('initial', metadata);
    } else {
      this.currentRevision = this.store.lastRevision;
    }
    this.graph.on('addNode', (function(_this) {
      return function(node) {
        return _this.appendCommand('addNode', node);
      };
    })(this));
    this.graph.on('removeNode', (function(_this) {
      return function(node) {
        return _this.appendCommand('removeNode', node);
      };
    })(this));
    this.graph.on('renameNode', (function(_this) {
      return function(oldId, newId) {
        var args;
        args = {
          oldId: oldId,
          newId: newId
        };
        return _this.appendCommand('renameNode', args);
      };
    })(this));
    this.graph.on('changeNode', (function(_this) {
      return function(node, oldMeta) {
        return _this.appendCommand('changeNode', {
          id: node.id,
          "new": node.metadata,
          old: oldMeta
        });
      };
    })(this));
    this.graph.on('addEdge', (function(_this) {
      return function(edge) {
        return _this.appendCommand('addEdge', edge);
      };
    })(this));
    this.graph.on('removeEdge', (function(_this) {
      return function(edge) {
        return _this.appendCommand('removeEdge', edge);
      };
    })(this));
    this.graph.on('changeEdge', (function(_this) {
      return function(edge, oldMeta) {
        return _this.appendCommand('changeEdge', {
          from: edge.from,
          to: edge.to,
          "new": edge.metadata,
          old: oldMeta
        });
      };
    })(this));
    this.graph.on('addInitial', (function(_this) {
      return function(iip) {
        return _this.appendCommand('addInitial', iip);
      };
    })(this));
    this.graph.on('removeInitial', (function(_this) {
      return function(iip) {
        return _this.appendCommand('removeInitial', iip);
      };
    })(this));
    this.graph.on('changeProperties', (function(_this) {
      return function(newProps, oldProps) {
        return _this.appendCommand('changeProperties', {
          "new": newProps,
          old: oldProps
        });
      };
    })(this));
    this.graph.on('addGroup', (function(_this) {
      return function(group) {
        return _this.appendCommand('addGroup', group);
      };
    })(this));
    this.graph.on('renameGroup', (function(_this) {
      return function(oldName, newName) {
        return _this.appendCommand('renameGroup', {
          oldName: oldName,
          newName: newName
        });
      };
    })(this));
    this.graph.on('removeGroup', (function(_this) {
      return function(group) {
        return _this.appendCommand('removeGroup', group);
      };
    })(this));
    this.graph.on('changeGroup', (function(_this) {
      return function(group, oldMeta) {
        return _this.appendCommand('changeGroup', {
          name: group.name,
          "new": group.metadata,
          old: oldMeta
        });
      };
    })(this));
    this.graph.on('addExport', (function(_this) {
      return function(exported) {
        return _this.appendCommand('addExport', exported);
      };
    })(this));
    this.graph.on('removeExport', (function(_this) {
      return function(exported) {
        return _this.appendCommand('removeExport', exported);
      };
    })(this));
    this.graph.on('addInport', (function(_this) {
      return function(name, port) {
        return _this.appendCommand('addInport', {
          name: name,
          port: port
        });
      };
    })(this));
    this.graph.on('removeInport', (function(_this) {
      return function(name, port) {
        return _this.appendCommand('removeInport', {
          name: name,
          port: port
        });
      };
    })(this));
    this.graph.on('renameInport', (function(_this) {
      return function(oldId, newId) {
        return _this.appendCommand('renameInport', {
          oldId: oldId,
          newId: newId
        });
      };
    })(this));
    this.graph.on('changeInport', (function(_this) {
      return function(name, port, oldMeta) {
        return _this.appendCommand('changeInport', {
          name: name,
          "new": port.metadata,
          old: oldMeta
        });
      };
    })(this));
    this.graph.on('addOutport', (function(_this) {
      return function(name, port) {
        return _this.appendCommand('addOutport', {
          name: name,
          port: port
        });
      };
    })(this));
    this.graph.on('removeOutport', (function(_this) {
      return function(name, port) {
        return _this.appendCommand('removeOutport', {
          name: name,
          port: port
        });
      };
    })(this));
    this.graph.on('renameOutport', (function(_this) {
      return function(oldId, newId) {
        return _this.appendCommand('renameOutport', {
          oldId: oldId,
          newId: newId
        });
      };
    })(this));
    this.graph.on('changeOutport', (function(_this) {
      return function(name, port, oldMeta) {
        return _this.appendCommand('changeOutport', {
          name: name,
          "new": port.metadata,
          old: oldMeta
        });
      };
    })(this));
    this.graph.on('startTransaction', (function(_this) {
      return function(id, meta) {
        return _this.startTransaction(id, meta);
      };
    })(this));
    this.graph.on('endTransaction', (function(_this) {
      return function(id, meta) {
        return _this.endTransaction(id, meta);
      };
    })(this));
  }

  Journal.prototype.startTransaction = function(id, meta) {
    if (!this.subscribed) {
      return;
    }
    if (this.entries.length > 0) {
      throw Error("Inconsistent @entries");
    }
    this.currentRevision++;
    return this.appendCommand('startTransaction', {
      id: id,
      metadata: meta
    }, this.currentRevision);
  };

  Journal.prototype.endTransaction = function(id, meta) {
    if (!this.subscribed) {
      return;
    }
    this.appendCommand('endTransaction', {
      id: id,
      metadata: meta
    }, this.currentRevision);
    this.store.putTransaction(this.currentRevision, this.entries);
    return this.entries = [];
  };

  Journal.prototype.appendCommand = function(cmd, args, rev) {
    var entry;
    if (!this.subscribed) {
      return;
    }
    entry = {
      cmd: cmd,
      args: clone(args)
    };
    if (rev != null) {
      entry.rev = rev;
    }
    return this.entries.push(entry);
  };

  Journal.prototype.executeEntry = function(entry) {
    var a;
    a = entry.args;
    switch (entry.cmd) {
      case 'addNode':
        return this.graph.addNode(a.id, a.component);
      case 'removeNode':
        return this.graph.removeNode(a.id);
      case 'renameNode':
        return this.graph.renameNode(a.oldId, a.newId);
      case 'changeNode':
        return this.graph.setNodeMetadata(a.id, calculateMeta(a.old, a["new"]));
      case 'addEdge':
        return this.graph.addEdge(a.from.node, a.from.port, a.to.node, a.to.port);
      case 'removeEdge':
        return this.graph.removeEdge(a.from.node, a.from.port, a.to.node, a.to.port);
      case 'changeEdge':
        return this.graph.setEdgeMetadata(a.from.node, a.from.port, a.to.node, a.to.port, calculateMeta(a.old, a["new"]));
      case 'addInitial':
        return this.graph.addInitial(a.from.data, a.to.node, a.to.port);
      case 'removeInitial':
        return this.graph.removeInitial(a.to.node, a.to.port);
      case 'startTransaction':
        return null;
      case 'endTransaction':
        return null;
      case 'changeProperties':
        return this.graph.setProperties(a["new"]);
      case 'addGroup':
        return this.graph.addGroup(a.name, a.nodes, a.metadata);
      case 'renameGroup':
        return this.graph.renameGroup(a.oldName, a.newName);
      case 'removeGroup':
        return this.graph.removeGroup(a.name);
      case 'changeGroup':
        return this.graph.setGroupMetadata(a.name, calculateMeta(a.old, a["new"]));
      case 'addInport':
        return this.graph.addInport(a.name, a.port.process, a.port.port, a.port.metadata);
      case 'removeInport':
        return this.graph.removeInport(a.name);
      case 'renameInport':
        return this.graph.renameInport(a.oldId, a.newId);
      case 'changeInport':
        return this.graph.setInportMetadata(a.name, calculateMeta(a.old, a["new"]));
      case 'addOutport':
        return this.graph.addOutport(a.name, a.port.process, a.port.port, a.port.metadata(a.name));
      case 'removeOutport':
        return this.graph.removeOutport;
      case 'renameOutport':
        return this.graph.renameOutport(a.oldId, a.newId);
      case 'changeOutport':
        return this.graph.setOutportMetadata(a.name, calculateMeta(a.old, a["new"]));
      default:
        throw new Error("Unknown journal entry: " + entry.cmd);
    }
  };

  Journal.prototype.executeEntryInversed = function(entry) {
    var a;
    a = entry.args;
    switch (entry.cmd) {
      case 'addNode':
        return this.graph.removeNode(a.id);
      case 'removeNode':
        return this.graph.addNode(a.id, a.component);
      case 'renameNode':
        return this.graph.renameNode(a.newId, a.oldId);
      case 'changeNode':
        return this.graph.setNodeMetadata(a.id, calculateMeta(a["new"], a.old));
      case 'addEdge':
        return this.graph.removeEdge(a.from.node, a.from.port, a.to.node, a.to.port);
      case 'removeEdge':
        return this.graph.addEdge(a.from.node, a.from.port, a.to.node, a.to.port);
      case 'changeEdge':
        return this.graph.setEdgeMetadata(a.from.node, a.from.port, a.to.node, a.to.port, calculateMeta(a["new"], a.old));
      case 'addInitial':
        return this.graph.removeInitial(a.to.node, a.to.port);
      case 'removeInitial':
        return this.graph.addInitial(a.from.data, a.to.node, a.to.port);
      case 'startTransaction':
        return null;
      case 'endTransaction':
        return null;
      case 'changeProperties':
        return this.graph.setProperties(a.old);
      case 'addGroup':
        return this.graph.removeGroup(a.name);
      case 'renameGroup':
        return this.graph.renameGroup(a.newName, a.oldName);
      case 'removeGroup':
        return this.graph.addGroup(a.name, a.nodes, a.metadata);
      case 'changeGroup':
        return this.graph.setGroupMetadata(a.name, calculateMeta(a["new"], a.old));
      case 'addInport':
        return this.graph.removeInport(a.name);
      case 'removeInport':
        return this.graph.addInport(a.name, a.port.process, a.port.port, a.port.metadata);
      case 'renameInport':
        return this.graph.renameInport(a.newId, a.oldId);
      case 'changeInport':
        return this.graph.setInportMetadata(a.name, calculateMeta(a["new"], a.old));
      case 'addOutport':
        return this.graph.removeOutport(a.name);
      case 'removeOutport':
        return this.graph.addOutport(a.name, a.port.process, a.port.port, a.port.metadata);
      case 'renameOutport':
        return this.graph.renameOutport(a.newId, a.oldId);
      case 'changeOutport':
        return this.graph.setOutportMetadata(a.name, calculateMeta(a["new"], a.old));
      default:
        throw new Error("Unknown journal entry: " + entry.cmd);
    }
  };

  Journal.prototype.moveToRevision = function(revId) {
    var entries, entry, i, j, l, len, m, n, r, ref, ref1, ref2, ref3, ref4, ref5;
    if (revId === this.currentRevision) {
      return;
    }
    this.subscribed = false;
    if (revId > this.currentRevision) {
      for (r = j = ref = this.currentRevision + 1, ref1 = revId; ref <= ref1 ? j <= ref1 : j >= ref1; r = ref <= ref1 ? ++j : --j) {
        ref2 = this.store.fetchTransaction(r);
        for (l = 0, len = ref2.length; l < len; l++) {
          entry = ref2[l];
          this.executeEntry(entry);
        }
      }
    } else {
      for (r = m = ref3 = this.currentRevision, ref4 = revId + 1; m >= ref4; r = m += -1) {
        entries = this.store.fetchTransaction(r);
        for (i = n = ref5 = entries.length - 1; n >= 0; i = n += -1) {
          this.executeEntryInversed(entries[i]);
        }
      }
    }
    this.currentRevision = revId;
    return this.subscribed = true;
  };

  Journal.prototype.undo = function() {
    if (!this.canUndo()) {
      return;
    }
    return this.moveToRevision(this.currentRevision - 1);
  };

  Journal.prototype.canUndo = function() {
    return this.currentRevision > 0;
  };

  Journal.prototype.redo = function() {
    if (!this.canRedo()) {
      return;
    }
    return this.moveToRevision(this.currentRevision + 1);
  };

  Journal.prototype.canRedo = function() {
    return this.currentRevision < this.store.lastRevision;
  };

  Journal.prototype.toPrettyString = function(startRev, endRev) {
    var e, entry, j, l, len, lines, r, ref, ref1;
    startRev |= 0;
    endRev |= this.store.lastRevision;
    lines = [];
    for (r = j = ref = startRev, ref1 = endRev; ref <= ref1 ? j < ref1 : j > ref1; r = ref <= ref1 ? ++j : --j) {
      e = this.store.fetchTransaction(r);
      for (l = 0, len = e.length; l < len; l++) {
        entry = e[l];
        lines.push(entryToPrettyString(entry));
      }
    }
    return lines.join('\n');
  };

  Journal.prototype.toJSON = function(startRev, endRev) {
    var entries, entry, j, l, len, r, ref, ref1, ref2;
    startRev |= 0;
    endRev |= this.store.lastRevision;
    entries = [];
    for (r = j = ref = startRev, ref1 = endRev; j < ref1; r = j += 1) {
      ref2 = this.store.fetchTransaction(r);
      for (l = 0, len = ref2.length; l < len; l++) {
        entry = ref2[l];
        entries.push(entryToPrettyString(entry));
      }
    }
    return entries;
  };

  Journal.prototype.save = function(file, success) {
    var json;
    json = JSON.stringify(this.toJSON(), null, 4);
    return require('fs').writeFile(file + ".json", json, "utf-8", function(err, data) {
      if (err) {
        throw err;
      }
      return success(file);
    });
  };

  return Journal;

})(EventEmitter);

exports.Journal = Journal;

exports.JournalStore = JournalStore;

exports.MemoryJournalStore = MemoryJournalStore;

});
require.register("noflo-noflo/src/lib/Utils.js", function(exports, require, module){
var clone, guessLanguageFromFilename;

clone = function(obj) {
  var flags, key, newInstance;
  if ((obj == null) || typeof obj !== 'object') {
    return obj;
  }
  if (obj instanceof Date) {
    return new Date(obj.getTime());
  }
  if (obj instanceof RegExp) {
    flags = '';
    if (obj.global != null) {
      flags += 'g';
    }
    if (obj.ignoreCase != null) {
      flags += 'i';
    }
    if (obj.multiline != null) {
      flags += 'm';
    }
    if (obj.sticky != null) {
      flags += 'y';
    }
    return new RegExp(obj.source, flags);
  }
  newInstance = new obj.constructor();
  for (key in obj) {
    newInstance[key] = clone(obj[key]);
  }
  return newInstance;
};

guessLanguageFromFilename = function(filename) {
  if (/.*\.coffee$/.test(filename)) {
    return 'coffeescript';
  }
  return 'javascript';
};

exports.clone = clone;

exports.guessLanguageFromFilename = guessLanguageFromFilename;

});
require.register("noflo-noflo/src/lib/Helpers.js", function(exports, require, module){
var InternalSocket, StreamReceiver, StreamSender, _, isArray,
  hasProp = {}.hasOwnProperty;

_ = require('underscore');

StreamSender = require('./Streams').StreamSender;

StreamReceiver = require('./Streams').StreamReceiver;

InternalSocket = require('./InternalSocket');

isArray = function(obj) {
  if (Array.isArray) {
    return Array.isArray(obj);
  }
  return Object.prototype.toString.call(arg) === '[object Array]';
};

exports.MapComponent = function(component, func, config) {
  var groups, inPort, outPort;
  if (!config) {
    config = {};
  }
  if (!config.inPort) {
    config.inPort = 'in';
  }
  if (!config.outPort) {
    config.outPort = 'out';
  }
  inPort = component.inPorts[config.inPort];
  outPort = component.outPorts[config.outPort];
  groups = [];
  return inPort.process = function(event, payload) {
    switch (event) {
      case 'connect':
        return outPort.connect();
      case 'begingroup':
        groups.push(payload);
        return outPort.beginGroup(payload);
      case 'data':
        return func(payload, groups, outPort);
      case 'endgroup':
        groups.pop();
        return outPort.endGroup();
      case 'disconnect':
        groups = [];
        return outPort.disconnect();
    }
  };
};

exports.WirePattern = function(component, config, proc) {
  var baseShutdown, closeGroupOnOuts, collectGroups, disconnectOuts, fn, fn1, gc, inPorts, j, k, l, len, len1, len2, len3, len4, m, n, name, outPorts, port, processQueue, ref, ref1, resumeTaskQ, sendGroupToOuts;
  inPorts = 'in' in config ? config["in"] : 'in';
  if (!isArray(inPorts)) {
    inPorts = [inPorts];
  }
  outPorts = 'out' in config ? config.out : 'out';
  if (!isArray(outPorts)) {
    outPorts = [outPorts];
  }
  if (!('error' in config)) {
    config.error = 'error';
  }
  if (!('async' in config)) {
    config.async = false;
  }
  if (!('ordered' in config)) {
    config.ordered = true;
  }
  if (!('group' in config)) {
    config.group = false;
  }
  if (!('field' in config)) {
    config.field = null;
  }
  if (!('forwardGroups' in config)) {
    config.forwardGroups = false;
  }
  if (!('receiveStreams' in config)) {
    config.receiveStreams = false;
  }
  if (typeof config.receiveStreams === 'string') {
    config.receiveStreams = [config.receiveStreams];
  }
  if (!('sendStreams' in config)) {
    config.sendStreams = false;
  }
  if (typeof config.sendStreams === 'string') {
    config.sendStreams = [config.sendStreams];
  }
  if (config.async) {
    config.sendStreams = outPorts;
  }
  if (!('params' in config)) {
    config.params = [];
  }
  if (typeof config.params === 'string') {
    config.params = [config.params];
  }
  if (!('name' in config)) {
    config.name = '';
  }
  if (!('dropInput' in config)) {
    config.dropInput = false;
  }
  if (!('arrayPolicy' in config)) {
    config.arrayPolicy = {
      "in": 'any',
      params: 'all'
    };
  }
  if (!('gcFrequency' in config)) {
    config.gcFrequency = 100;
  }
  if (!('gcTimeout' in config)) {
    config.gcTimeout = 300;
  }
  collectGroups = config.forwardGroups;
  if (typeof collectGroups === 'boolean' && !config.group) {
    collectGroups = inPorts;
  }
  if (typeof collectGroups === 'string' && !config.group) {
    collectGroups = [collectGroups];
  }
  if (collectGroups !== false && config.group) {
    collectGroups = true;
  }
  for (j = 0, len = inPorts.length; j < len; j++) {
    name = inPorts[j];
    if (!component.inPorts[name]) {
      throw new Error("no inPort named '" + name + "'");
    }
  }
  for (k = 0, len1 = outPorts.length; k < len1; k++) {
    name = outPorts[k];
    if (!component.outPorts[name]) {
      throw new Error("no outPort named '" + name + "'");
    }
  }
  component.groupedData = {};
  component.groupedGroups = {};
  component.groupedDisconnects = {};
  disconnectOuts = function() {
    var l, len2, p, results;
    results = [];
    for (l = 0, len2 = outPorts.length; l < len2; l++) {
      p = outPorts[l];
      if (component.outPorts[p].isConnected()) {
        results.push(component.outPorts[p].disconnect());
      } else {
        results.push(void 0);
      }
    }
    return results;
  };
  sendGroupToOuts = function(grp) {
    var l, len2, p, results;
    results = [];
    for (l = 0, len2 = outPorts.length; l < len2; l++) {
      p = outPorts[l];
      results.push(component.outPorts[p].beginGroup(grp));
    }
    return results;
  };
  closeGroupOnOuts = function(grp) {
    var l, len2, p, results;
    results = [];
    for (l = 0, len2 = outPorts.length; l < len2; l++) {
      p = outPorts[l];
      results.push(component.outPorts[p].endGroup(grp));
    }
    return results;
  };
  component.outputQ = [];
  processQueue = function() {
    var flushed, key, stream, streams, tmp;
    while (component.outputQ.length > 0) {
      streams = component.outputQ[0];
      flushed = false;
      if (streams === null) {
        disconnectOuts();
        flushed = true;
      } else {
        if (outPorts.length === 1) {
          tmp = {};
          tmp[outPorts[0]] = streams;
          streams = tmp;
        }
        for (key in streams) {
          stream = streams[key];
          if (stream.resolved) {
            stream.flush();
            flushed = true;
          }
        }
      }
      if (flushed) {
        component.outputQ.shift();
      }
      if (!flushed) {
        return;
      }
    }
  };
  if (config.async) {
    if ('load' in component.outPorts) {
      component.load = 0;
    }
    component.beforeProcess = function(outs) {
      if (config.ordered) {
        component.outputQ.push(outs);
      }
      component.load++;
      if ('load' in component.outPorts && component.outPorts.load.isAttached()) {
        component.outPorts.load.send(component.load);
        return component.outPorts.load.disconnect();
      }
    };
    component.afterProcess = function(err, outs) {
      processQueue();
      component.load--;
      if ('load' in component.outPorts && component.outPorts.load.isAttached()) {
        component.outPorts.load.send(component.load);
        return component.outPorts.load.disconnect();
      }
    };
  }
  component.taskQ = [];
  component.params = {};
  component.requiredParams = [];
  component.completeParams = [];
  component.receivedParams = [];
  component.defaultedParams = [];
  component.defaultsSent = false;
  component.sendDefaults = function() {
    var l, len2, param, ref, tempSocket;
    if (component.defaultedParams.length > 0) {
      ref = component.defaultedParams;
      for (l = 0, len2 = ref.length; l < len2; l++) {
        param = ref[l];
        if (component.receivedParams.indexOf(param) === -1) {
          tempSocket = InternalSocket.createSocket();
          component.inPorts[param].attach(tempSocket);
          tempSocket.send();
          tempSocket.disconnect();
          component.inPorts[param].detach(tempSocket);
        }
      }
    }
    return component.defaultsSent = true;
  };
  resumeTaskQ = function() {
    var results, task, temp;
    if (component.completeParams.length === component.requiredParams.length && component.taskQ.length > 0) {
      temp = component.taskQ.slice(0);
      component.taskQ = [];
      results = [];
      while (temp.length > 0) {
        task = temp.shift();
        results.push(task());
      }
      return results;
    }
  };
  ref = config.params;
  for (l = 0, len2 = ref.length; l < len2; l++) {
    port = ref[l];
    if (!component.inPorts[port]) {
      throw new Error("no inPort named '" + port + "'");
    }
    if (component.inPorts[port].isRequired()) {
      component.requiredParams.push(port);
    }
    if (component.inPorts[port].hasDefault()) {
      component.defaultedParams.push(port);
    }
  }
  ref1 = config.params;
  fn = function(port) {
    var inPort;
    inPort = component.inPorts[port];
    return inPort.process = function(event, payload, index) {
      if (event !== 'data') {
        return;
      }
      if (inPort.isAddressable()) {
        if (!(port in component.params)) {
          component.params[port] = {};
        }
        component.params[port][index] = payload;
        if (config.arrayPolicy.params === 'all' && Object.keys(component.params[port]).length < inPort.listAttached().length) {
          return;
        }
      } else {
        component.params[port] = payload;
      }
      if (component.completeParams.indexOf(port) === -1 && component.requiredParams.indexOf(port) > -1) {
        component.completeParams.push(port);
      }
      component.receivedParams.push(port);
      return resumeTaskQ();
    };
  };
  for (m = 0, len3 = ref1.length; m < len3; m++) {
    port = ref1[m];
    fn(port);
  }
  component.disconnectData = {};
  component.disconnectQ = [];
  component.groupBuffers = {};
  component.keyBuffers = {};
  component.gcTimestamps = {};
  component.dropRequest = function(key) {
    if (key in component.disconnectData) {
      delete component.disconnectData[key];
    }
    if (key in component.groupedData) {
      delete component.groupedData[key];
    }
    if (key in component.groupedGroups) {
      return delete component.groupedGroups[key];
    }
  };
  component.gcCounter = 0;
  gc = function() {
    var current, key, ref2, results, val;
    component.gcCounter++;
    if (component.gcCounter % config.gcFrequency === 0) {
      current = new Date().getTime();
      ref2 = component.gcTimestamps;
      results = [];
      for (key in ref2) {
        val = ref2[key];
        if ((current - val) > (config.gcTimeout * 1000)) {
          component.dropRequest(key);
          results.push(delete component.gcTimestamps[key]);
        } else {
          results.push(void 0);
        }
      }
      return results;
    }
  };
  fn1 = function(port) {
    var inPort, needPortGroups;
    component.groupBuffers[port] = [];
    component.keyBuffers[port] = null;
    if (config.receiveStreams && config.receiveStreams.indexOf(port) !== -1) {
      inPort = new StreamReceiver(component.inPorts[port]);
    } else {
      inPort = component.inPorts[port];
    }
    needPortGroups = collectGroups instanceof Array && collectGroups.indexOf(port) !== -1;
    return inPort.process = function(event, payload, index) {
      var data, foundGroup, g, groupLength, groups, grp, i, key, len5, len6, len7, len8, o, obj, out, outs, postpone, postponedToQ, q, r, ref2, ref3, ref4, reqId, requiredLength, resume, s, t, task, tmp, u, whenDone, whenDoneGroups;
      if (!component.groupBuffers[port]) {
        component.groupBuffers[port] = [];
      }
      switch (event) {
        case 'begingroup':
          component.groupBuffers[port].push(payload);
          if (config.forwardGroups && (collectGroups === true || needPortGroups) && !config.async) {
            return sendGroupToOuts(payload);
          }
          break;
        case 'endgroup':
          component.groupBuffers[port] = component.groupBuffers[port].slice(0, component.groupBuffers[port].length - 1);
          if (config.forwardGroups && (collectGroups === true || needPortGroups) && !config.async) {
            return closeGroupOnOuts(payload);
          }
          break;
        case 'disconnect':
          if (inPorts.length === 1) {
            if (config.async || config.StreamSender) {
              if (config.ordered) {
                component.outputQ.push(null);
                return processQueue();
              } else {
                return component.disconnectQ.push(true);
              }
            } else {
              return disconnectOuts();
            }
          } else {
            foundGroup = false;
            key = component.keyBuffers[port];
            if (!(key in component.disconnectData)) {
              component.disconnectData[key] = [];
            }
            for (i = o = 0, ref2 = component.disconnectData[key].length; 0 <= ref2 ? o < ref2 : o > ref2; i = 0 <= ref2 ? ++o : --o) {
              if (!(port in component.disconnectData[key][i])) {
                foundGroup = true;
                component.disconnectData[key][i][port] = true;
                if (Object.keys(component.disconnectData[key][i]).length === inPorts.length) {
                  component.disconnectData[key].shift();
                  if (config.async || config.StreamSender) {
                    if (config.ordered) {
                      component.outputQ.push(null);
                      processQueue();
                    } else {
                      component.disconnectQ.push(true);
                    }
                  } else {
                    disconnectOuts();
                  }
                  if (component.disconnectData[key].length === 0) {
                    delete component.disconnectData[key];
                  }
                }
                break;
              }
            }
            if (!foundGroup) {
              obj = {};
              obj[port] = true;
              return component.disconnectData[key].push(obj);
            }
          }
          break;
        case 'data':
          if (inPorts.length === 1 && !inPort.isAddressable()) {
            data = payload;
            groups = component.groupBuffers[port];
          } else {
            key = '';
            if (config.group && component.groupBuffers[port].length > 0) {
              key = component.groupBuffers[port].toString();
              if (config.group instanceof RegExp) {
                reqId = null;
                ref3 = component.groupBuffers[port];
                for (q = 0, len5 = ref3.length; q < len5; q++) {
                  grp = ref3[q];
                  if (config.group.test(grp)) {
                    reqId = grp;
                    break;
                  }
                }
                key = reqId ? reqId : '';
              }
            } else if (config.field && typeof payload === 'object' && config.field in payload) {
              key = payload[config.field];
            }
            component.keyBuffers[port] = key;
            if (!(key in component.groupedData)) {
              component.groupedData[key] = [];
            }
            if (!(key in component.groupedGroups)) {
              component.groupedGroups[key] = [];
            }
            foundGroup = false;
            requiredLength = inPorts.length;
            if (config.field) {
              ++requiredLength;
            }
            for (i = r = 0, ref4 = component.groupedData[key].length; 0 <= ref4 ? r < ref4 : r > ref4; i = 0 <= ref4 ? ++r : --r) {
              if (!(port in component.groupedData[key][i]) || (component.inPorts[port].isAddressable() && config.arrayPolicy["in"] === 'all' && !(index in component.groupedData[key][i][port]))) {
                foundGroup = true;
                if (component.inPorts[port].isAddressable()) {
                  if (!(port in component.groupedData[key][i])) {
                    component.groupedData[key][i][port] = {};
                  }
                  component.groupedData[key][i][port][index] = payload;
                } else {
                  component.groupedData[key][i][port] = payload;
                }
                if (needPortGroups) {
                  component.groupedGroups[key][i] = _.union(component.groupedGroups[key][i], component.groupBuffers[port]);
                } else if (collectGroups === true) {
                  component.groupedGroups[key][i][port] = component.groupBuffers[port];
                }
                if (component.inPorts[port].isAddressable() && config.arrayPolicy["in"] === 'all' && Object.keys(component.groupedData[key][i][port]).length < component.inPorts[port].listAttached().length) {
                  return;
                }
                groupLength = Object.keys(component.groupedData[key][i]).length;
                if (groupLength === requiredLength) {
                  data = (component.groupedData[key].splice(i, 1))[0];
                  if (inPorts.length === 1 && inPort.isAddressable()) {
                    data = data[port];
                  }
                  groups = (component.groupedGroups[key].splice(i, 1))[0];
                  if (collectGroups === true) {
                    groups = _.intersection.apply(null, _.values(groups));
                  }
                  if (component.groupedData[key].length === 0) {
                    delete component.groupedData[key];
                  }
                  if (component.groupedGroups[key].length === 0) {
                    delete component.groupedGroups[key];
                  }
                  if (config.group && key) {
                    delete component.gcTimestamps[key];
                  }
                  break;
                } else {
                  return;
                }
              }
            }
            if (!foundGroup) {
              obj = {};
              if (config.field) {
                obj[config.field] = key;
              }
              if (component.inPorts[port].isAddressable()) {
                obj[port] = {};
                obj[port][index] = payload;
              } else {
                obj[port] = payload;
              }
              if (inPorts.length === 1 && component.inPorts[port].isAddressable() && (config.arrayPolicy["in"] === 'any' || component.inPorts[port].listAttached().length === 1)) {
                data = obj[port];
                groups = component.groupBuffers[port];
              } else {
                component.groupedData[key].push(obj);
                if (needPortGroups) {
                  component.groupedGroups[key].push(component.groupBuffers[port]);
                } else if (collectGroups === true) {
                  tmp = {};
                  tmp[port] = component.groupBuffers[port];
                  component.groupedGroups[key].push(tmp);
                } else {
                  component.groupedGroups[key].push([]);
                }
                if (config.group && key) {
                  component.gcTimestamps[key] = new Date().getTime();
                }
                return;
              }
            }
          }
          if (config.dropInput && component.completeParams.length !== component.requiredParams.length) {
            return;
          }
          outs = {};
          for (s = 0, len6 = outPorts.length; s < len6; s++) {
            name = outPorts[s];
            if (config.async || config.sendStreams && config.sendStreams.indexOf(name) !== -1) {
              outs[name] = new StreamSender(component.outPorts[name], config.ordered);
            } else {
              outs[name] = component.outPorts[name];
            }
          }
          if (outPorts.length === 1) {
            outs = outs[outPorts[0]];
          }
          if (!groups) {
            groups = [];
          }
          whenDoneGroups = groups.slice(0);
          whenDone = function(err) {
            var disconnect, len7, out, outputs, t;
            if (err) {
              component.error(err, whenDoneGroups);
            }
            if (typeof component.fail === 'function' && component.hasErrors) {
              component.fail();
            }
            outputs = outPorts.length === 1 ? {
              port: outs
            } : outs;
            disconnect = false;
            if (component.disconnectQ.length > 0) {
              component.disconnectQ.shift();
              disconnect = true;
            }
            for (name in outputs) {
              out = outputs[name];
              if (config.forwardGroups && config.async) {
                for (t = 0, len7 = whenDoneGroups.length; t < len7; t++) {
                  i = whenDoneGroups[t];
                  out.endGroup();
                }
              }
              if (disconnect) {
                out.disconnect();
              }
              if (config.async || config.StreamSender) {
                out.done();
              }
            }
            if (typeof component.afterProcess === 'function') {
              return component.afterProcess(err || component.hasErrors, outs);
            }
          };
          if (typeof component.beforeProcess === 'function') {
            component.beforeProcess(outs);
          }
          if (config.forwardGroups && config.async) {
            if (outPorts.length === 1) {
              for (t = 0, len7 = groups.length; t < len7; t++) {
                g = groups[t];
                outs.beginGroup(g);
              }
            } else {
              for (name in outs) {
                out = outs[name];
                for (u = 0, len8 = groups.length; u < len8; u++) {
                  g = groups[u];
                  out.beginGroup(g);
                }
              }
            }
          }
          exports.MultiError(component, config.name, config.error, groups);
          if (config.async) {
            postpone = function() {};
            resume = function() {};
            postponedToQ = false;
            task = function() {
              return proc.call(component, data, groups, outs, whenDone, postpone, resume);
            };
            postpone = function(backToQueue) {
              if (backToQueue == null) {
                backToQueue = true;
              }
              postponedToQ = backToQueue;
              if (backToQueue) {
                return component.taskQ.push(task);
              }
            };
            resume = function() {
              if (postponedToQ) {
                return resumeTaskQ();
              } else {
                return task();
              }
            };
          } else {
            task = function() {
              proc.call(component, data, groups, outs);
              return whenDone();
            };
          }
          component.taskQ.push(task);
          resumeTaskQ();
          return gc();
      }
    };
  };
  for (n = 0, len4 = inPorts.length; n < len4; n++) {
    port = inPorts[n];
    fn1(port);
  }
  baseShutdown = component.shutdown;
  component.shutdown = function() {
    baseShutdown.call(component);
    component.groupedData = {};
    component.groupedGroups = {};
    component.outputQ = [];
    component.disconnectData = {};
    component.disconnectQ = [];
    component.taskQ = [];
    component.params = {};
    component.completeParams = [];
    component.receivedParams = [];
    component.defaultsSent = false;
    component.groupBuffers = {};
    component.keyBuffers = {};
    component.gcTimestamps = {};
    return component.gcCounter = 0;
  };
  return component;
};

exports.GroupedInput = exports.WirePattern;

exports.CustomError = function(message, options) {
  var err;
  err = new Error(message);
  return exports.CustomizeError(err, options);
};

exports.CustomizeError = function(err, options) {
  var key, val;
  for (key in options) {
    if (!hasProp.call(options, key)) continue;
    val = options[key];
    err[key] = val;
  }
  return err;
};

exports.MultiError = function(component, group, errorPort, forwardedGroups) {
  var baseShutdown;
  if (group == null) {
    group = '';
  }
  if (errorPort == null) {
    errorPort = 'error';
  }
  if (forwardedGroups == null) {
    forwardedGroups = [];
  }
  component.hasErrors = false;
  component.errors = [];
  component.error = function(e, groups) {
    if (groups == null) {
      groups = [];
    }
    component.errors.push({
      err: e,
      groups: forwardedGroups.concat(groups)
    });
    return component.hasErrors = true;
  };
  component.fail = function(e, groups) {
    var error, grp, j, k, l, len, len1, len2, ref, ref1, ref2;
    if (e == null) {
      e = null;
    }
    if (groups == null) {
      groups = [];
    }
    if (e) {
      component.error(e, groups);
    }
    if (!component.hasErrors) {
      return;
    }
    if (!(errorPort in component.outPorts)) {
      return;
    }
    if (!component.outPorts[errorPort].isAttached()) {
      return;
    }
    if (group) {
      component.outPorts[errorPort].beginGroup(group);
    }
    ref = component.errors;
    for (j = 0, len = ref.length; j < len; j++) {
      error = ref[j];
      ref1 = error.groups;
      for (k = 0, len1 = ref1.length; k < len1; k++) {
        grp = ref1[k];
        component.outPorts[errorPort].beginGroup(grp);
      }
      component.outPorts[errorPort].send(error.err);
      ref2 = error.groups;
      for (l = 0, len2 = ref2.length; l < len2; l++) {
        grp = ref2[l];
        component.outPorts[errorPort].endGroup();
      }
    }
    if (group) {
      component.outPorts[errorPort].endGroup();
    }
    component.outPorts[errorPort].disconnect();
    component.hasErrors = false;
    return component.errors = [];
  };
  baseShutdown = component.shutdown;
  component.shutdown = function() {
    baseShutdown.call(component);
    component.hasErrors = false;
    return component.errors = [];
  };
  return component;
};

});
require.register("noflo-noflo/src/lib/Streams.js", function(exports, require, module){
var IP, StreamReceiver, StreamSender, Substream;

IP = (function() {
  function IP(data1) {
    this.data = data1;
  }

  IP.prototype.sendTo = function(port) {
    return port.send(this.data);
  };

  IP.prototype.getValue = function() {
    return this.data;
  };

  IP.prototype.toObject = function() {
    return this.data;
  };

  return IP;

})();

exports.IP = IP;

Substream = (function() {
  function Substream(key) {
    this.key = key;
    this.value = [];
  }

  Substream.prototype.push = function(value) {
    return this.value.push(value);
  };

  Substream.prototype.sendTo = function(port) {
    var i, ip, len, ref;
    port.beginGroup(this.key);
    ref = this.value;
    for (i = 0, len = ref.length; i < len; i++) {
      ip = ref[i];
      if (ip instanceof Substream || ip instanceof IP) {
        ip.sendTo(port);
      } else {
        port.send(ip);
      }
    }
    return port.endGroup();
  };

  Substream.prototype.getKey = function() {
    return this.key;
  };

  Substream.prototype.getValue = function() {
    var hasKeys, i, ip, len, obj, ref, res, val;
    switch (this.value.length) {
      case 0:
        return null;
      case 1:
        if (typeof this.value[0].getValue === 'function') {
          if (this.value[0] instanceof Substream) {
            obj = {};
            obj[this.value[0].key] = this.value[0].getValue();
            return obj;
          } else {
            return this.value[0].getValue();
          }
        } else {
          return this.value[0];
        }
        break;
      default:
        res = [];
        hasKeys = false;
        ref = this.value;
        for (i = 0, len = ref.length; i < len; i++) {
          ip = ref[i];
          val = typeof ip.getValue === 'function' ? ip.getValue() : ip;
          if (ip instanceof Substream) {
            obj = {};
            obj[ip.key] = ip.getValue();
            res.push(obj);
          } else {
            res.push(val);
          }
        }
        return res;
    }
  };

  Substream.prototype.toObject = function() {
    var obj;
    obj = {};
    obj[this.key] = this.getValue();
    return obj;
  };

  return Substream;

})();

exports.Substream = Substream;

StreamSender = (function() {
  function StreamSender(port1, ordered) {
    this.port = port1;
    this.ordered = ordered != null ? ordered : false;
    this.q = [];
    this.resetCurrent();
    this.resolved = false;
  }

  StreamSender.prototype.resetCurrent = function() {
    this.level = 0;
    this.current = null;
    return this.stack = [];
  };

  StreamSender.prototype.beginGroup = function(group) {
    var stream;
    this.level++;
    stream = new Substream(group);
    this.stack.push(stream);
    this.current = stream;
    return this;
  };

  StreamSender.prototype.endGroup = function() {
    var parent, value;
    if (this.level > 0) {
      this.level--;
    }
    value = this.stack.pop();
    if (this.level === 0) {
      this.q.push(value);
      this.resetCurrent();
    } else {
      parent = this.stack[this.stack.length - 1];
      parent.push(value);
      this.current = parent;
    }
    return this;
  };

  StreamSender.prototype.send = function(data) {
    if (this.level === 0) {
      this.q.push(new IP(data));
    } else {
      this.current.push(new IP(data));
    }
    return this;
  };

  StreamSender.prototype.done = function() {
    if (this.ordered) {
      this.resolved = true;
    } else {
      this.flush();
    }
    return this;
  };

  StreamSender.prototype.disconnect = function() {
    this.q.push(null);
    return this;
  };

  StreamSender.prototype.flush = function() {
    var i, ip, len, ref, res;
    res = false;
    if (this.q.length > 0) {
      ref = this.q;
      for (i = 0, len = ref.length; i < len; i++) {
        ip = ref[i];
        if (ip === null) {
          if (this.port.isConnected()) {
            this.port.disconnect();
          }
        } else {
          ip.sendTo(this.port);
        }
      }
      res = true;
    }
    this.q = [];
    return res;
  };

  StreamSender.prototype.isAttached = function() {
    return this.port.isAttached();
  };

  return StreamSender;

})();

exports.StreamSender = StreamSender;

StreamReceiver = (function() {
  function StreamReceiver(port1, buffered, process) {
    this.port = port1;
    this.buffered = buffered != null ? buffered : false;
    this.process = process != null ? process : null;
    this.q = [];
    this.resetCurrent();
    this.port.process = (function(_this) {
      return function(event, payload, index) {
        var stream;
        switch (event) {
          case 'connect':
            if (typeof _this.process === 'function') {
              return _this.process('connect', index);
            }
            break;
          case 'begingroup':
            _this.level++;
            stream = new Substream(payload);
            if (_this.level === 1) {
              _this.root = stream;
              _this.parent = null;
            } else {
              _this.parent = _this.current;
            }
            return _this.current = stream;
          case 'endgroup':
            if (_this.level > 0) {
              _this.level--;
            }
            if (_this.level === 0) {
              if (_this.buffered) {
                _this.q.push(_this.root);
                _this.process('readable', index);
              } else {
                if (typeof _this.process === 'function') {
                  _this.process('data', _this.root, index);
                }
              }
              return _this.resetCurrent();
            } else {
              _this.parent.push(_this.current);
              return _this.current = _this.parent;
            }
            break;
          case 'data':
            if (_this.level === 0) {
              return _this.q.push(new IP(payload));
            } else {
              return _this.current.push(new IP(payload));
            }
            break;
          case 'disconnect':
            if (typeof _this.process === 'function') {
              return _this.process('disconnect', index);
            }
        }
      };
    })(this);
  }

  StreamReceiver.prototype.resetCurrent = function() {
    this.level = 0;
    this.root = null;
    this.current = null;
    return this.parent = null;
  };

  StreamReceiver.prototype.read = function() {
    if (this.q.length === 0) {
      return void 0;
    }
    return this.q.shift();
  };

  return StreamReceiver;

})();

exports.StreamReceiver = StreamReceiver;

});
require.register("noflo-noflo/src/components/Graph.js", function(exports, require, module){
var Graph, noflo,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

if (typeof process !== 'undefined' && process.execPath && process.execPath.indexOf('node') !== -1) {
  noflo = require("../../lib/NoFlo");
} else {
  noflo = require('../lib/NoFlo');
}

Graph = (function(superClass) {
  extend(Graph, superClass);

  function Graph(metadata1) {
    this.metadata = metadata1;
    this.network = null;
    this.ready = true;
    this.started = false;
    this.baseDir = null;
    this.loader = null;
    this.inPorts = new noflo.InPorts({
      graph: {
        datatype: 'all',
        description: 'NoFlo graph definition to be used with the subgraph component',
        required: true,
        immediate: true
      }
    });
    this.outPorts = new noflo.OutPorts;
    this.inPorts.on('graph', 'data', (function(_this) {
      return function(data) {
        return _this.setGraph(data);
      };
    })(this));
  }

  Graph.prototype.setGraph = function(graph) {
    this.ready = false;
    if (typeof graph === 'object') {
      if (typeof graph.addNode === 'function') {
        return this.createNetwork(graph);
      }
      noflo.graph.loadJSON(graph, (function(_this) {
        return function(err, instance) {
          if (err) {
            return _this.error(err);
          }
          instance.baseDir = _this.baseDir;
          return _this.createNetwork(instance);
        };
      })(this));
      return;
    }
    if (graph.substr(0, 1) !== "/" && graph.substr(1, 1) !== ":" && process && process.cwd) {
      graph = (process.cwd()) + "/" + graph;
    }
    return graph = noflo.graph.loadFile(graph, (function(_this) {
      return function(err, instance) {
        if (err) {
          return _this.error(err);
        }
        instance.baseDir = _this.baseDir;
        return _this.createNetwork(instance);
      };
    })(this));
  };

  Graph.prototype.createNetwork = function(graph) {
    this.description = graph.properties.description || '';
    this.icon = graph.properties.icon || this.icon;
    graph.componentLoader = this.loader;
    return noflo.createNetwork(graph, (function(_this) {
      return function(err, network) {
        _this.network = network;
        if (err) {
          return _this.error(err);
        }
        _this.emit('network', _this.network);
        return _this.network.connect(function(err) {
          var name, notReady, process, ref;
          if (err) {
            return _this.error(err);
          }
          notReady = false;
          ref = _this.network.processes;
          for (name in ref) {
            process = ref[name];
            if (!_this.checkComponent(name, process)) {
              notReady = true;
            }
          }
          if (!notReady) {
            return _this.setToReady();
          }
        });
      };
    })(this), true);
  };

  Graph.prototype.start = function() {
    if (!this.isReady()) {
      this.on('ready', (function(_this) {
        return function() {
          return _this.start();
        };
      })(this));
      return;
    }
    if (!this.network) {
      return;
    }
    this.started = true;
    return this.network.start();
  };

  Graph.prototype.checkComponent = function(name, process) {
    if (!process.component.isReady()) {
      process.component.once("ready", (function(_this) {
        return function() {
          _this.checkComponent(name, process);
          return _this.setToReady();
        };
      })(this));
      return false;
    }
    this.findEdgePorts(name, process);
    return true;
  };

  Graph.prototype.isExportedInport = function(port, nodeName, portName) {
    var exported, i, len, priv, pub, ref, ref1;
    ref = this.network.graph.inports;
    for (pub in ref) {
      priv = ref[pub];
      if (!(priv.process === nodeName && priv.port === portName)) {
        continue;
      }
      return pub;
    }
    ref1 = this.network.graph.exports;
    for (i = 0, len = ref1.length; i < len; i++) {
      exported = ref1[i];
      if (!(exported.process === nodeName && exported.port === portName)) {
        continue;
      }
      this.network.graph.checkTransactionStart();
      this.network.graph.removeExport(exported["public"]);
      this.network.graph.addInport(exported["public"], exported.process, exported.port, exported.metadata);
      this.network.graph.checkTransactionEnd();
      return exported["public"];
    }
    return false;
  };

  Graph.prototype.isExportedOutport = function(port, nodeName, portName) {
    var exported, i, len, priv, pub, ref, ref1;
    ref = this.network.graph.outports;
    for (pub in ref) {
      priv = ref[pub];
      if (!(priv.process === nodeName && priv.port === portName)) {
        continue;
      }
      return pub;
    }
    ref1 = this.network.graph.exports;
    for (i = 0, len = ref1.length; i < len; i++) {
      exported = ref1[i];
      if (!(exported.process === nodeName && exported.port === portName)) {
        continue;
      }
      this.network.graph.checkTransactionStart();
      this.network.graph.removeExport(exported["public"]);
      this.network.graph.addOutport(exported["public"], exported.process, exported.port, exported.metadata);
      this.network.graph.checkTransactionEnd();
      return exported["public"];
    }
    return false;
  };

  Graph.prototype.setToReady = function() {
    if (typeof process !== 'undefined' && process.execPath && process.execPath.indexOf('node') !== -1) {
      return process.nextTick((function(_this) {
        return function() {
          _this.ready = true;
          return _this.emit('ready');
        };
      })(this));
    } else {
      return setTimeout((function(_this) {
        return function() {
          _this.ready = true;
          return _this.emit('ready');
        };
      })(this), 0);
    }
  };

  Graph.prototype.findEdgePorts = function(name, process) {
    var port, portName, ref, ref1, targetPortName;
    ref = process.component.inPorts;
    for (portName in ref) {
      port = ref[portName];
      if (!port || typeof port === 'function' || !port.canAttach) {
        continue;
      }
      targetPortName = this.isExportedInport(port, name, portName);
      if (targetPortName === false) {
        continue;
      }
      this.inPorts.add(targetPortName, port);
      this.inPorts[targetPortName].once('connect', (function(_this) {
        return function() {
          if (_this.isStarted()) {
            return;
          }
          return _this.start();
        };
      })(this));
    }
    ref1 = process.component.outPorts;
    for (portName in ref1) {
      port = ref1[portName];
      if (!port || typeof port === 'function' || !port.canAttach) {
        continue;
      }
      targetPortName = this.isExportedOutport(port, name, portName);
      if (targetPortName === false) {
        continue;
      }
      this.outPorts.add(targetPortName, port);
    }
    return true;
  };

  Graph.prototype.isReady = function() {
    return this.ready;
  };

  Graph.prototype.isSubgraph = function() {
    return true;
  };

  Graph.prototype.shutdown = function() {
    if (!this.network) {
      return;
    }
    return this.network.stop();
  };

  return Graph;

})(noflo.Component);

exports.getComponent = function(metadata) {
  return new Graph(metadata);
};

});
require.register("component-reduce/index.js", function(exports, require, module){

/**
 * Reduce `arr` with `fn`.
 *
 * @param {Array} arr
 * @param {Function} fn
 * @param {Mixed} initial
 *
 * TODO: combatible error handling?
 */

module.exports = function(arr, fn, initial){  
  var idx = 0;
  var len = arr.length;
  var curr = arguments.length == 3
    ? initial
    : arr[idx++];

  while (idx < len) {
    curr = fn.call(null, curr, arr[idx], ++idx, arr);
  }
  
  return curr;
};
});
require.register("visionmedia-superagent/lib/client.js", function(exports, require, module){
/**
 * Module dependencies.
 */

var Emitter = require('emitter');
var reduce = require('reduce');

/**
 * Root reference for iframes.
 */

var root = 'undefined' == typeof window
  ? this
  : window;

/**
 * Noop.
 */

function noop(){};

/**
 * Check if `obj` is a host object,
 * we don't want to serialize these :)
 *
 * TODO: future proof, move to compoent land
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */

function isHost(obj) {
  var str = {}.toString.call(obj);

  switch (str) {
    case '[object File]':
    case '[object Blob]':
    case '[object FormData]':
      return true;
    default:
      return false;
  }
}

/**
 * Determine XHR.
 */

function getXHR() {
  if (root.XMLHttpRequest
    && ('file:' != root.location.protocol || !root.ActiveXObject)) {
    return new XMLHttpRequest;
  } else {
    try { return new ActiveXObject('Microsoft.XMLHTTP'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP.6.0'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP.3.0'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP'); } catch(e) {}
  }
  return false;
}

/**
 * Removes leading and trailing whitespace, added to support IE.
 *
 * @param {String} s
 * @return {String}
 * @api private
 */

var trim = ''.trim
  ? function(s) { return s.trim(); }
  : function(s) { return s.replace(/(^\s*|\s*$)/g, ''); };

/**
 * Check if `obj` is an object.
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */

function isObject(obj) {
  return obj === Object(obj);
}

/**
 * Serialize the given `obj`.
 *
 * @param {Object} obj
 * @return {String}
 * @api private
 */

function serialize(obj) {
  if (!isObject(obj)) return obj;
  var pairs = [];
  for (var key in obj) {
    if (null != obj[key]) {
      pairs.push(encodeURIComponent(key)
        + '=' + encodeURIComponent(obj[key]));
    }
  }
  return pairs.join('&');
}

/**
 * Expose serialization method.
 */

 request.serializeObject = serialize;

 /**
  * Parse the given x-www-form-urlencoded `str`.
  *
  * @param {String} str
  * @return {Object}
  * @api private
  */

function parseString(str) {
  var obj = {};
  var pairs = str.split('&');
  var parts;
  var pair;

  for (var i = 0, len = pairs.length; i < len; ++i) {
    pair = pairs[i];
    parts = pair.split('=');
    obj[decodeURIComponent(parts[0])] = decodeURIComponent(parts[1]);
  }

  return obj;
}

/**
 * Expose parser.
 */

request.parseString = parseString;

/**
 * Default MIME type map.
 *
 *     superagent.types.xml = 'application/xml';
 *
 */

request.types = {
  html: 'text/html',
  json: 'application/json',
  xml: 'application/xml',
  urlencoded: 'application/x-www-form-urlencoded',
  'form': 'application/x-www-form-urlencoded',
  'form-data': 'application/x-www-form-urlencoded'
};

/**
 * Default serialization map.
 *
 *     superagent.serialize['application/xml'] = function(obj){
 *       return 'generated xml here';
 *     };
 *
 */

 request.serialize = {
   'application/x-www-form-urlencoded': serialize,
   'application/json': JSON.stringify
 };

 /**
  * Default parsers.
  *
  *     superagent.parse['application/xml'] = function(str){
  *       return { object parsed from str };
  *     };
  *
  */

request.parse = {
  'application/x-www-form-urlencoded': parseString,
  'application/json': JSON.parse
};

/**
 * Parse the given header `str` into
 * an object containing the mapped fields.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function parseHeader(str) {
  var lines = str.split(/\r?\n/);
  var fields = {};
  var index;
  var line;
  var field;
  var val;

  lines.pop(); // trailing CRLF

  for (var i = 0, len = lines.length; i < len; ++i) {
    line = lines[i];
    index = line.indexOf(':');
    field = line.slice(0, index).toLowerCase();
    val = trim(line.slice(index + 1));
    fields[field] = val;
  }

  return fields;
}

/**
 * Return the mime type for the given `str`.
 *
 * @param {String} str
 * @return {String}
 * @api private
 */

function type(str){
  return str.split(/ *; */).shift();
};

/**
 * Return header field parameters.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function params(str){
  return reduce(str.split(/ *; */), function(obj, str){
    var parts = str.split(/ *= */)
      , key = parts.shift()
      , val = parts.shift();

    if (key && val) obj[key] = val;
    return obj;
  }, {});
};

/**
 * Initialize a new `Response` with the given `xhr`.
 *
 *  - set flags (.ok, .error, etc)
 *  - parse header
 *
 * Examples:
 *
 *  Aliasing `superagent` as `request` is nice:
 *
 *      request = superagent;
 *
 *  We can use the promise-like API, or pass callbacks:
 *
 *      request.get('/').end(function(res){});
 *      request.get('/', function(res){});
 *
 *  Sending data can be chained:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' })
 *        .end(function(res){});
 *
 *  Or passed to `.send()`:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' }, function(res){});
 *
 *  Or passed to `.post()`:
 *
 *      request
 *        .post('/user', { name: 'tj' })
 *        .end(function(res){});
 *
 * Or further reduced to a single call for simple cases:
 *
 *      request
 *        .post('/user', { name: 'tj' }, function(res){});
 *
 * @param {XMLHTTPRequest} xhr
 * @param {Object} options
 * @api private
 */

function Response(req, options) {
  options = options || {};
  this.req = req;
  this.xhr = this.req.xhr;
  this.text = this.req.method !='HEAD' 
     ? this.xhr.responseText 
     : null;
  this.setStatusProperties(this.xhr.status);
  this.header = this.headers = parseHeader(this.xhr.getAllResponseHeaders());
  // getAllResponseHeaders sometimes falsely returns "" for CORS requests, but
  // getResponseHeader still works. so we get content-type even if getting
  // other headers fails.
  this.header['content-type'] = this.xhr.getResponseHeader('content-type');
  this.setHeaderProperties(this.header);
  this.body = this.req.method != 'HEAD'
    ? this.parseBody(this.text)
    : null;
}

/**
 * Get case-insensitive `field` value.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */

Response.prototype.get = function(field){
  return this.header[field.toLowerCase()];
};

/**
 * Set header related properties:
 *
 *   - `.type` the content type without params
 *
 * A response of "Content-Type: text/plain; charset=utf-8"
 * will provide you with a `.type` of "text/plain".
 *
 * @param {Object} header
 * @api private
 */

Response.prototype.setHeaderProperties = function(header){
  // content-type
  var ct = this.header['content-type'] || '';
  this.type = type(ct);

  // params
  var obj = params(ct);
  for (var key in obj) this[key] = obj[key];
};

/**
 * Parse the given body `str`.
 *
 * Used for auto-parsing of bodies. Parsers
 * are defined on the `superagent.parse` object.
 *
 * @param {String} str
 * @return {Mixed}
 * @api private
 */

Response.prototype.parseBody = function(str){
  var parse = request.parse[this.type];
  return parse && str && str.length
    ? parse(str)
    : null;
};

/**
 * Set flags such as `.ok` based on `status`.
 *
 * For example a 2xx response will give you a `.ok` of __true__
 * whereas 5xx will be __false__ and `.error` will be __true__. The
 * `.clientError` and `.serverError` are also available to be more
 * specific, and `.statusType` is the class of error ranging from 1..5
 * sometimes useful for mapping respond colors etc.
 *
 * "sugar" properties are also defined for common cases. Currently providing:
 *
 *   - .noContent
 *   - .badRequest
 *   - .unauthorized
 *   - .notAcceptable
 *   - .notFound
 *
 * @param {Number} status
 * @api private
 */

Response.prototype.setStatusProperties = function(status){
  var type = status / 100 | 0;

  // status / class
  this.status = status;
  this.statusType = type;

  // basics
  this.info = 1 == type;
  this.ok = 2 == type;
  this.clientError = 4 == type;
  this.serverError = 5 == type;
  this.error = (4 == type || 5 == type)
    ? this.toError()
    : false;

  // sugar
  this.accepted = 202 == status;
  this.noContent = 204 == status || 1223 == status;
  this.badRequest = 400 == status;
  this.unauthorized = 401 == status;
  this.notAcceptable = 406 == status;
  this.notFound = 404 == status;
  this.forbidden = 403 == status;
};

/**
 * Return an `Error` representative of this response.
 *
 * @return {Error}
 * @api public
 */

Response.prototype.toError = function(){
  var req = this.req;
  var method = req.method;
  var url = req.url;

  var msg = 'cannot ' + method + ' ' + url + ' (' + this.status + ')';
  var err = new Error(msg);
  err.status = this.status;
  err.method = method;
  err.url = url;

  return err;
};

/**
 * Expose `Response`.
 */

request.Response = Response;

/**
 * Initialize a new `Request` with the given `method` and `url`.
 *
 * @param {String} method
 * @param {String} url
 * @api public
 */

function Request(method, url) {
  var self = this;
  Emitter.call(this);
  this._query = this._query || [];
  this.method = method;
  this.url = url;
  this.header = {};
  this._header = {};
  this.on('end', function(){
    var err = null;
    var res = null;

    try {
      res = new Response(self); 
    } catch(e) {
      err = new Error('Parser is unable to parse the response');
      err.parse = true;
      err.original = e;
    }

    self.callback(err, res);
  });
}

/**
 * Mixin `Emitter`.
 */

Emitter(Request.prototype);

/**
 * Allow for extension
 */

Request.prototype.use = function(fn) {
  fn(this);
  return this;
}

/**
 * Set timeout to `ms`.
 *
 * @param {Number} ms
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.timeout = function(ms){
  this._timeout = ms;
  return this;
};

/**
 * Clear previous timeout.
 *
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.clearTimeout = function(){
  this._timeout = 0;
  clearTimeout(this._timer);
  return this;
};

/**
 * Abort the request, and clear potential timeout.
 *
 * @return {Request}
 * @api public
 */

Request.prototype.abort = function(){
  if (this.aborted) return;
  this.aborted = true;
  this.xhr.abort();
  this.clearTimeout();
  this.emit('abort');
  return this;
};

/**
 * Set header `field` to `val`, or multiple fields with one object.
 *
 * Examples:
 *
 *      req.get('/')
 *        .set('Accept', 'application/json')
 *        .set('X-API-Key', 'foobar')
 *        .end(callback);
 *
 *      req.get('/')
 *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })
 *        .end(callback);
 *
 * @param {String|Object} field
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.set = function(field, val){
  if (isObject(field)) {
    for (var key in field) {
      this.set(key, field[key]);
    }
    return this;
  }
  this._header[field.toLowerCase()] = val;
  this.header[field] = val;
  return this;
};

/**
 * Remove header `field`.
 *
 * Example:
 *
 *      req.get('/')
 *        .unset('User-Agent')
 *        .end(callback);
 *
 * @param {String} field
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.unset = function(field){
  delete this._header[field.toLowerCase()];
  delete this.header[field];
  return this;
};

/**
 * Get case-insensitive header `field` value.
 *
 * @param {String} field
 * @return {String}
 * @api private
 */

Request.prototype.getHeader = function(field){
  return this._header[field.toLowerCase()];
};

/**
 * Set Content-Type to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.xml = 'application/xml';
 *
 *      request.post('/')
 *        .type('xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 *      request.post('/')
 *        .type('application/xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 * @param {String} type
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.type = function(type){
  this.set('Content-Type', request.types[type] || type);
  return this;
};

/**
 * Set Accept to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.json = 'application/json';
 *
 *      request.get('/agent')
 *        .accept('json')
 *        .end(callback);
 *
 *      request.get('/agent')
 *        .accept('application/json')
 *        .end(callback);
 *
 * @param {String} accept
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.accept = function(type){
  this.set('Accept', request.types[type] || type);
  return this;
};

/**
 * Set Authorization field value with `user` and `pass`.
 *
 * @param {String} user
 * @param {String} pass
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.auth = function(user, pass){
  var str = btoa(user + ':' + pass);
  this.set('Authorization', 'Basic ' + str);
  return this;
};

/**
* Add query-string `val`.
*
* Examples:
*
*   request.get('/shoes')
*     .query('size=10')
*     .query({ color: 'blue' })
*
* @param {Object|String} val
* @return {Request} for chaining
* @api public
*/

Request.prototype.query = function(val){
  if ('string' != typeof val) val = serialize(val);
  if (val) this._query.push(val);
  return this;
};

/**
 * Write the field `name` and `val` for "multipart/form-data"
 * request bodies.
 *
 * ``` js
 * request.post('/upload')
 *   .field('foo', 'bar')
 *   .end(callback);
 * ```
 *
 * @param {String} name
 * @param {String|Blob|File} val
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.field = function(name, val){
  if (!this._formData) this._formData = new FormData();
  this._formData.append(name, val);
  return this;
};

/**
 * Queue the given `file` as an attachment to the specified `field`,
 * with optional `filename`.
 *
 * ``` js
 * request.post('/upload')
 *   .attach(new Blob(['<a id="a"><b id="b">hey!</b></a>'], { type: "text/html"}))
 *   .end(callback);
 * ```
 *
 * @param {String} field
 * @param {Blob|File} file
 * @param {String} filename
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.attach = function(field, file, filename){
  if (!this._formData) this._formData = new FormData();
  this._formData.append(field, file, filename);
  return this;
};

/**
 * Send `data`, defaulting the `.type()` to "json" when
 * an object is given.
 *
 * Examples:
 *
 *       // querystring
 *       request.get('/search')
 *         .end(callback)
 *
 *       // multiple data "writes"
 *       request.get('/search')
 *         .send({ search: 'query' })
 *         .send({ range: '1..5' })
 *         .send({ order: 'desc' })
 *         .end(callback)
 *
 *       // manual json
 *       request.post('/user')
 *         .type('json')
 *         .send('{"name":"tj"})
 *         .end(callback)
 *
 *       // auto json
 *       request.post('/user')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // manual x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send('name=tj')
 *         .end(callback)
 *
 *       // auto x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // defaults to x-www-form-urlencoded
  *      request.post('/user')
  *        .send('name=tobi')
  *        .send('species=ferret')
  *        .end(callback)
 *
 * @param {String|Object} data
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.send = function(data){
  var obj = isObject(data);
  var type = this.getHeader('Content-Type');

  // merge
  if (obj && isObject(this._data)) {
    for (var key in data) {
      this._data[key] = data[key];
    }
  } else if ('string' == typeof data) {
    if (!type) this.type('form');
    type = this.getHeader('Content-Type');
    if ('application/x-www-form-urlencoded' == type) {
      this._data = this._data
        ? this._data + '&' + data
        : data;
    } else {
      this._data = (this._data || '') + data;
    }
  } else {
    this._data = data;
  }

  if (!obj) return this;
  if (!type) this.type('json');
  return this;
};

/**
 * Invoke the callback with `err` and `res`
 * and handle arity check.
 *
 * @param {Error} err
 * @param {Response} res
 * @api private
 */

Request.prototype.callback = function(err, res){
  var fn = this._callback;
  this.clearTimeout();
  if (2 == fn.length) return fn(err, res);
  if (err) return this.emit('error', err);
  fn(res);
};

/**
 * Invoke callback with x-domain error.
 *
 * @api private
 */

Request.prototype.crossDomainError = function(){
  var err = new Error('Origin is not allowed by Access-Control-Allow-Origin');
  err.crossDomain = true;
  this.callback(err);
};

/**
 * Invoke callback with timeout error.
 *
 * @api private
 */

Request.prototype.timeoutError = function(){
  var timeout = this._timeout;
  var err = new Error('timeout of ' + timeout + 'ms exceeded');
  err.timeout = timeout;
  this.callback(err);
};

/**
 * Enable transmission of cookies with x-domain requests.
 *
 * Note that for this to work the origin must not be
 * using "Access-Control-Allow-Origin" with a wildcard,
 * and also must set "Access-Control-Allow-Credentials"
 * to "true".
 *
 * @api public
 */

Request.prototype.withCredentials = function(){
  this._withCredentials = true;
  return this;
};

/**
 * Initiate request, invoking callback `fn(res)`
 * with an instanceof `Response`.
 *
 * @param {Function} fn
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.end = function(fn){
  var self = this;
  var xhr = this.xhr = getXHR();
  var query = this._query.join('&');
  var timeout = this._timeout;
  var data = this._formData || this._data;

  // store callback
  this._callback = fn || noop;

  // state change
  xhr.onreadystatechange = function(){
    if (4 != xhr.readyState) return;
    if (0 == xhr.status) {
      if (self.aborted) return self.timeoutError();
      return self.crossDomainError();
    }
    self.emit('end');
  };

  // progress
  if (xhr.upload) {
    xhr.upload.onprogress = function(e){
      e.percent = e.loaded / e.total * 100;
      self.emit('progress', e);
    };
  }

  // timeout
  if (timeout && !this._timer) {
    this._timer = setTimeout(function(){
      self.abort();
    }, timeout);
  }

  // querystring
  if (query) {
    query = request.serializeObject(query);
    this.url += ~this.url.indexOf('?')
      ? '&' + query
      : '?' + query;
  }

  // initiate request
  xhr.open(this.method, this.url, true);

  // CORS
  if (this._withCredentials) xhr.withCredentials = true;

  // body
  if ('GET' != this.method && 'HEAD' != this.method && 'string' != typeof data && !isHost(data)) {
    // serialize stuff
    var serialize = request.serialize[this.getHeader('Content-Type')];
    if (serialize) data = serialize(data);
  }

  // set header fields
  for (var field in this.header) {
    if (null == this.header[field]) continue;
    xhr.setRequestHeader(field, this.header[field]);
  }

  // send stuff
  this.emit('request', this);
  xhr.send(data);
  return this;
};

/**
 * Expose `Request`.
 */

request.Request = Request;

/**
 * Issue a request:
 *
 * Examples:
 *
 *    request('GET', '/users').end(callback)
 *    request('/users').end(callback)
 *    request('/users', callback)
 *
 * @param {String} method
 * @param {String|Function} url or callback
 * @return {Request}
 * @api public
 */

function request(method, url) {
  // callback
  if ('function' == typeof url) {
    return new Request('GET', method).end(url);
  }

  // url first
  if (1 == arguments.length) {
    return new Request('GET', method);
  }

  return new Request(method, url);
}

/**
 * GET `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} data or fn
 * @param {Function} fn
 * @return {Request}
 * @api public
 */

request.get = function(url, data, fn){
  var req = request('GET', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.query(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * HEAD `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} data or fn
 * @param {Function} fn
 * @return {Request}
 * @api public
 */

request.head = function(url, data, fn){
  var req = request('HEAD', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * DELETE `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Function} fn
 * @return {Request}
 * @api public
 */

request.del = function(url, fn){
  var req = request('DELETE', url);
  if (fn) req.end(fn);
  return req;
};

/**
 * PATCH `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} data
 * @param {Function} fn
 * @return {Request}
 * @api public
 */

request.patch = function(url, data, fn){
  var req = request('PATCH', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * POST `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} data
 * @param {Function} fn
 * @return {Request}
 * @api public
 */

request.post = function(url, data, fn){
  var req = request('POST', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * PUT `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} data or fn
 * @param {Function} fn
 * @return {Request}
 * @api public
 */

request.put = function(url, data, fn){
  var req = request('PUT', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * Expose `request`.
 */

module.exports = request;

});
require.register("the-grid-flowhub-registry/index.js", function(exports, require, module){
var superagent = require('superagent');
var defaults = {
  host: 'https://api.flowhub.io'
};

Object.defineProperty(exports, "PING_INTERVAL", {
    value:      10 * 60 * 1000,
    enumerable: true
  });

exports.Runtime = function (runtime, options) {
  if (typeof runtime !== 'object') {
    throw new Error('Runtime options expected');
  }
  if (!runtime.id) {
    throw new Error('Runtime requires an UUID');
  }

  this.runtime = runtime;
  this.options = {};
  Object.keys(defaults).forEach(function (name) {
    this.options[name] = defaults[name];
  }.bind(this));

  if (options) {
    Object.keys(options).forEach(function (name) {
      this.options[name] = options[name];
    }.bind(this));
  }
};

exports.Runtime.prototype.register = function (callback) {
  if (!this.runtime.user) {
    callback (new Error('Runtime registration requires a user UUID'));
    return;
  }
  if (!this.runtime.address) {
    callback (new Error('Runtime registration requires an address URL'));
    return;
  }
  if (!this.runtime.protocol) {
    callback (new Error('Runtime registration requires a protocol'));
    return;
  }
  if (!this.runtime.type) {
    callback (new Error('Runtime registration requires a type'));
    return;
  }
  superagent.put(this.options.host + '/runtimes/' + this.runtime.id)
  .send(this.runtime)
  .end(callback);
};

exports.Runtime.prototype.ping = function (callback) {
  superagent.post(this.options.host + '/runtimes/' + this.runtime.id)
  .send({})
  .end(function (err, res) {
    if (callback) {
      callback(err);
    }
  });
};

exports.Runtime.prototype.get = function (token, callback) {
  if (!token) {
    return callback(new Error('API token required for fetching'));
  }
  superagent.get(this.options.host + '/runtimes/' + this.runtime.id)
  .set('Authorization', 'Bearer ' + token)
  .end(function (err, res) {
    if (err) {
      callback(err);
      return;
    }
    if (res.status !== 200) {
      callback(new Error('Request returned ' + res.status));
      return;
    }
    Object.keys(res.body).forEach(function (name) {
      if (name == 'seen' || name == 'registered') {
        this.runtime[name] = new Date(res.body[name]);
        return;
      }
      this.runtime[name] = res.body[name];
    }.bind(this));
    callback(null, this.runtime);
  }.bind(this));
};


exports.Runtime.prototype.del = function (token, callback) {
  if (!token) {
    return callback(new Error('API token required for deletion'));
  }
  superagent.del(this.options.host + '/runtimes/' + this.runtime.id)
  .set('Authorization', 'Bearer ' + token)
  .end(callback);
};

exports.list = function (token, options, callback) {
  if (!token) {
    return callback(new Error('API token required for fetching'));
  }
  if (!callback) {
    callback = options;
    options = {};
  }

  Object.keys(defaults).forEach(function (name) {
    if (options[name]) {
      return;
    }
    options[name] = defaults[name];
  }.bind(this));

  superagent.get(options.host + '/runtimes/')
  .set('Authorization', 'Bearer ' + token)
  .end(function (err, res) {
    if (err) {
      callback(err);
      return;
    }
    if (res.status !== 200) {
      callback(new Error('Request returned ' + res.status));
      return;
    }
    var results = [];
    res.body.forEach(function (result) {
      result.registered = new Date(result.registered);
      result.seen = new Date(result.seen);
      results.push(new exports.Runtime(result, options));
    });
    callback(null, results);
  });
};

});
require.register("noflo-fbp/lib/fbp.js", function(exports, require, module){
module.exports = (function() {
  /*
   * Generated by PEG.js 0.8.0.
   *
   * http://pegjs.majda.cz/
   */

  function peg$subclass(child, parent) {
    function ctor() { this.constructor = child; }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
  }

  function SyntaxError(message, expected, found, offset, line, column) {
    this.message  = message;
    this.expected = expected;
    this.found    = found;
    this.offset   = offset;
    this.line     = line;
    this.column   = column;

    this.name     = "SyntaxError";
  }

  peg$subclass(SyntaxError, Error);

  function parse(input) {
    var options = arguments.length > 1 ? arguments[1] : {},

        peg$FAILED = {},

        peg$startRuleFunctions = { start: peg$parsestart },
        peg$startRuleFunction  = peg$parsestart,

        peg$c0 = [],
        peg$c1 = function() { return parser.getResult();  },
        peg$c2 = peg$FAILED,
        peg$c3 = "EXPORT=",
        peg$c4 = { type: "literal", value: "EXPORT=", description: "\"EXPORT=\"" },
        peg$c5 = /^[A-Za-z.0-9_]/,
        peg$c6 = { type: "class", value: "[A-Za-z.0-9_]", description: "[A-Za-z.0-9_]" },
        peg$c7 = ":",
        peg$c8 = { type: "literal", value: ":", description: "\":\"" },
        peg$c9 = /^[A-Z0-9_]/,
        peg$c10 = { type: "class", value: "[A-Z0-9_]", description: "[A-Z0-9_]" },
        peg$c11 = null,
        peg$c12 = function(priv, pub) {return parser.registerExports(priv.join(""),pub.join(""))},
        peg$c13 = "INPORT=",
        peg$c14 = { type: "literal", value: "INPORT=", description: "\"INPORT=\"" },
        peg$c15 = /^[A-Za-z0-9_]/,
        peg$c16 = { type: "class", value: "[A-Za-z0-9_]", description: "[A-Za-z0-9_]" },
        peg$c17 = ".",
        peg$c18 = { type: "literal", value: ".", description: "\".\"" },
        peg$c19 = function(node, port, pub) {return parser.registerInports(node.join(""),port.join(""),pub.join(""))},
        peg$c20 = "OUTPORT=",
        peg$c21 = { type: "literal", value: "OUTPORT=", description: "\"OUTPORT=\"" },
        peg$c22 = function(node, port, pub) {return parser.registerOutports(node.join(""),port.join(""),pub.join(""))},
        peg$c23 = /^[\n\r\u2028\u2029]/,
        peg$c24 = { type: "class", value: "[\\n\\r\\u2028\\u2029]", description: "[\\n\\r\\u2028\\u2029]" },
        peg$c25 = function(edges) {return parser.registerEdges(edges);},
        peg$c26 = ",",
        peg$c27 = { type: "literal", value: ",", description: "\",\"" },
        peg$c28 = "#",
        peg$c29 = { type: "literal", value: "#", description: "\"#\"" },
        peg$c30 = "->",
        peg$c31 = { type: "literal", value: "->", description: "\"->\"" },
        peg$c32 = function(x, y) { return [x,y]; },
        peg$c33 = function(x, proc, y) { return [{"tgt":{process:proc, port:x}},{"src":{process:proc, port:y}}]; },
        peg$c34 = function(proc, port) { return {"src":{process:proc, port:port}} },
        peg$c35 = function(proc, port) { return {"src":{process:proc, port:port.port, index: port.index}} },
        peg$c36 = "'",
        peg$c37 = { type: "literal", value: "'", description: "\"'\"" },
        peg$c38 = function(iip) { return {"data":iip.join("")} },
        peg$c39 = function(port, proc) { return {"tgt":{process:proc, port:port}} },
        peg$c40 = function(port, proc) { return {"tgt":{process:proc, port:port.port, index: port.index}} },
        peg$c41 = /^[a-zA-Z0-9_\-]/,
        peg$c42 = { type: "class", value: "[a-zA-Z0-9_\\-]", description: "[a-zA-Z0-9_\\-]" },
        peg$c43 = function(node, comp) { if(comp){parser.addNode(node.join(""),comp);}; return node.join("")},
        peg$c44 = "(",
        peg$c45 = { type: "literal", value: "(", description: "\"(\"" },
        peg$c46 = /^[a-zA-Z\/\-0-9_]/,
        peg$c47 = { type: "class", value: "[a-zA-Z\\/\\-0-9_]", description: "[a-zA-Z\\/\\-0-9_]" },
        peg$c48 = ")",
        peg$c49 = { type: "literal", value: ")", description: "\")\"" },
        peg$c50 = function(comp, meta) { var o = {}; comp ? o.comp = comp.join("") : o.comp = ''; meta ? o.meta = meta.join("").split(',') : null; return o; },
        peg$c51 = /^[a-zA-Z\/=_,0-9]/,
        peg$c52 = { type: "class", value: "[a-zA-Z\\/=_,0-9]", description: "[a-zA-Z\\/=_,0-9]" },
        peg$c53 = function(meta) {return meta},
        peg$c54 = /^[A-Z.0-9_]/,
        peg$c55 = { type: "class", value: "[A-Z.0-9_]", description: "[A-Z.0-9_]" },
        peg$c56 = function(portname) {return portname.join("").toLowerCase()},
        peg$c57 = "[",
        peg$c58 = { type: "literal", value: "[", description: "\"[\"" },
        peg$c59 = /^[0-9]/,
        peg$c60 = { type: "class", value: "[0-9]", description: "[0-9]" },
        peg$c61 = "]",
        peg$c62 = { type: "literal", value: "]", description: "\"]\"" },
        peg$c63 = function(portname, portindex) {return { port: portname.join("").toLowerCase(), index: parseInt(portindex.join('')) }},
        peg$c64 = /^[^\n\r\u2028\u2029]/,
        peg$c65 = { type: "class", value: "[^\\n\\r\\u2028\\u2029]", description: "[^\\n\\r\\u2028\\u2029]" },
        peg$c66 = /^[\\]/,
        peg$c67 = { type: "class", value: "[\\\\]", description: "[\\\\]" },
        peg$c68 = /^[']/,
        peg$c69 = { type: "class", value: "[']", description: "[']" },
        peg$c70 = function() { return "'"; },
        peg$c71 = /^[^']/,
        peg$c72 = { type: "class", value: "[^']", description: "[^']" },
        peg$c73 = " ",
        peg$c74 = { type: "literal", value: " ", description: "\" \"" },

        peg$currPos          = 0,
        peg$reportedPos      = 0,
        peg$cachedPos        = 0,
        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },
        peg$maxFailPos       = 0,
        peg$maxFailExpected  = [],
        peg$silentFails      = 0,

        peg$result;

    if ("startRule" in options) {
      if (!(options.startRule in peg$startRuleFunctions)) {
        throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
      }

      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
    }

    function text() {
      return input.substring(peg$reportedPos, peg$currPos);
    }

    function offset() {
      return peg$reportedPos;
    }

    function line() {
      return peg$computePosDetails(peg$reportedPos).line;
    }

    function column() {
      return peg$computePosDetails(peg$reportedPos).column;
    }

    function expected(description) {
      throw peg$buildException(
        null,
        [{ type: "other", description: description }],
        peg$reportedPos
      );
    }

    function error(message) {
      throw peg$buildException(message, null, peg$reportedPos);
    }

    function peg$computePosDetails(pos) {
      function advance(details, startPos, endPos) {
        var p, ch;

        for (p = startPos; p < endPos; p++) {
          ch = input.charAt(p);
          if (ch === "\n") {
            if (!details.seenCR) { details.line++; }
            details.column = 1;
            details.seenCR = false;
          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
            details.line++;
            details.column = 1;
            details.seenCR = true;
          } else {
            details.column++;
            details.seenCR = false;
          }
        }
      }

      if (peg$cachedPos !== pos) {
        if (peg$cachedPos > pos) {
          peg$cachedPos = 0;
          peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };
        }
        advance(peg$cachedPosDetails, peg$cachedPos, pos);
        peg$cachedPos = pos;
      }

      return peg$cachedPosDetails;
    }

    function peg$fail(expected) {
      if (peg$currPos < peg$maxFailPos) { return; }

      if (peg$currPos > peg$maxFailPos) {
        peg$maxFailPos = peg$currPos;
        peg$maxFailExpected = [];
      }

      peg$maxFailExpected.push(expected);
    }

    function peg$buildException(message, expected, pos) {
      function cleanupExpected(expected) {
        var i = 1;

        expected.sort(function(a, b) {
          if (a.description < b.description) {
            return -1;
          } else if (a.description > b.description) {
            return 1;
          } else {
            return 0;
          }
        });

        while (i < expected.length) {
          if (expected[i - 1] === expected[i]) {
            expected.splice(i, 1);
          } else {
            i++;
          }
        }
      }

      function buildMessage(expected, found) {
        function stringEscape(s) {
          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }

          return s
            .replace(/\\/g,   '\\\\')
            .replace(/"/g,    '\\"')
            .replace(/\x08/g, '\\b')
            .replace(/\t/g,   '\\t')
            .replace(/\n/g,   '\\n')
            .replace(/\f/g,   '\\f')
            .replace(/\r/g,   '\\r')
            .replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) { return '\\x0' + hex(ch); })
            .replace(/[\x10-\x1F\x80-\xFF]/g,    function(ch) { return '\\x'  + hex(ch); })
            .replace(/[\u0180-\u0FFF]/g,         function(ch) { return '\\u0' + hex(ch); })
            .replace(/[\u1080-\uFFFF]/g,         function(ch) { return '\\u'  + hex(ch); });
        }

        var expectedDescs = new Array(expected.length),
            expectedDesc, foundDesc, i;

        for (i = 0; i < expected.length; i++) {
          expectedDescs[i] = expected[i].description;
        }

        expectedDesc = expected.length > 1
          ? expectedDescs.slice(0, -1).join(", ")
              + " or "
              + expectedDescs[expected.length - 1]
          : expectedDescs[0];

        foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";

        return "Expected " + expectedDesc + " but " + foundDesc + " found.";
      }

      var posDetails = peg$computePosDetails(pos),
          found      = pos < input.length ? input.charAt(pos) : null;

      if (expected !== null) {
        cleanupExpected(expected);
      }

      return new SyntaxError(
        message !== null ? message : buildMessage(expected, found),
        expected,
        found,
        pos,
        posDetails.line,
        posDetails.column
      );
    }

    function peg$parsestart() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parseline();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parseline();
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c1();
      }
      s0 = s1;

      return s0;
    }

    function peg$parseline() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;

      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        if (input.substr(peg$currPos, 7) === peg$c3) {
          s2 = peg$c3;
          peg$currPos += 7;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c4); }
        }
        if (s2 !== peg$FAILED) {
          s3 = [];
          if (peg$c5.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c6); }
          }
          if (s4 !== peg$FAILED) {
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              if (peg$c5.test(input.charAt(peg$currPos))) {
                s4 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c6); }
              }
            }
          } else {
            s3 = peg$c2;
          }
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 58) {
              s4 = peg$c7;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c8); }
            }
            if (s4 !== peg$FAILED) {
              s5 = [];
              if (peg$c9.test(input.charAt(peg$currPos))) {
                s6 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c10); }
              }
              if (s6 !== peg$FAILED) {
                while (s6 !== peg$FAILED) {
                  s5.push(s6);
                  if (peg$c9.test(input.charAt(peg$currPos))) {
                    s6 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s6 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c10); }
                  }
                }
              } else {
                s5 = peg$c2;
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parse_();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parseLineTerminator();
                  if (s7 === peg$FAILED) {
                    s7 = peg$c11;
                  }
                  if (s7 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c12(s3, s5);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parse_();
        if (s1 !== peg$FAILED) {
          if (input.substr(peg$currPos, 7) === peg$c13) {
            s2 = peg$c13;
            peg$currPos += 7;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c14); }
          }
          if (s2 !== peg$FAILED) {
            s3 = [];
            if (peg$c15.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c16); }
            }
            if (s4 !== peg$FAILED) {
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                if (peg$c15.test(input.charAt(peg$currPos))) {
                  s4 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c16); }
                }
              }
            } else {
              s3 = peg$c2;
            }
            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 46) {
                s4 = peg$c17;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c18); }
              }
              if (s4 !== peg$FAILED) {
                s5 = [];
                if (peg$c9.test(input.charAt(peg$currPos))) {
                  s6 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c10); }
                }
                if (s6 !== peg$FAILED) {
                  while (s6 !== peg$FAILED) {
                    s5.push(s6);
                    if (peg$c9.test(input.charAt(peg$currPos))) {
                      s6 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s6 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c10); }
                    }
                  }
                } else {
                  s5 = peg$c2;
                }
                if (s5 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 58) {
                    s6 = peg$c7;
                    peg$currPos++;
                  } else {
                    s6 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c8); }
                  }
                  if (s6 !== peg$FAILED) {
                    s7 = [];
                    if (peg$c9.test(input.charAt(peg$currPos))) {
                      s8 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s8 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c10); }
                    }
                    if (s8 !== peg$FAILED) {
                      while (s8 !== peg$FAILED) {
                        s7.push(s8);
                        if (peg$c9.test(input.charAt(peg$currPos))) {
                          s8 = input.charAt(peg$currPos);
                          peg$currPos++;
                        } else {
                          s8 = peg$FAILED;
                          if (peg$silentFails === 0) { peg$fail(peg$c10); }
                        }
                      }
                    } else {
                      s7 = peg$c2;
                    }
                    if (s7 !== peg$FAILED) {
                      s8 = peg$parse_();
                      if (s8 !== peg$FAILED) {
                        s9 = peg$parseLineTerminator();
                        if (s9 === peg$FAILED) {
                          s9 = peg$c11;
                        }
                        if (s9 !== peg$FAILED) {
                          peg$reportedPos = s0;
                          s1 = peg$c19(s3, s5, s7);
                          s0 = s1;
                        } else {
                          peg$currPos = s0;
                          s0 = peg$c2;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parse_();
          if (s1 !== peg$FAILED) {
            if (input.substr(peg$currPos, 8) === peg$c20) {
              s2 = peg$c20;
              peg$currPos += 8;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c21); }
            }
            if (s2 !== peg$FAILED) {
              s3 = [];
              if (peg$c15.test(input.charAt(peg$currPos))) {
                s4 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c16); }
              }
              if (s4 !== peg$FAILED) {
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  if (peg$c15.test(input.charAt(peg$currPos))) {
                    s4 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c16); }
                  }
                }
              } else {
                s3 = peg$c2;
              }
              if (s3 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 46) {
                  s4 = peg$c17;
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c18); }
                }
                if (s4 !== peg$FAILED) {
                  s5 = [];
                  if (peg$c9.test(input.charAt(peg$currPos))) {
                    s6 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s6 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c10); }
                  }
                  if (s6 !== peg$FAILED) {
                    while (s6 !== peg$FAILED) {
                      s5.push(s6);
                      if (peg$c9.test(input.charAt(peg$currPos))) {
                        s6 = input.charAt(peg$currPos);
                        peg$currPos++;
                      } else {
                        s6 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c10); }
                      }
                    }
                  } else {
                    s5 = peg$c2;
                  }
                  if (s5 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 58) {
                      s6 = peg$c7;
                      peg$currPos++;
                    } else {
                      s6 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c8); }
                    }
                    if (s6 !== peg$FAILED) {
                      s7 = [];
                      if (peg$c9.test(input.charAt(peg$currPos))) {
                        s8 = input.charAt(peg$currPos);
                        peg$currPos++;
                      } else {
                        s8 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c10); }
                      }
                      if (s8 !== peg$FAILED) {
                        while (s8 !== peg$FAILED) {
                          s7.push(s8);
                          if (peg$c9.test(input.charAt(peg$currPos))) {
                            s8 = input.charAt(peg$currPos);
                            peg$currPos++;
                          } else {
                            s8 = peg$FAILED;
                            if (peg$silentFails === 0) { peg$fail(peg$c10); }
                          }
                        }
                      } else {
                        s7 = peg$c2;
                      }
                      if (s7 !== peg$FAILED) {
                        s8 = peg$parse_();
                        if (s8 !== peg$FAILED) {
                          s9 = peg$parseLineTerminator();
                          if (s9 === peg$FAILED) {
                            s9 = peg$c11;
                          }
                          if (s9 !== peg$FAILED) {
                            peg$reportedPos = s0;
                            s1 = peg$c22(s3, s5, s7);
                            s0 = s1;
                          } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$c2;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsecomment();
            if (s1 !== peg$FAILED) {
              if (peg$c23.test(input.charAt(peg$currPos))) {
                s2 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c24); }
              }
              if (s2 === peg$FAILED) {
                s2 = peg$c11;
              }
              if (s2 !== peg$FAILED) {
                s1 = [s1, s2];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parse_();
              if (s1 !== peg$FAILED) {
                if (peg$c23.test(input.charAt(peg$currPos))) {
                  s2 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c24); }
                }
                if (s2 !== peg$FAILED) {
                  s1 = [s1, s2];
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parse_();
                if (s1 !== peg$FAILED) {
                  s2 = peg$parseconnection();
                  if (s2 !== peg$FAILED) {
                    s3 = peg$parse_();
                    if (s3 !== peg$FAILED) {
                      s4 = peg$parseLineTerminator();
                      if (s4 === peg$FAILED) {
                        s4 = peg$c11;
                      }
                      if (s4 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c25(s2);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              }
            }
          }
        }
      }

      return s0;
    }

    function peg$parseLineTerminator() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 44) {
          s2 = peg$c26;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c27); }
        }
        if (s2 === peg$FAILED) {
          s2 = peg$c11;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parsecomment();
          if (s3 === peg$FAILED) {
            s3 = peg$c11;
          }
          if (s3 !== peg$FAILED) {
            if (peg$c23.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c24); }
            }
            if (s4 === peg$FAILED) {
              s4 = peg$c11;
            }
            if (s4 !== peg$FAILED) {
              s1 = [s1, s2, s3, s4];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      return s0;
    }

    function peg$parsecomment() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 35) {
          s2 = peg$c28;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c29); }
        }
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$parseanychar();
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parseanychar();
          }
          if (s3 !== peg$FAILED) {
            s1 = [s1, s2, s3];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      return s0;
    }

    function peg$parseconnection() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$parsebridge();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c30) {
            s3 = peg$c30;
            peg$currPos += 2;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c31); }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseconnection();
              if (s5 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c32(s1, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$parsebridge();
      }

      return s0;
    }

    function peg$parsebridge() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$parseport();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parsenode();
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseport();
              if (s5 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c33(s1, s3, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$parseiip();
        if (s0 === peg$FAILED) {
          s0 = peg$parserightlet();
          if (s0 === peg$FAILED) {
            s0 = peg$parseleftlet();
          }
        }
      }

      return s0;
    }

    function peg$parseleftlet() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parsenode();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseport();
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c34(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parsenode();
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseportWithIndex();
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c35(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      }

      return s0;
    }

    function peg$parseiip() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 39) {
        s1 = peg$c36;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c37); }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parseiipchar();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parseiipchar();
        }
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 39) {
            s3 = peg$c36;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c37); }
          }
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c38(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      return s0;
    }

    function peg$parserightlet() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parseport();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parsenode();
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c39(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseportWithIndex();
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();
          if (s2 !== peg$FAILED) {
            s3 = peg$parsenode();
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c40(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      }

      return s0;
    }

    function peg$parsenode() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      if (peg$c41.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c42); }
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          if (peg$c41.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c42); }
          }
        }
      } else {
        s1 = peg$c2;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsecomponent();
        if (s2 === peg$FAILED) {
          s2 = peg$c11;
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c43(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      return s0;
    }

    function peg$parsecomponent() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 40) {
        s1 = peg$c44;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c45); }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        if (peg$c46.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c47); }
        }
        if (s3 !== peg$FAILED) {
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            if (peg$c46.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c47); }
            }
          }
        } else {
          s2 = peg$c2;
        }
        if (s2 === peg$FAILED) {
          s2 = peg$c11;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parsecompMeta();
          if (s3 === peg$FAILED) {
            s3 = peg$c11;
          }
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 41) {
              s4 = peg$c48;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c49); }
            }
            if (s4 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c50(s2, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      return s0;
    }

    function peg$parsecompMeta() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 58) {
        s1 = peg$c7;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c8); }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        if (peg$c51.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c52); }
        }
        if (s3 !== peg$FAILED) {
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            if (peg$c51.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c52); }
            }
          }
        } else {
          s2 = peg$c2;
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c53(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      return s0;
    }

    function peg$parseport() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      if (peg$c54.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c55); }
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          if (peg$c54.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c55); }
          }
        }
      } else {
        s1 = peg$c2;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c56(s1);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      return s0;
    }

    function peg$parseportWithIndex() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = [];
      if (peg$c54.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c55); }
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          if (peg$c54.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c55); }
          }
        }
      } else {
        s1 = peg$c2;
      }
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 91) {
          s2 = peg$c57;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c58); }
        }
        if (s2 !== peg$FAILED) {
          s3 = [];
          if (peg$c59.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c60); }
          }
          if (s4 !== peg$FAILED) {
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              if (peg$c59.test(input.charAt(peg$currPos))) {
                s4 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c60); }
              }
            }
          } else {
            s3 = peg$c2;
          }
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 93) {
              s4 = peg$c61;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c62); }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parse__();
              if (s5 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c63(s1, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      return s0;
    }

    function peg$parseanychar() {
      var s0;

      if (peg$c64.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c65); }
      }

      return s0;
    }

    function peg$parseiipchar() {
      var s0, s1, s2;

      s0 = peg$currPos;
      if (peg$c66.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c67); }
      }
      if (s1 !== peg$FAILED) {
        if (peg$c68.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c69); }
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c70();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }
      if (s0 === peg$FAILED) {
        if (peg$c71.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c72); }
        }
      }

      return s0;
    }

    function peg$parse_() {
      var s0, s1;

      s0 = [];
      if (input.charCodeAt(peg$currPos) === 32) {
        s1 = peg$c73;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c74); }
      }
      while (s1 !== peg$FAILED) {
        s0.push(s1);
        if (input.charCodeAt(peg$currPos) === 32) {
          s1 = peg$c73;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c74); }
        }
      }
      if (s0 === peg$FAILED) {
        s0 = peg$c11;
      }

      return s0;
    }

    function peg$parse__() {
      var s0, s1;

      s0 = [];
      if (input.charCodeAt(peg$currPos) === 32) {
        s1 = peg$c73;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c74); }
      }
      if (s1 !== peg$FAILED) {
        while (s1 !== peg$FAILED) {
          s0.push(s1);
          if (input.charCodeAt(peg$currPos) === 32) {
            s1 = peg$c73;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c74); }
          }
        }
      } else {
        s0 = peg$c2;
      }

      return s0;
    }


      var parser, edges, nodes; 

      parser = this;
      delete parser.exports;
      delete parser.inports;
      delete parser.outports;

      edges = parser.edges = [];

      nodes = {};

      parser.addNode = function (nodeName, comp) {
        if (!nodes[nodeName]) {
          nodes[nodeName] = {}
        }
        if (!!comp.comp) {
          nodes[nodeName].component = comp.comp;
        }
        if (!!comp.meta) {
          var metadata = {};
          for (var i = 0; i < comp.meta.length; i++) {
            var item = comp.meta[i].split('=');
            if (item.length === 1) {
              item = ['routes', item[0]];
            }
            var key = item[0];
            var value = item[1];
            if (key==='x' || key==='y') {
              value = parseFloat(value);
            }
            metadata[key] = value;
          }
          nodes[nodeName].metadata=metadata;
        }
       
      }

      parser.getResult = function () {
        return {processes:nodes, connections:parser.processEdges(), exports:parser.exports, inports: parser.inports, outports: parser.outports};
      }  

      var flatten = function (array, isShallow) {
        var index = -1,
          length = array ? array.length : 0,
          result = [];

        while (++index < length) {
          var value = array[index];

          if (value instanceof Array) {
            Array.prototype.push.apply(result, isShallow ? value : flatten(value));
          }
          else {
            result.push(value);
          }
        }
        return result;
      }
      
      parser.registerExports = function (priv, pub) {
        if (!parser.exports) {
          parser.exports = [];
        }
        parser.exports.push({private:priv.toLowerCase(), public:pub.toLowerCase()})
      }
      parser.registerInports = function (node, port, pub) {
        if (!parser.inports) {
          parser.inports = {};
        }
        parser.inports[pub.toLowerCase()] = {process:node, port:port.toLowerCase()}
      }
      parser.registerOutports = function (node, port, pub) {
        if (!parser.outports) {
          parser.outports = {};
        }
        parser.outports[pub.toLowerCase()] = {process:node, port:port.toLowerCase()}
      }

      parser.registerEdges = function (edges) {

        edges.forEach(function (o, i) {
          parser.edges.push(o);
        });
      }  

      parser.processEdges = function () {   
        var flats, grouped;
        flats = flatten(parser.edges);
        grouped = [];
        var current = {};
        flats.forEach(function (o, i) {
          if (i % 2 !== 0) { 
            var pair = grouped[grouped.length - 1];
            pair.tgt = o.tgt;
            return;
          }
          grouped.push(o);
        });
        return grouped;
      }


    peg$result = peg$startRuleFunction();

    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
      return peg$result;
    } else {
      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
        peg$fail({ type: "end", description: "end of input" });
      }

      throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);
    }
  }

  return {
    SyntaxError: SyntaxError,
    parse:       parse
  };
})();
});
require.register("jonnor-ieee754/index.js", function(exports, require, module){
exports.read = function(buffer, offset, isLE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isLE ? (nBytes - 1) : 0,
      d = isLE ? -1 : 1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isLE ? 0 : (nBytes - 1),
      d = isLE ? 1 : -1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

});
require.register("jonnor-base64-js/lib/b64.js", function(exports, require, module){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var ZERO   = '0'.charCodeAt(0)
	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS)
			return 62 // '+'
		if (code === SLASH)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	module.exports.toByteArray = b64ToByteArray
	module.exports.fromByteArray = uint8ToBase64
}())

});
require.register("jonnor-buffer/index.js", function(exports, require, module){
/**
 * The buffer module from node.js, for the browser.
 *
 * Author:   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * License:  MIT
 *
 * `npm install buffer`
 */

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = Buffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192

/**
 * If `Buffer._useTypedArrays`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (compatible down to IE6)
 */
Buffer._useTypedArrays = (function () {
   // Detect if browser supports Typed Arrays. Supported browsers are IE 10+,
   // Firefox 4+, Chrome 7+, Safari 5.1+, Opera 11.6+, iOS 4.2+.
  if (typeof Uint8Array !== 'function' || typeof ArrayBuffer !== 'function')
    return false

  // Does the browser support adding properties to `Uint8Array` instances? If
  // not, then that's the same as no `Uint8Array` support. We need to be able to
  // add all the node Buffer API methods.
  // Bug in Firefox 4-29, now fixed: https://bugzilla.mozilla.org/show_bug.cgi?id=695438
  try {
    var arr = new Uint8Array(0)
    arr.foo = function () { return 42 }
    return 42 === arr.foo() &&
        typeof arr.subarray === 'function' // Chrome 9-10 lack `subarray`
  } catch (e) {
    return false
  }
})()

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (subject, encoding, noZero) {
  if (!(this instanceof Buffer))
    return new Buffer(subject, encoding, noZero)

  var type = typeof subject

  // Workaround: node's base64 implementation allows for non-padded strings
  // while base64-js does not.
  if (encoding === 'base64' && type === 'string') {
    subject = stringtrim(subject)
    while (subject.length % 4 !== 0) {
      subject = subject + '='
    }
  }

  // Find the length
  var length
  if (type === 'number')
    length = coerce(subject)
  else if (type === 'string')
    length = Buffer.byteLength(subject, encoding)
  else if (type === 'object')
    length = coerce(subject.length) // Assume object is an array
  else
    throw new Error('First argument needs to be a number, array or string.')

  var buf
  if (Buffer._useTypedArrays) {
    // Preferred: Return an augmented `Uint8Array` instance for best performance
    buf = augment(new Uint8Array(length))
  } else {
    // Fallback: Return THIS instance of Buffer (created by `new`)
    buf = this
    buf.length = length
    buf._isBuffer = true
  }

  var i
  if (Buffer._useTypedArrays && typeof Uint8Array === 'function' &&
      subject instanceof Uint8Array) {
    // Speed optimization -- use set if we're copying from a Uint8Array
    buf._set(subject)
  } else if (isArrayish(subject)) {
    // Treat array-ish objects as a byte array
    for (i = 0; i < length; i++) {
      if (Buffer.isBuffer(subject))
        buf[i] = subject.readUInt8(i)
      else
        buf[i] = subject[i]
    }
  } else if (type === 'string') {
    buf.write(subject, 0, encoding)
  } else if (type === 'number' && !Buffer._useTypedArrays && !noZero) {
    for (i = 0; i < length; i++) {
      buf[i] = 0
    }
  }

  return buf
}

// STATIC METHODS
// ==============

Buffer.isEncoding = function (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.isBuffer = function (b) {
  return !!(b !== null && b !== undefined && b._isBuffer)
}

Buffer.byteLength = function (str, encoding) {
  var ret
  str = str + ''
  switch (encoding || 'utf8') {
    case 'hex':
      ret = str.length / 2
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8ToBytes(str).length
      break
    case 'ascii':
    case 'binary':
    case 'raw':
      ret = str.length
      break
    case 'base64':
      ret = base64ToBytes(str).length
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = str.length * 2
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.concat = function (list, totalLength) {
  assert(isArray(list), 'Usage: Buffer.concat(list, [totalLength])\n' +
      'list should be an Array.')

  if (list.length === 0) {
    return new Buffer(0)
  } else if (list.length === 1) {
    return list[0]
  }

  var i
  if (typeof totalLength !== 'number') {
    totalLength = 0
    for (i = 0; i < list.length; i++) {
      totalLength += list[i].length
    }
  }

  var buf = new Buffer(totalLength)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

// BUFFER INSTANCE METHODS
// =======================

function _hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  assert(strLen % 2 === 0, 'Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16)
    assert(!isNaN(byte), 'Invalid hex string')
    buf[offset + i] = byte
  }
  Buffer._charsWritten = i * 2
  return i
}

function _utf8Write (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(utf8ToBytes(string), buf, offset, length)
  return charsWritten
}

function _asciiWrite (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(asciiToBytes(string), buf, offset, length)
  return charsWritten
}

function _binaryWrite (buf, string, offset, length) {
  return _asciiWrite(buf, string, offset, length)
}

function _base64Write (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(base64ToBytes(string), buf, offset, length)
  return charsWritten
}

function _utf16leWrite (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(utf16leToBytes(string), buf, offset, length)
  return charsWritten
}

Buffer.prototype.write = function (string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length
      length = undefined
    }
  } else {  // legacy
    var swap = encoding
    encoding = offset
    offset = length
    length = swap
  }

  offset = Number(offset) || 0
  var remaining = this.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase()

  var ret
  switch (encoding) {
    case 'hex':
      ret = _hexWrite(this, string, offset, length)
      break
    case 'utf8':
    case 'utf-8':
      ret = _utf8Write(this, string, offset, length)
      break
    case 'ascii':
      ret = _asciiWrite(this, string, offset, length)
      break
    case 'binary':
      ret = _binaryWrite(this, string, offset, length)
      break
    case 'base64':
      ret = _base64Write(this, string, offset, length)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = _utf16leWrite(this, string, offset, length)
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.prototype.toString = function (encoding, start, end) {
  var self = this

  encoding = String(encoding || 'utf8').toLowerCase()
  start = Number(start) || 0
  end = (end !== undefined)
    ? Number(end)
    : end = self.length

  // Fastpath empty strings
  if (end === start)
    return ''

  var ret
  switch (encoding) {
    case 'hex':
      ret = _hexSlice(self, start, end)
      break
    case 'utf8':
    case 'utf-8':
      ret = _utf8Slice(self, start, end)
      break
    case 'ascii':
      ret = _asciiSlice(self, start, end)
      break
    case 'binary':
      ret = _binarySlice(self, start, end)
      break
    case 'base64':
      ret = _base64Slice(self, start, end)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = _utf16leSlice(self, start, end)
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.prototype.toJSON = function () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function (target, target_start, start, end) {
  var source = this

  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (!target_start) target_start = 0

  // Copy 0 bytes; we're done
  if (end === start) return
  if (target.length === 0 || source.length === 0) return

  // Fatal error conditions
  assert(end >= start, 'sourceEnd < sourceStart')
  assert(target_start >= 0 && target_start < target.length,
      'targetStart out of bounds')
  assert(start >= 0 && start < source.length, 'sourceStart out of bounds')
  assert(end >= 0 && end <= source.length, 'sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length)
    end = this.length
  if (target.length - target_start < end - start)
    end = target.length - target_start + start

  // copy!
  for (var i = 0; i < end - start; i++)
    target[i + target_start] = this[i + start]
}

function _base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function _utf8Slice (buf, start, end) {
  var res = ''
  var tmp = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    if (buf[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
      tmp = ''
    } else {
      tmp += '%' + buf[i].toString(16)
    }
  }

  return res + decodeUtf8Char(tmp)
}

function _asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++)
    ret += String.fromCharCode(buf[i])
  return ret
}

function _binarySlice (buf, start, end) {
  return _asciiSlice(buf, start, end)
}

function _hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function _utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i+1] * 256)
  }
  return res
}

Buffer.prototype.slice = function (start, end) {
  var len = this.length
  start = clamp(start, len, 0)
  end = clamp(end, len, len)

  if (Buffer._useTypedArrays) {
    return augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    var newBuf = new Buffer(sliceLen, undefined, true)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
    return newBuf
  }
}

// `get` will be removed in Node 0.13+
Buffer.prototype.get = function (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` will be removed in Node 0.13+
Buffer.prototype.set = function (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

Buffer.prototype.readUInt8 = function (offset, noAssert) {
  if (!noAssert) {
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'Trying to read beyond buffer length')
  }

  if (offset >= this.length)
    return

  return this[offset]
}

function _readUInt16 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val
  if (littleEndian) {
    val = buf[offset]
    if (offset + 1 < len)
      val |= buf[offset + 1] << 8
  } else {
    val = buf[offset] << 8
    if (offset + 1 < len)
      val |= buf[offset + 1]
  }
  return val
}

Buffer.prototype.readUInt16LE = function (offset, noAssert) {
  return _readUInt16(this, offset, true, noAssert)
}

Buffer.prototype.readUInt16BE = function (offset, noAssert) {
  return _readUInt16(this, offset, false, noAssert)
}

function _readUInt32 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val
  if (littleEndian) {
    if (offset + 2 < len)
      val = buf[offset + 2] << 16
    if (offset + 1 < len)
      val |= buf[offset + 1] << 8
    val |= buf[offset]
    if (offset + 3 < len)
      val = val + (buf[offset + 3] << 24 >>> 0)
  } else {
    if (offset + 1 < len)
      val = buf[offset + 1] << 16
    if (offset + 2 < len)
      val |= buf[offset + 2] << 8
    if (offset + 3 < len)
      val |= buf[offset + 3]
    val = val + (buf[offset] << 24 >>> 0)
  }
  return val
}

Buffer.prototype.readUInt32LE = function (offset, noAssert) {
  return _readUInt32(this, offset, true, noAssert)
}

Buffer.prototype.readUInt32BE = function (offset, noAssert) {
  return _readUInt32(this, offset, false, noAssert)
}

Buffer.prototype.readInt8 = function (offset, noAssert) {
  if (!noAssert) {
    assert(offset !== undefined && offset !== null,
        'missing offset')
    assert(offset < this.length, 'Trying to read beyond buffer length')
  }

  if (offset >= this.length)
    return

  var neg = this[offset] & 0x80
  if (neg)
    return (0xff - this[offset] + 1) * -1
  else
    return this[offset]
}

function _readInt16 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val = _readUInt16(buf, offset, littleEndian, true)
  var neg = val & 0x8000
  if (neg)
    return (0xffff - val + 1) * -1
  else
    return val
}

Buffer.prototype.readInt16LE = function (offset, noAssert) {
  return _readInt16(this, offset, true, noAssert)
}

Buffer.prototype.readInt16BE = function (offset, noAssert) {
  return _readInt16(this, offset, false, noAssert)
}

function _readInt32 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val = _readUInt32(buf, offset, littleEndian, true)
  var neg = val & 0x80000000
  if (neg)
    return (0xffffffff - val + 1) * -1
  else
    return val
}

Buffer.prototype.readInt32LE = function (offset, noAssert) {
  return _readInt32(this, offset, true, noAssert)
}

Buffer.prototype.readInt32BE = function (offset, noAssert) {
  return _readInt32(this, offset, false, noAssert)
}

function _readFloat (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  return ieee754.read(buf, offset, littleEndian, 23, 4)
}

Buffer.prototype.readFloatLE = function (offset, noAssert) {
  return _readFloat(this, offset, true, noAssert)
}

Buffer.prototype.readFloatBE = function (offset, noAssert) {
  return _readFloat(this, offset, false, noAssert)
}

function _readDouble (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset + 7 < buf.length, 'Trying to read beyond buffer length')
  }

  return ieee754.read(buf, offset, littleEndian, 52, 8)
}

Buffer.prototype.readDoubleLE = function (offset, noAssert) {
  return _readDouble(this, offset, true, noAssert)
}

Buffer.prototype.readDoubleBE = function (offset, noAssert) {
  return _readDouble(this, offset, false, noAssert)
}

Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'trying to write beyond buffer length')
    verifuint(value, 0xff)
  }

  if (offset >= this.length) return

  this[offset] = value
}

function _writeUInt16 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xffff)
  }

  var len = buf.length
  if (offset >= len)
    return

  for (var i = 0, j = Math.min(len - offset, 2); i < j; i++) {
    buf[offset + i] =
        (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
            (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {
  _writeUInt16(this, value, offset, true, noAssert)
}

Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {
  _writeUInt16(this, value, offset, false, noAssert)
}

function _writeUInt32 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xffffffff)
  }

  var len = buf.length
  if (offset >= len)
    return

  for (var i = 0, j = Math.min(len - offset, 4); i < j; i++) {
    buf[offset + i] =
        (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {
  _writeUInt32(this, value, offset, true, noAssert)
}

Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {
  _writeUInt32(this, value, offset, false, noAssert)
}

Buffer.prototype.writeInt8 = function (value, offset, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7f, -0x80)
  }

  if (offset >= this.length)
    return

  if (value >= 0)
    this.writeUInt8(value, offset, noAssert)
  else
    this.writeUInt8(0xff + value + 1, offset, noAssert)
}

function _writeInt16 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7fff, -0x8000)
  }

  var len = buf.length
  if (offset >= len)
    return

  if (value >= 0)
    _writeUInt16(buf, value, offset, littleEndian, noAssert)
  else
    _writeUInt16(buf, 0xffff + value + 1, offset, littleEndian, noAssert)
}

Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {
  _writeInt16(this, value, offset, true, noAssert)
}

Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {
  _writeInt16(this, value, offset, false, noAssert)
}

function _writeInt32 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7fffffff, -0x80000000)
  }

  var len = buf.length
  if (offset >= len)
    return

  if (value >= 0)
    _writeUInt32(buf, value, offset, littleEndian, noAssert)
  else
    _writeUInt32(buf, 0xffffffff + value + 1, offset, littleEndian, noAssert)
}

Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {
  _writeInt32(this, value, offset, true, noAssert)
}

Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {
  _writeInt32(this, value, offset, false, noAssert)
}

function _writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')
    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }

  var len = buf.length
  if (offset >= len)
    return

  ieee754.write(buf, value, offset, littleEndian, 23, 4)
}

Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {
  _writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {
  _writeFloat(this, value, offset, false, noAssert)
}

function _writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 7 < buf.length,
        'Trying to write beyond buffer length')
    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }

  var len = buf.length
  if (offset >= len)
    return

  ieee754.write(buf, value, offset, littleEndian, 52, 8)
}

Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {
  _writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {
  _writeDouble(this, value, offset, false, noAssert)
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (typeof value === 'string') {
    value = value.charCodeAt(0)
  }

  assert(typeof value === 'number' && !isNaN(value), 'value is not a number')
  assert(end >= start, 'end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  assert(start >= 0 && start < this.length, 'start out of bounds')
  assert(end >= 0 && end <= this.length, 'end out of bounds')

  for (var i = start; i < end; i++) {
    this[i] = value
  }
}

Buffer.prototype.inspect = function () {
  var out = []
  var len = this.length
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i])
    if (i === exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...'
      break
    }
  }
  return '<Buffer ' + out.join(' ') + '>'
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function () {
  if (typeof Uint8Array === 'function') {
    if (Buffer._useTypedArrays) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1)
        buf[i] = this[i]
      return buf.buffer
    }
  } else {
    throw new Error('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

var BP = Buffer.prototype

/**
 * Augment the Uint8Array *instance* (not the class!) with Buffer methods
 */
function augment (arr) {
  arr._isBuffer = true

  // save reference to original Uint8Array get/set methods before overwriting
  arr._get = arr.get
  arr._set = arr.set

  // deprecated, will be removed in node 0.13+
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

// slice(start, end)
function clamp (index, len, defaultValue) {
  if (typeof index !== 'number') return defaultValue
  index = ~~index;  // Coerce to integer.
  if (index >= len) return len
  if (index >= 0) return index
  index += len
  if (index >= 0) return index
  return 0
}

function coerce (length) {
  // Coerce length to a number (possibly NaN), round up
  // in case it's fractional (e.g. 123.456) then do a
  // double negate to coerce a NaN to 0. Easy, right?
  length = ~~Math.ceil(+length)
  return length < 0 ? 0 : length
}

function isArray (subject) {
  return (Array.isArray || function (subject) {
    return Object.prototype.toString.call(subject) === '[object Array]'
  })(subject)
}

function isArrayish (subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
      subject && typeof subject === 'object' &&
      typeof subject.length === 'number'
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    var b = str.charCodeAt(i)
    if (b <= 0x7F)
      byteArray.push(str.charCodeAt(i))
    else {
      var start = i
      if (b >= 0xD800 && b <= 0xDFFF) i++
      var h = encodeURIComponent(str.slice(start, i+1)).substr(1).split('%')
      for (var j = 0; j < h.length; j++)
        byteArray.push(parseInt(h[j], 16))
    }
  }
  return byteArray
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(str)
}

function blitBuffer (src, dst, offset, length) {
  var pos
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length))
      break
    dst[i + offset] = src[i]
  }
  return i
}

function decodeUtf8Char (str) {
  try {
    return decodeURIComponent(str)
  } catch (err) {
    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
  }
}

/*
 * We have to make sure that the value is a valid integer. This means that it
 * is non-negative. It has no fractional component and that it does not
 * exceed the maximum allowed value.
 */
function verifuint (value, max) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value >= 0, 'specified a negative value for writing an unsigned value')
  assert(value <= max, 'value is larger than maximum value for type')
  assert(Math.floor(value) === value, 'value has a fractional component')
}

function verifsint (value, max, min) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value <= max, 'value larger than maximum allowed value')
  assert(value >= min, 'value smaller than minimum allowed value')
  assert(Math.floor(value) === value, 'value has a fractional component')
}

function verifIEEE754 (value, max, min) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value <= max, 'value larger than maximum allowed value')
  assert(value >= min, 'value smaller than minimum allowed value')
}

function assert (test, message) {
  if (!test) throw new Error(message || 'Failed assertion')
}

});
require.register("microflo-microflo/component.json", function(exports, require, module){
module.exports = JSON.parse('{"name":"microflo","description":"MicroFlo host functionality for browser","author":"Jon Nordby <jononor@gmail.com>","repo":"microflo/microflo","version":"0.3.29","keywords":["FBP"],"dependencies":{"component/emitter":"*","the-grid/flowhub-registry":"*","noflo/fbp":"*","jonnor/buffer":"*"},"main":"lib/microflo.js","scripts":["lib/commandformat.js","lib/commandstream.js","lib/componentlib.js","lib/generate.js","lib/microflo.js","lib/serial.js","lib/simulator.js","lib/util.js","lib/devicecommunication.js","lib/flash.js","lib/definition.js","lib/runtime.js"],"json":["component.json","microflo/commandformat.json"],"remotes":["https://raw.githubusercontent.com"],"styles":[],"files":[]}');
});
require.register("microflo-microflo/microflo/commandformat.json", function(exports, require, module){
module.exports = JSON.parse('{"magicString":"uC/Flo01","commandSize":8,"commands":{"Reset":{"id":10},"CreateComponent":{"id":11},"ConnectNodes":{"id":12},"SendPacket":{"id":13},"End":{"id":14},"ConfigureDebug":{"id":15},"SubscribeToPort":{"id":16},"ConnectSubgraphPort":{"id":17},"Ping":{"id":18},"CommunicationOpen":{"id":19},"StartNetwork":{"id":20},"SetIoValue":{"id":21},"NetworkStopped":{"id":100},"NodeAdded":{"id":101},"NodesConnected":{"id":102},"PacketSent":{"id":103},"NetworkStarted":{"id":104},"DebugChanged":{"id":105},"DebugMessage":{"id":106},"PortSubscriptionChanged":{"id":107},"SubgraphPortConnected":{"id":108},"Pong":{"id":109},"PacketDelivered":{"id":110},"TransmissionEnded":{"id":111},"SetIoValueCompleted":{"id":112},"IoValueChanged":{"id":113},"SendPacketDone":{"id":114},"Invalid":{},"Max":{"id":255}},"packetTypes":{"Invalid":{"id":0},"Setup":{"id":1},"Tick":{"id":2},"Void":{"id":3,"description":"No data payload, can be used like a \'bang\' in other flow-based systems"},"Byte":{"id":4},"Boolean":{"id":6},"Integer":{"id":7},"Float":{"id":8},"BracketStart":{"id":9},"BracketEnd":{"id":10},"MaxDefined":{},"Max":{"id":255}},"debugPoints":{"Invalid":{"id":0},"ProgramStart":{"id":1},"ComponentCreateStart":{"id":2},"ComponentCreateEnd":{"id":3},"ParserInvalidState":{"id":4},"ParserUnknownState":{"id":5},"ParseHeader":{"id":6},"ParseCommand":{"id":7},"ParseByte":{"id":8},"ParserUnknownCommand":{"id":9},"ParserInvalidCommand":{"id":10},"ParserUnknownPacketType":{"id":11},"NetworkConnectInvalidNodes":{"id":12},"ConnectNodesStart":{"id":13},"ReadByte":{"id":14},"AddNodeInvalidInstance":{"id":15},"ComponentSendInvalidPort":{"id":16},"ParseLookForHeader":{"id":17},"MagicMismatch":{"id":18},"NotImplemented":{"id":19},"SubGraphConnectNotASubgraph":{"id":20},"SubGraphConnectInvalidNodes":{"id":21},"SubGraphReceivedNormalMessage":{"id":22},"SendMessageInvalidNode":{"id":23},"AddNodeInvalidParent":{"id":24},"SubscribePortInvalidNode":{"id":25},"IoOperationNotImplemented":{"id":26},"InvalidComponentUsed":{"id":27},"IoFailure":{"id":28},"DeliverMessagesInvalidMessageId":{"id":29},"NotSupported":{"id":30},"MagicMatched":{"id":31},"EndOfTransmission":{"id":32},"IoInvalidValueSet":{"id":33},"UnknownIoType":{"id":34},"SubscribePortInvalidPort":{"id":35},"User1":{"id":100},"User2":{"id":101},"User3":{"id":102},"User4":{"id":103},"User5":{"id":104},"User6":{"id":105},"Max":{"id":255}},"debugLevels":{"Invalid":{"id":0},"Error":{"id":1},"Info":{"id":2},"Detailed":{"id":3},"VeryDetailed":{"id":4},"Max":{"id":255}},"ioTypes":{"Invalid":{"id":0},"Analog":{"id":1},"Digital":{"id":2},"TimeMs":{"id":3},"PinMode":{"id":4},"Max":{"id":255}}}');
});
require.register("microflo-microflo/lib/commandformat.js", function(exports, require, module){
var def, util;

util = require('./util');

def = null;

if (util.isBrowser()) {
  def = require('../microflo/commandformat.json');
} else {
  def = require('../microflo/commandformat.json');
}

module.exports = def;

});
require.register("microflo-microflo/lib/commandstream.js", function(exports, require, module){

/* MicroFlo - Flow-Based Programming for microcontrollers
 * Copyright (c) 2013 Jon Nordby <jononor@gmail.com>
 * MicroFlo may be freely distributed under the MIT license
 */
var Buffer, cmdFormat, cmdStreamBuildGraph, cmdStreamBuildSubGraph, cmdStreamFromGraph, dataLiteralToCommand, dataToCommand, fbp, findPort, nodeLookup, nodeNameById, parseReceivedCmd, util, writeCmd, writeNewCmd, writeString;

cmdFormat = require('./commandformat');

util = require('./util');

Buffer = util.Buffer;

fbp = require('fbp');

writeCmd = function() {
  var buf, data, i, offset;
  buf = arguments[0];
  offset = arguments[1];
  data = arguments[2];
  if (typeof data === 'object' && (data.length != null)) {
    data.copy(buf, offset);
    return data.length;
  } else {
    data = Array.prototype.slice.call(arguments, 2);
  }
  i = 0;
  while (i < cmdFormat.commandSize) {
    if (i < data.length) {
      buf.writeUInt8(data[i], offset + i);
    } else {
      buf.writeUInt8(0, offset + i);
    }
    i++;
  }
  return cmdFormat.commandSize;
};

writeString = function(buf, offset, string) {
  var i;
  i = 0;
  while (i < string.length) {
    buf[offset + i] = string.charCodeAt(i);
    i++;
  }
  return string.length;
};

writeNewCmd = function() {
  var args, b;
  b = new Buffer(cmdFormat.commandSize);
  b.fill(0, 0, cmdFormat.commandSize);
  args = Array.prototype.slice.call(arguments);
  args.unshift(b, 0);
  writeCmd.apply(this, args);
  return b;
};

dataToCommand = function(data, tgt, tgtPort) {
  var literal;
  if (Array.isArray(data)) {
    literal = JSON.stringify(data);
  } else {
    literal = data + '';
  }
  return dataLiteralToCommand(literal, tgt, tgtPort);
};

dataLiteralToCommand = function(literal, tgt, tgtPort) {
  var b, buffers, err, error, isBool, j, len, val, value;
  b = null;
  literal = literal.replace('^"|"$', '');
  value = parseInt(literal);
  if (typeof value === 'number' && value % 1 === 0) {
    b = new Buffer(cmdFormat.commandSize);
    b.fill(0);
    b.writeUInt8(cmdFormat.commands.SendPacket.id, 0);
    b.writeUInt8(tgt, 1);
    b.writeUInt8(tgtPort, 2);
    b.writeInt8(cmdFormat.packetTypes.Integer.id, 3);
    b.writeInt32LE(value, 4);
    return b;
  }
  isBool = literal === 'true' || literal === 'false';
  value = literal === 'true';
  if (isBool) {
    b = new Buffer(cmdFormat.commandSize);
    b.fill(0);
    b.writeUInt8(cmdFormat.commands.SendPacket.id, 0);
    b.writeUInt8(tgt, 1);
    b.writeUInt8(tgtPort, 2);
    b.writeInt8(cmdFormat.packetTypes.Boolean.id, 3);
    val = value ? 1 : 0;
    b.writeInt8(val, 4);
    return b;
  }
  try {
    value = JSON.parse(literal);
  } catch (error) {
    err = error;
    throw 'Unknown IIP data type for literal \'' + literal + '\' :' + err;
  }
  if (Array.isArray(value)) {
    buffers = [];
    b = writeNewCmd(cmdFormat.commands.SendPacket.id, tgt, tgtPort, cmdFormat.packetTypes.BracketStart.id);
    buffers.push(b);
    for (j = 0, len = value.length; j < len; j++) {
      val = value[j];
      b = dataToCommand(val, tgt, tgtPort);
      buffers.push(b);
    }
    b = writeNewCmd(cmdFormat.commands.SendPacket.id, tgt, tgtPort, cmdFormat.packetTypes.BracketEnd.id);
    buffers.push(b);
    return Buffer.concat(buffers);
  }
  throw 'Unknown IIP data type for literal \'' + literal + '\'';
};

findPort = function(componentLib, graph, nodeName, portName) {
  var isOutput, port;
  isOutput = false;
  port = componentLib.inputPort(graph.processes[nodeName].component, portName);
  if (!port) {
    port = componentLib.outputPort(graph.processes[nodeName].component, portName);
    isOutput = true;
  }
  return {
    isOutput: isOutput,
    port: port
  };
};

cmdStreamBuildSubGraph = function(currentNodeId, buffer, index, componentLib, graph, nodeName, comp) {
  var c, childNode, childPort, i, r, subgraph, subgraphNode, subgraphPort, tok, value;
  index += writeCmd(buffer, index, cmdFormat.commands.CreateComponent.id, componentLib.getComponent('SubGraph').id);
  graph.nodeMap[nodeName] = {
    id: currentNodeId++
  };
  subgraph = comp.graph;
  subgraph.nodeMap = graph.nodeMap;
  graph.processes[nodeName].graph = subgraph;
  r = cmdStreamBuildGraph(currentNodeId, buffer, index, componentLib, subgraph, nodeName);
  index += r.index;
  currentNodeId = r.nodeId;
  i = 0;
  while (i < subgraph.exports.length) {
    c = subgraph.exports[i];
    tok = c['private'].split('.');
    if (tok.length !== 2) {
      throw 'Invalid export definition';
    }
    childNode = graph.nodeMap[tok[0]];
    childPort = findPort(componentLib, subgraph, tok[0], tok[1]);
    subgraphNode = graph.nodeMap[nodeName];
    subgraphPort = componentLib.inputPort(graph.processes[nodeName].component, c['public']);
    value = childPort.isOutput ? 1 : 0;
    index += writeCmd(buffer, index, cmdFormat.commands.ConnectSubgraphPort.id, value, subgraphNode.id, subgraphPort.id, childNode.id, childPort.port.id);
    i++;
  }
  return {
    index: index,
    nodeId: currentNodeId
  };
};

cmdStreamBuildGraph = function(currentNodeId, buffer, index, componentLib, graph, parent) {
  var comp, nodeMap, nodeName, parentId, process, r, startIndex;
  nodeMap = graph.nodeMap;
  startIndex = index;
  for (nodeName in graph.processes) {
    if (!graph.processes.hasOwnProperty(nodeName)) {
      i++;
      continue;
    }
    process = graph.processes[nodeName];
    comp = componentLib.getComponent(process.component);
    if (typeof comp === 'undefined') {
      throw new Error('Cannot find component: ' + process.component);
    }
    if (comp.graph || comp.graphFile) {
      r = cmdStreamBuildSubGraph(currentNodeId, buffer, index, componentLib, graph, nodeName, comp);
      index = r.index;
      currentNodeId = r.nodeId;
    } else {
      parentId = parent ? nodeMap[parent].id : void 0;
      if (parentId) {
        graph.processes[nodeName].parent = parentId;
      }
      index += writeCmd(buffer, index, cmdFormat.commands.CreateComponent.id, comp.id, parentId || 0);
      nodeMap[nodeName] = {
        id: currentNodeId++,
        parent: parentId
      };
    }
  }
  graph.connections.forEach(function(connection) {
    var err, error, srcNode, srcPort, tgtNode, tgtPort;
    if (connection.src !== void 0) {
      srcNode = connection.src.process;
      tgtNode = connection.tgt.process;
      srcPort = void 0;
      tgtPort = void 0;
      try {
        srcPort = componentLib.outputPort(graph.processes[srcNode].component, connection.src.port).id;
        tgtPort = componentLib.inputPort(graph.processes[tgtNode].component, connection.tgt.port).id;
      } catch (error) {
        err = error;
        throw 'Could not connect: ' + srcNode + ' ' + connection.src.port + ' -> ' + connection.tgt.port + ' ' + tgtNode + ' : ' + err.toString();
      }
      if (tgtPort !== void 0 && srcPort !== void 0) {
        index += writeCmd(buffer, index, cmdFormat.commands.ConnectNodes.id, nodeMap[srcNode].id, nodeMap[tgtNode].id, srcPort, tgtPort);
      }
    }
  });
  graph.connections.forEach(function(connection) {
    var cmdBuf, component, err, error, tgtNode, tgtPort;
    if (connection.data !== void 0) {
      tgtNode = connection.tgt.process;
      tgtPort = void 0;
      try {
        component = graph.processes[tgtNode].component;
        tgtPort = componentLib.inputPort(component, connection.tgt.port).id;
      } catch (error) {
        err = error;
        throw 'Could not attach IIP: \'' + connection.data.toString() + '\' -> ' + tgtPort + ' ' + tgtNode + ' : ' + err;
      }
      cmdBuf = dataLiteralToCommand(connection.data, nodeMap[tgtNode].id, tgtPort);
      index += writeCmd(buffer, index, cmdBuf);
    }
  });
  return {
    index: index - startIndex,
    nodeId: currentNodeId
  };
};

cmdStreamFromGraph = function(componentLib, graph, debugLevel, openclose) {
  var buffer, currentNodeId, index, r;
  debugLevel = debugLevel || 'Error';
  buffer = new Buffer(1024);
  index = 0;
  currentNodeId = 1;
  if (!graph.nodeMap) {
    graph.nodeMap = {};
  }
  if (openclose) {
    index += writeString(buffer, index, cmdFormat.magicString);
  }
  index += writeCmd(buffer, index, cmdFormat.commands.Reset.id);
  index += writeCmd(buffer, index, cmdFormat.commands.ConfigureDebug.id, cmdFormat.debugLevels[debugLevel].id);
  r = cmdStreamBuildGraph(currentNodeId, buffer, index, componentLib, graph);
  index += r.index;
  currentNodeId = r.nodeId;
  index += writeCmd(buffer, index, cmdFormat.commands.StartNetwork.id);
  if (openclose) {
    index += writeCmd(buffer, index, cmdFormat.commands.End.id);
  }
  buffer = buffer.slice(0, index);
  return buffer;
};

nodeNameById = function(nodeMap, wantedId) {
  var id, name;
  for (name in nodeMap) {
    name = name;
    id = nodeMap[name].id !== void 0 ? nodeMap[name].id : nodeMap[name];
    if (id === wantedId) {
      return name;
    }
  }
};

nodeLookup = function(graph, nodeName) {
  var parent, r;
  parent = graph.nodeMap[nodeName].parent;
  r = parent !== void 0 ? graph.processes[nodeNameById(graph.nodeMap, parent)].graph.processes : graph.processes;
  return r[nodeName];
};

parseReceivedCmd = function(componentLib, graph, cmdData, handler) {
  var targetPort;
  var targetNode;
  var srcPort;
  var srcNode;
  var childNode, childPort, cmd, component, data, direction, enable, level, lvl, node, nodeName, point, port, portById, srcComponent, srcNode, srcPort, subgraphNode, subgraphPort, targetComponent, targetNode, targetPort, type;
  if (!componentLib) {
    throw new Error('Missing component library');
  }
  cmd = cmdData.readUInt8(0);
  if (cmd === cmdFormat.commands.NetworkStopped.id) {
    handler('NETSTOP');
  } else if (cmd === cmdFormat.commands.NetworkStarted.id) {
    handler('NETSTART');
  } else if (cmd === cmdFormat.commands.NodeAdded.id) {
    component = componentLib.getComponentById(cmdData.readUInt8(1)).name;
    nodeName = nodeNameById(graph.nodeMap, cmdData.readUInt8(2));
    handler('ADD', nodeName, '(', component, ')');
  } else if (cmd === cmdFormat.commands.NodesConnected.id) {
    srcNode = nodeNameById(graph.nodeMap, cmdData.readUInt8(1));
    if (!srcNode) {
      return;
    }
    srcComponent = nodeLookup(graph, srcNode).component;
    srcPort = componentLib.outputPortById(srcComponent, cmdData.readUInt8(2)).name;
    targetNode = nodeNameById(graph.nodeMap, cmdData.readUInt8(3));
    if (!targetNode) {
      return;
    }
    targetComponent = nodeLookup(graph, targetNode).component;
    targetPort = componentLib.inputPortById(targetComponent, cmdData.readUInt8(4)).name;
    handler('CONNECT', srcNode, srcPort, '->', targetPort, targetNode);
  } else if (cmd === cmdFormat.commands.DebugChanged.id) {
    level = nodeNameById(cmdFormat.debugLevels, cmdData.readUInt8(1));
    handler('DEBUGLEVEL', level);
  } else if (cmd === cmdFormat.commands.DebugMessage.id) {
    lvl = cmdData.readUInt8(1);
    point = nodeNameById(cmdFormat.debugPoints, cmdData.readUInt8(2));
    handler('DEBUG', lvl, point);
  } else if (cmd === cmdFormat.commands.PortSubscriptionChanged.id) {
    node = nodeNameById(graph.nodeMap, cmdData.readUInt8(1));
    port = componentLib.outputPortById(graph.processes[node].component, cmdData.readUInt8(2)).name;
    enable = cmdData.readUInt8(3) ? 'true' : 'false';
    handler('SUBSCRIBE', node, '->', port, enable);
  } else if (cmd === cmdFormat.commands.PacketSent.id) {
    srcNode = nodeNameById(graph.nodeMap, cmdData.readUInt8(1));
    srcPort = componentLib.outputPortById(nodeLookup(graph, srcNode).component, cmdData.readUInt8(2)).name;
    targetNode = nodeNameById(graph.nodeMap, cmdData.readUInt8(3));
    targetPort = componentLib.inputPortById(nodeLookup(graph, targetNode).component, cmdData.readUInt8(4)).name;
    type = nodeNameById(cmdFormat.packetTypes, cmdData.readUInt8(5));
    data = void 0;
    if (type === 'Boolean') {
      data = cmdData.readUInt8(6) ? true : false;
    } else if (type === 'Void') {
      data = null;
    } else if (type === 'Integer' || type === 'Float') {
      data = cmdData.readInt16LE(6);
    } else if (type === 'Byte') {
      data = cmdData.readUInt8(6);
    } else if (type === 'BracketStart' || type === 'BracketEnd') {
      data = type;
    } else {
      console.log('Unknown data type in PacketSent: ', type);
    }
    handler('SEND', srcNode, srcPort, type, data, targetNode, targetPort);
  } else if (cmd === cmdFormat.commands.SubgraphPortConnected.id) {
    direction = cmdData.readUInt8(1) ? 'output' : 'input';
    portById = direction === 'output' ? componentLib.outputPortById : componentLib.inputPortById;
    subgraphNode = nodeNameById(graph.nodeMap, cmdData.readUInt8(2));
    subgraphPort = portById(nodeLookup(graph, subgraphNode).component, cmdData.readUInt8(3)).name;
    childNode = nodeNameById(graph.nodeMap, cmdData.readUInt8(4));
    childPort = portById(nodeLookup(graph, childNode).component, cmdData.readUInt8(5)).name;
    handler('SUBGRAPH-CONNECT', direction, subgraphNode, subgraphPort, childNode, childPort);
  } else if (cmd === cmdFormat.commands.CommunicationOpen.id) {
    handler('OPEN');
  } else if (cmd === cmdFormat.commands.Pong.id) {
    handler('PONG', cmdData.slice(1, 8));
  } else if (cmd === cmdFormat.commands.TransmissionEnded.id) {
    handler('EOT');
  } else if (cmd === cmdFormat.commands.IoValueChanged.id) {
    handler('IOCHANGE', cmdData.slice(0, 7));
  } else if (cmd === cmdFormat.commands.SetIoValueCompleted.id) {
    handler('IOACK', cmdData.slice(0, 7));
  } else if (cmd === cmdFormat.commands.SendPacketDone.id) {
    handler('SENDACK');
  } else {
    handler('UNKNOWN' + cmd.toString(16), cmdData.slice(0, 8));
  }
};

module.exports = {
  cmdStreamFromGraph: cmdStreamFromGraph,
  dataLiteralToCommand: dataLiteralToCommand,
  dataToCommand: dataToCommand,
  writeCmd: writeCmd,
  writeString: writeString,
  cmdFormat: cmdFormat,
  format: cmdFormat,
  parseReceivedCmd: parseReceivedCmd,
  Buffer: Buffer
};

});
require.register("microflo-microflo/lib/componentlib.js", function(exports, require, module){
var ComponentLibrary, extractComponents, findHighestId, fs, path, util;

util = require("./util");

if (!util.isBrowser()) {
  path = require("path");
  fs = require("fs");
}

findHighestId = function(components) {
  var highest;
  highest = 0;
  Object.keys(components).forEach(function(name) {
    var comp;
    comp = components[name];
    if (!comp[".skip"] && comp.id > highest) {
      return highest = comp.id;
    }
  });
  return highest;
};

extractComponents = function(componentLib, inputFile) {
  var data, declarec, raw, yaml;
  declarec = require("declarec");
  yaml = require("js-yaml");
  data = fs.readFileSync(inputFile, {
    encoding: "utf-8"
  });
  raw = declarec.extractDefinition(data, "microflo_component", "c");
  return raw.forEach(function(def) {
    var d, needsFix;
    needsFix = function(str) {
      return str.indexOf(" ") === 0 && str.substring(0, 3) !== "---";
    };
    if (def.format === "yaml") {
      if (needsFix(def.content)) {
        def.content = "---\n" + def.content + "\n";
      }
      d = yaml.safeLoad(def.content);
      return componentLib.addComponent(d.name, d, inputFile);
    }
  });
};

ComponentLibrary = (function() {
  function ComponentLibrary() {
    this.reset();
  }

  ComponentLibrary.prototype.reset = function() {
    return this.definition = {
      components: {}
    };
  };

  ComponentLibrary.prototype.loadFile = function(filePath) {
    return extractComponents(this, filePath);
  };

  ComponentLibrary.prototype.loadSet = function(set, callback) {
    var e, error;
    try {
      set.components.forEach((function(_this) {
        return function(name) {
          return _this.loadFile(set.base + "/" + name + ".hpp");
        };
      })(this));
    } catch (error) {
      e = error;
      return callback(e);
    }
    return callback(null);
  };

  ComponentLibrary.prototype.loadSetFile = function(filePath, callback) {
    var content, modulePath;
    content = require(filePath);
    modulePath = require.resolve(filePath);
    if (typeof content.microflo !== "undefined") {
      content = content.microflo;
    }
    content.base = path.dirname(modulePath);
    return this.loadSet(content, callback);
  };

  ComponentLibrary.prototype.listComponents = function(includingSkipped, includingVirtual) {
    return Object.keys(this.getComponents(includingSkipped, includingVirtual));
  };

  ComponentLibrary.prototype.getComponents = function(includingSkipped, includingVirtual) {
    var comp, components, name, skip, virtual;
    if (includingSkipped) {
      return this.definition.components;
    }
    components = {};
    for (name in this.definition.components) {
      comp = this.getComponent(name);
      skip = comp[".skip"] || false;
      virtual = comp["graph"] || comp["graphFile"];
      if (!skip && (includingVirtual || !virtual)) {
        components[name] = comp;
      }
    }
    return components;
  };

  ComponentLibrary.prototype.getComponent = function(componentName) {
    return this.definition.components[componentName];
  };

  ComponentLibrary.prototype.getComponentById = function(componentId) {
    var comp, name;
    for (name in this.getComponents()) {
      comp = this.getComponent(name);
      if (comp.id === componentId) {
        comp.name = name;
        return comp;
      }
    }
    return null;
  };

  ComponentLibrary.prototype.getComponentSource = function(componentName, callback) {
    var componentFile, endLine, startLine;
    componentFile = path.join(this.baseDirectory, "components.cpp");
    startLine = 0;
    endLine = 0;
    return fs.readFile(componentFile, (function(_this) {
      return function(err, data) {
        var i, line, lines, source;
        if (err) {
          return callback(err, null);
        }
        data = data.toString();
        lines = data.split("\n");
        i = 0;
        while (i < lines.length) {
          line = lines[i].trim();
          if (startLine === 0 && line.match("class " + componentName)) {
            startLine = i;
          }
          if (startLine !== 0 && line.match("};")) {
            endLine = i + 1;
            source = lines.slice(startLine, endLine).join("\n");
            return callback(null, source);
          }
          i++;
        }
        return callback(new Error('Could not find component source'));
      };
    })(this));
  };

  ComponentLibrary.prototype.outputPortsFor = function(componentName) {
    return this.getComponent(componentName).outPorts;
  };

  ComponentLibrary.prototype.inputPortsFor = function(componentName) {
    return this.getComponent(componentName).inPorts;
  };

  ComponentLibrary.prototype.inputPort = function(componentName, portName) {
    return this.inputPortsFor(componentName)[portName];
  };

  ComponentLibrary.prototype.outputPort = function(componentName, portName) {
    return this.outputPortsFor(componentName)[portName];
  };

  ComponentLibrary.prototype.inputPortById = function(componentName, portId) {
    var name, port, ports;
    ports = this.inputPortsFor(componentName);
    for (name in ports) {
      port = ports[name];
      if (port.id === portId) {
        port.name = name;
        return port;
      }
    }
    return null;
  };

  ComponentLibrary.prototype.outputPortById = function(componentName, portId) {
    var name, port, ports;
    ports = this.outputPortsFor(componentName);
    for (name in ports) {
      port = ports[name];
      if (port.id === portId) {
        port.name = name;
        return port;
      }
    }
    return null;
  };

  ComponentLibrary.prototype.addComponent = function(componentName, def, filename) {
    var checkPortIdsAssigned;
    def.filename = filename;
    if (typeof def.id === "undefined") {
      def.id = findHighestId(this.definition.components) + 1;
    }
    if (typeof def.inports !== "undefined") {
      def.inPorts = def.inports;
      def.inports = null;
    }
    if (typeof def.inPorts === "undefined") {
      def.inPorts = {
        'in': {
          id: 0
        }
      };
    }
    if (typeof def.outports !== "undefined") {
      def.outPorts = def.outports;
      def.outports = null;
    }
    if (typeof def.outPorts === "undefined") {
      def.outPorts = {
        out: {
          id: 0
        }
      };
    }
    checkPortIdsAssigned = function(ports) {
      var names;
      names = Object.keys(ports);
      if (names.length > 0 && (ports[names[0]].id == null)) {
        return names.forEach(function(name, idx) {
          var port;
          port = ports[name];
          return port.id = idx;
        });
      }
    };
    checkPortIdsAssigned(def.inPorts);
    checkPortIdsAssigned(def.outPorts);
    return this.definition.components[componentName] = def;
  };

  return ComponentLibrary;

})();

module.exports = {
  ComponentLibrary: ComponentLibrary
};

});
require.register("microflo-microflo/lib/generate.js", function(exports, require, module){
var cmdFormat, cmdStreamToC, cmdStreamToCDefinition, commandstream, declarec, definition, endsWith, extractId, fs, generateComponentFactory, generateComponentIncludes, generateComponentMap, generateComponentPortDefinitions, generateConstInt, generateEnum, generateOutput, guardHead, guardTail, macroSafeName, path, updateComponentLibDefinitions, updateDefinitions, util;

util = require("./util");

cmdFormat = require("./commandformat");

commandstream = require("./commandstream");

definition = require("./definition");

if (!util.isBrowser()) {
  fs = require("fs");
  path = require("path");
  declarec = require("declarec");
}

cmdStreamToCDefinition = function(cmdStream, target) {
  var out;
  out = "";
  if (target === "arduino" || target === "avr") {
    out += "#include <avr/pgmspace.h>\n";
    out += cmdStreamToC(cmdStream, "PROGMEM");
  } else {
    out += cmdStreamToC(cmdStream);
  }
  return out;
};

cmdStreamToC = function(cmdStream, annotation) {
  var cCode, commas, i, prettyValues, values, variableName;
  if (!annotation) {
    annotation = "";
  }
  variableName = "graph";
  values = [];
  i = 0;
  while (i < cmdStream.length) {
    values[i] = "0x" + cmdStream.readUInt8(i).toString(16);
    i++;
  }
  values = values.join(",");
  prettyValues = "";
  commas = 0;
  i = 0;
  while (i < values.length) {
    if (values[i] === ",") {
      commas += 1;
    }
    prettyValues = prettyValues.concat(values[i]);
    if (commas && (commas % cmdFormat.commandSize) === 0) {
      prettyValues = prettyValues.concat("\n");
      commas = 0;
    }
    i++;
  }
  cCode = "const unsigned char " + variableName + "[] " + annotation + " = {\n" + prettyValues + "\n};";
  return cCode;
};

generateConstInt = function(prefix, iconsts) {
  var a, e, indent, out;
  if (Object.keys(iconsts).length === 0) {
    return "";
  }
  indent = "\n const MicroFlo::ComponentId ";
  out = "#ifndef COMPONENTLIB_IDS_H\n#define COMPONENTLIB_IDS_H\n\n";
  out += "// Component Id constants\n";
  out += "namespace {";
  a = [];
  for (e in iconsts) {
    if (!iconsts.hasOwnProperty(e)) {
      continue;
    }
    a.push(indent + prefix + e + (iconsts[e].id !== undefined ? " = " + iconsts[e].id : ""));
  }
  out += a.join(";");
  out += ";\n};\n\n";
  out += "#endif // COMPONENTLIB_IDS_H\n";
  return out;
};

generateEnum = function(name, prefix, enums) {
  var a, e, indent, out;
  if (Object.keys(enums).length === 0) {
    return "";
  }
  indent = "\n    ";
  out = "enum " + name + " {";
  a = [];
  for (e in enums) {
    if (!enums.hasOwnProperty(e)) {
      continue;
    }
    a.push(indent + prefix + e + (enums[e].id !== undefined ? " = " + enums[e].id : ""));
  }
  out += a.join(",");
  out += "\n};\n";
  return out;
};

generateComponentPortDefinitions = function(componentLib) {
  var name, out;
  out = "#ifndef COMPONENTLIB_PORTS_H\n#define COMPONENTLIB_PORTS_H\n\n";
  for (name in componentLib.getComponents()) {
    out += "\n" + "namespace " + name + "Ports {\n";
    out += "struct InPorts {\n";
    out += generateEnum("Ports", "", componentLib.inputPortsFor(name));
    out += "};\n";
    out += "struct OutPorts {\n";
    out += generateEnum("Ports", "", componentLib.outputPortsFor(name));
    out += "};";
    out += "\n}\n";
  }
  out += "\n#endif // COMPONENTLIB_PORTS_H\n";
  return out;
};

generateComponentFactory = function(componentLib, methodName) {
  var comp, indent, instantiator, name, out, t0, t1;
  out = "// Component factory functionality\nComponent *" + methodName + "(MicroFlo::ComponentId id) {";
  indent = "\n    ";
  out += indent + "Component *c;";
  out += indent + "switch (id) {";
  for (name in componentLib.getComponents()) {
    comp = componentLib.getComponent(name);
    instantiator = "new " + "::" + name;
    if (typeof comp.type !== "undefined" && comp.type === "pure2") {
      t0 = componentLib.inputPortById(name, 0).ctype;
      t1 = componentLib.inputPortById(name, 0).ctype;
      instantiator = "new PureFunctionComponent2<" + name + "," + t0 + "," + t1 + ">";
    }
    out += indent + "case Id" + name + ": c = " + instantiator + "; c->setComponentId(id); return c;";
  }
  out += indent + "default: return NULL;";
  out += indent + "}";
  out += "}";
  return out;
};

endsWith = function(str, suffix) {
  return str.indexOf(suffix) === str.length - suffix.length;
};

generateComponentIncludes = function(componentLib) {
  var comp, name, out;
  out = "";
  for (name in componentLib.getComponents()) {
    comp = componentLib.getComponent(name);
    if (comp.filename && !endsWith(comp.filename, ".cpp")) {
      out += "#include \"" + comp.filename + "\"\n";
    }
  }
  return out;
};

generateComponentMap = function(componentLib) {
  var out;
  out = JSON.stringify(componentLib.definition);
  return out;
};

macroSafeName = function(str) {
  return str.split(".").join("_").split("-").join("_");
};

guardHead = function(filename) {
  var guardname;
  guardname = "_" + macroSafeName(filename);
  return "#ifndef " + guardname + "\n" + "#define " + guardname + "\n";
};

guardTail = function(filename) {
  var guardname;
  guardname = "_" + macroSafeName(filename);
  return "#endif //" + guardname + "\n";
};

extractId = function(map, key) {
  return map[key].id;
};

updateComponentLibDefinitions = function(componentLib, baseDir, factoryMethodName) {
  var all, ids, ports, sourceOutput;
  sourceOutput = "";
  ids = generateConstInt("Id", componentLib.getComponents(true, true));
  ports = generateComponentPortDefinitions(componentLib);
  fs.writeFileSync(baseDir + "/componentlib-ids.h", ids);
  fs.writeFileSync(baseDir + "/componentlib-ports.h", ports);
  sourceOutput += generateComponentIncludes(componentLib);
  sourceOutput += "\n\n";
  sourceOutput += generateComponentFactory(componentLib, factoryMethodName);
  fs.writeFileSync(baseDir + "/componentlib-source.hpp", sourceOutput);
  all = "\n#include \"microflo.h\"\n" + ids + ports + sourceOutput;
  fs.writeFileSync(baseDir + "/componentlib.hpp", all);
  return fs.writeFileSync(baseDir + "/componentlib-map.json", generateComponentMap(componentLib));
};

updateDefinitions = function(baseDir) {
  var contents;
  contents = "// !! WARNING: This file is generated from commandformat.json !!" + "\n" + generateEnum("GraphCmd", "GraphCmd", cmdFormat.commands) + "\n" + declarec.generateStringMap('GraphCmd_names', cmdFormat.commands, extractId) + "\n" + generateEnum("Msg", "Msg", cmdFormat.packetTypes) + "\n" + declarec.generateStringMap('Msg_names', cmdFormat.packetTypes, extractId) + "\n" + generateEnum("DebugLevel", "DebugLevel", cmdFormat.debugLevels) + "\n" + declarec.generateStringMap('DebugLevel_names', cmdFormat.debugLevels, extractId) + "\n" + generateEnum("DebugId", "Debug", cmdFormat.debugPoints) + "\n" + declarec.generateStringMap('DebugId_names', cmdFormat.debugPoints, extractId) + "\n" + generateEnum("IoType", "IoType", cmdFormat.ioTypes) + "\n" + declarec.generateStringMap('IoType_names', cmdFormat.ioTypes, extractId);
  return fs.writeFileSync(baseDir + "/commandformat-gen.h", contents);
};

generateOutput = function(componentLib, inputFile, outputFile, target) {
  var outputBase, outputDir;
  outputBase = void 0;
  outputDir = void 0;
  outputBase = outputFile.replace(path.extname(outputFile), "");
  if (!path.extname(outputFile)) {
    outputFile = outputFile + ".pde";
  }
  outputDir = path.dirname(outputBase);
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir);
  }
  return definition.loadFile(inputFile, function(err, def) {
    var data, includes;
    data = void 0;
    if (err) {
      throw err;
    }
    fs.writeFile(outputBase + ".json", JSON.stringify(def), function(err) {
      if (err) {
        throw err;
      }
    });
    data = commandstream.cmdStreamFromGraph(componentLib, def, null, true);
    fs.writeFile(outputBase + ".fbcs", data, function(err) {
      if (err) {
        throw err;
      }
    });
    fs.writeFile(outputBase + ".h", cmdStreamToCDefinition(data, target), function(err) {
      if (err) {
        throw err;
      }
    });
    fs.writeFile(outputBase + "_maps.h", declarec.generateStringMap("graph_nodeMap", def.nodeMap, extractId), function(err) {
      if (err) {
        throw err;
      }
    });
    includes = "\n#define MICROFLO_EMBED_GRAPH 1\n#include \"microflo.h\"\n#include \"main.hpp\"\n#include \"componentlib.hpp\"\n";
    return fs.writeFile(outputFile, cmdStreamToCDefinition(data, target) + includes, function(err) {
      if (err) {
        throw err;
      }
    });
  });
};

module.exports = {
  updateDefinitions: updateDefinitions,
  updateComponentLibDefinitions: updateComponentLibDefinitions,
  cmdStreamToCDefinition: cmdStreamToCDefinition,
  generateEnum: generateEnum,
  generateOutput: generateOutput
};

});
require.register("microflo-microflo/lib/microflo.js", function(exports, require, module){
module.exports = {
  util: require("./util"),
  componentlib: require("./componentlib"),
  runtime: require("./runtime"),
  generate: require("./generate"),
  commandstream: require("./commandstream"),
  devicecommunication: require("./devicecommunication"),
  simulator: require("./simulator"),
  serial: require("./serial")
};

});
require.register("microflo-microflo/lib/serial.js", function(exports, require, module){

/* MicroFlo - Flow-Based Programming for microcontrollers
 * Copyright (c) 2014 Jon Nordby <jononor@gmail.com>
 * MicroFlo may be freely distributed under the MIT license
 */
var getChromeSerial, getSerial, guessSerialPort, isLikelyArduinoSerial, isSupported, listChromeSerial, listNodeSerial, serial, serialport, util,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

util = require('./util');

if (util.isBrowser()) {
  if (indexOf.call(window, 'chrome') >= 0 && indexOf.call(window.chrome, 'serial') >= 0) {
    serial = window.chrome.serial;
  }
} else {
  serialport = require('serialport');
}

isLikelyArduinoSerial = function(e) {
  return e.comName.indexOf('usbserial') !== -1 || e.comName.indexOf('usbmodem') !== -1;
};

guessSerialPort = function(wantedPortName, callback) {
  serialport.list(function(err, ports) {
    var p, preferred;
    if (err) {
      callback(err);
    } else {
      if (ports.length === 0) {
        callback('No serial port found', void 0, void 0);
        return;
      }
      p = void 0;
      ports.forEach(function(port) {
        if (wantedPortName && wantedPortName !== 'auto' && wantedPortName === port.comName) {
          p = port.comName;
        }
      });
      if (p) {
        callback(err, p, ports);
        return;
      } else if (wantedPortName && wantedPortName !== 'auto') {
        console.log('WARN: unable to find serial port: ', wantedPortName);
      }
      preferred = ports.filter(isLikelyArduinoSerial);
      p = preferred.length > 0 ? preferred[0].comName : ports[0].comName;
      callback(err, p, ports);
    }
  });
};

getSerial = function(serialPortToUse, baudRate, cb) {
  var serial;
  console.log('Using serial baudrate with ' + serialPortToUse, baudRate);
  serial = void 0;
  guessSerialPort(serialPortToUse, function(err, portName, ports) {
    if (err) {
      console.log('No serial port found!: ', err);
      if (cb) {
        cb(err, void 0);
      }
    } else {
      ports = ports.map(function(item) {
        return item.comName;
      });
      console.log('Available serial ports: ', ports);
      console.log('Using serial port: ' + portName);
      serial = new serialport.SerialPort(portName, {
        baudrate: baudRate
      }, false);
      serial.open(function() {
        if (cb) {
          cb(void 0, serial);
        }
      });
      serial.getTransportType = function() {
        return 'Serial';
      };
    }
  });
  return function() {
    return serial;
  };
};

listChromeSerial = function(callback) {
  var f;
  f = function(ports) {
    var devices, i, port;
    devices = [];
    i = 0;
    while (i < ports.length) {
      port = ports[i];
      if (port.path.search('/dev/ttyS') !== -1) {
        i++;
      }
      continue;
      devices.push(port.path);
      i++;
    }
    return callback(devices);
  };
  chrome.serial.getDevices(f);
};

listNodeSerial = function(callback) {
  throw new Error('listNodeSerial: Not implemented');
};

getChromeSerial = function(serialPortToUse, baudRate, readyCallback) {
  var onConnect, onReceiveCallback, transport;
  transport = {};
  transport.connectionId = null;
  transport.listeners = {
    'data': null
  };
  transport.write = function(data, callback) {
    data = util.bufferToArrayBuffer(data);
    chrome.serial.send(transport.connectionId, data, function(sendinfo, error) {
      if (typeof callback !== 'undefined') {
        callback(error, sendinfo);
      }
    });
  };
  transport.close = function(callback) {
    if (!transport.connectionId) {
      return;
    }
    chrome.serial.disconnect(transport.connectionId, callback);
  };
  transport.removeAllListeners = function(event) {
    transport.listeners[event] = null;
  };
  transport.on = function(event, callback) {
    transport.listeners[event] = callback;
  };
  transport.emit = function(event, arg) {
    var cb;
    cb = transport.listeners[event];
    if (cb) {
      cb(arg);
    }
  };
  transport.getTransportType = function() {
    return 'Serial';
  };
  onConnect = function(connectionInfo) {
    var e;
    if (connectionInfo) {
      transport.connectionId = connectionInfo.connectionId;
      return readyCallback(null, transport);
    } else {
      e = new Error('Could not connect to serialport');
      return readyCallback(e, null);
    }
  };
  onReceiveCallback = function(info) {
    var data;
    if (info.connectionId === connectionId && info.data) {
      data = util.arrayBufferToBuffer(info.data);
      transport.emit('data', data);
    }
  };
  chrome.serial.onReceive.addListener(onReceiveCallback);
  chrome.serial.connect(serialPortToUse, {
    'bitrate': baudRate
  }, onConnect);
  return function() {
    return transport;
  };
};

isSupported = function() {
  return util.isBrowser() && indexOf.call(window, 'chrome') >= 0 && indexOf.call(window.chrome, 'serial') >= 0 || !util.isBrowser();
};

if (util.isBrowser()) {
  module.exports.listDevices = listChromeSerial;
  module.exports.openTransport = getChromeSerial;
} else {
  module.exports.listDevices = listNodeSerial;
  module.exports.openTransport = getSerial;
}

module.exports.isSupported = isSupported;

});
require.register("microflo-microflo/lib/simulator.js", function(exports, require, module){

/* MicroFlo - Flow-Based Programming for microcontrollers
 * Copyright (c) 2013 Jon Nordby <jononor@gmail.com>
 * MicroFlo may be freely distributed under the MIT license
 */
var ComponentLibrary, EventEmitter, RuntimeSimulator, Transport, devicecommunication, fbp, runtime, util,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  slice = [].slice;

util = require('./util');

EventEmitter = util.EventEmitter;

fbp = require('fbp');

devicecommunication = require('./devicecommunication');

runtime = require('./runtime');

ComponentLibrary = require('./componentlib').ComponentLibrary;

Transport = (function(superClass) {
  extend(Transport, superClass);

  function Transport(runtime1, emscripten) {
    this.runtime = runtime1;
    this.emscripten = emscripten;
    this.outbound_queue = [];
    this.pullFuncPtr = this.emscripten.Runtime.addFunction((function(_this) {
      return function() {
        var vars;
        vars = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        return _this.onPull.apply(_this, vars);
      };
    })(this));
    this.receiveFuncPtr = this.emscripten.Runtime.addFunction((function(_this) {
      return function() {
        var vars;
        vars = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        return _this.onReceive.apply(_this, vars);
      };
    })(this));
    this.emscripten['_emscripten_runtime_setup'](this.runtime, this.receiveFuncPtr, this.pullFuncPtr);
  }

  Transport.prototype.getTransportType = function() {
    return 'HostJavaScript';
  };

  Transport.prototype.write = function(buffer, callback) {
    this.outbound_queue.push(buffer);
    if (callback) {
      return callback();
    }
  };

  Transport.prototype.close = function(callback) {
    return callback(null);
  };

  Transport.prototype.onPull = function() {
    var buffer, byte, i, j;
    i = 0;
    while (i < this.outbound_queue.length) {
      buffer = this.outbound_queue[i];
      j = 0;
      while (j < buffer.length) {
        byte = buffer.readUInt8(j);
        this.emscripten['_emscripten_runtime_send'](this.runtime, byte);
        j++;
      }
      i++;
    }
    return this.outbound_queue = [];
  };

  Transport.prototype.onReceive = function() {
    var i;
    i = 0;
    while (i < arguments.length) {
      this.emit('data', new util.Buffer([arguments[i]]));
      i++;
    }
  };

  return Transport;

})(EventEmitter);

RuntimeSimulator = (function(superClass) {
  extend(RuntimeSimulator, superClass);

  function RuntimeSimulator(emscripten, options) {
    var transport;
    this.emscripten = emscripten;
    this.runtime = this.emscripten['_emscripten_runtime_new']();
    transport = new Transport(this.runtime, this.emscripten);
    RuntimeSimulator.__super__.constructor.call(this, transport, options);
  }

  RuntimeSimulator.prototype.runTick = function(tickIntervalMs) {
    tickIntervalMs |= 0;
    return this.emscripten['_emscripten_runtime_run'](this.runtime, tickIntervalMs);
  };

  RuntimeSimulator.prototype.start = function(timeFactor) {
    var intervalMs, runTick;
    if (timeFactor == null) {
      timeFactor = 1.0;
    }
    intervalMs = 100;
    runTick = (function(_this) {
      return function() {
        var t;
        t = intervalMs * timeFactor;
        return _this.runTick(t);
      };
    })(this);
    return this.tickInterval = setInterval(runTick, intervalMs);
  };

  RuntimeSimulator.prototype.stop = function() {
    return clearInterval(this.tickInterval);
  };

  return RuntimeSimulator;

})(runtime.Runtime);

exports.RuntimeSimulator = RuntimeSimulator;

});
require.register("microflo-microflo/lib/util.js", function(exports, require, module){
var Buffer, EventEmitter, arrayBufferToBuffer, arrayBufferToString, bufferToArrayBuffer, contains, e, error, inherits, isBrowser, stringToArrayBuffer;

exports.isBrowser = isBrowser = function() {
  return !(typeof process !== "undefined" && process.execPath && process.execPath.indexOf("node") !== -1);
};

Buffer = require("buffer").Buffer;

try {
  EventEmitter = require('emitter');
} catch (error) {
  e = error;
  EventEmitter = require("events").EventEmitter;
}

exports.EventEmitter = EventEmitter;

contains = function(str, substr) {
  return (str != null) && str.indexOf(substr) !== -1;
};

exports.debug_protocol = false;

if (!isBrowser()) {
  exports.debug_protocol = contains(process.env.MICROFLO_DEBUG, 'protocol');
}

if (typeof Object.create === "function") {
  inherits = function(ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  inherits = function(ctor, superCtor) {
    var TempCtor;
    ctor.super_ = superCtor;
    TempCtor = function() {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  };
}

arrayBufferToString = function(buffer) {
  var array, i, str;
  array = new Uint8Array(buffer);
  str = "";
  i = 0;
  while (i < array.length) {
    str += String.fromCharCode(array[i]);
    ++i;
  }
  return str;
};

stringToArrayBuffer = function(string) {
  var buffer, bufferView, i;
  buffer = new ArrayBuffer(string.length);
  bufferView = new Uint8Array(buffer);
  i = 0;
  while (i < string.length) {
    bufferView[i] = string.charCodeAt(i);
    i++;
  }
  return buffer;
};

bufferToArrayBuffer = function(buffer) {
  var arrayBuffer, arrayBufferView, i;
  arrayBuffer = new ArrayBuffer(buffer.length);
  arrayBufferView = new Uint8Array(arrayBuffer);
  i = 0;
  while (i < buffer.length) {
    arrayBufferView[i] = buffer[i];
    i++;
  }
  return arrayBuffer;
};

arrayBufferToBuffer = function(arrayBuffer) {
  var buffer, i, view;
  view = new Uint8Array(arrayBuffer);
  buffer = new Buffer(view.length);
  i = 0;
  while (i < view.length) {
    buffer[i] = view[i];
    i++;
  }
  return buffer;
};

exports.Buffer = Buffer;

if (exports.isBrowser()) {
  exports.inherits = inherits;
  exports.stringToArrayBuffer = stringToArrayBuffer;
  exports.arrayBufferToString = arrayBufferToString;
  exports.arrayBufferToBuffer = arrayBufferToBuffer;
  exports.bufferToArrayBuffer = bufferToArrayBuffer;
} else {
  exports.inherits = require("util").inherits;
}

});
require.register("microflo-microflo/lib/devicecommunication.js", function(exports, require, module){
var CommandAccumulator, DeviceCommunication, DeviceCommunicationError, DeviceTransport, EventEmitter, RemoteIo, SendQueue, commandstream, contains, debug_comms, debug_send, keyFromId, util,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

commandstream = require('./commandstream');

util = require('./util');

EventEmitter = util.EventEmitter;

contains = function(str, substr) {
  return (str != null) && str.indexOf(substr) !== -1;
};

debug_comms = false;

if (!util.isBrowser()) {
  debug_comms = contains(process.env.MICROFLO_DEBUG, 'communication');
  debug_send = contains(process.env.MICROFLO_DEBUG, 'sending');
}

DeviceCommunicationError = (function(superClass) {
  extend(DeviceCommunicationError, superClass);

  function DeviceCommunicationError() {
    return DeviceCommunicationError.__super__.constructor.apply(this, arguments);
  }

  return DeviceCommunicationError;

})(Error);

DeviceTransport = (function(superClass) {
  extend(DeviceTransport, superClass);

  function DeviceTransport() {
    return DeviceTransport.__super__.constructor.apply(this, arguments);
  }

  DeviceTransport.prototype.getTransportType = function() {
    throw new DeviceCommunicationError('getTransportType() not implemented');
  };

  DeviceTransport.prototype.write = function(buffer, callback) {
    throw new DeviceCommunicationError('write() not implemented');
  };

  return DeviceTransport;

})(EventEmitter);

CommandAccumulator = (function(superClass) {
  extend(CommandAccumulator, superClass);

  function CommandAccumulator(commandSize) {
    this.commandSize = commandSize;
    this.buffer = new commandstream.Buffer(commandstream.cmdFormat.commandSize * 100);
    this.offset = 0;
  }

  CommandAccumulator.prototype.onData = function(da) {
    var b, j, maxIdx, ref, ref1, slush, startIdx;
    da.copy(this.buffer, this.offset, 0, da.length);
    this.offset += da.length;
    if (this.offset > this.buffer.length) {
      this.emit('error', new DeviceCommunicationError('Receive buffer overflow'));
    }
    maxIdx = (Math.floor(this.offset / this.commandSize)) * this.commandSize;
    for (startIdx = j = 0, ref = maxIdx, ref1 = this.commandSize; ref1 > 0 ? j < ref : j > ref; startIdx = j += ref1) {
      b = this.buffer.slice(startIdx, startIdx + this.commandSize);
      this.emit('command', b);
    }
    slush = this.offset % this.commandSize;
    this.buffer.copy(this.buffer, 0, this.offset - slush, this.offset);
    return this.offset = slush;
  };

  return CommandAccumulator;

})(EventEmitter);

SendQueue = (function(superClass) {
  extend(SendQueue, superClass);

  function SendQueue(commandSize, options) {
    this.commandSize = commandSize;
    this.queue = [];
    this.current = null;
    this.sending = false;
    this.bytesPerSec = 0;
    this.speedo = setInterval((function(_this) {
      return function() {
        return _this.checkBytes();
      };
    })(this), 1000);
    this.previousRun = Date.now();
    this.roundTrips = 0;
    this.latestRoundTrip = null;
    this.roundTripTotal = 0;
    this.options = options || {};
    if (!this.options.wait) {
      this.options.wait = 0;
    }
  }

  SendQueue.prototype.checkBytes = function() {
    var elapsed, perSec;
    if (!this.bytesPerSec) {
      this.previousRun = Date.now();
      return;
    }
    elapsed = (Date.now() - this.previousRun) / 1000;
    if (!elapsed) {
      return;
    }
    perSec = Math.ceil(this.bytesPerSec / elapsed);
    if (debug_send) {
      console.log("MICROFLO " + this.options.type + ": buffered " + this.bytesPerSec + " at " + perSec + "/sec. Time elapsed: " + (Math.ceil(elapsed)) + "s. " + this.queue.length + " commands in buffer");
    }
    this.bytesPerSec = 0;
    this.previousRun = Date.now();
    if (!this.roundTrips) {
      return;
    }
    if (debug_send) {
      return console.log("MICROFLO " + this.options.type + ": made " + this.roundTrips + " round-trips at average " + (Math.ceil(this.roundTripTotal / this.roundTrips)) + "ms each. Latest took " + (Math.ceil(this.latestRoundTrip)) + "ms");
    }
  };

  SendQueue.prototype.write = function(chunk, callback) {
    throw new Error('SendQueue.write must be implemented by consumer');
  };

  SendQueue.prototype.push = function(buffer, callback) {
    if (debug_comms) {
      console.log('queuing buf', buffer, this.queue.length, buffer.length, this.sending);
    }
    this.bytesPerSec += buffer.length;
    this.queue.push({
      data: buffer,
      callback: callback,
      responses: 0
    });
    if (this.sending) {
      return;
    }
    this.sending = true;
    return this.next();
  };

  SendQueue.prototype.next = function() {
    var chunkSize, sendCmd;
    if (!this.queue.length) {
      this.sending = false;
      return;
    }
    this.current = this.queue.shift();
    chunkSize = commandstream.cmdFormat.commandSize;
    sendCmd = (function(_this) {
      return function(dataBuf, index) {
        var chunk;
        chunk = dataBuf.slice(index, index + chunkSize);
        if (!chunk.length) {
          return;
        }
        _this.current.sent = Date.now();
        return _this.write(chunk, function(err, len) {
          var errored;
          errored = err || len === -1;
          if (!errored && chunk.length && index < dataBuf.length) {
            if (debug_comms) {
              console.log('MICROFLO SEND:', chunkSize, chunk, err, len, errored);
            }
            return sendCmd(dataBuf, index += chunkSize);
          }
        });
      };
    })(this);
    if (this.current != null) {
      return sendCmd(this.current.data, 0);
    }
  };

  SendQueue.prototype.onResponse = function(type) {
    var elapsed, numberOfCommands;
    if (!this.sending) {
      return;
    }
    if (type === 'IOCHANGE' || type === 'DEBUG' || type === 'UNKNOWN' || type === 'SEND') {
      return;
    }
    numberOfCommands = this.current.data.length / commandstream.cmdFormat.commandSize;
    this.current.responses++;
    if (this.current.responses === numberOfCommands) {
      this.current.callback(null);
      elapsed = Date.now() - this.current.sent;
      this.roundTrips++;
      this.roundTripTotal += elapsed;
      this.latestRoundTrip = elapsed;
      this.current = null;
      return this.next();
    }
  };

  return SendQueue;

})(EventEmitter);

DeviceCommunication = (function(superClass) {
  extend(DeviceCommunication, superClass);

  function DeviceCommunication(transport, graph, componentLib) {
    this.graph = graph;
    this.transport = transport;
    this.componentLib = componentLib;
    this.accumulator = new CommandAccumulator(commandstream.cmdFormat.commandSize);
    if (!this.transport) {
      return;
    }
    this.sender = new SendQueue(commandstream.cmdFormat.commandSize, {
      type: this.transport.getTransportType()
    });
    this.transport.on('data', (function(_this) {
      return function(buf) {
        return _this.accumulator.onData(buf);
      };
    })(this));
    this.accumulator.on('command', (function(_this) {
      return function(buf) {
        return _this._onCommandReceived(buf);
      };
    })(this));
    this.sender.write = (function(_this) {
      return function(chunk, cb) {
        return _this.transport.write(chunk, cb);
      };
    })(this);
  }

  DeviceCommunication.prototype.open = function(cb) {
    var buffer;
    buffer = commandstream.Buffer(commandstream.cmdFormat.commandSize);
    commandstream.writeString(buffer, 0, commandstream.cmdFormat.magicString);
    return this.sendCommands(buffer, cb);
  };

  DeviceCommunication.prototype.close = function(cb) {
    var buffer;
    buffer = commandstream.Buffer(commandstream.cmdFormat.commandSize);
    commandstream.writeCmd(buffer, 0, commandstream.cmdFormat.commands.End.id);
    return this.sendCommands(buffer, cb);
  };

  DeviceCommunication.prototype.ping = function(cb) {
    var buffer;
    buffer = commandstream.Buffer(commandstream.cmdFormat.commandSize);
    commandstream.writeCmd(buffer, 0, commandstream.cmdFormat.commands.Ping.id);
    return this.sendCommands(buffer, cb);
  };

  DeviceCommunication.prototype.addNode = function(node, component, cb) {};

  DeviceCommunication.prototype.removeNode = function(node, cb) {};

  DeviceCommunication.prototype.addEdge = function(srcNode, srcPort, tgtNode, tgtPort, cb) {};

  DeviceCommunication.prototype.removeEdge = function(srcNode, srcPort, tgtNode, tgtPort, cb) {};

  DeviceCommunication.prototype.addInitial = function(tgtNode, tgtPort, data, cb) {};

  DeviceCommunication.prototype.removeInitial = function(tgtNode, tgtPort, cb) {};

  DeviceCommunication.prototype.startNetwork = function(cb) {};

  DeviceCommunication.prototype.stopNetwork = function(cb) {};

  DeviceCommunication.prototype.subscribePort = function() {};

  DeviceCommunication.prototype.configureDebug = function() {};

  DeviceCommunication.prototype.sendCommands = function(buffer, callback) {
    return this.sender.push(buffer, callback);
  };

  DeviceCommunication.prototype._onCommandReceived = function(buf) {
    var err, error, out;
    try {
      return commandstream.parseReceivedCmd(this.componentLib, this.graph, buf, (function(_this) {
        return function() {
          if (debug_comms) {
            console.log('MICROFLO RECV:', buf.length, buf, Array.prototype.slice.call(arguments));
          }
          return _this._handleCommandReceived.apply(_this, arguments);
        };
      })(this));
    } catch (error) {
      err = error;
      out = 'ERROR';
      if (debug_comms) {
        console.log('MICROFLO RECV ERROR:', buf.length, buf, out);
      }
      return this._handleCommandReceived(out, err.message);
    }
  };

  DeviceCommunication.prototype._handleCommandReceived = function(type) {
    var args, i, j, ref;
    this.sender.onResponse(type);
    this.emit.apply(this, arguments);
    args = new Array(arguments.length);
    for (i = j = 0, ref = arguments.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      args[i] = arguments[i];
    }
    args.unshift('response');
    return this.emit.apply(this, args);
  };

  return DeviceCommunication;

})(EventEmitter);

keyFromId = function(map, wantedId) {
  var id, name, val;
  for (name in map) {
    val = map[name];
    id = val.id != null ? val.id : val;
    if (id === wantedId) {
      return name;
    }
  }
};

RemoteIo = (function(superClass) {
  extend(RemoteIo, superClass);

  function RemoteIo(comm) {
    this.comm = comm;
    this.latestState = {
      digitalOutputs: [],
      timeMs: 0
    };
    this.comm.on('IOCHANGE', (function(_this) {
      return function(buf) {
        return _this.onIoChange(buf);
      };
    })(this));
  }

  RemoteIo.prototype.onIoChange = function(buf) {
    var pin, type, val;
    type = keyFromId(commandstream.cmdFormat.ioTypes, buf.readUInt8(1));
    if (type === 'Digital') {
      pin = buf.readUInt8(2);
      val = (buf.readUInt8(3)) !== 0;
      this.latestState.digitalOutputs[pin] = val;
      this.emit('digital', this.latestState.digitalOutputs);
    }
    return this.emit('change', this.latestState);
  };

  RemoteIo.prototype.forwardTime = function(increment, cb) {
    var buffer, c, newTime;
    c = commandstream.cmdFormat;
    buffer = commandstream.Buffer(c.commandSize);
    commandstream.writeCmd(buffer, 0, c.commands.SetIoValue.id, c.ioTypes.TimeMs.id);
    newTime = this.latestState.timeMs + increment;
    buffer.writeInt32LE(newTime, 2);
    this.latestState.timeMs = newTime;
    return this.comm.sendCommands(buffer, cb);
  };

  return RemoteIo;

})(EventEmitter);

exports.DeviceTransport = DeviceTransport;

exports.DeviceCommunication = DeviceCommunication;

exports.RemoteIo = RemoteIo;

exports.DeviceCommunicationError = DeviceCommunicationError;

});
require.register("microflo-microflo/lib/flash.js", function(exports, require, module){
var SerialPort, avrUploadHexFile, avrUploader, fs, hexToBin, pageBytes;

SerialPort = require('serialport').SerialPort;

fs = require('fs');

pageBytes = 128;

avrUploader = function(bytes, tty, baudrate, cb) {
  var done, next, offset, reply, serial, state, states, timer;
  serial = new SerialPort(tty, {
    baudrate: baudrate
  });
  done = function(err) {
    return serial.close(function() {
      return cb(err);
    });
  };
  timer = null;
  state = offset = 0;
  reply = '';
  states = [
    function() {
      return ['0 '];
    }, function() {
      var buf;
      buf = new Buffer(20);
      buf.fill(0);
      buf.writeInt16BE(pageBytes, 12);
      return ['B', buf, ' '];
    }, function() {
      return ['P '];
    }, function() {
      var buf;
      if (offset >= bytes.length) {
        state += 1;
      }
      buf = new Buffer(2);
      buf.writeInt16LE(offset >> 1, 0);
      return ['U', buf, ' '];
    }, function() {
      var buf, count, pos;
      state -= 2;
      count = Math.min(bytes.length - offset, pageBytes);
      buf = new Buffer(2);
      buf.writeInt16BE(count, 0);
      pos = offset;
      offset += count;
      return ['d', buf, 'F', bytes.slice(pos, offset), ' '];
    }, function() {
      return ['Q '];
    }
  ];
  next = function() {
    var i, len, ref, x;
    if (state < states.length) {
      ref = states[state++]();
      for (i = 0, len = ref.length; i < len; i++) {
        x = ref[i];
        serial.write(x);
      }
      serial.flush();
      reply = '';
      return timer = setTimeout((function() {
        return done(state);
      }), 300);
    } else {
      return done();
    }
  };
  serial.on('open', next);
  serial.on('error', done);
  return serial.on('data', function(data) {
    reply += data;
    if (reply.slice(-2) === '\x14\x10') {
      clearTimeout(timer);
      return next();
    }
  });
};

hexToBin = function(code) {
  var count, data, i, len, line, ref;
  data = '';
  ref = code.split('\n');
  for (i = 0, len = ref.length; i < len; i++) {
    line = ref[i];
    count = parseInt(line.slice(1, 3), 16);
    if (count && line.slice(7, 9) === '00') {
      data += line.slice(9, 9 + 2 * count);
    }
  }
  return new Buffer(data, 'hex');
};

avrUploadHexFile = function(filename, tty, baud, callback) {
  return fs.readFile(filename, 'ascii', function(err, hex) {
    var bin;
    bin = hexToBin(hex);
    console.log(hex);
    return avrUploader(bin, tty, baud, function(err) {
      return callback(err, bin.length);
    });
  });
};

exports.avrUploader = avrUploader;

exports.avrUploadHexFile = avrUploadHexFile;

});
require.register("microflo-microflo/lib/definition.js", function(exports, require, module){
var declarec, fbp, fs, loadFile, loadString, path, trim, util;

util = require('./util');

fbp = require('fbp');

if (util.isBrowser()) {

} else {
  fs = require('fs');
  path = require('path');
  declarec = require('declarec');
}

trim = function(str) {
  return str.replace(/^\s+|\s+$/g, "");
};

loadString = function(data, type) {
  var def, raw;
  def = null;
  if (type === ".fbp") {
    def = fbp.parse(data);
  } else if (type === '.cpp' || type === '.c' || type === '.h' || type === '.hpp') {
    raw = declarec.extractDefinition(data, 'microflo_graph', 'c');
    if (raw.length !== 1) {
      return console.log('ERROR: only main graph supported when embedded in cpp');
    }
    if (raw[0].format === 'fbp') {
      def = loadString(raw[0].content, '.fbp');
    }
    if (raw[0].format === 'json') {
      def = loadString(raw[0].content, '.json');
    }
  } else {
    def = JSON.parse(data);
  }
  return def;
};

loadFile = function(filename, callback) {
  return fs.readFile(filename, {
    encoding: "utf8"
  }, function(err, data) {
    var def, type;
    console.log(filename);
    if (err) {
      return callback(err);
    }
    type = path.extname(filename);
    def = loadString(data, type);
    return callback(null, def);
  });
};

exports.loadFile = loadFile;

exports.loadString = loadString;

});
require.register("microflo-microflo/lib/runtime.js", function(exports, require, module){
var EventEmitter, Runtime, c, cmdFormat, commandstream, connectionsWithoutEdge, createFlowhubRuntime, definition, deviceResponseToFbpProtocol, devicecommunication, e, error, flowhub, generate, handleComponentCommand, handleGraphCommand, handleMessage, handleNetworkCommand, handleNetworkEdges, handleNetworkStartStop, handleRuntimeCommand, http, listComponents, portDefAsArray, printReceived, registerFlowhubRuntime, sendAck, sendExportedPorts, sendPacket, sendPacketCmd, sendPackets, serial, setupFlowhubRuntimePing, setupRuntime, setupSimulator, setupWebsocket, subscribeEdges, uploadGraphFromFile, url, util, uuid, websocket, wsConnectionFormatToFbp,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

util = require("./util");

if (util.isBrowser()) {
  http = window.http;
  uuid = window.uuid;
} else {
  http = require("http");
  websocket = require("websocket");
  url = require("url");
  uuid = require("node-uuid");
}

EventEmitter = util.EventEmitter;

try {
  flowhub = require("flowhub-registry");
} catch (error) {
  e = error;
}

commandstream = require("./commandstream");

generate = require("./generate");

c = require("./componentlib");

cmdFormat = require("./commandformat");

serial = require("./serial");

devicecommunication = require("./devicecommunication");

definition = require('./definition');

portDefAsArray = function(port) {
  var a, name;
  a = [];
  for (name in port) {
    a.push({
      id: name,
      type: "all"
    });
  }
  return a;
};

connectionsWithoutEdge = function(connections, findConn) {
  var edgeEq, newList;
  edgeEq = function(a, b) {
    return JSON.stringify(a === JSON.stringify(b));
  };
  newList = [];
  connections.forEach(function(conn) {
    if (conn.src && edgeEq(conn.src, findConn.src && edgeEq(conn.tgt, findConn.tgt))) {

    } else if (conn.data && edgeEq(conn.tgt, findConn.tgt)) {

    } else {
      return newList.push(conn);
    }
  });
  return newList;
};

wsConnectionFormatToFbp = function(ws) {
  var out;
  if (ws.src && ws.src.port) {
    return {
      src: {
        port: ws.src.port,
        process: ws.src.node
      },
      tgt: {
        port: ws.tgt.port,
        process: ws.tgt.node
      }
    };
  } else {
    out = {};
    out.tgt = {
      port: ws.tgt.port,
      process: ws.tgt.node
    };
    if (ws.src) {
      out.data = ws.src.data;
    }
    return out;
  }
};

printReceived = function() {
  var args, i;
  args = [];
  i = 0;
  while (i < arguments.length) {
    args.push(arguments[i]);
    i++;
  }
  console.log(args.join(", "));
};

listComponents = function(runtime, connection) {
  var comp, componentLib, name, resp;
  componentLib = runtime.library;
  for (name in componentLib.getComponents()) {
    comp = componentLib.getComponent(name);
    resp = {
      protocol: "component",
      command: "component",
      payload: {
        name: name,
        description: comp.description || "",
        inPorts: portDefAsArray(componentLib.inputPortsFor(name)),
        outPorts: portDefAsArray(componentLib.outputPortsFor(name))
      }
    };
    connection.send(resp);
  }
};

sendExportedPorts = function(connection, runtime) {
  var port, ports, pub, ref, ref1;
  ports = {
    inPorts: [],
    outPorts: []
  };
  ref = runtime.graph.inports;
  for (pub in ref) {
    port = ref[pub];
    ports.inPorts.push({
      id: pub,
      type: 'any',
      addressable: false,
      required: false
    });
  }
  ref1 = runtime.graph.outports;
  for (pub in ref1) {
    port = ref1[pub];
    ports.outPorts.push({
      id: pub,
      type: 'any',
      addressable: false,
      required: false
    });
  }
  return connection.send({
    protocol: 'runtime',
    command: 'ports',
    payload: ports
  });
};

sendPacketCmd = function(runtime, port, event, payload) {
  var buffer, componentName, internal, nodeId, portId;
  if (event === !'data') {
    return console.log("WARN: sendPacket, unknown event " + event);
  }
  if (runtime.uploadInProgress) {
    return console.log('WARN: ignoring sendPacket during graph upload');
  }
  internal = runtime.graph.inports[port];
  componentName = runtime.graph.processes[internal.process].component;
  nodeId = runtime.graph.nodeMap[internal.process].id;
  portId = runtime.library.inputPort(componentName, internal.port).id;
  return buffer = commandstream.dataToCommand(payload, nodeId, portId);
};

sendPacket = function(runtime, port, event, payload) {
  var buffer;
  buffer = sendPacketCmd(runtime, port, event, payload);
  return runtime.device.sendCommands(buffer, function() {});
};

sendPackets = function(runtime, mapping, callback) {
  var buffer, buffers, port, val;
  buffers = [];
  for (port in mapping) {
    val = mapping[port];
    buffers.push(sendPacketCmd(runtime, port, 'data', val));
  }
  buffer = commandstream.Buffer.concat(buffers);
  return runtime.device.sendCommands(buffer, callback);
};

handleRuntimeCommand = function(command, payload, connection, runtime) {
  var caps, r;
  if (command === "getruntime") {
    caps = ["protocol:graph", "protocol:network", "protocol:component", "protocol:runtime"];
    r = {
      type: "microflo",
      version: "0.4",
      capabilities: caps
    };
    connection.send({
      protocol: "runtime",
      command: "runtime",
      payload: r
    });
    sendExportedPorts(connection, runtime);
  } else if (command === 'packet') {
    sendPacket(runtime, payload.port, payload.event, payload.payload);
  } else {
    console.log("Unknown NoFlo UI command on 'runtime' protocol:", command, payload);
  }
};

handleComponentCommand = function(command, payload, connection, runtime) {
  if (command === "list") {
    listComponents(runtime, connection);
  } else if (command === "getsource") {
    runtime.library.getComponentSource(payload.name, function(err, source) {
      var r;
      r = {
        name: payload.name,
        language: "c++",
        code: source
      };
      connection.send({
        protocol: "component",
        command: "source",
        payload: r
      });
    });
  } else {
    console.log("Unknown NoFlo UI command on 'component' protocol:", command, payload);
  }
};

sendAck = function(connection, msg) {
  return connection.send(msg);
};

handleGraphCommand = function(command, payload, connection, runtime) {
  var graph, node;
  graph = runtime.graph;
  if (command === "clear") {
    graph.processes = {};
    graph.connections = [];
    graph.name = payload.name || '';
    graph.nodeMap = {};
    runtime.exportedEdges = [];
    runtime.edgesForInspection = [];
    sendAck(connection, {
      protocol: 'graph',
      command: command,
      payload: payload
    });
  } else if (command === "addnode") {
    graph.processes[payload.id] = payload;
    sendAck(connection, {
      protocol: 'graph',
      command: command,
      payload: payload
    });
  } else if (command === "removenode") {
    delete graph.processes[payload.id];
    sendAck(connection, {
      protocol: 'graph',
      command: command,
      payload: payload
    });
  } else if (command === "renamenode") {
    node = graph.processes[payload.from];
    graph.processes[payload.to] = node;
    sendAck(connection, {
      protocol: 'graph',
      command: command,
      payload: payload
    });
  } else if (command === "changenode") {
    sendAck(connection, {
      protocol: 'graph',
      command: command,
      payload: payload
    });
  } else if (command === "addedge") {
    graph.connections.push(wsConnectionFormatToFbp(payload));
    sendAck(connection, {
      protocol: 'graph',
      command: command,
      payload: payload
    });
  } else if (command === "removeedge") {
    graph.connections = connectionsWithoutEdge(graph.connections, wsConnectionFormatToFbp(payload));
    sendAck(connection, {
      protocol: 'graph',
      command: command,
      payload: payload
    });
  } else if (command === "addinitial") {
    graph.connections.push(wsConnectionFormatToFbp(payload));
    sendAck(connection, {
      protocol: 'graph',
      command: command,
      payload: payload
    });
  } else if (command === "removeinitial") {
    graph.connections = connectionsWithoutEdge(graph.connections, wsConnectionFormatToFbp(payload));
    sendAck(connection, {
      protocol: 'graph',
      command: command,
      payload: payload
    });
  } else if (command === "addinport") {
    if (graph.inports == null) {
      graph.inports = {};
    }
    graph.inports[payload["public"]] = {
      process: payload.node,
      port: payload.port
    };
    sendExportedPorts(connection, runtime);
  } else if (command === "removeinport") {
    delete graph.inports[payload["public"]];
    sendExportedPorts(connection, runtime);
  } else if (command === "addoutport") {
    if (graph.outports == null) {
      graph.outports = {};
    }
    graph.outports[payload["public"]] = {
      process: payload.node,
      port: payload.port
    };
    sendExportedPorts(connection, runtime);
    runtime.exportedEdges.push({
      src: {
        process: payload.node,
        port: payload.port
      }
    });
  } else if (command === "removeoutport") {
    delete graph.outports[payload["public"]];
    sendExportedPorts(connection, runtime);
  } else {
    console.log("Unknown NoFlo UI command on protocol 'graph':", command, payload);
  }
};

deviceResponseToFbpProtocol = function(runtime, send, args) {
  var data, found, internal, m, match, msg, pub, ref, src, string, tgt;
  if (args[0] === "SEND") {
    data = undefined;
    if (args[3] === "Void") {
      data = "!";
    } else {
      data = args[4];
    }
    src = {
      node: args[1],
      port: args[2]
    };
    tgt = {
      node: args[5],
      port: args[6]
    };
    send({
      protocol: "network",
      command: "data",
      payload: {
        src: src,
        tgt: tgt,
        data: data
      }
    });
    if (runtime.graph.outports) {
      found = null;
      ref = runtime.graph.outports;
      for (pub in ref) {
        internal = ref[pub];
        match = internal.process === src.node && internal.port === src.port;
        if (match) {
          found = pub;
        }
      }
      m = {
        protocol: "runtime",
        command: "packet",
        payload: {
          port: found,
          event: 'data',
          payload: data,
          index: null
        }
      };
      if (found) {
        return send(m);
      }
    }
  } else if (args[0] === "NETSTOP") {
    m = {
      protocol: "network",
      command: "stopped",
      payload: {
        running: false,
        started: false
      }
    };
    return send(m);
  } else if (args[0] === "NETSTART") {
    m = {
      protocol: "network",
      command: "started",
      payload: {
        running: true,
        started: true
      }
    };
    return send(m);
  } else {
    string = args.join(", ");
    string = string.replace(/\n$/, "");
    return msg = {
      protocol: "network",
      command: "output",
      payload: {
        message: string
      }
    };
  }
};

handleNetworkStartStop = function(runtime, connection, transport, debugLevel) {
  var data, graph, send;
  graph = runtime.graph;
  if (runtime.uploadInProgress) {
    console.log('Ignoring multiple attempts of graph upload');
    return;
  }
  runtime.uploadInProgress = true;
  data = commandstream.cmdStreamFromGraph(runtime.library, graph, debugLevel);
  send = function() {
    return runtime.device.sendCommands(data, function(err) {
      var edges;
      edges = runtime.exportedEdges.concat(runtime.edgesForInspection);
      return handleNetworkEdges(runtime, connection, edges, function(err) {
        return runtime.uploadInProgress = false;
      });
    });
  };
  return setTimeout(function() {
    return runtime.device.open(function() {
      return send();
    });
  }, 2000);
};

subscribeEdges = function(runtime, edges, callback) {
  var buffer, graph, maxCommands, offset, sendBuf;
  graph = runtime.graph;
  maxCommands = graph.connections.length + edges.length;
  buffer = new commandstream.Buffer(8 * maxCommands);
  offset = 0;
  graph.connections.forEach(function(edge) {
    var srcComp, srcId, srcPort;
    if (edge.src) {
      srcId = graph.nodeMap[edge.src.process].id;
      srcComp = graph.processes[edge.src.process].component;
      srcPort = runtime.library.outputPort(srcComp, edge.src.port).id;
      offset += commandstream.writeCmd(buffer, offset, cmdFormat.commands.SubscribeToPort.id, srcId, srcPort, 0);
    }
  });
  edges.forEach(function(edge) {
    var srcComp, srcId, srcPort;
    srcId = graph.nodeMap[edge.src.process].id;
    srcComp = graph.processes[edge.src.process].component;
    srcPort = runtime.library.outputPort(srcComp, edge.src.port).id;
    offset += commandstream.writeCmd(buffer, offset, cmdFormat.commands.SubscribeToPort.id, srcId, srcPort, 1);
  });
  sendBuf = buffer.slice(0, offset);
  if (sendBuf.length) {
    return runtime.device.sendCommands(sendBuf, callback);
  } else {
    return callback(null);
  }
};

handleNetworkEdges = function(runtime, connection, edges, callback) {
  return subscribeEdges(runtime, edges, callback);
};

handleNetworkCommand = function(command, payload, connection, runtime, transport, debugLevel) {
  var edges;
  if (command === "start" || command === "stop") {
    handleNetworkStartStop(runtime, connection, debugLevel);
  } else if (command === "edges") {
    runtime.edgesForInspection = payload.edges;
    edges = runtime.edgesForInspection.concat(runtime.exportedEdges);
    handleNetworkEdges(runtime, connection, edges);
    sendAck(connection, {
      protocol: 'network',
      command: command,
      payload: payload
    });
  } else {
    console.log("Unknown NoFlo UI command on protocol 'network':", command, payload);
  }
};

handleMessage = function(runtime, contents) {
  var connection;
  connection = runtime.conn;
  if (contents.protocol === "component") {
    handleComponentCommand(contents.command, contents.payload, connection, runtime);
  } else if (contents.protocol === "graph") {
    handleGraphCommand(contents.command, contents.payload, connection, runtime);
  } else if (contents.protocol === "runtime") {
    handleRuntimeCommand(contents.command, contents.payload, connection, runtime);
  } else if (contents.protocol === "network") {
    handleNetworkCommand(contents.command, contents.payload, connection, runtime);
  } else {
    console.log("Unknown NoFlo UI protocol:", contents);
  }
};

createFlowhubRuntime = function(user, ip, port, label, id, apihost) {
  var regoptions, rt, rtinfo;
  if (!flowhub) {
    return null;
  }
  id = id || uuid.v4();
  label = label || "MicroFlo";
  rtinfo = {
    label: label,
    id: id,
    user: user,
    protocol: "websocket",
    type: "microflo",
    secret: "19osdf3034s"
  };
  if (ip !== "auto") {
    rtinfo.address = "ws://" + ip + ":" + port;
  } else {
    rtinfo.address = "auto";
  }
  regoptions = {};
  if (typeof apihost !== "undefined") {
    regoptions.host = apihost;
  }
  rt = new flowhub.Runtime(rtinfo, regoptions);
  return rt;
};

setupFlowhubRuntimePing = function(rt) {
  var rtPingInterval;
  if (!rt) {
    return;
  }
  rtPingInterval = setInterval(function() {
    return rt.ping(function(err) {
      if (err) {
        return console.log("Warning: failed to ping Flowhub registry");
      }
    });
  }, 5 * 60 * 1000);
  return rtPingInterval;
};

registerFlowhubRuntime = function(rt, callback) {
  if (!rt) {
    return;
  }
  rt.register(callback);
};

setupWebsocket = function(runtime, ip, port, callback) {
  var httpServer, wsServer;
  httpServer = http.createServer(function(request, response) {
    var path;
    path = url.parse(request.url).pathname;
    if (path === "/") {
      response.writeHead(200, {
        "Content-Type": "text/plain"
      });
      response.write("NoFlo UI WebSocket API at: " + "ws://" + request.headers.host);
    } else {
      response.writeHead(404);
    }
    return response.end();
  });
  wsServer = new websocket.server({
    httpServer: httpServer
  });
  wsServer.on("request", function(request) {
    var connection, subProtocol;
    subProtocol = (request.requestedProtocols.indexOf("noflo") !== -1 ? "noflo" : null);
    connection = request.accept(subProtocol, request.origin);
    runtime.on('message', function(response) {
      return connection.sendUTF(JSON.stringify(response));
    });
    return connection.on("message", function(message) {
      var contents, error1;
      if (message.type === !"utf8") {
        return;
      }
      try {
        contents = JSON.parse(message.utf8Data);
      } catch (error1) {
        e = error1;
        console.log("WS parser error: ", e);
      }
      return runtime.handleMessage(contents);
    });
  });
  return httpServer.listen(port, ip, function(err) {
    if (err) {
      return callback(err, null);
    }
    console.log("MicroFlo runtime listening at", ip + ":" + port);
    return callback(null, httpServer);
  });
};

setupRuntime = function(serialPortToUse, baudRate, port, debugLevel, ip, callback) {
  return serial.openTransport(serialPortToUse, baudRate, function(err, transport) {
    var runtime;
    if (err) {
      return callback(err, null);
    }
    runtime = new Runtime(transport);
    return setupWebsocket(runtime, ip, port, function(err, server) {
      return callback(null, runtime);
    });
  });
};

setupSimulator = function(file, baudRate, port, debugLevel, ip, callback) {
  var build, error1, libraryPath, runtime, simulator;
  simulator = require('./simulator');
  build = require(file);
  runtime = new simulator.RuntimeSimulator(build);
  runtime.start(1.0);
  libraryPath = file.replace('microflo-runtime.js', 'componentlib-map.json');
  try {
    runtime.library.definition = require(libraryPath);
  } catch (error1) {
    e = error1;
    console.log('WARN: could not load simulator lib', e);
  }
  return runtime.device.open(function(err) {
    return setupWebsocket(runtime, ip, port, function(err, server) {
      return callback(null, runtime);
    });
  });
};

uploadGraphFromFile = function(graphPath, serialPortName, baudRate, debugLevel) {
  return serial.openTransport(serialPortName, baudRate, function(err, transport) {
    return definition.loadFile(graphPath, function(err, graph) {
      var data;
      data = commandstream.cmdStreamFromGraph(runtime.library, graph, debugLevel);
      return uploadGraph(transport, data, graph);
    });
  });
};

Runtime = (function(superClass) {
  extend(Runtime, superClass);

  function Runtime(transport, options) {
    var bracketed, received;
    this.graph = {};
    this.transport = transport;
    this.debugLevel = (options != null ? options.debug : void 0) || 'Error';
    this.library = new c.ComponentLibrary;
    this.device = new devicecommunication.DeviceCommunication(this.transport, this.graph, this.library);
    this.io = new devicecommunication.RemoteIo(this.device);
    this.conn = {
      send: (function(_this) {
        return function(response) {
          if (util.debug_protocol) {
            console.log('FBP MICROFLO SEND:', response);
          }
          return _this.emit('message', response);
        };
      })(this)
    };
    received = {};
    bracketed = null;
    this.device.on('response', (function(_this) {
      return function() {
        var args, data, event, node, port, type;
        args = Array.prototype.slice.call(arguments);
        event = args[0];
        if (event === 'SEND') {
          event = args[0], node = args[1], port = args[2], type = args[3], data = args[4];
          console.log(event, node, port, type, data);
          if ((bracketed != null) && type !== 'BracketEnd') {
            bracketed.push(data);
            return;
          }
          if (type === 'BracketStart') {
            bracketed = [];
            return;
          }
          if (type === 'BracketEnd') {
            data = bracketed.slice();
            bracketed = null;
          }
          args = [event, node, port, type, data];
          return deviceResponseToFbpProtocol(_this, _this.conn.send, args);
        } else {
          return deviceResponseToFbpProtocol(_this, _this.conn.send, args);
        }
      };
    })(this));
  }

  Runtime.prototype.handleMessage = function(msg) {
    if (util.debug_protocol) {
      console.log('FBP MICROFLO RECV:', msg);
    }
    return handleMessage(this, msg);
  };

  Runtime.prototype.uploadGraph = function(graph, callback) {
    var checkUploadDone, error1;
    this.graph = graph;
    this.device.graph = graph;
    checkUploadDone = (function(_this) {
      return function(m) {
        if (m.protocol === 'network' && m.command === 'started') {
          _this.removeListener('message', checkUploadDone);
          return callback();
        }
      };
    })(this);
    this.on('message', checkUploadDone);
    try {
      return this.handleMessage({
        protocol: 'network',
        command: 'start'
      });
    } catch (error1) {
      e = error1;
      return callback(e);
    }
  };

  Runtime.prototype.uploadFBP = function(prog, callback) {
    var error1, graph;
    try {
      graph = require('fbp').parse(prog);
    } catch (error1) {
      e = error1;
      return callback(e);
    }
    return this.uploadGraph(graph, callback);
  };

  return Runtime;

})(EventEmitter);

module.exports = {
  setupRuntime: setupRuntime,
  setupWebsocket: setupWebsocket,
  setupSimulator: setupSimulator,
  Runtime: Runtime,
  uploadGraphFromFile: uploadGraphFromFile,
  createFlowhubRuntime: createFlowhubRuntime,
  registerFlowhubRuntime: registerFlowhubRuntime
};

});
require.register("microflo-microflo-emscripten/microflo-runtime.js", function(exports, require, module){

var Module = {};
var isCommonJs = typeof module !== 'undefined' && typeof module.exports !== 'undefined';
if (isCommonJs) {
  module.exports = Module;
}

// The Module object: Our interface to the outside world. We import
// and export values on it, and do the work to get that through
// closure compiler if necessary. There are various ways Module can be used:
// 1. Not defined. We create it here
// 2. A function parameter, function(Module) { ..generated code.. }
// 3. pre-run appended it, var Module = {}; ..generated code..
// 4. External script tag defines var Module.
// We need to do an eval in order to handle the closure compiler
// case, where this code here is minified but Module was defined
// elsewhere (e.g. case 4 above). We also need to check if Module
// already exists (e.g. case 3 above).
// Note that if you want to run closure, and also to use Module
// after the generated code, you will need to define   var Module = {};
// before the code. Then that object will be used in the code, and you
// can continue to use Module afterwards as well.
var Module;
if (!Module) Module = (typeof Module !== 'undefined' ? Module : null) || {};

// Sometimes an existing Module object exists with properties
// meant to overwrite the default module functionality. Here
// we collect those properties and reapply _after_ we configure
// the current environment's defaults to avoid having to be so
// defensive during initialization.
var moduleOverrides = {};
for (var key in Module) {
  if (Module.hasOwnProperty(key)) {
    moduleOverrides[key] = Module[key];
  }
}

// The environment setup code below is customized to use Module.
// *** Environment setup code ***
var ENVIRONMENT_IS_NODE = typeof process === 'object' && typeof require === 'function';
var ENVIRONMENT_IS_WEB = typeof window === 'object';
var ENVIRONMENT_IS_WORKER = typeof importScripts === 'function';
var ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;

if (ENVIRONMENT_IS_NODE) {
  // Expose functionality in the same simple way that the shells work
  // Note that we pollute the global namespace here, otherwise we break in node
  if (!Module['print']) Module['print'] = function print(x) {
    process['stdout'].write(x + '\n');
  };
  if (!Module['printErr']) Module['printErr'] = function printErr(x) {
    process['stderr'].write(x + '\n');
  };

  var nodeFS = require('fs');
  var nodePath = require('path');

  Module['read'] = function read(filename, binary) {
    filename = nodePath['normalize'](filename);
    var ret = nodeFS['readFileSync'](filename);
    // The path is absolute if the normalized version is the same as the resolved.
    if (!ret && filename != nodePath['resolve'](filename)) {
      filename = path.join(__dirname, '..', 'src', filename);
      ret = nodeFS['readFileSync'](filename);
    }
    if (ret && !binary) ret = ret.toString();
    return ret;
  };

  Module['readBinary'] = function readBinary(filename) { return Module['read'](filename, true) };

  Module['load'] = function load(f) {
    globalEval(read(f));
  };

  if (process['argv'].length > 1) {
    Module['thisProgram'] = process['argv'][1].replace(/\\/g, '/');
  } else {
    Module['thisProgram'] = 'unknown-program';
  }

  Module['arguments'] = process['argv'].slice(2);

  if (typeof module !== 'undefined') {
    module['exports'] = Module;
  }

  process['on']('uncaughtException', function(ex) {
    // suppress ExitStatus exceptions from showing an error
    if (!(ex instanceof ExitStatus)) {
      throw ex;
    }
  });
}
else if (ENVIRONMENT_IS_SHELL) {
  if (!Module['print']) Module['print'] = print;
  if (typeof printErr != 'undefined') Module['printErr'] = printErr; // not present in v8 or older sm

  if (typeof read != 'undefined') {
    Module['read'] = read;
  } else {
    Module['read'] = function read() { throw 'no read() available (jsc?)' };
  }

  Module['readBinary'] = function readBinary(f) {
    if (typeof readbuffer === 'function') {
      return new Uint8Array(readbuffer(f));
    }
    var data = read(f, 'binary');
    assert(typeof data === 'object');
    return data;
  };

  if (typeof scriptArgs != 'undefined') {
    Module['arguments'] = scriptArgs;
  } else if (typeof arguments != 'undefined') {
    Module['arguments'] = arguments;
  }

}
else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
  Module['read'] = function read(url) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, false);
    xhr.send(null);
    return xhr.responseText;
  };

  if (typeof arguments != 'undefined') {
    Module['arguments'] = arguments;
  }

  if (typeof console !== 'undefined') {
    if (!Module['print']) Module['print'] = function print(x) {
      console.log(x);
    };
    if (!Module['printErr']) Module['printErr'] = function printErr(x) {
      console.log(x);
    };
  } else {
    // Probably a worker, and without console.log. We can do very little here...
    var TRY_USE_DUMP = false;
    if (!Module['print']) Module['print'] = (TRY_USE_DUMP && (typeof(dump) !== "undefined") ? (function(x) {
      dump(x);
    }) : (function(x) {
      // self.postMessage(x); // enable this if you want stdout to be sent as messages
    }));
  }

  if (ENVIRONMENT_IS_WORKER) {
    Module['load'] = importScripts;
  }

  if (typeof Module['setWindowTitle'] === 'undefined') {
    Module['setWindowTitle'] = function(title) { document.title = title };
  }
}
else {
  // Unreachable because SHELL is dependant on the others
  throw 'Unknown runtime environment. Where are we?';
}

function globalEval(x) {
  throw 'NO_DYNAMIC_EXECUTION was set, cannot eval';
}
if (!Module['load'] && Module['read']) {
  Module['load'] = function load(f) {
    globalEval(Module['read'](f));
  };
}
if (!Module['print']) {
  Module['print'] = function(){};
}
if (!Module['printErr']) {
  Module['printErr'] = Module['print'];
}
if (!Module['arguments']) {
  Module['arguments'] = [];
}
if (!Module['thisProgram']) {
  Module['thisProgram'] = './this.program';
}

// *** Environment setup code ***

// Closure helpers
Module.print = Module['print'];
Module.printErr = Module['printErr'];

// Callbacks
Module['preRun'] = [];
Module['postRun'] = [];

// Merge back in the overrides
for (var key in moduleOverrides) {
  if (moduleOverrides.hasOwnProperty(key)) {
    Module[key] = moduleOverrides[key];
  }
}



// === Preamble library stuff ===

// Documentation for the public APIs defined in this file must be updated in: 
//    site/source/docs/api_reference/preamble.js.rst
// A prebuilt local version of the documentation is available at: 
//    site/build/text/docs/api_reference/preamble.js.txt
// You can also build docs locally as HTML or other formats in site/
// An online HTML version (which may be of a different version of Emscripten)
//    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html

//========================================
// Runtime code shared with compiler
//========================================

var Runtime = {
  setTempRet0: function (value) {
    tempRet0 = value;
  },
  getTempRet0: function () {
    return tempRet0;
  },
  stackSave: function () {
    return STACKTOP;
  },
  stackRestore: function (stackTop) {
    STACKTOP = stackTop;
  },
  getNativeTypeSize: function (type) {
    switch (type) {
      case 'i1': case 'i8': return 1;
      case 'i16': return 2;
      case 'i32': return 4;
      case 'i64': return 8;
      case 'float': return 4;
      case 'double': return 8;
      default: {
        if (type[type.length-1] === '*') {
          return Runtime.QUANTUM_SIZE; // A pointer
        } else if (type[0] === 'i') {
          var bits = parseInt(type.substr(1));
          assert(bits % 8 === 0);
          return bits/8;
        } else {
          return 0;
        }
      }
    }
  },
  getNativeFieldSize: function (type) {
    return Math.max(Runtime.getNativeTypeSize(type), Runtime.QUANTUM_SIZE);
  },
  STACK_ALIGN: 16,
  getAlignSize: function (type, size, vararg) {
    // we align i64s and doubles on 64-bit boundaries, unlike x86
    if (!vararg && (type == 'i64' || type == 'double')) return 8;
    if (!type) return Math.min(size, 8); // align structures internally to 64 bits
    return Math.min(size || (type ? Runtime.getNativeFieldSize(type) : 0), Runtime.QUANTUM_SIZE);
  },
  dynCall: function (sig, ptr, args) {
    if (args && args.length) {
      assert(args.length == sig.length-1);
      if (!args.splice) args = Array.prototype.slice.call(args);
      args.splice(0, 0, ptr);
      assert(('dynCall_' + sig) in Module, 'bad function pointer type - no table for sig \'' + sig + '\'');
      return Module['dynCall_' + sig].apply(null, args);
    } else {
      assert(sig.length == 1);
      assert(('dynCall_' + sig) in Module, 'bad function pointer type - no table for sig \'' + sig + '\'');
      return Module['dynCall_' + sig].call(null, ptr);
    }
  },
  functionPointers: [null,null,null,null,null,null,null,null,null,null],
  addFunction: function (func) {
    for (var i = 0; i < Runtime.functionPointers.length; i++) {
      if (!Runtime.functionPointers[i]) {
        Runtime.functionPointers[i] = func;
        return 2*(1 + i);
      }
    }
    throw 'Finished up all reserved function pointers. Use a higher value for RESERVED_FUNCTION_POINTERS.';
  },
  removeFunction: function (index) {
    Runtime.functionPointers[(index-2)/2] = null;
  },
  getAsmConst: function (code, numArgs) {
    // code is a constant string on the heap, so we can cache these
    if (!Runtime.asmConstCache) Runtime.asmConstCache = {};
    var func = Runtime.asmConstCache[code];
    if (func) return func;
    var args = [];
    for (var i = 0; i < numArgs; i++) {
      args.push(String.fromCharCode(36) + i); // $0, $1 etc
    }
    var source = Pointer_stringify(code);
    if (source[0] === '"') {
      // tolerate EM_ASM("..code..") even though EM_ASM(..code..) is correct
      if (source.indexOf('"', 1) === source.length-1) {
        source = source.substr(1, source.length-2);
      } else {
        // something invalid happened, e.g. EM_ASM("..code($0)..", input)
        abort('invalid EM_ASM input |' + source + '|. Please use EM_ASM(..code..) (no quotes) or EM_ASM({ ..code($0).. }, input) (to input values)');
      }
    }
    abort('NO_DYNAMIC_EXECUTION was set, cannot eval, so EM_ASM is not functional');
    return Runtime.asmConstCache[code] = evalled;
  },
  warnOnce: function (text) {
    if (!Runtime.warnOnce.shown) Runtime.warnOnce.shown = {};
    if (!Runtime.warnOnce.shown[text]) {
      Runtime.warnOnce.shown[text] = 1;
      Module.printErr(text);
    }
  },
  funcWrappers: {},
  getFuncWrapper: function (func, sig) {
    assert(sig);
    if (!Runtime.funcWrappers[sig]) {
      Runtime.funcWrappers[sig] = {};
    }
    var sigCache = Runtime.funcWrappers[sig];
    if (!sigCache[func]) {
      sigCache[func] = function dynCall_wrapper() {
        return Runtime.dynCall(sig, func, arguments);
      };
    }
    return sigCache[func];
  },
  getCompilerSetting: function (name) {
    throw 'You must build with -s RETAIN_COMPILER_SETTINGS=1 for Runtime.getCompilerSetting or emscripten_get_compiler_setting to work';
  },
  stackAlloc: function (size) { var ret = STACKTOP;STACKTOP = (STACKTOP + size)|0;STACKTOP = (((STACKTOP)+15)&-16);(assert((((STACKTOP|0) < (STACK_MAX|0))|0))|0); return ret; },
  staticAlloc: function (size) { var ret = STATICTOP;STATICTOP = (STATICTOP + (assert(!staticSealed),size))|0;STATICTOP = (((STATICTOP)+15)&-16); return ret; },
  dynamicAlloc: function (size) { var ret = DYNAMICTOP;DYNAMICTOP = (DYNAMICTOP + (assert(DYNAMICTOP > 0),size))|0;DYNAMICTOP = (((DYNAMICTOP)+15)&-16); if (DYNAMICTOP >= TOTAL_MEMORY) enlargeMemory();; return ret; },
  alignMemory: function (size,quantum) { var ret = size = Math.ceil((size)/(quantum ? quantum : 16))*(quantum ? quantum : 16); return ret; },
  makeBigInt: function (low,high,unsigned) { var ret = (unsigned ? ((+((low>>>0)))+((+((high>>>0)))*4294967296.0)) : ((+((low>>>0)))+((+((high|0)))*4294967296.0))); return ret; },
  GLOBAL_BASE: 8,
  QUANTUM_SIZE: 4,
  __dummy__: 0
}


Module['Runtime'] = Runtime;

function jsCall() {
  var args = Array.prototype.slice.call(arguments);
  return Runtime.functionPointers[args[0]].apply(null, args.slice(1));
}








//========================================
// Runtime essentials
//========================================

var __THREW__ = 0; // Used in checking for thrown exceptions.

var ABORT = false; // whether we are quitting the application. no code should run after this. set in exit() and abort()
var EXITSTATUS = 0;

var undef = 0;
// tempInt is used for 32-bit signed values or smaller. tempBigInt is used
// for 32-bit unsigned values or more than 32 bits. TODO: audit all uses of tempInt
var tempValue, tempInt, tempBigInt, tempInt2, tempBigInt2, tempPair, tempBigIntI, tempBigIntR, tempBigIntS, tempBigIntP, tempBigIntD, tempDouble, tempFloat;
var tempI64, tempI64b;
var tempRet0, tempRet1, tempRet2, tempRet3, tempRet4, tempRet5, tempRet6, tempRet7, tempRet8, tempRet9;

function assert(condition, text) {
  if (!condition) {
    abort('Assertion failed: ' + text);
  }
}

var globalScope = this;

// Returns the C function with a specified identifier (for C++, you need to do manual name mangling)
function getCFunc(ident) {
  var func = Module['_' + ident]; // closure exported function
  if (!func) {
    abort('NO_DYNAMIC_EXECUTION was set, cannot eval - ccall/cwrap are not functional');
  }
  assert(func, 'Cannot call unknown function ' + ident + ' (perhaps LLVM optimizations or closure removed it?)');
  return func;
}

var cwrap, ccall;
(function(){
  var JSfuncs = {
    // Helpers for cwrap -- it can't refer to Runtime directly because it might
    // be renamed by closure, instead it calls JSfuncs['stackSave'].body to find
    // out what the minified function name is.
    'stackSave': function() {
      Runtime.stackSave()
    },
    'stackRestore': function() {
      Runtime.stackRestore()
    },
    // type conversion from js to c
    'arrayToC' : function(arr) {
      var ret = Runtime.stackAlloc(arr.length);
      writeArrayToMemory(arr, ret);
      return ret;
    },
    'stringToC' : function(str) {
      var ret = 0;
      if (str !== null && str !== undefined && str !== 0) { // null string
        // at most 4 bytes per UTF-8 code point, +1 for the trailing '\0'
        ret = Runtime.stackAlloc((str.length << 2) + 1);
        writeStringToMemory(str, ret);
      }
      return ret;
    }
  };
  // For fast lookup of conversion functions
  var toC = {'string' : JSfuncs['stringToC'], 'array' : JSfuncs['arrayToC']};

  // C calling interface. 
  ccall = function ccallFunc(ident, returnType, argTypes, args) {
    var func = getCFunc(ident);
    var cArgs = [];
    var stack = 0;
    assert(returnType !== 'array', 'Return type should not be "array".');
    if (args) {
      for (var i = 0; i < args.length; i++) {
        var converter = toC[argTypes[i]];
        if (converter) {
          if (stack === 0) stack = Runtime.stackSave();
          cArgs[i] = converter(args[i]);
        } else {
          cArgs[i] = args[i];
        }
      }
    }
    var ret = func.apply(null, cArgs);
    if (returnType === 'string') ret = Pointer_stringify(ret);
    if (stack !== 0) Runtime.stackRestore(stack);
    return ret;
  }

  // NO_DYNAMIC_EXECUTION is on, so we can't use the fast version of cwrap.
  // Fall back to returning a bound version of ccall.
  cwrap = function cwrap(ident, returnType, argTypes) {
    return function() {
      Runtime.warnOnce('NO_DYNAMIC_EXECUTION was set, '
                     + 'using slow cwrap implementation');
      return ccall(ident, returnType, argTypes, arguments);
    }
  }
})();
Module["cwrap"] = cwrap;
Module["ccall"] = ccall;


function setValue(ptr, value, type, noSafe) {
  type = type || 'i8';
  if (type.charAt(type.length-1) === '*') type = 'i32'; // pointers are 32-bit
    switch(type) {
      case 'i1': HEAP8[((ptr)>>0)]=value; break;
      case 'i8': HEAP8[((ptr)>>0)]=value; break;
      case 'i16': HEAP16[((ptr)>>1)]=value; break;
      case 'i32': HEAP32[((ptr)>>2)]=value; break;
      case 'i64': (tempI64 = [value>>>0,(tempDouble=value,(+(Math_abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math_min((+(Math_floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math_ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[((ptr)>>2)]=tempI64[0],HEAP32[(((ptr)+(4))>>2)]=tempI64[1]); break;
      case 'float': HEAPF32[((ptr)>>2)]=value; break;
      case 'double': HEAPF64[((ptr)>>3)]=value; break;
      default: abort('invalid type for setValue: ' + type);
    }
}
Module['setValue'] = setValue;


function getValue(ptr, type, noSafe) {
  type = type || 'i8';
  if (type.charAt(type.length-1) === '*') type = 'i32'; // pointers are 32-bit
    switch(type) {
      case 'i1': return HEAP8[((ptr)>>0)];
      case 'i8': return HEAP8[((ptr)>>0)];
      case 'i16': return HEAP16[((ptr)>>1)];
      case 'i32': return HEAP32[((ptr)>>2)];
      case 'i64': return HEAP32[((ptr)>>2)];
      case 'float': return HEAPF32[((ptr)>>2)];
      case 'double': return HEAPF64[((ptr)>>3)];
      default: abort('invalid type for setValue: ' + type);
    }
  return null;
}
Module['getValue'] = getValue;

var ALLOC_NORMAL = 0; // Tries to use _malloc()
var ALLOC_STACK = 1; // Lives for the duration of the current function call
var ALLOC_STATIC = 2; // Cannot be freed
var ALLOC_DYNAMIC = 3; // Cannot be freed except through sbrk
var ALLOC_NONE = 4; // Do not allocate
Module['ALLOC_NORMAL'] = ALLOC_NORMAL;
Module['ALLOC_STACK'] = ALLOC_STACK;
Module['ALLOC_STATIC'] = ALLOC_STATIC;
Module['ALLOC_DYNAMIC'] = ALLOC_DYNAMIC;
Module['ALLOC_NONE'] = ALLOC_NONE;

// allocate(): This is for internal use. You can use it yourself as well, but the interface
//             is a little tricky (see docs right below). The reason is that it is optimized
//             for multiple syntaxes to save space in generated code. So you should
//             normally not use allocate(), and instead allocate memory using _malloc(),
//             initialize it with setValue(), and so forth.
// @slab: An array of data, or a number. If a number, then the size of the block to allocate,
//        in *bytes* (note that this is sometimes confusing: the next parameter does not
//        affect this!)
// @types: Either an array of types, one for each byte (or 0 if no type at that position),
//         or a single type which is used for the entire block. This only matters if there
//         is initial data - if @slab is a number, then this does not matter at all and is
//         ignored.
// @allocator: How to allocate memory, see ALLOC_*
function allocate(slab, types, allocator, ptr) {
  var zeroinit, size;
  if (typeof slab === 'number') {
    zeroinit = true;
    size = slab;
  } else {
    zeroinit = false;
    size = slab.length;
  }

  var singleType = typeof types === 'string' ? types : null;

  var ret;
  if (allocator == ALLOC_NONE) {
    ret = ptr;
  } else {
    ret = [_malloc, Runtime.stackAlloc, Runtime.staticAlloc, Runtime.dynamicAlloc][allocator === undefined ? ALLOC_STATIC : allocator](Math.max(size, singleType ? 1 : types.length));
  }

  if (zeroinit) {
    var ptr = ret, stop;
    assert((ret & 3) == 0);
    stop = ret + (size & ~3);
    for (; ptr < stop; ptr += 4) {
      HEAP32[((ptr)>>2)]=0;
    }
    stop = ret + size;
    while (ptr < stop) {
      HEAP8[((ptr++)>>0)]=0;
    }
    return ret;
  }

  if (singleType === 'i8') {
    if (slab.subarray || slab.slice) {
      HEAPU8.set(slab, ret);
    } else {
      HEAPU8.set(new Uint8Array(slab), ret);
    }
    return ret;
  }

  var i = 0, type, typeSize, previousType;
  while (i < size) {
    var curr = slab[i];

    if (typeof curr === 'function') {
      curr = Runtime.getFunctionIndex(curr);
    }

    type = singleType || types[i];
    if (type === 0) {
      i++;
      continue;
    }
    assert(type, 'Must know what type to store in allocate!');

    if (type == 'i64') type = 'i32'; // special case: we have one i32 here, and one i32 later

    setValue(ret+i, curr, type);

    // no need to look up size unless type changes, so cache it
    if (previousType !== type) {
      typeSize = Runtime.getNativeTypeSize(type);
      previousType = type;
    }
    i += typeSize;
  }

  return ret;
}
Module['allocate'] = allocate;

function Pointer_stringify(ptr, /* optional */ length) {
  if (length === 0 || !ptr) return '';
  // TODO: use TextDecoder
  // Find the length, and check for UTF while doing so
  var hasUtf = 0;
  var t;
  var i = 0;
  while (1) {
    assert(ptr + i < TOTAL_MEMORY);
    t = HEAPU8[(((ptr)+(i))>>0)];
    hasUtf |= t;
    if (t == 0 && !length) break;
    i++;
    if (length && i == length) break;
  }
  if (!length) length = i;

  var ret = '';

  if (hasUtf < 128) {
    var MAX_CHUNK = 1024; // split up into chunks, because .apply on a huge string can overflow the stack
    var curr;
    while (length > 0) {
      curr = String.fromCharCode.apply(String, HEAPU8.subarray(ptr, ptr + Math.min(length, MAX_CHUNK)));
      ret = ret ? ret + curr : curr;
      ptr += MAX_CHUNK;
      length -= MAX_CHUNK;
    }
    return ret;
  }
  return Module['UTF8ToString'](ptr);
}
Module['Pointer_stringify'] = Pointer_stringify;

// Given a pointer 'ptr' to a null-terminated ASCII-encoded string in the emscripten HEAP, returns
// a copy of that string as a Javascript String object.

function AsciiToString(ptr) {
  var str = '';
  while (1) {
    var ch = HEAP8[((ptr++)>>0)];
    if (!ch) return str;
    str += String.fromCharCode(ch);
  }
}
Module['AsciiToString'] = AsciiToString;

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in ASCII form. The copy will require at most str.length+1 bytes of space in the HEAP.

function stringToAscii(str, outPtr) {
  return writeAsciiToMemory(str, outPtr, false);
}
Module['stringToAscii'] = stringToAscii;

// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the a given array that contains uint8 values, returns
// a copy of that string as a Javascript String object.

function UTF8ArrayToString(u8Array, idx) {
  var u0, u1, u2, u3, u4, u5;

  var str = '';
  while (1) {
    // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629
    u0 = u8Array[idx++];
    if (!u0) return str;
    if (!(u0 & 0x80)) { str += String.fromCharCode(u0); continue; }
    u1 = u8Array[idx++] & 63;
    if ((u0 & 0xE0) == 0xC0) { str += String.fromCharCode(((u0 & 31) << 6) | u1); continue; }
    u2 = u8Array[idx++] & 63;
    if ((u0 & 0xF0) == 0xE0) {
      u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;
    } else {
      u3 = u8Array[idx++] & 63;
      if ((u0 & 0xF8) == 0xF0) {
        u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | u3;
      } else {
        u4 = u8Array[idx++] & 63;
        if ((u0 & 0xFC) == 0xF8) {
          u0 = ((u0 & 3) << 24) | (u1 << 18) | (u2 << 12) | (u3 << 6) | u4;
        } else {
          u5 = u8Array[idx++] & 63;
          u0 = ((u0 & 1) << 30) | (u1 << 24) | (u2 << 18) | (u3 << 12) | (u4 << 6) | u5;
        }
      }
    }
    if (u0 < 0x10000) {
      str += String.fromCharCode(u0);
    } else {
      var ch = u0 - 0x10000;
      str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));
    }
  }
}
Module['UTF8ArrayToString'] = UTF8ArrayToString;

// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the emscripten HEAP, returns
// a copy of that string as a Javascript String object.

function UTF8ToString(ptr) {
  return UTF8ArrayToString(HEAPU8, ptr);
}
Module['UTF8ToString'] = UTF8ToString;

// Copies the given Javascript String object 'str' to the given byte array at address 'outIdx',
// encoded in UTF8 form and null-terminated. The copy will require at most str.length*4+1 bytes of space in the HEAP.
// Use the function lengthBytesUTF8() to compute the exact number of bytes (excluding null terminator) that this function will write.
// Parameters:
//   str: the Javascript string to copy.
//   outU8Array: the array to copy to. Each index in this array is assumed to be one 8-byte element.
//   outIdx: The starting offset in the array to begin the copying.
//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null 
//                    terminator, i.e. if maxBytesToWrite=1, only the null terminator will be written and nothing else.
//                    maxBytesToWrite=0 does not write any bytes to the output, not even the null terminator.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF8Array(str, outU8Array, outIdx, maxBytesToWrite) {
  if (!(maxBytesToWrite > 0)) // Parameter maxBytesToWrite is not optional. Negative values, 0, null, undefined and false each don't write out any bytes.
    return 0;

  var startIdx = outIdx;
  var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629
    var u = str.charCodeAt(i); // possibly a lead surrogate
    if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);
    if (u <= 0x7F) {
      if (outIdx >= endIdx) break;
      outU8Array[outIdx++] = u;
    } else if (u <= 0x7FF) {
      if (outIdx + 1 >= endIdx) break;
      outU8Array[outIdx++] = 0xC0 | (u >> 6);
      outU8Array[outIdx++] = 0x80 | (u & 63);
    } else if (u <= 0xFFFF) {
      if (outIdx + 2 >= endIdx) break;
      outU8Array[outIdx++] = 0xE0 | (u >> 12);
      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);
      outU8Array[outIdx++] = 0x80 | (u & 63);
    } else if (u <= 0x1FFFFF) {
      if (outIdx + 3 >= endIdx) break;
      outU8Array[outIdx++] = 0xF0 | (u >> 18);
      outU8Array[outIdx++] = 0x80 | ((u >> 12) & 63);
      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);
      outU8Array[outIdx++] = 0x80 | (u & 63);
    } else if (u <= 0x3FFFFFF) {
      if (outIdx + 4 >= endIdx) break;
      outU8Array[outIdx++] = 0xF8 | (u >> 24);
      outU8Array[outIdx++] = 0x80 | ((u >> 18) & 63);
      outU8Array[outIdx++] = 0x80 | ((u >> 12) & 63);
      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);
      outU8Array[outIdx++] = 0x80 | (u & 63);
    } else {
      if (outIdx + 5 >= endIdx) break;
      outU8Array[outIdx++] = 0xFC | (u >> 30);
      outU8Array[outIdx++] = 0x80 | ((u >> 24) & 63);
      outU8Array[outIdx++] = 0x80 | ((u >> 18) & 63);
      outU8Array[outIdx++] = 0x80 | ((u >> 12) & 63);
      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);
      outU8Array[outIdx++] = 0x80 | (u & 63);
    }
  }
  // Null-terminate the pointer to the buffer.
  outU8Array[outIdx] = 0;
  return outIdx - startIdx;
}
Module['stringToUTF8Array'] = stringToUTF8Array;

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in UTF8 form. The copy will require at most str.length*4+1 bytes of space in the HEAP.
// Use the function lengthBytesUTF8() to compute the exact number of bytes (excluding null terminator) that this function will write.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF8(str, outPtr, maxBytesToWrite) {
  assert(typeof maxBytesToWrite == 'number', 'stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');
  return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
}
Module['stringToUTF8'] = stringToUTF8;

// Returns the number of bytes the given Javascript string takes if encoded as a UTF8 byte array, EXCLUDING the null terminator byte.

function lengthBytesUTF8(str) {
  var len = 0;
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    var u = str.charCodeAt(i); // possibly a lead surrogate
    if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);
    if (u <= 0x7F) {
      ++len;
    } else if (u <= 0x7FF) {
      len += 2;
    } else if (u <= 0xFFFF) {
      len += 3;
    } else if (u <= 0x1FFFFF) {
      len += 4;
    } else if (u <= 0x3FFFFFF) {
      len += 5;
    } else {
      len += 6;
    }
  }
  return len;
}
Module['lengthBytesUTF8'] = lengthBytesUTF8;

// Given a pointer 'ptr' to a null-terminated UTF16LE-encoded string in the emscripten HEAP, returns
// a copy of that string as a Javascript String object.

function UTF16ToString(ptr) {
  var i = 0;

  var str = '';
  while (1) {
    var codeUnit = HEAP16[(((ptr)+(i*2))>>1)];
    if (codeUnit == 0)
      return str;
    ++i;
    // fromCharCode constructs a character from a UTF-16 code unit, so we can pass the UTF16 string right through.
    str += String.fromCharCode(codeUnit);
  }
}
Module['UTF16ToString'] = UTF16ToString;

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in UTF16 form. The copy will require at most str.length*4+2 bytes of space in the HEAP.
// Use the function lengthBytesUTF16() to compute the exact number of bytes (excluding null terminator) that this function will write.
// Parameters:
//   str: the Javascript string to copy.
//   outPtr: Byte address in Emscripten HEAP where to write the string to.
//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null 
//                    terminator, i.e. if maxBytesToWrite=2, only the null terminator will be written and nothing else.
//                    maxBytesToWrite<2 does not write any bytes to the output, not even the null terminator.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF16(str, outPtr, maxBytesToWrite) {
  assert(typeof maxBytesToWrite == 'number', 'stringToUTF16(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');
  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.
  if (maxBytesToWrite === undefined) {
    maxBytesToWrite = 0x7FFFFFFF;
  }
  if (maxBytesToWrite < 2) return 0;
  maxBytesToWrite -= 2; // Null terminator.
  var startPtr = outPtr;
  var numCharsToWrite = (maxBytesToWrite < str.length*2) ? (maxBytesToWrite / 2) : str.length;
  for (var i = 0; i < numCharsToWrite; ++i) {
    // charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP.
    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate
    HEAP16[((outPtr)>>1)]=codeUnit;
    outPtr += 2;
  }
  // Null-terminate the pointer to the HEAP.
  HEAP16[((outPtr)>>1)]=0;
  return outPtr - startPtr;
}
Module['stringToUTF16'] = stringToUTF16;

// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.

function lengthBytesUTF16(str) {
  return str.length*2;
}
Module['lengthBytesUTF16'] = lengthBytesUTF16;

function UTF32ToString(ptr) {
  var i = 0;

  var str = '';
  while (1) {
    var utf32 = HEAP32[(((ptr)+(i*4))>>2)];
    if (utf32 == 0)
      return str;
    ++i;
    // Gotcha: fromCharCode constructs a character from a UTF-16 encoded code (pair), not from a Unicode code point! So encode the code point to UTF-16 for constructing.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    if (utf32 >= 0x10000) {
      var ch = utf32 - 0x10000;
      str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));
    } else {
      str += String.fromCharCode(utf32);
    }
  }
}
Module['UTF32ToString'] = UTF32ToString;

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in UTF32 form. The copy will require at most str.length*4+4 bytes of space in the HEAP.
// Use the function lengthBytesUTF32() to compute the exact number of bytes (excluding null terminator) that this function will write.
// Parameters:
//   str: the Javascript string to copy.
//   outPtr: Byte address in Emscripten HEAP where to write the string to.
//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null 
//                    terminator, i.e. if maxBytesToWrite=4, only the null terminator will be written and nothing else.
//                    maxBytesToWrite<4 does not write any bytes to the output, not even the null terminator.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF32(str, outPtr, maxBytesToWrite) {
  assert(typeof maxBytesToWrite == 'number', 'stringToUTF32(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');
  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.
  if (maxBytesToWrite === undefined) {
    maxBytesToWrite = 0x7FFFFFFF;
  }
  if (maxBytesToWrite < 4) return 0;
  var startPtr = outPtr;
  var endPtr = startPtr + maxBytesToWrite - 4;
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate
    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) {
      var trailSurrogate = str.charCodeAt(++i);
      codeUnit = 0x10000 + ((codeUnit & 0x3FF) << 10) | (trailSurrogate & 0x3FF);
    }
    HEAP32[((outPtr)>>2)]=codeUnit;
    outPtr += 4;
    if (outPtr + 4 > endPtr) break;
  }
  // Null-terminate the pointer to the HEAP.
  HEAP32[((outPtr)>>2)]=0;
  return outPtr - startPtr;
}
Module['stringToUTF32'] = stringToUTF32;

// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.

function lengthBytesUTF32(str) {
  var len = 0;
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    var codeUnit = str.charCodeAt(i);
    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) ++i; // possibly a lead surrogate, so skip over the tail surrogate.
    len += 4;
  }

  return len;
}
Module['lengthBytesUTF32'] = lengthBytesUTF32;

function demangle(func) {
  var hasLibcxxabi = !!Module['___cxa_demangle'];
  if (hasLibcxxabi) {
    try {
      var buf = _malloc(func.length);
      writeStringToMemory(func.substr(1), buf);
      var status = _malloc(4);
      var ret = Module['___cxa_demangle'](buf, 0, 0, status);
      if (getValue(status, 'i32') === 0 && ret) {
        return Pointer_stringify(ret);
      }
      // otherwise, libcxxabi failed, we can try ours which may return a partial result
    } catch(e) {
      // failure when using libcxxabi, we can try ours which may return a partial result
    } finally {
      if (buf) _free(buf);
      if (status) _free(status);
      if (ret) _free(ret);
    }
  }
  var i = 3;
  // params, etc.
  var basicTypes = {
    'v': 'void',
    'b': 'bool',
    'c': 'char',
    's': 'short',
    'i': 'int',
    'l': 'long',
    'f': 'float',
    'd': 'double',
    'w': 'wchar_t',
    'a': 'signed char',
    'h': 'unsigned char',
    't': 'unsigned short',
    'j': 'unsigned int',
    'm': 'unsigned long',
    'x': 'long long',
    'y': 'unsigned long long',
    'z': '...'
  };
  var subs = [];
  var first = true;
  function dump(x) {
    //return;
    if (x) Module.print(x);
    Module.print(func);
    var pre = '';
    for (var a = 0; a < i; a++) pre += ' ';
    Module.print (pre + '^');
  }
  function parseNested() {
    i++;
    if (func[i] === 'K') i++; // ignore const
    var parts = [];
    while (func[i] !== 'E') {
      if (func[i] === 'S') { // substitution
        i++;
        var next = func.indexOf('_', i);
        var num = func.substring(i, next) || 0;
        parts.push(subs[num] || '?');
        i = next+1;
        continue;
      }
      if (func[i] === 'C') { // constructor
        parts.push(parts[parts.length-1]);
        i += 2;
        continue;
      }
      var size = parseInt(func.substr(i));
      var pre = size.toString().length;
      if (!size || !pre) { i--; break; } // counter i++ below us
      var curr = func.substr(i + pre, size);
      parts.push(curr);
      subs.push(curr);
      i += pre + size;
    }
    i++; // skip E
    return parts;
  }
  function parse(rawList, limit, allowVoid) { // main parser
    limit = limit || Infinity;
    var ret = '', list = [];
    function flushList() {
      return '(' + list.join(', ') + ')';
    }
    var name;
    if (func[i] === 'N') {
      // namespaced N-E
      name = parseNested().join('::');
      limit--;
      if (limit === 0) return rawList ? [name] : name;
    } else {
      // not namespaced
      if (func[i] === 'K' || (first && func[i] === 'L')) i++; // ignore const and first 'L'
      var size = parseInt(func.substr(i));
      if (size) {
        var pre = size.toString().length;
        name = func.substr(i + pre, size);
        i += pre + size;
      }
    }
    first = false;
    if (func[i] === 'I') {
      i++;
      var iList = parse(true);
      var iRet = parse(true, 1, true);
      ret += iRet[0] + ' ' + name + '<' + iList.join(', ') + '>';
    } else {
      ret = name;
    }
    paramLoop: while (i < func.length && limit-- > 0) {
      //dump('paramLoop');
      var c = func[i++];
      if (c in basicTypes) {
        list.push(basicTypes[c]);
      } else {
        switch (c) {
          case 'P': list.push(parse(true, 1, true)[0] + '*'); break; // pointer
          case 'R': list.push(parse(true, 1, true)[0] + '&'); break; // reference
          case 'L': { // literal
            i++; // skip basic type
            var end = func.indexOf('E', i);
            var size = end - i;
            list.push(func.substr(i, size));
            i += size + 2; // size + 'EE'
            break;
          }
          case 'A': { // array
            var size = parseInt(func.substr(i));
            i += size.toString().length;
            if (func[i] !== '_') throw '?';
            i++; // skip _
            list.push(parse(true, 1, true)[0] + ' [' + size + ']');
            break;
          }
          case 'E': break paramLoop;
          default: ret += '?' + c; break paramLoop;
        }
      }
    }
    if (!allowVoid && list.length === 1 && list[0] === 'void') list = []; // avoid (void)
    if (rawList) {
      if (ret) {
        list.push(ret + '?');
      }
      return list;
    } else {
      return ret + flushList();
    }
  }
  var parsed = func;
  try {
    // Special-case the entry point, since its name differs from other name mangling.
    if (func == 'Object._main' || func == '_main') {
      return 'main()';
    }
    if (typeof func === 'number') func = Pointer_stringify(func);
    if (func[0] !== '_') return func;
    if (func[1] !== '_') return func; // C function
    if (func[2] !== 'Z') return func;
    switch (func[3]) {
      case 'n': return 'operator new()';
      case 'd': return 'operator delete()';
    }
    parsed = parse();
  } catch(e) {
    parsed += '?';
  }
  if (parsed.indexOf('?') >= 0 && !hasLibcxxabi) {
    Runtime.warnOnce('warning: a problem occurred in builtin C++ name demangling; build with  -s DEMANGLE_SUPPORT=1  to link in libcxxabi demangling');
  }
  return parsed;
}

function demangleAll(text) {
  return text.replace(/__Z[\w\d_]+/g, function(x) { var y = demangle(x); return x === y ? x : (x + ' [' + y + ']') });
}

function jsStackTrace() {
  var err = new Error();
  if (!err.stack) {
    // IE10+ special cases: It does have callstack info, but it is only populated if an Error object is thrown,
    // so try that as a special-case.
    try {
      throw new Error(0);
    } catch(e) {
      err = e;
    }
    if (!err.stack) {
      return '(no stack trace available)';
    }
  }
  return err.stack.toString();
}

function stackTrace() {
  return demangleAll(jsStackTrace());
}
Module['stackTrace'] = stackTrace;

// Memory management

var PAGE_SIZE = 4096;
function alignMemoryPage(x) {
  return (x+4095)&-4096;
}

var HEAP;
var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;

var STATIC_BASE = 0, STATICTOP = 0, staticSealed = false; // static area
var STACK_BASE = 0, STACKTOP = 0, STACK_MAX = 0; // stack area
var DYNAMIC_BASE = 0, DYNAMICTOP = 0; // dynamic area handled by sbrk

function enlargeMemory() {
  abort('Cannot enlarge memory arrays. Either (1) compile with -s TOTAL_MEMORY=X with X higher than the current value ' + TOTAL_MEMORY + ', (2) compile with ALLOW_MEMORY_GROWTH which adjusts the size at runtime but prevents some optimizations, or (3) set Module.TOTAL_MEMORY before the program runs.');
}


var TOTAL_STACK = Module['TOTAL_STACK'] || 5242880;
var TOTAL_MEMORY = Module['TOTAL_MEMORY'] || 16777216;
var FAST_MEMORY = Module['FAST_MEMORY'] || 2097152;

var totalMemory = 64*1024;
while (totalMemory < TOTAL_MEMORY || totalMemory < 2*TOTAL_STACK) {
  if (totalMemory < 16*1024*1024) {
    totalMemory *= 2;
  } else {
    totalMemory += 16*1024*1024
  }
}
if (totalMemory !== TOTAL_MEMORY) {
  Module.printErr('increasing TOTAL_MEMORY to ' + totalMemory + ' to be compliant with the asm.js spec (and given that TOTAL_STACK=' + TOTAL_STACK + ')');
  TOTAL_MEMORY = totalMemory;
}

// Initialize the runtime's memory
// check for full engine support (use string 'subarray' to avoid closure compiler confusion)
assert(typeof Int32Array !== 'undefined' && typeof Float64Array !== 'undefined' && !!(new Int32Array(1)['subarray']) && !!(new Int32Array(1)['set']),
       'JS engine does not provide full typed array support');

var buffer = new ArrayBuffer(TOTAL_MEMORY);
HEAP8 = new Int8Array(buffer);
HEAP16 = new Int16Array(buffer);
HEAP32 = new Int32Array(buffer);
HEAPU8 = new Uint8Array(buffer);
HEAPU16 = new Uint16Array(buffer);
HEAPU32 = new Uint32Array(buffer);
HEAPF32 = new Float32Array(buffer);
HEAPF64 = new Float64Array(buffer);

// Endianness check (note: assumes compiler arch was little-endian)
HEAP32[0] = 255;
assert(HEAPU8[0] === 255 && HEAPU8[3] === 0, 'Typed arrays 2 must be run on a little-endian system');

Module['HEAP'] = HEAP;
Module['buffer'] = buffer;
Module['HEAP8'] = HEAP8;
Module['HEAP16'] = HEAP16;
Module['HEAP32'] = HEAP32;
Module['HEAPU8'] = HEAPU8;
Module['HEAPU16'] = HEAPU16;
Module['HEAPU32'] = HEAPU32;
Module['HEAPF32'] = HEAPF32;
Module['HEAPF64'] = HEAPF64;

function callRuntimeCallbacks(callbacks) {
  while(callbacks.length > 0) {
    var callback = callbacks.shift();
    if (typeof callback == 'function') {
      callback();
      continue;
    }
    var func = callback.func;
    if (typeof func === 'number') {
      if (callback.arg === undefined) {
        Runtime.dynCall('v', func);
      } else {
        Runtime.dynCall('vi', func, [callback.arg]);
      }
    } else {
      func(callback.arg === undefined ? null : callback.arg);
    }
  }
}

var __ATPRERUN__  = []; // functions called before the runtime is initialized
var __ATINIT__    = []; // functions called during startup
var __ATMAIN__    = []; // functions called when main() is to be run
var __ATEXIT__    = []; // functions called during shutdown
var __ATPOSTRUN__ = []; // functions called after the runtime has exited

var runtimeInitialized = false;
var runtimeExited = false;

function preRun() {
  // compatibility - merge in anything from Module['preRun'] at this time
  if (Module['preRun']) {
    if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];
    while (Module['preRun'].length) {
      addOnPreRun(Module['preRun'].shift());
    }
  }
  callRuntimeCallbacks(__ATPRERUN__);
}

function ensureInitRuntime() {
  if (runtimeInitialized) return;
  runtimeInitialized = true;
  callRuntimeCallbacks(__ATINIT__);
}

function preMain() {
  callRuntimeCallbacks(__ATMAIN__);
}

function exitRuntime() {
  callRuntimeCallbacks(__ATEXIT__);
  runtimeExited = true;
}

function postRun() {
  // compatibility - merge in anything from Module['postRun'] at this time
  if (Module['postRun']) {
    if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];
    while (Module['postRun'].length) {
      addOnPostRun(Module['postRun'].shift());
    }
  }
  callRuntimeCallbacks(__ATPOSTRUN__);
}

function addOnPreRun(cb) {
  __ATPRERUN__.unshift(cb);
}
Module['addOnPreRun'] = Module.addOnPreRun = addOnPreRun;

function addOnInit(cb) {
  __ATINIT__.unshift(cb);
}
Module['addOnInit'] = Module.addOnInit = addOnInit;

function addOnPreMain(cb) {
  __ATMAIN__.unshift(cb);
}
Module['addOnPreMain'] = Module.addOnPreMain = addOnPreMain;

function addOnExit(cb) {
  __ATEXIT__.unshift(cb);
}
Module['addOnExit'] = Module.addOnExit = addOnExit;

function addOnPostRun(cb) {
  __ATPOSTRUN__.unshift(cb);
}
Module['addOnPostRun'] = Module.addOnPostRun = addOnPostRun;

// Tools


function intArrayFromString(stringy, dontAddNull, length /* optional */) {
  var len = length > 0 ? length : lengthBytesUTF8(stringy)+1;
  var u8array = new Array(len);
  var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
  if (dontAddNull) u8array.length = numBytesWritten;
  return u8array;
}
Module['intArrayFromString'] = intArrayFromString;

function intArrayToString(array) {
  var ret = [];
  for (var i = 0; i < array.length; i++) {
    var chr = array[i];
    if (chr > 0xFF) {
        assert(false, 'Character code ' + chr + ' (' + String.fromCharCode(chr) + ')  at offset ' + i + ' not in 0x00-0xFF.');
      chr &= 0xFF;
    }
    ret.push(String.fromCharCode(chr));
  }
  return ret.join('');
}
Module['intArrayToString'] = intArrayToString;

function writeStringToMemory(string, buffer, dontAddNull) {
  var array = intArrayFromString(string, dontAddNull);
  var i = 0;
  while (i < array.length) {
    var chr = array[i];
    HEAP8[(((buffer)+(i))>>0)]=chr;
    i = i + 1;
  }
}
Module['writeStringToMemory'] = writeStringToMemory;

function writeArrayToMemory(array, buffer) {
  for (var i = 0; i < array.length; i++) {
    HEAP8[((buffer++)>>0)]=array[i];
  }
}
Module['writeArrayToMemory'] = writeArrayToMemory;

function writeAsciiToMemory(str, buffer, dontAddNull) {
  for (var i = 0; i < str.length; ++i) {
    assert(str.charCodeAt(i) === str.charCodeAt(i)&0xff);
    HEAP8[((buffer++)>>0)]=str.charCodeAt(i);
  }
  // Null-terminate the pointer to the HEAP.
  if (!dontAddNull) HEAP8[((buffer)>>0)]=0;
}
Module['writeAsciiToMemory'] = writeAsciiToMemory;

function unSign(value, bits, ignore) {
  if (value >= 0) {
    return value;
  }
  return bits <= 32 ? 2*Math.abs(1 << (bits-1)) + value // Need some trickery, since if bits == 32, we are right at the limit of the bits JS uses in bitshifts
                    : Math.pow(2, bits)         + value;
}
function reSign(value, bits, ignore) {
  if (value <= 0) {
    return value;
  }
  var half = bits <= 32 ? Math.abs(1 << (bits-1)) // abs is needed if bits == 32
                        : Math.pow(2, bits-1);
  if (value >= half && (bits <= 32 || value > half)) { // for huge values, we can hit the precision limit and always get true here. so don't do that
                                                       // but, in general there is no perfect solution here. With 64-bit ints, we get rounding and errors
                                                       // TODO: In i64 mode 1, resign the two parts separately and safely
    value = -2*half + value; // Cannot bitshift half, as it may be at the limit of the bits JS uses in bitshifts
  }
  return value;
}

// check for imul support, and also for correctness ( https://bugs.webkit.org/show_bug.cgi?id=126345 )
if (!Math['imul'] || Math['imul'](0xffffffff, 5) !== -5) Math['imul'] = function imul(a, b) {
  var ah  = a >>> 16;
  var al = a & 0xffff;
  var bh  = b >>> 16;
  var bl = b & 0xffff;
  return (al*bl + ((ah*bl + al*bh) << 16))|0;
};
Math.imul = Math['imul'];


if (!Math['clz32']) Math['clz32'] = function(x) {
  x = x >>> 0;
  for (var i = 0; i < 32; i++) {
    if (x & (1 << (31 - i))) return i;
  }
  return 32;
};
Math.clz32 = Math['clz32']

var Math_abs = Math.abs;
var Math_cos = Math.cos;
var Math_sin = Math.sin;
var Math_tan = Math.tan;
var Math_acos = Math.acos;
var Math_asin = Math.asin;
var Math_atan = Math.atan;
var Math_atan2 = Math.atan2;
var Math_exp = Math.exp;
var Math_log = Math.log;
var Math_sqrt = Math.sqrt;
var Math_ceil = Math.ceil;
var Math_floor = Math.floor;
var Math_pow = Math.pow;
var Math_imul = Math.imul;
var Math_fround = Math.fround;
var Math_min = Math.min;
var Math_clz32 = Math.clz32;

// A counter of dependencies for calling run(). If we need to
// do asynchronous work before running, increment this and
// decrement it. Incrementing must happen in a place like
// PRE_RUN_ADDITIONS (used by emcc to add file preloading).
// Note that you can add dependencies in preRun, even though
// it happens right before run - run will be postponed until
// the dependencies are met.
var runDependencies = 0;
var runDependencyWatcher = null;
var dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled
var runDependencyTracking = {};

function addRunDependency(id) {
  runDependencies++;
  if (Module['monitorRunDependencies']) {
    Module['monitorRunDependencies'](runDependencies);
  }
  if (id) {
    assert(!runDependencyTracking[id]);
    runDependencyTracking[id] = 1;
    if (runDependencyWatcher === null && typeof setInterval !== 'undefined') {
      // Check for missing dependencies every few seconds
      runDependencyWatcher = setInterval(function() {
        if (ABORT) {
          clearInterval(runDependencyWatcher);
          runDependencyWatcher = null;
          return;
        }
        var shown = false;
        for (var dep in runDependencyTracking) {
          if (!shown) {
            shown = true;
            Module.printErr('still waiting on run dependencies:');
          }
          Module.printErr('dependency: ' + dep);
        }
        if (shown) {
          Module.printErr('(end of list)');
        }
      }, 10000);
    }
  } else {
    Module.printErr('warning: run dependency added without ID');
  }
}
Module['addRunDependency'] = addRunDependency;
function removeRunDependency(id) {
  runDependencies--;
  if (Module['monitorRunDependencies']) {
    Module['monitorRunDependencies'](runDependencies);
  }
  if (id) {
    assert(runDependencyTracking[id]);
    delete runDependencyTracking[id];
  } else {
    Module.printErr('warning: run dependency removed without ID');
  }
  if (runDependencies == 0) {
    if (runDependencyWatcher !== null) {
      clearInterval(runDependencyWatcher);
      runDependencyWatcher = null;
    }
    if (dependenciesFulfilled) {
      var callback = dependenciesFulfilled;
      dependenciesFulfilled = null;
      callback(); // can add another dependenciesFulfilled
    }
  }
}
Module['removeRunDependency'] = removeRunDependency;

Module["preloadedImages"] = {}; // maps url to image data
Module["preloadedAudios"] = {}; // maps url to audio data


var memoryInitializer = null;

// === Body ===





STATIC_BASE = 8;

STATICTOP = STATIC_BASE + 4336;
  /* global initializers */ __ATINIT__.push();
  

/* memory initializer */ allocate([0,0,0,0,48,1,0,0,22,0,0,0,23,0,0,0,24,0,0,0,25,0,0,0,26,0,0,0,27,0,0,0,28,0,0,0,29,0,0,0,30,0,0,0,0,0,0,0,117,67,47,70,108,111,48,49,19,0,0,0,0,0,0,0,19,0,0,0,0,0,0,0,111,0,0,0,0,0,0,0,0,0,0,0,128,1,0,0,31,0,0,0,32,0,0,0,33,0,0,0,0,0,0,0,117,67,47,70,108,111,48,49,10,0,0,0,0,0,0,0,15,1,0,0,0,0,0,0,11,27,0,0,0,0,0,0,11,28,0,0,0,0,0,0,11,9,0,0,0,0,0,0,12,1,2,0,0,0,0,0,12,2,3,0,0,0,0,0,13,1,0,7,44,1,0,0,13,3,1,7,13,0,0,0,20,0,0,0,0,0,0,0,14,0,0,0,0,0,0,0,49,55,72,111,115,116,67,111,109,109,117,110,105,99,97,116,105,111,110,0,0,0,0,0,50,54,78,101,116,119,111,114,107,78,111,116,105,102,105,99,97,116,105,111,110,72,97,110,100,108,101,114,0,0,0,0,49,50,68,101,98,117,103,72,97,110,100,108,101,114,0,0,128,14,0,0,8,1,0,0,168,14,0,0,232,0,0,0,24,1,0,0,0,0,0,0,168,14,0,0,208,0,0,0,32,1,0,0,0,0,0,0,49,51,72,111,115,116,84,114,97,110,115,112,111,114,116,0,128,14,0,0,64,1,0,0,56,83,117,98,71,114,97,112,104,0,0,0,0,0,0,0,57,67,111,109,112,111,110,101,110,116,0,0,0,0,0,0,128,14,0,0,104,1,0,0,168,14,0,0,88,1,0,0,120,1,0,0,0,0,0,0,0,0,0,0,200,1,0,0,34,0,0,0,35,0,0,0,36,0,0,0,0,0,0,0,50,51,69,109,115,99,114,105,112,116,101,110,72,111,115,116,84,114,97,110,115,112,111,114,116,0,0,0,0,0,0,0,168,14,0,0,168,1,0,0,80,1,0,0,0,0,0,0,0,0,0,0,32,2,0,0,37,0,0,0,38,0,0,0,39,0,0,0,0,0,0,0,50,50,80,117,114,101,70,117,110,99,116,105,111,110,67,111,109,112,111,110,101,110,116,50,73,49,50,78,117,109,98,101,114,69,113,117,97,108,115,108,108,69,0,0,0,0,0,0,168,14,0,0,240,1,0,0,120,1,0,0,0,0,0,0,0,0,0,0,112,2,0,0,40,0,0,0,41,0,0,0,42,0,0,0,0,0,0,0,50,50,80,117,114,101,70,117,110,99,116,105,111,110,67,111,109,112,111,110,101,110,116,50,73,51,77,105,110,108,108,69,0,0,0,0,0,0,0,0,168,14,0,0,72,2,0,0,120,1,0,0,0,0,0,0,0,0,0,0,192,2,0,0,43,0,0,0,44,0,0,0,45,0,0,0,0,0,0,0,50,50,80,117,114,101,70,117,110,99,116,105,111,110,67,111,109,112,111,110,101,110,116,50,73,51,77,97,120,108,108,69,0,0,0,0,0,0,0,0,168,14,0,0,152,2,0,0,120,1,0,0,0,0,0,0,0,0,0,0,16,3,0,0,46,0,0,0,47,0,0,0,48,0,0,0,0,0,0,0,50,50,80,117,114,101,70,117,110,99,116,105,111,110,67,111,109,112,111,110,101,110,116,50,73,57,66,111,111,108,101,97,110,79,114,98,98,69,0,0,168,14,0,0,232,2,0,0,120,1,0,0,0,0,0,0,0,0,0,0,104,3,0,0,49,0,0,0,50,0,0,0,51,0,0,0,0,0,0,0,50,50,80,117,114,101,70,117,110,99,116,105,111,110,67,111,109,112,111,110,101,110,116,50,73,49,48,66,111,111,108,101,97,110,65,110,100,98,98,69,0,0,0,0,0,0,0,0,168,14,0,0,56,3,0,0,120,1,0,0,0,0,0,0,0,0,0,0,200,3,0,0,52,0,0,0,53,0,0,0,54,0,0,0,0,0,0,0,57,66,111,111,108,84,111,73,110,116,0,0,0,0,0,0,50,49,83,105,110,103,108,101,79,117,116,112,117,116,67,111,109,112,111,110,101,110,116,0,168,14,0,0,160,3,0,0,120,1,0,0,0,0,0,0,168,14,0,0,144,3,0,0,184,3,0,0,0,0,0,0,0,0,0,0,184,3,0,0,55,0,0,0,56,0,0,0,57,0,0,0,0,0,0,0,0,0,0,0,24,4,0,0,58,0,0,0,59,0,0,0,60,0,0,0,0,0,0,0,49,51,84,111,103,103,108,101,66,111,111,108,101,97,110,0,168,14,0,0,8,4,0,0,184,3,0,0,0,0,0,0,0,0,0,0,72,4,0,0,61,0,0,0,62,0,0,0,63,0,0,0,0,0,0,0,53,84,105,109,101,114,0,0,168,14,0,0,64,4,0,0,184,3,0,0,0,0,0,0,0,0,0,0,120,4,0,0,64,0,0,0,65,0,0,0,66,0,0,0,0,0,0,0,53,83,112,108,105,116,0,0,168,14,0,0,112,4,0,0,120,1,0,0,0,0,0,0,0,0,0,0,176,4,0,0,67,0,0,0,68,0,0,0,69,0,0,0,0,0,0,0,57,83,101,114,105,97,108,79,117,116,0,0,0,0,0,0,168,14,0,0,160,4,0,0,184,3,0,0,0,0,0,0,0,0,0,0,232,4,0,0,70,0,0,0,71,0,0,0,72,0,0,0,0,0,0,0,56,83,101,114,105,97,108,73,110,0,0,0,0,0,0,0,168,14,0,0,216,4,0,0,184,3,0,0,0,0,0,0,0,0,0,0,24,5,0,0,73,0,0,0,74,0,0,0,75,0,0,0,0,0,0,0,53,82,111,117,116,101,0,0,168,14,0,0,16,5,0,0,184,3,0,0,0,0,0,0,0,0,0,0,128,5,0,0,76,0,0,0,77,0,0,0,78,0,0,0,0,0,0,0,49,55,82,101,97,100,67,97,112,97,99,105,116,105,118,101,80,105,110,0,0,0,0,0,49,52,68,117,109,109,121,67,111,109,112,111,110,101,110,116,0,0,0,0,0,0,0,0,168,14,0,0,88,5,0,0,120,1,0,0,0,0,0,0,168,14,0,0,64,5,0,0,112,5,0,0,0,0,0,0,0,0,0,0,112,5,0,0,79,0,0,0,80,0,0,0,78,0,0,0,0,0,0,0,0,0,0,0,208,5,0,0,81,0,0,0,82,0,0,0,83,0,0,0,0,0,0,0,56,80,119,109,87,114,105,116,101,0,0,0,0,0,0,0,168,14,0,0,192,5,0,0,184,3,0,0,0,0,0,0,0,0,0,0,8,6,0,0,84,0,0,0,85,0,0,0,86,0,0,0,0,0,0,0,49,48,77,111,110,105,116,111,114,80,105,110,0,0,0,0,168,14,0,0,248,5,0,0,184,3,0,0,0,0,0,0,0,0,0,0,64,6,0,0,87,0,0,0,88,0,0,0,89,0,0,0,0,0,0,0,57,77,97,112,76,105,110,101,97,114,0,0,0,0,0,0,168,14,0,0,48,6,0,0,184,3,0,0,0,0,0,0,0,0,0,0,120,6,0,0,90,0,0,0,91,0,0,0,92,0,0,0,0,0,0,0,49,50,76,101,100,77,97,116,114,105,120,77,97,120,0,0,168,14,0,0,104,6,0,0,184,3,0,0,0,0,0,0,60,66,66,66,66,66,66,60,16,24,20,16,16,16,16,16,126,2,2,126,64,64,64,126,62,2,2,62,2,2,62,0,8,24,40,72,254,8,8,8,60,32,32,60,4,4,60,0,60,32,32,60,36,36,60,0,62,34,4,8,8,8,8,8,0,62,34,34,62,34,34,62,62,34,34,62,2,2,2,62,8,20,34,62,34,34,34,34,60,34,34,62,34,34,60,0,60,64,64,64,64,64,60,0,124,66,66,66,66,66,124,0,124,64,64,124,64,64,64,124,124,64,64,124,64,64,64,64,60,64,64,64,64,68,68,60,68,68,68,124,68,68,68,68,124,16,16,16,16,16,16,124,60,8,8,8,8,8,72,48,0,36,40,48,32,48,40,36,64,64,64,64,64,64,64,124,129,195,165,153,129,129,129,129,0,66,98,82,74,70,66,0,60,66,66,66,66,66,66,60,60,34,34,34,60,32,32,32,28,34,34,34,34,38,34,29,60,34,34,34,60,36,34,33,0,30,32,32,62,2,2,60,0,62,8,8,8,8,8,8,66,66,66,66,66,66,34,28,66,66,66,66,66,66,36,24,0,73,73,73,73,42,28,0,0,65,34,20,8,20,34,65,65,34,20,8,8,8,8,8,0,127,2,4,8,16,32,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,224,7,0,0,93,0,0,0,94,0,0,0,95,0,0,0,0,0,0,0,49,51,73,110,118,101,114,116,66,111,111,108,101,97,110,0,168,14,0,0,208,7,0,0,184,3,0,0,0,0,0,0,0,0,0,0,32,8,0,0,96,0,0,0,97,0,0,0,98,0,0,0,0,0,0,0,49,53,72,121,115,116,101,114,101,115,105,115,76,97,116,99,104,0,0,0,0,0,0,0,168,14,0,0,8,8,0,0,184,3,0,0,0,0,0,0,0,0,0,0,80,8,0,0,99,0,0,0,100,0,0,0,101,0,0,0,0,0,0,0,52,71,97,116,101,0,0,0,168,14,0,0,72,8,0,0,184,3,0,0,0,0,0,0,0,0,0,0,136,8,0,0,102,0,0,0,103,0,0,0,104,0,0,0,0,0,0,0,55,70,111,114,119,97,114,100,0,0,0,0,0,0,0,0,168,14,0,0,120,8,0,0,184,3,0,0,0,0,0,0,0,0,0,0,192,8,0,0,105,0,0,0,106,0,0,0,107,0,0,0,0,0,0,0,49,50,68,105,103,105,116,97,108,87,114,105,116,101,0,0,168,14,0,0,176,8,0,0,184,3,0,0,0,0,0,0,0,0,0,0,248,8,0,0,108,0,0,0,109,0,0,0,110,0,0,0,0,0,0,0,49,49,68,105,103,105,116,97,108,82,101,97,100,0,0,0,168,14,0,0,232,8,0,0,184,3,0,0,0,0,0,0,0,0,0,0,40,9,0,0,111,0,0,0,112,0,0,0,113,0,0,0,0,0,0,0,53,67,111,117,110,116,0,0,168,14,0,0,32,9,0,0,184,3,0,0,0,0,0,0,0,0,0,0,96,9,0,0,114,0,0,0,115,0,0,0,116,0,0,0,0,0,0,0,57,67,111,110,115,116,114,97,105,110,0,0,0,0,0,0,168,14,0,0,80,9,0,0,184,3,0,0,0,0,0,0,0,0,0,0,160,9,0,0,117,0,0,0,118,0,0,0,119,0,0,0,0,0,0,0,49,53,66,114,101,97,107,66,101,102,111,114,101,77,97,107,101,0,0,0,0,0,0,0,168,14,0,0,136,9,0,0,120,1,0,0,0,0,0,0,0,0,0,0,216,9,0,0,120,0,0,0,121,0,0,0,122,0,0,0,0,0,0,0,49,48,65,114,100,117,105,110,111,85,110,111,0,0,0,0,168,14,0,0,200,9,0,0,120,1,0,0,0,0,0,0,0,0,0,0,16,10,0,0,123,0,0,0,124,0,0,0,125,0,0,0,0,0,0,0,49,48,65,110,97,108,111,103,82,101,97,100,0,0,0,0,168,14,0,0,0,10,0,0,184,3,0,0,0,0,0,0,0,0,0,0,136,10,0,0,126,0,0,0,127,0,0,0,128,0,0,0,129,0,0,0,130,0,0,0,131,0,0,0,132,0,0,0,133,0,0,0,134,0,0,0,135,0,0,0,136,0,0,0,137,0,0,0,138,0,0,0,139,0,0,0,140,0,0,0,141,0,0,0,49,50,69,109,115,99,114,105,112,116,101,110,73,79,0,0,50,73,79,0,0,0,0,0,128,14,0,0,120,10,0,0,168,14,0,0,104,10,0,0,128,10,0,0,0,0,0,0,0,0,0,0,128,10,0,0,142,0,0,0,143,0,0,0,144,0,0,0,57,0,0,0,57,0,0,0,57,0,0,0,57,0,0,0,57,0,0,0,57,0,0,0,57,0,0,0,57,0,0,0,57,0,0,0,57,0,0,0,57,0,0,0,140,0,0,0,57,0,0,0,0,0,0,0,120,1,0,0,145,0,0,0,146,0,0,0,57,0,0,0,0,0,0,0,0,0,0,0,80,1,0,0,57,0,0,0,57,0,0,0,57,0,0,0,0,0,0,0,0,0,0,0,32,1,0,0,57,0,0,0,57,0,0,0,57,0,0,0,57,0,0,0,57,0,0,0,57,0,0,0,57,0,0,0,57,0,0,0,57,0,0,0,0,0,0,0,0,0,0,0,24,1,0,0,57,0,0,0,57,0,0,0,147,0,0,0,0,0,0,0,96,11,0,0,0,0,0,0,117,110,99,97,117,103,104,116,0,0,0,0,0,0,0,0,116,101,114,109,105,110,97,116,105,110,103,32,119,105,116,104,32,37,115,32,101,120,99,101,112,116,105,111,110,32,111,102,32,116,121,112,101,32,37,115,58,32,37,115,0,0,0,0,116,101,114,109,105,110,97,116,105,110,103,32,119,105,116,104,32,37,115,32,101,120,99,101,112,116,105,111,110,32,111,102,32,116,121,112,101,32,37,115,0,0,0,0,0,0,0,0,116,101,114,109,105,110,97,116,105,110,103,32,119,105,116,104,32,37,115,32,102,111,114,101,105,103,110,32,101,120,99,101,112,116,105,111,110,0,0,0,116,101,114,109,105,110,97,116,105,110,103,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,112,116,104,114,101,97,100,95,111,110,99,101,32,102,97,105,108,117,114,101,32,105,110,32,95,95,99,120,97,95,103,101,116,95,103,108,111,98,97,108,115,95,102,97,115,116,40,41,0,0,0,0,0,0,0,0,99,97,110,110,111,116,32,99,114,101,97,116,101,32,112,116,104,114,101,97,100,32,107,101,121,32,102,111,114,32,95,95,99,120,97,95,103,101,116,95,103,108,111,98,97,108,115,40,41,0,0,0,0,0,0,0,99,97,110,110,111,116,32,122,101,114,111,32,111,117,116,32,116,104,114,101,97,100,32,118,97,108,117,101,32,102,111,114,32,95,95,99,120,97,95,103,101,116,95,103,108,111,98,97,108,115,40,41,0,0,0,0,0,0,0,0,248,12,0,0,148,0,0,0,149,0,0,0,150,0,0,0,0,0,0,0,115,116,100,58,58,98,97,100,95,97,108,108,111,99,0,0,83,116,57,98,97,100,95,97,108,108,111,99,0,0,0,0,168,14,0,0,232,12,0,0,120,13,0,0,0,0,0,0,116,101,114,109,105,110,97,116,101,95,104,97,110,100,108,101,114,32,117,110,101,120,112,101,99,116,101,100,108,121,32,114,101,116,117,114,110,101,100,0,116,101,114,109,105,110,97,116,101,95,104,97,110,100,108,101,114,32,117,110,101,120,112,101,99,116,101,100,108,121,32,116,104,114,101,119,32,97,110,32,101,120,99,101,112,116,105,111,110,0,0,0,0,0,0,0,83,116,57,101,120,99,101,112,116,105,111,110,0,0,0,0,128,14,0,0,104,13,0,0,83,116,57,116,121,112,101,95,105,110,102,111,0,0,0,0,128,14,0,0,128,13,0,0,78,49,48,95,95,99,120,120,97,98,105,118,49,49,54,95,95,115,104,105,109,95,116,121,112,101,95,105,110,102,111,69,0,0,0,0,0,0,0,0,168,14,0,0,152,13,0,0,144,13,0,0,0,0,0,0,78,49,48,95,95,99,120,120,97,98,105,118,49,49,55,95,95,99,108,97,115,115,95,116,121,112,101,95,105,110,102,111,69,0,0,0,0,0,0,0,168,14,0,0,208,13,0,0,192,13,0,0,0,0,0,0,78,49,48,95,95,99,120,120,97,98,105,118,49,49,57,95,95,112,111,105,110,116,101,114,95,116,121,112,101,95,105,110,102,111,69,0,0,0,0,0,78,49,48,95,95,99,120,120,97,98,105,118,49,49,55,95,95,112,98,97,115,101,95,116,121,112,101,95,105,110,102,111,69,0,0,0,0,0,0,0,168,14,0,0,48,14,0,0,192,13,0,0,0,0,0,0,168,14,0,0,8,14,0,0,88,14,0,0,0,0,0,0,0,0,0,0,248,13,0,0,151,0,0,0,152,0,0,0,153,0,0,0,154,0,0,0,155,0,0,0,156,0,0,0,157,0,0,0,158,0,0,0,0,0,0,0,240,14,0,0,151,0,0,0,159,0,0,0,153,0,0,0,154,0,0,0,155,0,0,0,160,0,0,0,161,0,0,0,162,0,0,0,78,49,48,95,95,99,120,120,97,98,105,118,49,50,48,95,95,115,105,95,99,108,97,115,115,95,116,121,112,101,95,105,110,102,111,69,0,0,0,0,168,14,0,0,200,14,0,0,248,13,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], "i8", ALLOC_NONE, Runtime.GLOBAL_BASE);




var tempDoublePtr = Runtime.alignMemory(allocate(12, "i8", ALLOC_STATIC), 8);

assert(tempDoublePtr % 8 == 0);

function copyTempFloat(ptr) { // functions, because inlining this code increases code size too much

  HEAP8[tempDoublePtr] = HEAP8[ptr];

  HEAP8[tempDoublePtr+1] = HEAP8[ptr+1];

  HEAP8[tempDoublePtr+2] = HEAP8[ptr+2];

  HEAP8[tempDoublePtr+3] = HEAP8[ptr+3];

}

function copyTempDouble(ptr) {

  HEAP8[tempDoublePtr] = HEAP8[ptr];

  HEAP8[tempDoublePtr+1] = HEAP8[ptr+1];

  HEAP8[tempDoublePtr+2] = HEAP8[ptr+2];

  HEAP8[tempDoublePtr+3] = HEAP8[ptr+3];

  HEAP8[tempDoublePtr+4] = HEAP8[ptr+4];

  HEAP8[tempDoublePtr+5] = HEAP8[ptr+5];

  HEAP8[tempDoublePtr+6] = HEAP8[ptr+6];

  HEAP8[tempDoublePtr+7] = HEAP8[ptr+7];

}


  function ___cxa_pure_virtual() {
      ABORT = true;
      throw 'Pure virtual function called!';
    }

  
  
  var ___errno_state=0;function ___setErrNo(value) {
      // For convenient setting and returning of errno.
      HEAP32[((___errno_state)>>2)]=value;
      return value;
    }
  
  var ERRNO_CODES={EPERM:1,ENOENT:2,ESRCH:3,EINTR:4,EIO:5,ENXIO:6,E2BIG:7,ENOEXEC:8,EBADF:9,ECHILD:10,EAGAIN:11,EWOULDBLOCK:11,ENOMEM:12,EACCES:13,EFAULT:14,ENOTBLK:15,EBUSY:16,EEXIST:17,EXDEV:18,ENODEV:19,ENOTDIR:20,EISDIR:21,EINVAL:22,ENFILE:23,EMFILE:24,ENOTTY:25,ETXTBSY:26,EFBIG:27,ENOSPC:28,ESPIPE:29,EROFS:30,EMLINK:31,EPIPE:32,EDOM:33,ERANGE:34,ENOMSG:42,EIDRM:43,ECHRNG:44,EL2NSYNC:45,EL3HLT:46,EL3RST:47,ELNRNG:48,EUNATCH:49,ENOCSI:50,EL2HLT:51,EDEADLK:35,ENOLCK:37,EBADE:52,EBADR:53,EXFULL:54,ENOANO:55,EBADRQC:56,EBADSLT:57,EDEADLOCK:35,EBFONT:59,ENOSTR:60,ENODATA:61,ETIME:62,ENOSR:63,ENONET:64,ENOPKG:65,EREMOTE:66,ENOLINK:67,EADV:68,ESRMNT:69,ECOMM:70,EPROTO:71,EMULTIHOP:72,EDOTDOT:73,EBADMSG:74,ENOTUNIQ:76,EBADFD:77,EREMCHG:78,ELIBACC:79,ELIBBAD:80,ELIBSCN:81,ELIBMAX:82,ELIBEXEC:83,ENOSYS:38,ENOTEMPTY:39,ENAMETOOLONG:36,ELOOP:40,EOPNOTSUPP:95,EPFNOSUPPORT:96,ECONNRESET:104,ENOBUFS:105,EAFNOSUPPORT:97,EPROTOTYPE:91,ENOTSOCK:88,ENOPROTOOPT:92,ESHUTDOWN:108,ECONNREFUSED:111,EADDRINUSE:98,ECONNABORTED:103,ENETUNREACH:101,ENETDOWN:100,ETIMEDOUT:110,EHOSTDOWN:112,EHOSTUNREACH:113,EINPROGRESS:115,EALREADY:114,EDESTADDRREQ:89,EMSGSIZE:90,EPROTONOSUPPORT:93,ESOCKTNOSUPPORT:94,EADDRNOTAVAIL:99,ENETRESET:102,EISCONN:106,ENOTCONN:107,ETOOMANYREFS:109,EUSERS:87,EDQUOT:122,ESTALE:116,ENOTSUP:95,ENOMEDIUM:123,EILSEQ:84,EOVERFLOW:75,ECANCELED:125,ENOTRECOVERABLE:131,EOWNERDEAD:130,ESTRPIPE:86};function _sysconf(name) {
      // long sysconf(int name);
      // http://pubs.opengroup.org/onlinepubs/009695399/functions/sysconf.html
      switch(name) {
        case 30: return PAGE_SIZE;
        case 132:
        case 133:
        case 12:
        case 137:
        case 138:
        case 15:
        case 235:
        case 16:
        case 17:
        case 18:
        case 19:
        case 20:
        case 149:
        case 13:
        case 10:
        case 236:
        case 153:
        case 9:
        case 21:
        case 22:
        case 159:
        case 154:
        case 14:
        case 77:
        case 78:
        case 139:
        case 80:
        case 81:
        case 79:
        case 82:
        case 68:
        case 67:
        case 164:
        case 11:
        case 29:
        case 47:
        case 48:
        case 95:
        case 52:
        case 51:
        case 46:
          return 200809;
        case 27:
        case 246:
        case 127:
        case 128:
        case 23:
        case 24:
        case 160:
        case 161:
        case 181:
        case 182:
        case 242:
        case 183:
        case 184:
        case 243:
        case 244:
        case 245:
        case 165:
        case 178:
        case 179:
        case 49:
        case 50:
        case 168:
        case 169:
        case 175:
        case 170:
        case 171:
        case 172:
        case 97:
        case 76:
        case 32:
        case 173:
        case 35:
          return -1;
        case 176:
        case 177:
        case 7:
        case 155:
        case 8:
        case 157:
        case 125:
        case 126:
        case 92:
        case 93:
        case 129:
        case 130:
        case 131:
        case 94:
        case 91:
          return 1;
        case 74:
        case 60:
        case 69:
        case 70:
        case 4:
          return 1024;
        case 31:
        case 42:
        case 72:
          return 32;
        case 87:
        case 26:
        case 33:
          return 2147483647;
        case 34:
        case 1:
          return 47839;
        case 38:
        case 36:
          return 99;
        case 43:
        case 37:
          return 2048;
        case 0: return 2097152;
        case 3: return 65536;
        case 28: return 32768;
        case 44: return 32767;
        case 75: return 16384;
        case 39: return 1000;
        case 89: return 700;
        case 71: return 256;
        case 40: return 255;
        case 2: return 100;
        case 180: return 64;
        case 25: return 20;
        case 5: return 16;
        case 6: return 6;
        case 73: return 4;
        case 84: {
          if (typeof navigator === 'object') return navigator['hardwareConcurrency'] || 1;
          return 1;
        }
      }
      ___setErrNo(ERRNO_CODES.EINVAL);
      return -1;
    }

  function ___errno_location() {
      return ___errno_state;
    }

  
  function __ZSt18uncaught_exceptionv() { // std::uncaught_exception()
      return !!__ZSt18uncaught_exceptionv.uncaught_exception;
    }
  
  
  
  var EXCEPTIONS={last:0,caught:[],infos:{},deAdjust:function (adjusted) {
        if (!adjusted || EXCEPTIONS.infos[adjusted]) return adjusted;
        for (var ptr in EXCEPTIONS.infos) {
          var info = EXCEPTIONS.infos[ptr];
          if (info.adjusted === adjusted) {
            return ptr;
          }
        }
        return adjusted;
      },addRef:function (ptr) {
        if (!ptr) return;
        var info = EXCEPTIONS.infos[ptr];
        info.refcount++;
      },decRef:function (ptr) {
        if (!ptr) return;
        var info = EXCEPTIONS.infos[ptr];
        assert(info.refcount > 0);
        info.refcount--;
        if (info.refcount === 0) {
          if (info.destructor) {
            Runtime.dynCall('vi', info.destructor, [ptr]);
          }
          delete EXCEPTIONS.infos[ptr];
          ___cxa_free_exception(ptr);
        }
      },clearRef:function (ptr) {
        if (!ptr) return;
        var info = EXCEPTIONS.infos[ptr];
        info.refcount = 0;
      }};
  function ___resumeException(ptr) {
      if (!EXCEPTIONS.last) { EXCEPTIONS.last = ptr; }
      EXCEPTIONS.clearRef(EXCEPTIONS.deAdjust(ptr)); // exception refcount should be cleared, but don't free it
      throw ptr;
    }function ___cxa_find_matching_catch() {
      var thrown = EXCEPTIONS.last;
      if (!thrown) {
        // just pass through the null ptr
        return ((asm["setTempRet0"](0),0)|0);
      }
      var info = EXCEPTIONS.infos[thrown];
      var throwntype = info.type;
      if (!throwntype) {
        // just pass through the thrown ptr
        return ((asm["setTempRet0"](0),thrown)|0);
      }
      var typeArray = Array.prototype.slice.call(arguments);
  
      var pointer = Module['___cxa_is_pointer_type'](throwntype);
      // can_catch receives a **, add indirection
      if (!___cxa_find_matching_catch.buffer) ___cxa_find_matching_catch.buffer = _malloc(4);
      HEAP32[((___cxa_find_matching_catch.buffer)>>2)]=thrown;
      thrown = ___cxa_find_matching_catch.buffer;
      // The different catch blocks are denoted by different types.
      // Due to inheritance, those types may not precisely match the
      // type of the thrown object. Find one which matches, and
      // return the type of the catch block which should be called.
      for (var i = 0; i < typeArray.length; i++) {
        if (typeArray[i] && Module['___cxa_can_catch'](typeArray[i], throwntype, thrown)) {
          thrown = HEAP32[((thrown)>>2)]; // undo indirection
          info.adjusted = thrown;
          return ((asm["setTempRet0"](typeArray[i]),thrown)|0);
        }
      }
      // Shouldn't happen unless we have bogus data in typeArray
      // or encounter a type for which emscripten doesn't have suitable
      // typeinfo defined. Best-efforts match just in case.
      thrown = HEAP32[((thrown)>>2)]; // undo indirection
      return ((asm["setTempRet0"](throwntype),thrown)|0);
    }function ___cxa_throw(ptr, type, destructor) {
      EXCEPTIONS.infos[ptr] = {
        ptr: ptr,
        adjusted: ptr,
        type: type,
        destructor: destructor,
        refcount: 0
      };
      EXCEPTIONS.last = ptr;
      if (!("uncaught_exception" in __ZSt18uncaught_exceptionv)) {
        __ZSt18uncaught_exceptionv.uncaught_exception = 1;
      } else {
        __ZSt18uncaught_exceptionv.uncaught_exception++;
      }
      throw ptr;
    }

   
  Module["_memset"] = _memset;

  var _emscripten_resume=true;

  var _emscripten_landingpad=true;

  function _abort() {
      Module['abort']();
    }

  
  
  function _free() {
  }
  Module["_free"] = _free;function ___cxa_free_exception(ptr) {
      try {
        return _free(ptr);
      } catch(e) { // XXX FIXME
        Module.printErr('exception during cxa_free_exception: ' + e);
      }
    }function ___cxa_end_catch() {
      if (___cxa_end_catch.rethrown) {
        ___cxa_end_catch.rethrown = false;
        return;
      }
      // Clear state flag.
      asm['setThrew'](0);
      // Call destructor if one is registered then clear it.
      var ptr = EXCEPTIONS.caught.pop();
      if (ptr) {
        EXCEPTIONS.decRef(EXCEPTIONS.deAdjust(ptr));
        EXCEPTIONS.last = 0; // XXX in decRef?
      }
    }

  function ___cxa_begin_catch(ptr) {
      __ZSt18uncaught_exceptionv.uncaught_exception--;
      EXCEPTIONS.caught.push(ptr);
      EXCEPTIONS.addRef(EXCEPTIONS.deAdjust(ptr));
      return ptr;
    }

  function _pthread_once(ptr, func) {
      if (!_pthread_once.seen) _pthread_once.seen = {};
      if (ptr in _pthread_once.seen) return;
      Runtime.dynCall('v', func);
      _pthread_once.seen[ptr] = 1;
    }

   
  Module["_strlen"] = _strlen;

  
  function _emscripten_memcpy_big(dest, src, num) {
      HEAPU8.set(HEAPU8.subarray(src, src+num), dest);
      return dest;
    } 
  Module["_memcpy"] = _memcpy;

  
  
  var ERRNO_MESSAGES={0:"Success",1:"Not super-user",2:"No such file or directory",3:"No such process",4:"Interrupted system call",5:"I/O error",6:"No such device or address",7:"Arg list too long",8:"Exec format error",9:"Bad file number",10:"No children",11:"No more processes",12:"Not enough core",13:"Permission denied",14:"Bad address",15:"Block device required",16:"Mount device busy",17:"File exists",18:"Cross-device link",19:"No such device",20:"Not a directory",21:"Is a directory",22:"Invalid argument",23:"Too many open files in system",24:"Too many open files",25:"Not a typewriter",26:"Text file busy",27:"File too large",28:"No space left on device",29:"Illegal seek",30:"Read only file system",31:"Too many links",32:"Broken pipe",33:"Math arg out of domain of func",34:"Math result not representable",35:"File locking deadlock error",36:"File or path name too long",37:"No record locks available",38:"Function not implemented",39:"Directory not empty",40:"Too many symbolic links",42:"No message of desired type",43:"Identifier removed",44:"Channel number out of range",45:"Level 2 not synchronized",46:"Level 3 halted",47:"Level 3 reset",48:"Link number out of range",49:"Protocol driver not attached",50:"No CSI structure available",51:"Level 2 halted",52:"Invalid exchange",53:"Invalid request descriptor",54:"Exchange full",55:"No anode",56:"Invalid request code",57:"Invalid slot",59:"Bad font file fmt",60:"Device not a stream",61:"No data (for no delay io)",62:"Timer expired",63:"Out of streams resources",64:"Machine is not on the network",65:"Package not installed",66:"The object is remote",67:"The link has been severed",68:"Advertise error",69:"Srmount error",70:"Communication error on send",71:"Protocol error",72:"Multihop attempted",73:"Cross mount point (not really error)",74:"Trying to read unreadable message",75:"Value too large for defined data type",76:"Given log. name not unique",77:"f.d. invalid for this operation",78:"Remote address changed",79:"Can   access a needed shared lib",80:"Accessing a corrupted shared lib",81:".lib section in a.out corrupted",82:"Attempting to link in too many libs",83:"Attempting to exec a shared library",84:"Illegal byte sequence",86:"Streams pipe error",87:"Too many users",88:"Socket operation on non-socket",89:"Destination address required",90:"Message too long",91:"Protocol wrong type for socket",92:"Protocol not available",93:"Unknown protocol",94:"Socket type not supported",95:"Not supported",96:"Protocol family not supported",97:"Address family not supported by protocol family",98:"Address already in use",99:"Address not available",100:"Network interface is not configured",101:"Network is unreachable",102:"Connection reset by network",103:"Connection aborted",104:"Connection reset by peer",105:"No buffer space available",106:"Socket is already connected",107:"Socket is not connected",108:"Can't send after socket shutdown",109:"Too many references",110:"Connection timed out",111:"Connection refused",112:"Host is down",113:"Host is unreachable",114:"Socket already connected",115:"Connection already in progress",116:"Stale file handle",122:"Quota exceeded",123:"No medium (in tape drive)",125:"Operation canceled",130:"Previous owner died",131:"State not recoverable"};
  
  var PATH={splitPath:function (filename) {
        var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
        return splitPathRe.exec(filename).slice(1);
      },normalizeArray:function (parts, allowAboveRoot) {
        // if the path tries to go above the root, `up` ends up > 0
        var up = 0;
        for (var i = parts.length - 1; i >= 0; i--) {
          var last = parts[i];
          if (last === '.') {
            parts.splice(i, 1);
          } else if (last === '..') {
            parts.splice(i, 1);
            up++;
          } else if (up) {
            parts.splice(i, 1);
            up--;
          }
        }
        // if the path is allowed to go above the root, restore leading ..s
        if (allowAboveRoot) {
          for (; up--; up) {
            parts.unshift('..');
          }
        }
        return parts;
      },normalize:function (path) {
        var isAbsolute = path.charAt(0) === '/',
            trailingSlash = path.substr(-1) === '/';
        // Normalize the path
        path = PATH.normalizeArray(path.split('/').filter(function(p) {
          return !!p;
        }), !isAbsolute).join('/');
        if (!path && !isAbsolute) {
          path = '.';
        }
        if (path && trailingSlash) {
          path += '/';
        }
        return (isAbsolute ? '/' : '') + path;
      },dirname:function (path) {
        var result = PATH.splitPath(path),
            root = result[0],
            dir = result[1];
        if (!root && !dir) {
          // No dirname whatsoever
          return '.';
        }
        if (dir) {
          // It has a dirname, strip trailing slash
          dir = dir.substr(0, dir.length - 1);
        }
        return root + dir;
      },basename:function (path) {
        // EMSCRIPTEN return '/'' for '/', not an empty string
        if (path === '/') return '/';
        var lastSlash = path.lastIndexOf('/');
        if (lastSlash === -1) return path;
        return path.substr(lastSlash+1);
      },extname:function (path) {
        return PATH.splitPath(path)[3];
      },join:function () {
        var paths = Array.prototype.slice.call(arguments, 0);
        return PATH.normalize(paths.join('/'));
      },join2:function (l, r) {
        return PATH.normalize(l + '/' + r);
      },resolve:function () {
        var resolvedPath = '',
          resolvedAbsolute = false;
        for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
          var path = (i >= 0) ? arguments[i] : FS.cwd();
          // Skip empty and invalid entries
          if (typeof path !== 'string') {
            throw new TypeError('Arguments to path.resolve must be strings');
          } else if (!path) {
            return ''; // an invalid portion invalidates the whole thing
          }
          resolvedPath = path + '/' + resolvedPath;
          resolvedAbsolute = path.charAt(0) === '/';
        }
        // At this point the path should be resolved to a full absolute path, but
        // handle relative paths to be safe (might happen when process.cwd() fails)
        resolvedPath = PATH.normalizeArray(resolvedPath.split('/').filter(function(p) {
          return !!p;
        }), !resolvedAbsolute).join('/');
        return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
      },relative:function (from, to) {
        from = PATH.resolve(from).substr(1);
        to = PATH.resolve(to).substr(1);
        function trim(arr) {
          var start = 0;
          for (; start < arr.length; start++) {
            if (arr[start] !== '') break;
          }
          var end = arr.length - 1;
          for (; end >= 0; end--) {
            if (arr[end] !== '') break;
          }
          if (start > end) return [];
          return arr.slice(start, end - start + 1);
        }
        var fromParts = trim(from.split('/'));
        var toParts = trim(to.split('/'));
        var length = Math.min(fromParts.length, toParts.length);
        var samePartsLength = length;
        for (var i = 0; i < length; i++) {
          if (fromParts[i] !== toParts[i]) {
            samePartsLength = i;
            break;
          }
        }
        var outputParts = [];
        for (var i = samePartsLength; i < fromParts.length; i++) {
          outputParts.push('..');
        }
        outputParts = outputParts.concat(toParts.slice(samePartsLength));
        return outputParts.join('/');
      }};
  
  var TTY={ttys:[],init:function () {
        // https://github.com/kripken/emscripten/pull/1555
        // if (ENVIRONMENT_IS_NODE) {
        //   // currently, FS.init does not distinguish if process.stdin is a file or TTY
        //   // device, it always assumes it's a TTY device. because of this, we're forcing
        //   // process.stdin to UTF8 encoding to at least make stdin reading compatible
        //   // with text files until FS.init can be refactored.
        //   process['stdin']['setEncoding']('utf8');
        // }
      },shutdown:function () {
        // https://github.com/kripken/emscripten/pull/1555
        // if (ENVIRONMENT_IS_NODE) {
        //   // inolen: any idea as to why node -e 'process.stdin.read()' wouldn't exit immediately (with process.stdin being a tty)?
        //   // isaacs: because now it's reading from the stream, you've expressed interest in it, so that read() kicks off a _read() which creates a ReadReq operation
        //   // inolen: I thought read() in that case was a synchronous operation that just grabbed some amount of buffered data if it exists?
        //   // isaacs: it is. but it also triggers a _read() call, which calls readStart() on the handle
        //   // isaacs: do process.stdin.pause() and i'd think it'd probably close the pending call
        //   process['stdin']['pause']();
        // }
      },register:function (dev, ops) {
        TTY.ttys[dev] = { input: [], output: [], ops: ops };
        FS.registerDevice(dev, TTY.stream_ops);
      },stream_ops:{open:function (stream) {
          var tty = TTY.ttys[stream.node.rdev];
          if (!tty) {
            throw new FS.ErrnoError(ERRNO_CODES.ENODEV);
          }
          stream.tty = tty;
          stream.seekable = false;
        },close:function (stream) {
          // flush any pending line data
          stream.tty.ops.flush(stream.tty);
        },flush:function (stream) {
          stream.tty.ops.flush(stream.tty);
        },read:function (stream, buffer, offset, length, pos /* ignored */) {
          if (!stream.tty || !stream.tty.ops.get_char) {
            throw new FS.ErrnoError(ERRNO_CODES.ENXIO);
          }
          var bytesRead = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = stream.tty.ops.get_char(stream.tty);
            } catch (e) {
              throw new FS.ErrnoError(ERRNO_CODES.EIO);
            }
            if (result === undefined && bytesRead === 0) {
              throw new FS.ErrnoError(ERRNO_CODES.EAGAIN);
            }
            if (result === null || result === undefined) break;
            bytesRead++;
            buffer[offset+i] = result;
          }
          if (bytesRead) {
            stream.node.timestamp = Date.now();
          }
          return bytesRead;
        },write:function (stream, buffer, offset, length, pos) {
          if (!stream.tty || !stream.tty.ops.put_char) {
            throw new FS.ErrnoError(ERRNO_CODES.ENXIO);
          }
          for (var i = 0; i < length; i++) {
            try {
              stream.tty.ops.put_char(stream.tty, buffer[offset+i]);
            } catch (e) {
              throw new FS.ErrnoError(ERRNO_CODES.EIO);
            }
          }
          if (length) {
            stream.node.timestamp = Date.now();
          }
          return i;
        }},default_tty_ops:{get_char:function (tty) {
          if (!tty.input.length) {
            var result = null;
            if (ENVIRONMENT_IS_NODE) {
              result = process['stdin']['read']();
              if (!result) {
                if (process['stdin']['_readableState'] && process['stdin']['_readableState']['ended']) {
                  return null;  // EOF
                }
                return undefined;  // no data available
              }
            } else if (typeof window != 'undefined' &&
              typeof window.prompt == 'function') {
              // Browser.
              result = window.prompt('Input: ');  // returns null on cancel
              if (result !== null) {
                result += '\n';
              }
            } else if (typeof readline == 'function') {
              // Command line.
              result = readline();
              if (result !== null) {
                result += '\n';
              }
            }
            if (!result) {
              return null;
            }
            tty.input = intArrayFromString(result, true);
          }
          return tty.input.shift();
        },put_char:function (tty, val) {
          if (val === null || val === 10) {
            Module['print'](UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          } else {
            if (val != 0) tty.output.push(val); // val == 0 would cut text output off in the middle.
          }
        },flush:function (tty) {
          if (tty.output && tty.output.length > 0) {
            Module['print'](UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          }
        }},default_tty1_ops:{put_char:function (tty, val) {
          if (val === null || val === 10) {
            Module['printErr'](UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          } else {
            if (val != 0) tty.output.push(val);
          }
        },flush:function (tty) {
          if (tty.output && tty.output.length > 0) {
            Module['printErr'](UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          }
        }}};
  
  var MEMFS={ops_table:null,mount:function (mount) {
        return MEMFS.createNode(null, '/', 16384 | 511 /* 0777 */, 0);
      },createNode:function (parent, name, mode, dev) {
        if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
          // no supported
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        if (!MEMFS.ops_table) {
          MEMFS.ops_table = {
            dir: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr,
                lookup: MEMFS.node_ops.lookup,
                mknod: MEMFS.node_ops.mknod,
                rename: MEMFS.node_ops.rename,
                unlink: MEMFS.node_ops.unlink,
                rmdir: MEMFS.node_ops.rmdir,
                readdir: MEMFS.node_ops.readdir,
                symlink: MEMFS.node_ops.symlink
              },
              stream: {
                llseek: MEMFS.stream_ops.llseek
              }
            },
            file: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr
              },
              stream: {
                llseek: MEMFS.stream_ops.llseek,
                read: MEMFS.stream_ops.read,
                write: MEMFS.stream_ops.write,
                allocate: MEMFS.stream_ops.allocate,
                mmap: MEMFS.stream_ops.mmap
              }
            },
            link: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr,
                readlink: MEMFS.node_ops.readlink
              },
              stream: {}
            },
            chrdev: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr
              },
              stream: FS.chrdev_stream_ops
            }
          };
        }
        var node = FS.createNode(parent, name, mode, dev);
        if (FS.isDir(node.mode)) {
          node.node_ops = MEMFS.ops_table.dir.node;
          node.stream_ops = MEMFS.ops_table.dir.stream;
          node.contents = {};
        } else if (FS.isFile(node.mode)) {
          node.node_ops = MEMFS.ops_table.file.node;
          node.stream_ops = MEMFS.ops_table.file.stream;
          node.usedBytes = 0; // The actual number of bytes used in the typed array, as opposed to contents.buffer.byteLength which gives the whole capacity.
          // When the byte data of the file is populated, this will point to either a typed array, or a normal JS array. Typed arrays are preferred
          // for performance, and used by default. However, typed arrays are not resizable like normal JS arrays are, so there is a small disk size
          // penalty involved for appending file writes that continuously grow a file similar to std::vector capacity vs used -scheme.
          node.contents = null; 
        } else if (FS.isLink(node.mode)) {
          node.node_ops = MEMFS.ops_table.link.node;
          node.stream_ops = MEMFS.ops_table.link.stream;
        } else if (FS.isChrdev(node.mode)) {
          node.node_ops = MEMFS.ops_table.chrdev.node;
          node.stream_ops = MEMFS.ops_table.chrdev.stream;
        }
        node.timestamp = Date.now();
        // add the new node to the parent
        if (parent) {
          parent.contents[name] = node;
        }
        return node;
      },getFileDataAsRegularArray:function (node) {
        if (node.contents && node.contents.subarray) {
          var arr = [];
          for (var i = 0; i < node.usedBytes; ++i) arr.push(node.contents[i]);
          return arr; // Returns a copy of the original data.
        }
        return node.contents; // No-op, the file contents are already in a JS array. Return as-is.
      },getFileDataAsTypedArray:function (node) {
        if (!node.contents) return new Uint8Array;
        if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes); // Make sure to not return excess unused bytes.
        return new Uint8Array(node.contents);
      },expandFileStorage:function (node, newCapacity) {
  
        // If we are asked to expand the size of a file that already exists, revert to using a standard JS array to store the file
        // instead of a typed array. This makes resizing the array more flexible because we can just .push() elements at the back to
        // increase the size.
        if (node.contents && node.contents.subarray && newCapacity > node.contents.length) {
          node.contents = MEMFS.getFileDataAsRegularArray(node);
          node.usedBytes = node.contents.length; // We might be writing to a lazy-loaded file which had overridden this property, so force-reset it.
        }
  
        if (!node.contents || node.contents.subarray) { // Keep using a typed array if creating a new storage, or if old one was a typed array as well.
          var prevCapacity = node.contents ? node.contents.buffer.byteLength : 0;
          if (prevCapacity >= newCapacity) return; // No need to expand, the storage was already large enough.
          // Don't expand strictly to the given requested limit if it's only a very small increase, but instead geometrically grow capacity.
          // For small filesizes (<1MB), perform size*2 geometric increase, but for large sizes, do a much more conservative size*1.125 increase to
          // avoid overshooting the allocation cap by a very large margin.
          var CAPACITY_DOUBLING_MAX = 1024 * 1024;
          newCapacity = Math.max(newCapacity, (prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2.0 : 1.125)) | 0);
          if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256); // At minimum allocate 256b for each file when expanding.
          var oldContents = node.contents;
          node.contents = new Uint8Array(newCapacity); // Allocate new storage.
          if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0); // Copy old data over to the new storage.
          return;
        }
        // Not using a typed array to back the file storage. Use a standard JS array instead.
        if (!node.contents && newCapacity > 0) node.contents = [];
        while (node.contents.length < newCapacity) node.contents.push(0);
      },resizeFileStorage:function (node, newSize) {
        if (node.usedBytes == newSize) return;
        if (newSize == 0) {
          node.contents = null; // Fully decommit when requesting a resize to zero.
          node.usedBytes = 0;
          return;
        }
  
        if (!node.contents || node.contents.subarray) { // Resize a typed array if that is being used as the backing store.
          var oldContents = node.contents;
          node.contents = new Uint8Array(new ArrayBuffer(newSize)); // Allocate new storage.
          if (oldContents) {
            node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes))); // Copy old data over to the new storage.
          }
          node.usedBytes = newSize;
          return;
        }
        // Backing with a JS array.
        if (!node.contents) node.contents = [];
        if (node.contents.length > newSize) node.contents.length = newSize;
        else while (node.contents.length < newSize) node.contents.push(0);
        node.usedBytes = newSize;
      },node_ops:{getattr:function (node) {
          var attr = {};
          // device numbers reuse inode numbers.
          attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
          attr.ino = node.id;
          attr.mode = node.mode;
          attr.nlink = 1;
          attr.uid = 0;
          attr.gid = 0;
          attr.rdev = node.rdev;
          if (FS.isDir(node.mode)) {
            attr.size = 4096;
          } else if (FS.isFile(node.mode)) {
            attr.size = node.usedBytes;
          } else if (FS.isLink(node.mode)) {
            attr.size = node.link.length;
          } else {
            attr.size = 0;
          }
          attr.atime = new Date(node.timestamp);
          attr.mtime = new Date(node.timestamp);
          attr.ctime = new Date(node.timestamp);
          // NOTE: In our implementation, st_blocks = Math.ceil(st_size/st_blksize),
          //       but this is not required by the standard.
          attr.blksize = 4096;
          attr.blocks = Math.ceil(attr.size / attr.blksize);
          return attr;
        },setattr:function (node, attr) {
          if (attr.mode !== undefined) {
            node.mode = attr.mode;
          }
          if (attr.timestamp !== undefined) {
            node.timestamp = attr.timestamp;
          }
          if (attr.size !== undefined) {
            MEMFS.resizeFileStorage(node, attr.size);
          }
        },lookup:function (parent, name) {
          throw FS.genericErrors[ERRNO_CODES.ENOENT];
        },mknod:function (parent, name, mode, dev) {
          return MEMFS.createNode(parent, name, mode, dev);
        },rename:function (old_node, new_dir, new_name) {
          // if we're overwriting a directory at new_name, make sure it's empty.
          if (FS.isDir(old_node.mode)) {
            var new_node;
            try {
              new_node = FS.lookupNode(new_dir, new_name);
            } catch (e) {
            }
            if (new_node) {
              for (var i in new_node.contents) {
                throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY);
              }
            }
          }
          // do the internal rewiring
          delete old_node.parent.contents[old_node.name];
          old_node.name = new_name;
          new_dir.contents[new_name] = old_node;
          old_node.parent = new_dir;
        },unlink:function (parent, name) {
          delete parent.contents[name];
        },rmdir:function (parent, name) {
          var node = FS.lookupNode(parent, name);
          for (var i in node.contents) {
            throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY);
          }
          delete parent.contents[name];
        },readdir:function (node) {
          var entries = ['.', '..']
          for (var key in node.contents) {
            if (!node.contents.hasOwnProperty(key)) {
              continue;
            }
            entries.push(key);
          }
          return entries;
        },symlink:function (parent, newname, oldpath) {
          var node = MEMFS.createNode(parent, newname, 511 /* 0777 */ | 40960, 0);
          node.link = oldpath;
          return node;
        },readlink:function (node) {
          if (!FS.isLink(node.mode)) {
            throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
          }
          return node.link;
        }},stream_ops:{read:function (stream, buffer, offset, length, position) {
          var contents = stream.node.contents;
          if (position >= stream.node.usedBytes) return 0;
          var size = Math.min(stream.node.usedBytes - position, length);
          assert(size >= 0);
          if (size > 8 && contents.subarray) { // non-trivial, and typed array
            buffer.set(contents.subarray(position, position + size), offset);
          } else
          {
            for (var i = 0; i < size; i++) buffer[offset + i] = contents[position + i];
          }
          return size;
        },write:function (stream, buffer, offset, length, position, canOwn) {
          if (!length) return 0;
          var node = stream.node;
          node.timestamp = Date.now();
  
          if (buffer.subarray && (!node.contents || node.contents.subarray)) { // This write is from a typed array to a typed array?
            if (canOwn) { // Can we just reuse the buffer we are given?
              assert(position === 0, 'canOwn must imply no weird position inside the file');
              node.contents = buffer.subarray(offset, offset + length);
              node.usedBytes = length;
              return length;
            } else if (node.usedBytes === 0 && position === 0) { // If this is a simple first write to an empty file, do a fast set since we don't need to care about old data.
              node.contents = new Uint8Array(buffer.subarray(offset, offset + length));
              node.usedBytes = length;
              return length;
            } else if (position + length <= node.usedBytes) { // Writing to an already allocated and used subrange of the file?
              node.contents.set(buffer.subarray(offset, offset + length), position);
              return length;
            }
          }
          // Appending to an existing file and we need to reallocate, or source data did not come as a typed array.
          MEMFS.expandFileStorage(node, position+length);
          if (node.contents.subarray && buffer.subarray) node.contents.set(buffer.subarray(offset, offset + length), position); // Use typed array write if available.
          else
            for (var i = 0; i < length; i++) {
             node.contents[position + i] = buffer[offset + i]; // Or fall back to manual write if not.
            }
          node.usedBytes = Math.max(node.usedBytes, position+length);
          return length;
        },llseek:function (stream, offset, whence) {
          var position = offset;
          if (whence === 1) {  // SEEK_CUR.
            position += stream.position;
          } else if (whence === 2) {  // SEEK_END.
            if (FS.isFile(stream.node.mode)) {
              position += stream.node.usedBytes;
            }
          }
          if (position < 0) {
            throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
          }
          return position;
        },allocate:function (stream, offset, length) {
          MEMFS.expandFileStorage(stream.node, offset + length);
          stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);
        },mmap:function (stream, buffer, offset, length, position, prot, flags) {
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(ERRNO_CODES.ENODEV);
          }
          var ptr;
          var allocated;
          var contents = stream.node.contents;
          // Only make a new copy when MAP_PRIVATE is specified.
          if ( !(flags & 2) &&
                (contents.buffer === buffer || contents.buffer === buffer.buffer) ) {
            // We can't emulate MAP_SHARED when the file is not backed by the buffer
            // we're mapping to (e.g. the HEAP buffer).
            allocated = false;
            ptr = contents.byteOffset;
          } else {
            // Try to avoid unnecessary slices.
            if (position > 0 || position + length < stream.node.usedBytes) {
              if (contents.subarray) {
                contents = contents.subarray(position, position + length);
              } else {
                contents = Array.prototype.slice.call(contents, position, position + length);
              }
            }
            allocated = true;
            ptr = _malloc(length);
            if (!ptr) {
              throw new FS.ErrnoError(ERRNO_CODES.ENOMEM);
            }
            buffer.set(contents, ptr);
          }
          return { ptr: ptr, allocated: allocated };
        }}};
  
  var IDBFS={dbs:{},indexedDB:function () {
        if (typeof indexedDB !== 'undefined') return indexedDB;
        var ret = null;
        if (typeof window === 'object') ret = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
        assert(ret, 'IDBFS used, but indexedDB not supported');
        return ret;
      },DB_VERSION:21,DB_STORE_NAME:"FILE_DATA",mount:function (mount) {
        // reuse all of the core MEMFS functionality
        return MEMFS.mount.apply(null, arguments);
      },syncfs:function (mount, populate, callback) {
        IDBFS.getLocalSet(mount, function(err, local) {
          if (err) return callback(err);
  
          IDBFS.getRemoteSet(mount, function(err, remote) {
            if (err) return callback(err);
  
            var src = populate ? remote : local;
            var dst = populate ? local : remote;
  
            IDBFS.reconcile(src, dst, callback);
          });
        });
      },getDB:function (name, callback) {
        // check the cache first
        var db = IDBFS.dbs[name];
        if (db) {
          return callback(null, db);
        }
  
        var req;
        try {
          req = IDBFS.indexedDB().open(name, IDBFS.DB_VERSION);
        } catch (e) {
          return callback(e);
        }
        req.onupgradeneeded = function(e) {
          var db = e.target.result;
          var transaction = e.target.transaction;
  
          var fileStore;
  
          if (db.objectStoreNames.contains(IDBFS.DB_STORE_NAME)) {
            fileStore = transaction.objectStore(IDBFS.DB_STORE_NAME);
          } else {
            fileStore = db.createObjectStore(IDBFS.DB_STORE_NAME);
          }
  
          if (!fileStore.indexNames.contains('timestamp')) {
            fileStore.createIndex('timestamp', 'timestamp', { unique: false });
          }
        };
        req.onsuccess = function() {
          db = req.result;
  
          // add to the cache
          IDBFS.dbs[name] = db;
          callback(null, db);
        };
        req.onerror = function(e) {
          callback(this.error);
          e.preventDefault();
        };
      },getLocalSet:function (mount, callback) {
        var entries = {};
  
        function isRealDir(p) {
          return p !== '.' && p !== '..';
        };
        function toAbsolute(root) {
          return function(p) {
            return PATH.join2(root, p);
          }
        };
  
        var check = FS.readdir(mount.mountpoint).filter(isRealDir).map(toAbsolute(mount.mountpoint));
  
        while (check.length) {
          var path = check.pop();
          var stat;
  
          try {
            stat = FS.stat(path);
          } catch (e) {
            return callback(e);
          }
  
          if (FS.isDir(stat.mode)) {
            check.push.apply(check, FS.readdir(path).filter(isRealDir).map(toAbsolute(path)));
          }
  
          entries[path] = { timestamp: stat.mtime };
        }
  
        return callback(null, { type: 'local', entries: entries });
      },getRemoteSet:function (mount, callback) {
        var entries = {};
  
        IDBFS.getDB(mount.mountpoint, function(err, db) {
          if (err) return callback(err);
  
          var transaction = db.transaction([IDBFS.DB_STORE_NAME], 'readonly');
          transaction.onerror = function(e) {
            callback(this.error);
            e.preventDefault();
          };
  
          var store = transaction.objectStore(IDBFS.DB_STORE_NAME);
          var index = store.index('timestamp');
  
          index.openKeyCursor().onsuccess = function(event) {
            var cursor = event.target.result;
  
            if (!cursor) {
              return callback(null, { type: 'remote', db: db, entries: entries });
            }
  
            entries[cursor.primaryKey] = { timestamp: cursor.key };
  
            cursor.continue();
          };
        });
      },loadLocalEntry:function (path, callback) {
        var stat, node;
  
        try {
          var lookup = FS.lookupPath(path);
          node = lookup.node;
          stat = FS.stat(path);
        } catch (e) {
          return callback(e);
        }
  
        if (FS.isDir(stat.mode)) {
          return callback(null, { timestamp: stat.mtime, mode: stat.mode });
        } else if (FS.isFile(stat.mode)) {
          // Performance consideration: storing a normal JavaScript array to a IndexedDB is much slower than storing a typed array.
          // Therefore always convert the file contents to a typed array first before writing the data to IndexedDB.
          node.contents = MEMFS.getFileDataAsTypedArray(node);
          return callback(null, { timestamp: stat.mtime, mode: stat.mode, contents: node.contents });
        } else {
          return callback(new Error('node type not supported'));
        }
      },storeLocalEntry:function (path, entry, callback) {
        try {
          if (FS.isDir(entry.mode)) {
            FS.mkdir(path, entry.mode);
          } else if (FS.isFile(entry.mode)) {
            FS.writeFile(path, entry.contents, { encoding: 'binary', canOwn: true });
          } else {
            return callback(new Error('node type not supported'));
          }
  
          FS.chmod(path, entry.mode);
          FS.utime(path, entry.timestamp, entry.timestamp);
        } catch (e) {
          return callback(e);
        }
  
        callback(null);
      },removeLocalEntry:function (path, callback) {
        try {
          var lookup = FS.lookupPath(path);
          var stat = FS.stat(path);
  
          if (FS.isDir(stat.mode)) {
            FS.rmdir(path);
          } else if (FS.isFile(stat.mode)) {
            FS.unlink(path);
          }
        } catch (e) {
          return callback(e);
        }
  
        callback(null);
      },loadRemoteEntry:function (store, path, callback) {
        var req = store.get(path);
        req.onsuccess = function(event) { callback(null, event.target.result); };
        req.onerror = function(e) {
          callback(this.error);
          e.preventDefault();
        };
      },storeRemoteEntry:function (store, path, entry, callback) {
        var req = store.put(entry, path);
        req.onsuccess = function() { callback(null); };
        req.onerror = function(e) {
          callback(this.error);
          e.preventDefault();
        };
      },removeRemoteEntry:function (store, path, callback) {
        var req = store.delete(path);
        req.onsuccess = function() { callback(null); };
        req.onerror = function(e) {
          callback(this.error);
          e.preventDefault();
        };
      },reconcile:function (src, dst, callback) {
        var total = 0;
  
        var create = [];
        Object.keys(src.entries).forEach(function (key) {
          var e = src.entries[key];
          var e2 = dst.entries[key];
          if (!e2 || e.timestamp > e2.timestamp) {
            create.push(key);
            total++;
          }
        });
  
        var remove = [];
        Object.keys(dst.entries).forEach(function (key) {
          var e = dst.entries[key];
          var e2 = src.entries[key];
          if (!e2) {
            remove.push(key);
            total++;
          }
        });
  
        if (!total) {
          return callback(null);
        }
  
        var errored = false;
        var completed = 0;
        var db = src.type === 'remote' ? src.db : dst.db;
        var transaction = db.transaction([IDBFS.DB_STORE_NAME], 'readwrite');
        var store = transaction.objectStore(IDBFS.DB_STORE_NAME);
  
        function done(err) {
          if (err) {
            if (!done.errored) {
              done.errored = true;
              return callback(err);
            }
            return;
          }
          if (++completed >= total) {
            return callback(null);
          }
        };
  
        transaction.onerror = function(e) {
          done(this.error);
          e.preventDefault();
        };
  
        // sort paths in ascending order so directory entries are created
        // before the files inside them
        create.sort().forEach(function (path) {
          if (dst.type === 'local') {
            IDBFS.loadRemoteEntry(store, path, function (err, entry) {
              if (err) return done(err);
              IDBFS.storeLocalEntry(path, entry, done);
            });
          } else {
            IDBFS.loadLocalEntry(path, function (err, entry) {
              if (err) return done(err);
              IDBFS.storeRemoteEntry(store, path, entry, done);
            });
          }
        });
  
        // sort paths in descending order so files are deleted before their
        // parent directories
        remove.sort().reverse().forEach(function(path) {
          if (dst.type === 'local') {
            IDBFS.removeLocalEntry(path, done);
          } else {
            IDBFS.removeRemoteEntry(store, path, done);
          }
        });
      }};
  
  var NODEFS={isWindows:false,staticInit:function () {
        NODEFS.isWindows = !!process.platform.match(/^win/);
      },mount:function (mount) {
        assert(ENVIRONMENT_IS_NODE);
        return NODEFS.createNode(null, '/', NODEFS.getMode(mount.opts.root), 0);
      },createNode:function (parent, name, mode, dev) {
        if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        var node = FS.createNode(parent, name, mode);
        node.node_ops = NODEFS.node_ops;
        node.stream_ops = NODEFS.stream_ops;
        return node;
      },getMode:function (path) {
        var stat;
        try {
          stat = fs.lstatSync(path);
          if (NODEFS.isWindows) {
            // On Windows, directories return permission bits 'rw-rw-rw-', even though they have 'rwxrwxrwx', so 
            // propagate write bits to execute bits.
            stat.mode = stat.mode | ((stat.mode & 146) >> 1);
          }
        } catch (e) {
          if (!e.code) throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
        return stat.mode;
      },realPath:function (node) {
        var parts = [];
        while (node.parent !== node) {
          parts.push(node.name);
          node = node.parent;
        }
        parts.push(node.mount.opts.root);
        parts.reverse();
        return PATH.join.apply(null, parts);
      },flagsToPermissionStringMap:{0:"r",1:"r+",2:"r+",64:"r",65:"r+",66:"r+",129:"rx+",193:"rx+",514:"w+",577:"w",578:"w+",705:"wx",706:"wx+",1024:"a",1025:"a",1026:"a+",1089:"a",1090:"a+",1153:"ax",1154:"ax+",1217:"ax",1218:"ax+",4096:"rs",4098:"rs+"},flagsToPermissionString:function (flags) {
        if (flags in NODEFS.flagsToPermissionStringMap) {
          return NODEFS.flagsToPermissionStringMap[flags];
        } else {
          return flags;
        }
      },node_ops:{getattr:function (node) {
          var path = NODEFS.realPath(node);
          var stat;
          try {
            stat = fs.lstatSync(path);
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
          // node.js v0.10.20 doesn't report blksize and blocks on Windows. Fake them with default blksize of 4096.
          // See http://support.microsoft.com/kb/140365
          if (NODEFS.isWindows && !stat.blksize) {
            stat.blksize = 4096;
          }
          if (NODEFS.isWindows && !stat.blocks) {
            stat.blocks = (stat.size+stat.blksize-1)/stat.blksize|0;
          }
          return {
            dev: stat.dev,
            ino: stat.ino,
            mode: stat.mode,
            nlink: stat.nlink,
            uid: stat.uid,
            gid: stat.gid,
            rdev: stat.rdev,
            size: stat.size,
            atime: stat.atime,
            mtime: stat.mtime,
            ctime: stat.ctime,
            blksize: stat.blksize,
            blocks: stat.blocks
          };
        },setattr:function (node, attr) {
          var path = NODEFS.realPath(node);
          try {
            if (attr.mode !== undefined) {
              fs.chmodSync(path, attr.mode);
              // update the common node structure mode as well
              node.mode = attr.mode;
            }
            if (attr.timestamp !== undefined) {
              var date = new Date(attr.timestamp);
              fs.utimesSync(path, date, date);
            }
            if (attr.size !== undefined) {
              fs.truncateSync(path, attr.size);
            }
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
        },lookup:function (parent, name) {
          var path = PATH.join2(NODEFS.realPath(parent), name);
          var mode = NODEFS.getMode(path);
          return NODEFS.createNode(parent, name, mode);
        },mknod:function (parent, name, mode, dev) {
          var node = NODEFS.createNode(parent, name, mode, dev);
          // create the backing node for this in the fs root as well
          var path = NODEFS.realPath(node);
          try {
            if (FS.isDir(node.mode)) {
              fs.mkdirSync(path, node.mode);
            } else {
              fs.writeFileSync(path, '', { mode: node.mode });
            }
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
          return node;
        },rename:function (oldNode, newDir, newName) {
          var oldPath = NODEFS.realPath(oldNode);
          var newPath = PATH.join2(NODEFS.realPath(newDir), newName);
          try {
            fs.renameSync(oldPath, newPath);
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
        },unlink:function (parent, name) {
          var path = PATH.join2(NODEFS.realPath(parent), name);
          try {
            fs.unlinkSync(path);
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
        },rmdir:function (parent, name) {
          var path = PATH.join2(NODEFS.realPath(parent), name);
          try {
            fs.rmdirSync(path);
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
        },readdir:function (node) {
          var path = NODEFS.realPath(node);
          try {
            return fs.readdirSync(path);
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
        },symlink:function (parent, newName, oldPath) {
          var newPath = PATH.join2(NODEFS.realPath(parent), newName);
          try {
            fs.symlinkSync(oldPath, newPath);
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
        },readlink:function (node) {
          var path = NODEFS.realPath(node);
          try {
            return fs.readlinkSync(path);
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
        }},stream_ops:{open:function (stream) {
          var path = NODEFS.realPath(stream.node);
          try {
            if (FS.isFile(stream.node.mode)) {
              stream.nfd = fs.openSync(path, NODEFS.flagsToPermissionString(stream.flags));
            }
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
        },close:function (stream) {
          try {
            if (FS.isFile(stream.node.mode) && stream.nfd) {
              fs.closeSync(stream.nfd);
            }
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
        },read:function (stream, buffer, offset, length, position) {
          if (length === 0) return 0; // node errors on 0 length reads
          // FIXME this is terrible.
          var nbuffer = new Buffer(length);
          var res;
          try {
            res = fs.readSync(stream.nfd, nbuffer, 0, length, position);
          } catch (e) {
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
          if (res > 0) {
            for (var i = 0; i < res; i++) {
              buffer[offset + i] = nbuffer[i];
            }
          }
          return res;
        },write:function (stream, buffer, offset, length, position) {
          // FIXME this is terrible.
          var nbuffer = new Buffer(buffer.subarray(offset, offset + length));
          var res;
          try {
            res = fs.writeSync(stream.nfd, nbuffer, 0, length, position);
          } catch (e) {
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
          return res;
        },llseek:function (stream, offset, whence) {
          var position = offset;
          if (whence === 1) {  // SEEK_CUR.
            position += stream.position;
          } else if (whence === 2) {  // SEEK_END.
            if (FS.isFile(stream.node.mode)) {
              try {
                var stat = fs.fstatSync(stream.nfd);
                position += stat.size;
              } catch (e) {
                throw new FS.ErrnoError(ERRNO_CODES[e.code]);
              }
            }
          }
  
          if (position < 0) {
            throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
          }
  
          return position;
        }}};
  
  var _stdin=allocate(1, "i32*", ALLOC_STATIC);
  
  var _stdout=allocate(1, "i32*", ALLOC_STATIC);
  
  var _stderr=allocate(1, "i32*", ALLOC_STATIC);
  
  function _fflush(stream) {
      // int fflush(FILE *stream);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/fflush.html
  
      /*
      // Disabled, see https://github.com/kripken/emscripten/issues/2770
      stream = FS.getStreamFromPtr(stream);
      if (stream.stream_ops.flush) {
        stream.stream_ops.flush(stream);
      }
      */
    }var FS={root:null,mounts:[],devices:[null],streams:[],nextInode:1,nameTable:null,currentPath:"/",initialized:false,ignorePermissions:true,trackingDelegate:{},tracking:{openFlags:{READ:1,WRITE:2}},ErrnoError:null,genericErrors:{},handleFSError:function (e) {
        if (!(e instanceof FS.ErrnoError)) throw e + ' : ' + stackTrace();
        return ___setErrNo(e.errno);
      },lookupPath:function (path, opts) {
        path = PATH.resolve(FS.cwd(), path);
        opts = opts || {};
  
        if (!path) return { path: '', node: null };
  
        var defaults = {
          follow_mount: true,
          recurse_count: 0
        };
        for (var key in defaults) {
          if (opts[key] === undefined) {
            opts[key] = defaults[key];
          }
        }
  
        if (opts.recurse_count > 8) {  // max recursive lookup of 8
          throw new FS.ErrnoError(ERRNO_CODES.ELOOP);
        }
  
        // split the path
        var parts = PATH.normalizeArray(path.split('/').filter(function(p) {
          return !!p;
        }), false);
  
        // start at the root
        var current = FS.root;
        var current_path = '/';
  
        for (var i = 0; i < parts.length; i++) {
          var islast = (i === parts.length-1);
          if (islast && opts.parent) {
            // stop resolving
            break;
          }
  
          current = FS.lookupNode(current, parts[i]);
          current_path = PATH.join2(current_path, parts[i]);
  
          // jump to the mount's root node if this is a mountpoint
          if (FS.isMountpoint(current)) {
            if (!islast || (islast && opts.follow_mount)) {
              current = current.mounted.root;
            }
          }
  
          // by default, lookupPath will not follow a symlink if it is the final path component.
          // setting opts.follow = true will override this behavior.
          if (!islast || opts.follow) {
            var count = 0;
            while (FS.isLink(current.mode)) {
              var link = FS.readlink(current_path);
              current_path = PATH.resolve(PATH.dirname(current_path), link);
              
              var lookup = FS.lookupPath(current_path, { recurse_count: opts.recurse_count });
              current = lookup.node;
  
              if (count++ > 40) {  // limit max consecutive symlinks to 40 (SYMLOOP_MAX).
                throw new FS.ErrnoError(ERRNO_CODES.ELOOP);
              }
            }
          }
        }
  
        return { path: current_path, node: current };
      },getPath:function (node) {
        var path;
        while (true) {
          if (FS.isRoot(node)) {
            var mount = node.mount.mountpoint;
            if (!path) return mount;
            return mount[mount.length-1] !== '/' ? mount + '/' + path : mount + path;
          }
          path = path ? node.name + '/' + path : node.name;
          node = node.parent;
        }
      },hashName:function (parentid, name) {
        var hash = 0;
  
  
        for (var i = 0; i < name.length; i++) {
          hash = ((hash << 5) - hash + name.charCodeAt(i)) | 0;
        }
        return ((parentid + hash) >>> 0) % FS.nameTable.length;
      },hashAddNode:function (node) {
        var hash = FS.hashName(node.parent.id, node.name);
        node.name_next = FS.nameTable[hash];
        FS.nameTable[hash] = node;
      },hashRemoveNode:function (node) {
        var hash = FS.hashName(node.parent.id, node.name);
        if (FS.nameTable[hash] === node) {
          FS.nameTable[hash] = node.name_next;
        } else {
          var current = FS.nameTable[hash];
          while (current) {
            if (current.name_next === node) {
              current.name_next = node.name_next;
              break;
            }
            current = current.name_next;
          }
        }
      },lookupNode:function (parent, name) {
        var err = FS.mayLookup(parent);
        if (err) {
          throw new FS.ErrnoError(err, parent);
        }
        var hash = FS.hashName(parent.id, name);
        for (var node = FS.nameTable[hash]; node; node = node.name_next) {
          var nodeName = node.name;
          if (node.parent.id === parent.id && nodeName === name) {
            return node;
          }
        }
        // if we failed to find it in the cache, call into the VFS
        return FS.lookup(parent, name);
      },createNode:function (parent, name, mode, rdev) {
        if (!FS.FSNode) {
          FS.FSNode = function(parent, name, mode, rdev) {
            if (!parent) {
              parent = this;  // root node sets parent to itself
            }
            this.parent = parent;
            this.mount = parent.mount;
            this.mounted = null;
            this.id = FS.nextInode++;
            this.name = name;
            this.mode = mode;
            this.node_ops = {};
            this.stream_ops = {};
            this.rdev = rdev;
          };
  
          FS.FSNode.prototype = {};
  
          // compatibility
          var readMode = 292 | 73;
          var writeMode = 146;
  
          // NOTE we must use Object.defineProperties instead of individual calls to
          // Object.defineProperty in order to make closure compiler happy
          Object.defineProperties(FS.FSNode.prototype, {
            read: {
              get: function() { return (this.mode & readMode) === readMode; },
              set: function(val) { val ? this.mode |= readMode : this.mode &= ~readMode; }
            },
            write: {
              get: function() { return (this.mode & writeMode) === writeMode; },
              set: function(val) { val ? this.mode |= writeMode : this.mode &= ~writeMode; }
            },
            isFolder: {
              get: function() { return FS.isDir(this.mode); }
            },
            isDevice: {
              get: function() { return FS.isChrdev(this.mode); }
            }
          });
        }
  
        var node = new FS.FSNode(parent, name, mode, rdev);
  
        FS.hashAddNode(node);
  
        return node;
      },destroyNode:function (node) {
        FS.hashRemoveNode(node);
      },isRoot:function (node) {
        return node === node.parent;
      },isMountpoint:function (node) {
        return !!node.mounted;
      },isFile:function (mode) {
        return (mode & 61440) === 32768;
      },isDir:function (mode) {
        return (mode & 61440) === 16384;
      },isLink:function (mode) {
        return (mode & 61440) === 40960;
      },isChrdev:function (mode) {
        return (mode & 61440) === 8192;
      },isBlkdev:function (mode) {
        return (mode & 61440) === 24576;
      },isFIFO:function (mode) {
        return (mode & 61440) === 4096;
      },isSocket:function (mode) {
        return (mode & 49152) === 49152;
      },flagModes:{"r":0,"rs":1052672,"r+":2,"w":577,"wx":705,"xw":705,"w+":578,"wx+":706,"xw+":706,"a":1089,"ax":1217,"xa":1217,"a+":1090,"ax+":1218,"xa+":1218},modeStringToFlags:function (str) {
        var flags = FS.flagModes[str];
        if (typeof flags === 'undefined') {
          throw new Error('Unknown file open mode: ' + str);
        }
        return flags;
      },flagsToPermissionString:function (flag) {
        var accmode = flag & 2097155;
        var perms = ['r', 'w', 'rw'][accmode];
        if ((flag & 512)) {
          perms += 'w';
        }
        return perms;
      },nodePermissions:function (node, perms) {
        if (FS.ignorePermissions) {
          return 0;
        }
        // return 0 if any user, group or owner bits are set.
        if (perms.indexOf('r') !== -1 && !(node.mode & 292)) {
          return ERRNO_CODES.EACCES;
        } else if (perms.indexOf('w') !== -1 && !(node.mode & 146)) {
          return ERRNO_CODES.EACCES;
        } else if (perms.indexOf('x') !== -1 && !(node.mode & 73)) {
          return ERRNO_CODES.EACCES;
        }
        return 0;
      },mayLookup:function (dir) {
        var err = FS.nodePermissions(dir, 'x');
        if (err) return err;
        if (!dir.node_ops.lookup) return ERRNO_CODES.EACCES;
        return 0;
      },mayCreate:function (dir, name) {
        try {
          var node = FS.lookupNode(dir, name);
          return ERRNO_CODES.EEXIST;
        } catch (e) {
        }
        return FS.nodePermissions(dir, 'wx');
      },mayDelete:function (dir, name, isdir) {
        var node;
        try {
          node = FS.lookupNode(dir, name);
        } catch (e) {
          return e.errno;
        }
        var err = FS.nodePermissions(dir, 'wx');
        if (err) {
          return err;
        }
        if (isdir) {
          if (!FS.isDir(node.mode)) {
            return ERRNO_CODES.ENOTDIR;
          }
          if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
            return ERRNO_CODES.EBUSY;
          }
        } else {
          if (FS.isDir(node.mode)) {
            return ERRNO_CODES.EISDIR;
          }
        }
        return 0;
      },mayOpen:function (node, flags) {
        if (!node) {
          return ERRNO_CODES.ENOENT;
        }
        if (FS.isLink(node.mode)) {
          return ERRNO_CODES.ELOOP;
        } else if (FS.isDir(node.mode)) {
          if ((flags & 2097155) !== 0 ||  // opening for write
              (flags & 512)) {
            return ERRNO_CODES.EISDIR;
          }
        }
        return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
      },MAX_OPEN_FDS:4096,nextfd:function (fd_start, fd_end) {
        fd_start = fd_start || 0;
        fd_end = fd_end || FS.MAX_OPEN_FDS;
        for (var fd = fd_start; fd <= fd_end; fd++) {
          if (!FS.streams[fd]) {
            return fd;
          }
        }
        throw new FS.ErrnoError(ERRNO_CODES.EMFILE);
      },getStream:function (fd) {
        return FS.streams[fd];
      },createStream:function (stream, fd_start, fd_end) {
        if (!FS.FSStream) {
          FS.FSStream = function(){};
          FS.FSStream.prototype = {};
          // compatibility
          Object.defineProperties(FS.FSStream.prototype, {
            object: {
              get: function() { return this.node; },
              set: function(val) { this.node = val; }
            },
            isRead: {
              get: function() { return (this.flags & 2097155) !== 1; }
            },
            isWrite: {
              get: function() { return (this.flags & 2097155) !== 0; }
            },
            isAppend: {
              get: function() { return (this.flags & 1024); }
            }
          });
        }
        // clone it, so we can return an instance of FSStream
        var newStream = new FS.FSStream();
        for (var p in stream) {
          newStream[p] = stream[p];
        }
        stream = newStream;
        var fd = FS.nextfd(fd_start, fd_end);
        stream.fd = fd;
        FS.streams[fd] = stream;
        return stream;
      },closeStream:function (fd) {
        FS.streams[fd] = null;
      },getStreamFromPtr:function (ptr) {
        return FS.streams[ptr - 1];
      },getPtrForStream:function (stream) {
        return stream ? stream.fd + 1 : 0;
      },chrdev_stream_ops:{open:function (stream) {
          var device = FS.getDevice(stream.node.rdev);
          // override node's stream ops with the device's
          stream.stream_ops = device.stream_ops;
          // forward the open call
          if (stream.stream_ops.open) {
            stream.stream_ops.open(stream);
          }
        },llseek:function () {
          throw new FS.ErrnoError(ERRNO_CODES.ESPIPE);
        }},major:function (dev) {
        return ((dev) >> 8);
      },minor:function (dev) {
        return ((dev) & 0xff);
      },makedev:function (ma, mi) {
        return ((ma) << 8 | (mi));
      },registerDevice:function (dev, ops) {
        FS.devices[dev] = { stream_ops: ops };
      },getDevice:function (dev) {
        return FS.devices[dev];
      },getMounts:function (mount) {
        var mounts = [];
        var check = [mount];
  
        while (check.length) {
          var m = check.pop();
  
          mounts.push(m);
  
          check.push.apply(check, m.mounts);
        }
  
        return mounts;
      },syncfs:function (populate, callback) {
        if (typeof(populate) === 'function') {
          callback = populate;
          populate = false;
        }
  
        var mounts = FS.getMounts(FS.root.mount);
        var completed = 0;
  
        function done(err) {
          if (err) {
            if (!done.errored) {
              done.errored = true;
              return callback(err);
            }
            return;
          }
          if (++completed >= mounts.length) {
            callback(null);
          }
        };
  
        // sync all mounts
        mounts.forEach(function (mount) {
          if (!mount.type.syncfs) {
            return done(null);
          }
          mount.type.syncfs(mount, populate, done);
        });
      },mount:function (type, opts, mountpoint) {
        var root = mountpoint === '/';
        var pseudo = !mountpoint;
        var node;
  
        if (root && FS.root) {
          throw new FS.ErrnoError(ERRNO_CODES.EBUSY);
        } else if (!root && !pseudo) {
          var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
  
          mountpoint = lookup.path;  // use the absolute path
          node = lookup.node;
  
          if (FS.isMountpoint(node)) {
            throw new FS.ErrnoError(ERRNO_CODES.EBUSY);
          }
  
          if (!FS.isDir(node.mode)) {
            throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR);
          }
        }
  
        var mount = {
          type: type,
          opts: opts,
          mountpoint: mountpoint,
          mounts: []
        };
  
        // create a root node for the fs
        var mountRoot = type.mount(mount);
        mountRoot.mount = mount;
        mount.root = mountRoot;
  
        if (root) {
          FS.root = mountRoot;
        } else if (node) {
          // set as a mountpoint
          node.mounted = mount;
  
          // add the new mount to the current mount's children
          if (node.mount) {
            node.mount.mounts.push(mount);
          }
        }
  
        return mountRoot;
      },unmount:function (mountpoint) {
        var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
  
        if (!FS.isMountpoint(lookup.node)) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
  
        // destroy the nodes for this mount, and all its child mounts
        var node = lookup.node;
        var mount = node.mounted;
        var mounts = FS.getMounts(mount);
  
        Object.keys(FS.nameTable).forEach(function (hash) {
          var current = FS.nameTable[hash];
  
          while (current) {
            var next = current.name_next;
  
            if (mounts.indexOf(current.mount) !== -1) {
              FS.destroyNode(current);
            }
  
            current = next;
          }
        });
  
        // no longer a mountpoint
        node.mounted = null;
  
        // remove this mount from the child mounts
        var idx = node.mount.mounts.indexOf(mount);
        assert(idx !== -1);
        node.mount.mounts.splice(idx, 1);
      },lookup:function (parent, name) {
        return parent.node_ops.lookup(parent, name);
      },mknod:function (path, mode, dev) {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        if (!name || name === '.' || name === '..') {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        var err = FS.mayCreate(parent, name);
        if (err) {
          throw new FS.ErrnoError(err);
        }
        if (!parent.node_ops.mknod) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        return parent.node_ops.mknod(parent, name, mode, dev);
      },create:function (path, mode) {
        mode = mode !== undefined ? mode : 438 /* 0666 */;
        mode &= 4095;
        mode |= 32768;
        return FS.mknod(path, mode, 0);
      },mkdir:function (path, mode) {
        mode = mode !== undefined ? mode : 511 /* 0777 */;
        mode &= 511 | 512;
        mode |= 16384;
        return FS.mknod(path, mode, 0);
      },mkdev:function (path, mode, dev) {
        if (typeof(dev) === 'undefined') {
          dev = mode;
          mode = 438 /* 0666 */;
        }
        mode |= 8192;
        return FS.mknod(path, mode, dev);
      },symlink:function (oldpath, newpath) {
        if (!PATH.resolve(oldpath)) {
          throw new FS.ErrnoError(ERRNO_CODES.ENOENT);
        }
        var lookup = FS.lookupPath(newpath, { parent: true });
        var parent = lookup.node;
        if (!parent) {
          throw new FS.ErrnoError(ERRNO_CODES.ENOENT);
        }
        var newname = PATH.basename(newpath);
        var err = FS.mayCreate(parent, newname);
        if (err) {
          throw new FS.ErrnoError(err);
        }
        if (!parent.node_ops.symlink) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        return parent.node_ops.symlink(parent, newname, oldpath);
      },rename:function (old_path, new_path) {
        var old_dirname = PATH.dirname(old_path);
        var new_dirname = PATH.dirname(new_path);
        var old_name = PATH.basename(old_path);
        var new_name = PATH.basename(new_path);
        // parents must exist
        var lookup, old_dir, new_dir;
        try {
          lookup = FS.lookupPath(old_path, { parent: true });
          old_dir = lookup.node;
          lookup = FS.lookupPath(new_path, { parent: true });
          new_dir = lookup.node;
        } catch (e) {
          throw new FS.ErrnoError(ERRNO_CODES.EBUSY);
        }
        if (!old_dir || !new_dir) throw new FS.ErrnoError(ERRNO_CODES.ENOENT);
        // need to be part of the same mount
        if (old_dir.mount !== new_dir.mount) {
          throw new FS.ErrnoError(ERRNO_CODES.EXDEV);
        }
        // source must exist
        var old_node = FS.lookupNode(old_dir, old_name);
        // old path should not be an ancestor of the new path
        var relative = PATH.relative(old_path, new_dirname);
        if (relative.charAt(0) !== '.') {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        // new path should not be an ancestor of the old path
        relative = PATH.relative(new_path, old_dirname);
        if (relative.charAt(0) !== '.') {
          throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY);
        }
        // see if the new path already exists
        var new_node;
        try {
          new_node = FS.lookupNode(new_dir, new_name);
        } catch (e) {
          // not fatal
        }
        // early out if nothing needs to change
        if (old_node === new_node) {
          return;
        }
        // we'll need to delete the old entry
        var isdir = FS.isDir(old_node.mode);
        var err = FS.mayDelete(old_dir, old_name, isdir);
        if (err) {
          throw new FS.ErrnoError(err);
        }
        // need delete permissions if we'll be overwriting.
        // need create permissions if new doesn't already exist.
        err = new_node ?
          FS.mayDelete(new_dir, new_name, isdir) :
          FS.mayCreate(new_dir, new_name);
        if (err) {
          throw new FS.ErrnoError(err);
        }
        if (!old_dir.node_ops.rename) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        if (FS.isMountpoint(old_node) || (new_node && FS.isMountpoint(new_node))) {
          throw new FS.ErrnoError(ERRNO_CODES.EBUSY);
        }
        // if we are going to change the parent, check write permissions
        if (new_dir !== old_dir) {
          err = FS.nodePermissions(old_dir, 'w');
          if (err) {
            throw new FS.ErrnoError(err);
          }
        }
        try {
          if (FS.trackingDelegate['willMovePath']) {
            FS.trackingDelegate['willMovePath'](old_path, new_path);
          }
        } catch(e) {
          console.log("FS.trackingDelegate['willMovePath']('"+old_path+"', '"+new_path+"') threw an exception: " + e.message);
        }
        // remove the node from the lookup hash
        FS.hashRemoveNode(old_node);
        // do the underlying fs rename
        try {
          old_dir.node_ops.rename(old_node, new_dir, new_name);
        } catch (e) {
          throw e;
        } finally {
          // add the node back to the hash (in case node_ops.rename
          // changed its name)
          FS.hashAddNode(old_node);
        }
        try {
          if (FS.trackingDelegate['onMovePath']) FS.trackingDelegate['onMovePath'](old_path, new_path);
        } catch(e) {
          console.log("FS.trackingDelegate['onMovePath']('"+old_path+"', '"+new_path+"') threw an exception: " + e.message);
        }
      },rmdir:function (path) {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        var node = FS.lookupNode(parent, name);
        var err = FS.mayDelete(parent, name, true);
        if (err) {
          throw new FS.ErrnoError(err);
        }
        if (!parent.node_ops.rmdir) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(ERRNO_CODES.EBUSY);
        }
        try {
          if (FS.trackingDelegate['willDeletePath']) {
            FS.trackingDelegate['willDeletePath'](path);
          }
        } catch(e) {
          console.log("FS.trackingDelegate['willDeletePath']('"+path+"') threw an exception: " + e.message);
        }
        parent.node_ops.rmdir(parent, name);
        FS.destroyNode(node);
        try {
          if (FS.trackingDelegate['onDeletePath']) FS.trackingDelegate['onDeletePath'](path);
        } catch(e) {
          console.log("FS.trackingDelegate['onDeletePath']('"+path+"') threw an exception: " + e.message);
        }
      },readdir:function (path) {
        var lookup = FS.lookupPath(path, { follow: true });
        var node = lookup.node;
        if (!node.node_ops.readdir) {
          throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR);
        }
        return node.node_ops.readdir(node);
      },unlink:function (path) {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        var node = FS.lookupNode(parent, name);
        var err = FS.mayDelete(parent, name, false);
        if (err) {
          // POSIX says unlink should set EPERM, not EISDIR
          if (err === ERRNO_CODES.EISDIR) err = ERRNO_CODES.EPERM;
          throw new FS.ErrnoError(err);
        }
        if (!parent.node_ops.unlink) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(ERRNO_CODES.EBUSY);
        }
        try {
          if (FS.trackingDelegate['willDeletePath']) {
            FS.trackingDelegate['willDeletePath'](path);
          }
        } catch(e) {
          console.log("FS.trackingDelegate['willDeletePath']('"+path+"') threw an exception: " + e.message);
        }
        parent.node_ops.unlink(parent, name);
        FS.destroyNode(node);
        try {
          if (FS.trackingDelegate['onDeletePath']) FS.trackingDelegate['onDeletePath'](path);
        } catch(e) {
          console.log("FS.trackingDelegate['onDeletePath']('"+path+"') threw an exception: " + e.message);
        }
      },readlink:function (path) {
        var lookup = FS.lookupPath(path);
        var link = lookup.node;
        if (!link) {
          throw new FS.ErrnoError(ERRNO_CODES.ENOENT);
        }
        if (!link.node_ops.readlink) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        return link.node_ops.readlink(link);
      },stat:function (path, dontFollow) {
        var lookup = FS.lookupPath(path, { follow: !dontFollow });
        var node = lookup.node;
        if (!node) {
          throw new FS.ErrnoError(ERRNO_CODES.ENOENT);
        }
        if (!node.node_ops.getattr) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        return node.node_ops.getattr(node);
      },lstat:function (path) {
        return FS.stat(path, true);
      },chmod:function (path, mode, dontFollow) {
        var node;
        if (typeof path === 'string') {
          var lookup = FS.lookupPath(path, { follow: !dontFollow });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        node.node_ops.setattr(node, {
          mode: (mode & 4095) | (node.mode & ~4095),
          timestamp: Date.now()
        });
      },lchmod:function (path, mode) {
        FS.chmod(path, mode, true);
      },fchmod:function (fd, mode) {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(ERRNO_CODES.EBADF);
        }
        FS.chmod(stream.node, mode);
      },chown:function (path, uid, gid, dontFollow) {
        var node;
        if (typeof path === 'string') {
          var lookup = FS.lookupPath(path, { follow: !dontFollow });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        node.node_ops.setattr(node, {
          timestamp: Date.now()
          // we ignore the uid / gid for now
        });
      },lchown:function (path, uid, gid) {
        FS.chown(path, uid, gid, true);
      },fchown:function (fd, uid, gid) {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(ERRNO_CODES.EBADF);
        }
        FS.chown(stream.node, uid, gid);
      },truncate:function (path, len) {
        if (len < 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        var node;
        if (typeof path === 'string') {
          var lookup = FS.lookupPath(path, { follow: true });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        if (FS.isDir(node.mode)) {
          throw new FS.ErrnoError(ERRNO_CODES.EISDIR);
        }
        if (!FS.isFile(node.mode)) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        var err = FS.nodePermissions(node, 'w');
        if (err) {
          throw new FS.ErrnoError(err);
        }
        node.node_ops.setattr(node, {
          size: len,
          timestamp: Date.now()
        });
      },ftruncate:function (fd, len) {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(ERRNO_CODES.EBADF);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        FS.truncate(stream.node, len);
      },utime:function (path, atime, mtime) {
        var lookup = FS.lookupPath(path, { follow: true });
        var node = lookup.node;
        node.node_ops.setattr(node, {
          timestamp: Math.max(atime, mtime)
        });
      },open:function (path, flags, mode, fd_start, fd_end) {
        if (path === "") {
          throw new FS.ErrnoError(ERRNO_CODES.ENOENT);
        }
        flags = typeof flags === 'string' ? FS.modeStringToFlags(flags) : flags;
        mode = typeof mode === 'undefined' ? 438 /* 0666 */ : mode;
        if ((flags & 64)) {
          mode = (mode & 4095) | 32768;
        } else {
          mode = 0;
        }
        var node;
        if (typeof path === 'object') {
          node = path;
        } else {
          path = PATH.normalize(path);
          try {
            var lookup = FS.lookupPath(path, {
              follow: !(flags & 131072)
            });
            node = lookup.node;
          } catch (e) {
            // ignore
          }
        }
        // perhaps we need to create the node
        var created = false;
        if ((flags & 64)) {
          if (node) {
            // if O_CREAT and O_EXCL are set, error out if the node already exists
            if ((flags & 128)) {
              throw new FS.ErrnoError(ERRNO_CODES.EEXIST);
            }
          } else {
            // node doesn't exist, try to create it
            node = FS.mknod(path, mode, 0);
            created = true;
          }
        }
        if (!node) {
          throw new FS.ErrnoError(ERRNO_CODES.ENOENT);
        }
        // can't truncate a device
        if (FS.isChrdev(node.mode)) {
          flags &= ~512;
        }
        // check permissions, if this is not a file we just created now (it is ok to
        // create and write to a file with read-only permissions; it is read-only
        // for later use)
        if (!created) {
          var err = FS.mayOpen(node, flags);
          if (err) {
            throw new FS.ErrnoError(err);
          }
        }
        // do truncation if necessary
        if ((flags & 512)) {
          FS.truncate(node, 0);
        }
        // we've already handled these, don't pass down to the underlying vfs
        flags &= ~(128 | 512);
  
        // register the stream with the filesystem
        var stream = FS.createStream({
          node: node,
          path: FS.getPath(node),  // we want the absolute path to the node
          flags: flags,
          seekable: true,
          position: 0,
          stream_ops: node.stream_ops,
          // used by the file family libc calls (fopen, fwrite, ferror, etc.)
          ungotten: [],
          error: false
        }, fd_start, fd_end);
        // call the new stream's open function
        if (stream.stream_ops.open) {
          stream.stream_ops.open(stream);
        }
        if (Module['logReadFiles'] && !(flags & 1)) {
          if (!FS.readFiles) FS.readFiles = {};
          if (!(path in FS.readFiles)) {
            FS.readFiles[path] = 1;
            Module['printErr']('read file: ' + path);
          }
        }
        try {
          if (FS.trackingDelegate['onOpenFile']) {
            var trackingFlags = 0;
            if ((flags & 2097155) !== 1) {
              trackingFlags |= FS.tracking.openFlags.READ;
            }
            if ((flags & 2097155) !== 0) {
              trackingFlags |= FS.tracking.openFlags.WRITE;
            }
            FS.trackingDelegate['onOpenFile'](path, trackingFlags);
          }
        } catch(e) {
          console.log("FS.trackingDelegate['onOpenFile']('"+path+"', flags) threw an exception: " + e.message);
        }
        return stream;
      },close:function (stream) {
        try {
          if (stream.stream_ops.close) {
            stream.stream_ops.close(stream);
          }
        } catch (e) {
          throw e;
        } finally {
          FS.closeStream(stream.fd);
        }
      },llseek:function (stream, offset, whence) {
        if (!stream.seekable || !stream.stream_ops.llseek) {
          throw new FS.ErrnoError(ERRNO_CODES.ESPIPE);
        }
        stream.position = stream.stream_ops.llseek(stream, offset, whence);
        stream.ungotten = [];
        return stream.position;
      },read:function (stream, buffer, offset, length, position) {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(ERRNO_CODES.EBADF);
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(ERRNO_CODES.EISDIR);
        }
        if (!stream.stream_ops.read) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        var seeking = true;
        if (typeof position === 'undefined') {
          position = stream.position;
          seeking = false;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(ERRNO_CODES.ESPIPE);
        }
        var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);
        if (!seeking) stream.position += bytesRead;
        return bytesRead;
      },write:function (stream, buffer, offset, length, position, canOwn) {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EBADF);
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(ERRNO_CODES.EISDIR);
        }
        if (!stream.stream_ops.write) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        if (stream.flags & 1024) {
          // seek to the end before writing in append mode
          FS.llseek(stream, 0, 2);
        }
        var seeking = true;
        if (typeof position === 'undefined') {
          position = stream.position;
          seeking = false;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(ERRNO_CODES.ESPIPE);
        }
        var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);
        if (!seeking) stream.position += bytesWritten;
        try {
          if (stream.path && FS.trackingDelegate['onWriteToFile']) FS.trackingDelegate['onWriteToFile'](stream.path);
        } catch(e) {
          console.log("FS.trackingDelegate['onWriteToFile']('"+path+"') threw an exception: " + e.message);
        }
        return bytesWritten;
      },allocate:function (stream, offset, length) {
        if (offset < 0 || length <= 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EBADF);
        }
        if (!FS.isFile(stream.node.mode) && !FS.isDir(node.mode)) {
          throw new FS.ErrnoError(ERRNO_CODES.ENODEV);
        }
        if (!stream.stream_ops.allocate) {
          throw new FS.ErrnoError(ERRNO_CODES.EOPNOTSUPP);
        }
        stream.stream_ops.allocate(stream, offset, length);
      },mmap:function (stream, buffer, offset, length, position, prot, flags) {
        // TODO if PROT is PROT_WRITE, make sure we have write access
        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(ERRNO_CODES.EACCES);
        }
        if (!stream.stream_ops.mmap) {
          throw new FS.ErrnoError(ERRNO_CODES.ENODEV);
        }
        return stream.stream_ops.mmap(stream, buffer, offset, length, position, prot, flags);
      },ioctl:function (stream, cmd, arg) {
        if (!stream.stream_ops.ioctl) {
          throw new FS.ErrnoError(ERRNO_CODES.ENOTTY);
        }
        return stream.stream_ops.ioctl(stream, cmd, arg);
      },readFile:function (path, opts) {
        opts = opts || {};
        opts.flags = opts.flags || 'r';
        opts.encoding = opts.encoding || 'binary';
        if (opts.encoding !== 'utf8' && opts.encoding !== 'binary') {
          throw new Error('Invalid encoding type "' + opts.encoding + '"');
        }
        var ret;
        var stream = FS.open(path, opts.flags);
        var stat = FS.stat(path);
        var length = stat.size;
        var buf = new Uint8Array(length);
        FS.read(stream, buf, 0, length, 0);
        if (opts.encoding === 'utf8') {
          ret = UTF8ArrayToString(buf, 0);
        } else if (opts.encoding === 'binary') {
          ret = buf;
        }
        FS.close(stream);
        return ret;
      },writeFile:function (path, data, opts) {
        opts = opts || {};
        opts.flags = opts.flags || 'w';
        opts.encoding = opts.encoding || 'utf8';
        if (opts.encoding !== 'utf8' && opts.encoding !== 'binary') {
          throw new Error('Invalid encoding type "' + opts.encoding + '"');
        }
        var stream = FS.open(path, opts.flags, opts.mode);
        if (opts.encoding === 'utf8') {
          var buf = new Uint8Array(lengthBytesUTF8(data)+1);
          var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
          FS.write(stream, buf, 0, actualNumBytes, 0, opts.canOwn);
        } else if (opts.encoding === 'binary') {
          FS.write(stream, data, 0, data.length, 0, opts.canOwn);
        }
        FS.close(stream);
      },cwd:function () {
        return FS.currentPath;
      },chdir:function (path) {
        var lookup = FS.lookupPath(path, { follow: true });
        if (!FS.isDir(lookup.node.mode)) {
          throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR);
        }
        var err = FS.nodePermissions(lookup.node, 'x');
        if (err) {
          throw new FS.ErrnoError(err);
        }
        FS.currentPath = lookup.path;
      },createDefaultDirectories:function () {
        FS.mkdir('/tmp');
        FS.mkdir('/home');
        FS.mkdir('/home/web_user');
      },createDefaultDevices:function () {
        // create /dev
        FS.mkdir('/dev');
        // setup /dev/null
        FS.registerDevice(FS.makedev(1, 3), {
          read: function() { return 0; },
          write: function() { return 0; }
        });
        FS.mkdev('/dev/null', FS.makedev(1, 3));
        // setup /dev/tty and /dev/tty1
        // stderr needs to print output using Module['printErr']
        // so we register a second tty just for it.
        TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
        TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
        FS.mkdev('/dev/tty', FS.makedev(5, 0));
        FS.mkdev('/dev/tty1', FS.makedev(6, 0));
        // setup /dev/[u]random
        var random_device;
        if (typeof crypto !== 'undefined') {
          // for modern web browsers
          var randomBuffer = new Uint8Array(1);
          random_device = function() { crypto.getRandomValues(randomBuffer); return randomBuffer[0]; };
        } else if (ENVIRONMENT_IS_NODE) {
          // for nodejs
          random_device = function() { return require('crypto').randomBytes(1)[0]; };
        } else {
          // default for ES5 platforms
          random_device = function() { return (Math.random()*256)|0; };
        }
        FS.createDevice('/dev', 'random', random_device);
        FS.createDevice('/dev', 'urandom', random_device);
        // we're not going to emulate the actual shm device,
        // just create the tmp dirs that reside in it commonly
        FS.mkdir('/dev/shm');
        FS.mkdir('/dev/shm/tmp');
      },createStandardStreams:function () {
        // TODO deprecate the old functionality of a single
        // input / output callback and that utilizes FS.createDevice
        // and instead require a unique set of stream ops
  
        // by default, we symlink the standard streams to the
        // default tty devices. however, if the standard streams
        // have been overwritten we create a unique device for
        // them instead.
        if (Module['stdin']) {
          FS.createDevice('/dev', 'stdin', Module['stdin']);
        } else {
          FS.symlink('/dev/tty', '/dev/stdin');
        }
        if (Module['stdout']) {
          FS.createDevice('/dev', 'stdout', null, Module['stdout']);
        } else {
          FS.symlink('/dev/tty', '/dev/stdout');
        }
        if (Module['stderr']) {
          FS.createDevice('/dev', 'stderr', null, Module['stderr']);
        } else {
          FS.symlink('/dev/tty1', '/dev/stderr');
        }
  
        // open default streams for the stdin, stdout and stderr devices
        var stdin = FS.open('/dev/stdin', 'r');
        HEAP32[((_stdin)>>2)]=FS.getPtrForStream(stdin);
        assert(stdin.fd === 0, 'invalid handle for stdin (' + stdin.fd + ')');
  
        var stdout = FS.open('/dev/stdout', 'w');
        HEAP32[((_stdout)>>2)]=FS.getPtrForStream(stdout);
        assert(stdout.fd === 1, 'invalid handle for stdout (' + stdout.fd + ')');
  
        var stderr = FS.open('/dev/stderr', 'w');
        HEAP32[((_stderr)>>2)]=FS.getPtrForStream(stderr);
        assert(stderr.fd === 2, 'invalid handle for stderr (' + stderr.fd + ')');
      },ensureErrnoError:function () {
        if (FS.ErrnoError) return;
        FS.ErrnoError = function ErrnoError(errno, node) {
          this.node = node;
          this.setErrno = function(errno) {
            this.errno = errno;
            for (var key in ERRNO_CODES) {
              if (ERRNO_CODES[key] === errno) {
                this.code = key;
                break;
              }
            }
          };
          this.setErrno(errno);
          this.message = ERRNO_MESSAGES[errno];
          if (this.stack) this.stack = demangleAll(this.stack);
        };
        FS.ErrnoError.prototype = new Error();
        FS.ErrnoError.prototype.constructor = FS.ErrnoError;
        // Some errors may happen quite a bit, to avoid overhead we reuse them (and suffer a lack of stack info)
        [ERRNO_CODES.ENOENT].forEach(function(code) {
          FS.genericErrors[code] = new FS.ErrnoError(code);
          FS.genericErrors[code].stack = '<generic error, no stack>';
        });
      },staticInit:function () {
        FS.ensureErrnoError();
  
        FS.nameTable = new Array(4096);
  
        FS.mount(MEMFS, {}, '/');
  
        FS.createDefaultDirectories();
        FS.createDefaultDevices();
      },init:function (input, output, error) {
        assert(!FS.init.initialized, 'FS.init was previously called. If you want to initialize later with custom parameters, remove any earlier calls (note that one is automatically added to the generated code)');
        FS.init.initialized = true;
  
        FS.ensureErrnoError();
  
        // Allow Module.stdin etc. to provide defaults, if none explicitly passed to us here
        Module['stdin'] = input || Module['stdin'];
        Module['stdout'] = output || Module['stdout'];
        Module['stderr'] = error || Module['stderr'];
  
        FS.createStandardStreams();
      },quit:function () {
        FS.init.initialized = false;
        for (var i = 0; i < FS.streams.length; i++) {
          var stream = FS.streams[i];
          if (!stream) {
            continue;
          }
          FS.close(stream);
        }
      },getMode:function (canRead, canWrite) {
        var mode = 0;
        if (canRead) mode |= 292 | 73;
        if (canWrite) mode |= 146;
        return mode;
      },joinPath:function (parts, forceRelative) {
        var path = PATH.join.apply(null, parts);
        if (forceRelative && path[0] == '/') path = path.substr(1);
        return path;
      },absolutePath:function (relative, base) {
        return PATH.resolve(base, relative);
      },standardizePath:function (path) {
        return PATH.normalize(path);
      },findObject:function (path, dontResolveLastLink) {
        var ret = FS.analyzePath(path, dontResolveLastLink);
        if (ret.exists) {
          return ret.object;
        } else {
          ___setErrNo(ret.error);
          return null;
        }
      },analyzePath:function (path, dontResolveLastLink) {
        // operate from within the context of the symlink's target
        try {
          var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
          path = lookup.path;
        } catch (e) {
        }
        var ret = {
          isRoot: false, exists: false, error: 0, name: null, path: null, object: null,
          parentExists: false, parentPath: null, parentObject: null
        };
        try {
          var lookup = FS.lookupPath(path, { parent: true });
          ret.parentExists = true;
          ret.parentPath = lookup.path;
          ret.parentObject = lookup.node;
          ret.name = PATH.basename(path);
          lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
          ret.exists = true;
          ret.path = lookup.path;
          ret.object = lookup.node;
          ret.name = lookup.node.name;
          ret.isRoot = lookup.path === '/';
        } catch (e) {
          ret.error = e.errno;
        };
        return ret;
      },createFolder:function (parent, name, canRead, canWrite) {
        var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name);
        var mode = FS.getMode(canRead, canWrite);
        return FS.mkdir(path, mode);
      },createPath:function (parent, path, canRead, canWrite) {
        parent = typeof parent === 'string' ? parent : FS.getPath(parent);
        var parts = path.split('/').reverse();
        while (parts.length) {
          var part = parts.pop();
          if (!part) continue;
          var current = PATH.join2(parent, part);
          try {
            FS.mkdir(current);
          } catch (e) {
            // ignore EEXIST
          }
          parent = current;
        }
        return current;
      },createFile:function (parent, name, properties, canRead, canWrite) {
        var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name);
        var mode = FS.getMode(canRead, canWrite);
        return FS.create(path, mode);
      },createDataFile:function (parent, name, data, canRead, canWrite, canOwn) {
        var path = name ? PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name) : parent;
        var mode = FS.getMode(canRead, canWrite);
        var node = FS.create(path, mode);
        if (data) {
          if (typeof data === 'string') {
            var arr = new Array(data.length);
            for (var i = 0, len = data.length; i < len; ++i) arr[i] = data.charCodeAt(i);
            data = arr;
          }
          // make sure we can write to the file
          FS.chmod(node, mode | 146);
          var stream = FS.open(node, 'w');
          FS.write(stream, data, 0, data.length, 0, canOwn);
          FS.close(stream);
          FS.chmod(node, mode);
        }
        return node;
      },createDevice:function (parent, name, input, output) {
        var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name);
        var mode = FS.getMode(!!input, !!output);
        if (!FS.createDevice.major) FS.createDevice.major = 64;
        var dev = FS.makedev(FS.createDevice.major++, 0);
        // Create a fake device that a set of stream ops to emulate
        // the old behavior.
        FS.registerDevice(dev, {
          open: function(stream) {
            stream.seekable = false;
          },
          close: function(stream) {
            // flush any pending line data
            if (output && output.buffer && output.buffer.length) {
              output(10);
            }
          },
          read: function(stream, buffer, offset, length, pos /* ignored */) {
            var bytesRead = 0;
            for (var i = 0; i < length; i++) {
              var result;
              try {
                result = input();
              } catch (e) {
                throw new FS.ErrnoError(ERRNO_CODES.EIO);
              }
              if (result === undefined && bytesRead === 0) {
                throw new FS.ErrnoError(ERRNO_CODES.EAGAIN);
              }
              if (result === null || result === undefined) break;
              bytesRead++;
              buffer[offset+i] = result;
            }
            if (bytesRead) {
              stream.node.timestamp = Date.now();
            }
            return bytesRead;
          },
          write: function(stream, buffer, offset, length, pos) {
            for (var i = 0; i < length; i++) {
              try {
                output(buffer[offset+i]);
              } catch (e) {
                throw new FS.ErrnoError(ERRNO_CODES.EIO);
              }
            }
            if (length) {
              stream.node.timestamp = Date.now();
            }
            return i;
          }
        });
        return FS.mkdev(path, mode, dev);
      },createLink:function (parent, name, target, canRead, canWrite) {
        var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name);
        return FS.symlink(target, path);
      },forceLoadFile:function (obj) {
        if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;
        var success = true;
        if (typeof XMLHttpRequest !== 'undefined') {
          throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
        } else if (Module['read']) {
          // Command-line.
          try {
            // WARNING: Can't read binary files in V8's d8 or tracemonkey's js, as
            //          read() will try to parse UTF8.
            obj.contents = intArrayFromString(Module['read'](obj.url), true);
            obj.usedBytes = obj.contents.length;
          } catch (e) {
            success = false;
          }
        } else {
          throw new Error('Cannot load without read() or XMLHttpRequest.');
        }
        if (!success) ___setErrNo(ERRNO_CODES.EIO);
        return success;
      },createLazyFile:function (parent, name, url, canRead, canWrite) {
        // Lazy chunked Uint8Array (implements get and length from Uint8Array). Actual getting is abstracted away for eventual reuse.
        function LazyUint8Array() {
          this.lengthKnown = false;
          this.chunks = []; // Loaded chunks. Index is the chunk number
        }
        LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {
          if (idx > this.length-1 || idx < 0) {
            return undefined;
          }
          var chunkOffset = idx % this.chunkSize;
          var chunkNum = (idx / this.chunkSize)|0;
          return this.getter(chunkNum)[chunkOffset];
        }
        LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {
          this.getter = getter;
        }
        LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {
          // Find length
          var xhr = new XMLHttpRequest();
          xhr.open('HEAD', url, false);
          xhr.send(null);
          if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
          var datalength = Number(xhr.getResponseHeader("Content-length"));
          var header;
          var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
          var chunkSize = 1024*1024; // Chunk size in bytes
  
          if (!hasByteServing) chunkSize = datalength;
  
          // Function to get a range from the remote URL.
          var doXHR = (function(from, to) {
            if (from > to) throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
            if (to > datalength-1) throw new Error("only " + datalength + " bytes available! programmer error!");
  
            // TODO: Use mozResponseArrayBuffer, responseStream, etc. if available.
            var xhr = new XMLHttpRequest();
            xhr.open('GET', url, false);
            if (datalength !== chunkSize) xhr.setRequestHeader("Range", "bytes=" + from + "-" + to);
  
            // Some hints to the browser that we want binary data.
            if (typeof Uint8Array != 'undefined') xhr.responseType = 'arraybuffer';
            if (xhr.overrideMimeType) {
              xhr.overrideMimeType('text/plain; charset=x-user-defined');
            }
  
            xhr.send(null);
            if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
            if (xhr.response !== undefined) {
              return new Uint8Array(xhr.response || []);
            } else {
              return intArrayFromString(xhr.responseText || '', true);
            }
          });
          var lazyArray = this;
          lazyArray.setDataGetter(function(chunkNum) {
            var start = chunkNum * chunkSize;
            var end = (chunkNum+1) * chunkSize - 1; // including this byte
            end = Math.min(end, datalength-1); // if datalength-1 is selected, this is the last block
            if (typeof(lazyArray.chunks[chunkNum]) === "undefined") {
              lazyArray.chunks[chunkNum] = doXHR(start, end);
            }
            if (typeof(lazyArray.chunks[chunkNum]) === "undefined") throw new Error("doXHR failed!");
            return lazyArray.chunks[chunkNum];
          });
  
          this._length = datalength;
          this._chunkSize = chunkSize;
          this.lengthKnown = true;
        }
        if (typeof XMLHttpRequest !== 'undefined') {
          if (!ENVIRONMENT_IS_WORKER) throw 'Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc';
          var lazyArray = new LazyUint8Array();
          Object.defineProperty(lazyArray, "length", {
              get: function() {
                  if(!this.lengthKnown) {
                      this.cacheLength();
                  }
                  return this._length;
              }
          });
          Object.defineProperty(lazyArray, "chunkSize", {
              get: function() {
                  if(!this.lengthKnown) {
                      this.cacheLength();
                  }
                  return this._chunkSize;
              }
          });
  
          var properties = { isDevice: false, contents: lazyArray };
        } else {
          var properties = { isDevice: false, url: url };
        }
  
        var node = FS.createFile(parent, name, properties, canRead, canWrite);
        // This is a total hack, but I want to get this lazy file code out of the
        // core of MEMFS. If we want to keep this lazy file concept I feel it should
        // be its own thin LAZYFS proxying calls to MEMFS.
        if (properties.contents) {
          node.contents = properties.contents;
        } else if (properties.url) {
          node.contents = null;
          node.url = properties.url;
        }
        // Add a function that defers querying the file size until it is asked the first time.
        Object.defineProperty(node, "usedBytes", {
            get: function() { return this.contents.length; }
        });
        // override each stream op with one that tries to force load the lazy file first
        var stream_ops = {};
        var keys = Object.keys(node.stream_ops);
        keys.forEach(function(key) {
          var fn = node.stream_ops[key];
          stream_ops[key] = function forceLoadLazyFile() {
            if (!FS.forceLoadFile(node)) {
              throw new FS.ErrnoError(ERRNO_CODES.EIO);
            }
            return fn.apply(null, arguments);
          };
        });
        // use a custom read function
        stream_ops.read = function stream_ops_read(stream, buffer, offset, length, position) {
          if (!FS.forceLoadFile(node)) {
            throw new FS.ErrnoError(ERRNO_CODES.EIO);
          }
          var contents = stream.node.contents;
          if (position >= contents.length)
            return 0;
          var size = Math.min(contents.length - position, length);
          assert(size >= 0);
          if (contents.slice) { // normal array
            for (var i = 0; i < size; i++) {
              buffer[offset + i] = contents[position + i];
            }
          } else {
            for (var i = 0; i < size; i++) { // LazyUint8Array from sync binary XHR
              buffer[offset + i] = contents.get(position + i);
            }
          }
          return size;
        };
        node.stream_ops = stream_ops;
        return node;
      },createPreloadedFile:function (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn) {
        Browser.init();
        // TODO we should allow people to just pass in a complete filename instead
        // of parent and name being that we just join them anyways
        var fullname = name ? PATH.resolve(PATH.join2(parent, name)) : parent;
        function processData(byteArray) {
          function finish(byteArray) {
            if (!dontCreateFile) {
              FS.createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);
            }
            if (onload) onload();
            removeRunDependency('cp ' + fullname);
          }
          var handled = false;
          Module['preloadPlugins'].forEach(function(plugin) {
            if (handled) return;
            if (plugin['canHandle'](fullname)) {
              plugin['handle'](byteArray, fullname, finish, function() {
                if (onerror) onerror();
                removeRunDependency('cp ' + fullname);
              });
              handled = true;
            }
          });
          if (!handled) finish(byteArray);
        }
        addRunDependency('cp ' + fullname);
        if (typeof url == 'string') {
          Browser.asyncLoad(url, function(byteArray) {
            processData(byteArray);
          }, onerror);
        } else {
          processData(url);
        }
      },indexedDB:function () {
        return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
      },DB_NAME:function () {
        return 'EM_FS_' + window.location.pathname;
      },DB_VERSION:20,DB_STORE_NAME:"FILE_DATA",saveFilesToDB:function (paths, onload, onerror) {
        onload = onload || function(){};
        onerror = onerror || function(){};
        var indexedDB = FS.indexedDB();
        try {
          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
        } catch (e) {
          return onerror(e);
        }
        openRequest.onupgradeneeded = function openRequest_onupgradeneeded() {
          console.log('creating db');
          var db = openRequest.result;
          db.createObjectStore(FS.DB_STORE_NAME);
        };
        openRequest.onsuccess = function openRequest_onsuccess() {
          var db = openRequest.result;
          var transaction = db.transaction([FS.DB_STORE_NAME], 'readwrite');
          var files = transaction.objectStore(FS.DB_STORE_NAME);
          var ok = 0, fail = 0, total = paths.length;
          function finish() {
            if (fail == 0) onload(); else onerror();
          }
          paths.forEach(function(path) {
            var putRequest = files.put(FS.analyzePath(path).object.contents, path);
            putRequest.onsuccess = function putRequest_onsuccess() { ok++; if (ok + fail == total) finish() };
            putRequest.onerror = function putRequest_onerror() { fail++; if (ok + fail == total) finish() };
          });
          transaction.onerror = onerror;
        };
        openRequest.onerror = onerror;
      },loadFilesFromDB:function (paths, onload, onerror) {
        onload = onload || function(){};
        onerror = onerror || function(){};
        var indexedDB = FS.indexedDB();
        try {
          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
        } catch (e) {
          return onerror(e);
        }
        openRequest.onupgradeneeded = onerror; // no database to load from
        openRequest.onsuccess = function openRequest_onsuccess() {
          var db = openRequest.result;
          try {
            var transaction = db.transaction([FS.DB_STORE_NAME], 'readonly');
          } catch(e) {
            onerror(e);
            return;
          }
          var files = transaction.objectStore(FS.DB_STORE_NAME);
          var ok = 0, fail = 0, total = paths.length;
          function finish() {
            if (fail == 0) onload(); else onerror();
          }
          paths.forEach(function(path) {
            var getRequest = files.get(path);
            getRequest.onsuccess = function getRequest_onsuccess() {
              if (FS.analyzePath(path).exists) {
                FS.unlink(path);
              }
              FS.createDataFile(PATH.dirname(path), PATH.basename(path), getRequest.result, true, true, true);
              ok++;
              if (ok + fail == total) finish();
            };
            getRequest.onerror = function getRequest_onerror() { fail++; if (ok + fail == total) finish() };
          });
          transaction.onerror = onerror;
        };
        openRequest.onerror = onerror;
      }};
  
  
  
  
  function _mkport() { throw 'TODO' }var SOCKFS={mount:function (mount) {
        // If Module['websocket'] has already been defined (e.g. for configuring
        // the subprotocol/url) use that, if not initialise it to a new object.
        Module['websocket'] = (Module['websocket'] && 
                               ('object' === typeof Module['websocket'])) ? Module['websocket'] : {};
  
        // Add the Event registration mechanism to the exported websocket configuration
        // object so we can register network callbacks from native JavaScript too.
        // For more documentation see system/include/emscripten/emscripten.h
        Module['websocket']._callbacks = {};
        Module['websocket']['on'] = function(event, callback) {
  	    if ('function' === typeof callback) {
  		  this._callbacks[event] = callback;
          }
  	    return this;
        };
  
        Module['websocket'].emit = function(event, param) {
  	    if ('function' === typeof this._callbacks[event]) {
  		  this._callbacks[event].call(this, param);
          }
        };
  
        // If debug is enabled register simple default logging callbacks for each Event.
  
        return FS.createNode(null, '/', 16384 | 511 /* 0777 */, 0);
      },createSocket:function (family, type, protocol) {
        var streaming = type == 1;
        if (protocol) {
          assert(streaming == (protocol == 6)); // if SOCK_STREAM, must be tcp
        }
  
        // create our internal socket structure
        var sock = {
          family: family,
          type: type,
          protocol: protocol,
          server: null,
          error: null, // Used in getsockopt for SOL_SOCKET/SO_ERROR test
          peers: {},
          pending: [],
          recv_queue: [],
          sock_ops: SOCKFS.websocket_sock_ops
        };
  
        // create the filesystem node to store the socket structure
        var name = SOCKFS.nextname();
        var node = FS.createNode(SOCKFS.root, name, 49152, 0);
        node.sock = sock;
  
        // and the wrapping stream that enables library functions such
        // as read and write to indirectly interact with the socket
        var stream = FS.createStream({
          path: name,
          node: node,
          flags: FS.modeStringToFlags('r+'),
          seekable: false,
          stream_ops: SOCKFS.stream_ops
        });
  
        // map the new stream to the socket structure (sockets have a 1:1
        // relationship with a stream)
        sock.stream = stream;
  
        return sock;
      },getSocket:function (fd) {
        var stream = FS.getStream(fd);
        if (!stream || !FS.isSocket(stream.node.mode)) {
          return null;
        }
        return stream.node.sock;
      },stream_ops:{poll:function (stream) {
          var sock = stream.node.sock;
          return sock.sock_ops.poll(sock);
        },ioctl:function (stream, request, varargs) {
          var sock = stream.node.sock;
          return sock.sock_ops.ioctl(sock, request, varargs);
        },read:function (stream, buffer, offset, length, position /* ignored */) {
          var sock = stream.node.sock;
          var msg = sock.sock_ops.recvmsg(sock, length);
          if (!msg) {
            // socket is closed
            return 0;
          }
          buffer.set(msg.buffer, offset);
          return msg.buffer.length;
        },write:function (stream, buffer, offset, length, position /* ignored */) {
          var sock = stream.node.sock;
          return sock.sock_ops.sendmsg(sock, buffer, offset, length);
        },close:function (stream) {
          var sock = stream.node.sock;
          sock.sock_ops.close(sock);
        }},nextname:function () {
        if (!SOCKFS.nextname.current) {
          SOCKFS.nextname.current = 0;
        }
        return 'socket[' + (SOCKFS.nextname.current++) + ']';
      },websocket_sock_ops:{createPeer:function (sock, addr, port) {
          var ws;
  
          if (typeof addr === 'object') {
            ws = addr;
            addr = null;
            port = null;
          }
  
          if (ws) {
            // for sockets that've already connected (e.g. we're the server)
            // we can inspect the _socket property for the address
            if (ws._socket) {
              addr = ws._socket.remoteAddress;
              port = ws._socket.remotePort;
            }
            // if we're just now initializing a connection to the remote,
            // inspect the url property
            else {
              var result = /ws[s]?:\/\/([^:]+):(\d+)/.exec(ws.url);
              if (!result) {
                throw new Error('WebSocket URL must be in the format ws(s)://address:port');
              }
              addr = result[1];
              port = parseInt(result[2], 10);
            }
          } else {
            // create the actual websocket object and connect
            try {
              // runtimeConfig gets set to true if WebSocket runtime configuration is available.
              var runtimeConfig = (Module['websocket'] && ('object' === typeof Module['websocket']));
  
              // The default value is 'ws://' the replace is needed because the compiler replaces '//' comments with '#'
              // comments without checking context, so we'd end up with ws:#, the replace swaps the '#' for '//' again.
              var url = 'ws:#'.replace('#', '//');
  
              if (runtimeConfig) {
                if ('string' === typeof Module['websocket']['url']) {
                  url = Module['websocket']['url']; // Fetch runtime WebSocket URL config.
                }
              }
  
              if (url === 'ws://' || url === 'wss://') { // Is the supplied URL config just a prefix, if so complete it.
                var parts = addr.split('/');
                url = url + parts[0] + ":" + port + "/" + parts.slice(1).join('/');
              }
  
              // Make the WebSocket subprotocol (Sec-WebSocket-Protocol) default to binary if no configuration is set.
              var subProtocols = 'binary'; // The default value is 'binary'
  
              if (runtimeConfig) {
                if ('string' === typeof Module['websocket']['subprotocol']) {
                  subProtocols = Module['websocket']['subprotocol']; // Fetch runtime WebSocket subprotocol config.
                }
              }
  
              // The regex trims the string (removes spaces at the beginning and end, then splits the string by
              // <any space>,<any space> into an Array. Whitespace removal is important for Websockify and ws.
              subProtocols = subProtocols.replace(/^ +| +$/g,"").split(/ *, */);
  
              // The node ws library API for specifying optional subprotocol is slightly different than the browser's.
              var opts = ENVIRONMENT_IS_NODE ? {'protocol': subProtocols.toString()} : subProtocols;
  
              // If node we use the ws library.
              var WebSocket = ENVIRONMENT_IS_NODE ? require('ws') : window['WebSocket'];
              ws = new WebSocket(url, opts);
              ws.binaryType = 'arraybuffer';
            } catch (e) {
              throw new FS.ErrnoError(ERRNO_CODES.EHOSTUNREACH);
            }
          }
  
  
          var peer = {
            addr: addr,
            port: port,
            socket: ws,
            dgram_send_queue: []
          };
  
          SOCKFS.websocket_sock_ops.addPeer(sock, peer);
          SOCKFS.websocket_sock_ops.handlePeerEvents(sock, peer);
  
          // if this is a bound dgram socket, send the port number first to allow
          // us to override the ephemeral port reported to us by remotePort on the
          // remote end.
          if (sock.type === 2 && typeof sock.sport !== 'undefined') {
            peer.dgram_send_queue.push(new Uint8Array([
                255, 255, 255, 255,
                'p'.charCodeAt(0), 'o'.charCodeAt(0), 'r'.charCodeAt(0), 't'.charCodeAt(0),
                ((sock.sport & 0xff00) >> 8) , (sock.sport & 0xff)
            ]));
          }
  
          return peer;
        },getPeer:function (sock, addr, port) {
          return sock.peers[addr + ':' + port];
        },addPeer:function (sock, peer) {
          sock.peers[peer.addr + ':' + peer.port] = peer;
        },removePeer:function (sock, peer) {
          delete sock.peers[peer.addr + ':' + peer.port];
        },handlePeerEvents:function (sock, peer) {
          var first = true;
  
          var handleOpen = function () {
  
            Module['websocket'].emit('open', sock.stream.fd);
  
            try {
              var queued = peer.dgram_send_queue.shift();
              while (queued) {
                peer.socket.send(queued);
                queued = peer.dgram_send_queue.shift();
              }
            } catch (e) {
              // not much we can do here in the way of proper error handling as we've already
              // lied and said this data was sent. shut it down.
              peer.socket.close();
            }
          };
  
          function handleMessage(data) {
            assert(typeof data !== 'string' && data.byteLength !== undefined);  // must receive an ArrayBuffer
            data = new Uint8Array(data);  // make a typed array view on the array buffer
  
  
            // if this is the port message, override the peer's port with it
            var wasfirst = first;
            first = false;
            if (wasfirst &&
                data.length === 10 &&
                data[0] === 255 && data[1] === 255 && data[2] === 255 && data[3] === 255 &&
                data[4] === 'p'.charCodeAt(0) && data[5] === 'o'.charCodeAt(0) && data[6] === 'r'.charCodeAt(0) && data[7] === 't'.charCodeAt(0)) {
              // update the peer's port and it's key in the peer map
              var newport = ((data[8] << 8) | data[9]);
              SOCKFS.websocket_sock_ops.removePeer(sock, peer);
              peer.port = newport;
              SOCKFS.websocket_sock_ops.addPeer(sock, peer);
              return;
            }
  
            sock.recv_queue.push({ addr: peer.addr, port: peer.port, data: data });
            Module['websocket'].emit('message', sock.stream.fd);
          };
  
          if (ENVIRONMENT_IS_NODE) {
            peer.socket.on('open', handleOpen);
            peer.socket.on('message', function(data, flags) {
              if (!flags.binary) {
                return;
              }
              handleMessage((new Uint8Array(data)).buffer);  // copy from node Buffer -> ArrayBuffer
            });
            peer.socket.on('close', function() {
              Module['websocket'].emit('close', sock.stream.fd);
            });
            peer.socket.on('error', function(error) {
              // Although the ws library may pass errors that may be more descriptive than
              // ECONNREFUSED they are not necessarily the expected error code e.g. 
              // ENOTFOUND on getaddrinfo seems to be node.js specific, so using ECONNREFUSED
              // is still probably the most useful thing to do.
              sock.error = ERRNO_CODES.ECONNREFUSED; // Used in getsockopt for SOL_SOCKET/SO_ERROR test.
              Module['websocket'].emit('error', [sock.stream.fd, sock.error, 'ECONNREFUSED: Connection refused']);
              // don't throw
            });
          } else {
            peer.socket.onopen = handleOpen;
            peer.socket.onclose = function() {
              Module['websocket'].emit('close', sock.stream.fd);
            };
            peer.socket.onmessage = function peer_socket_onmessage(event) {
              handleMessage(event.data);
            };
            peer.socket.onerror = function(error) {
              // The WebSocket spec only allows a 'simple event' to be thrown on error,
              // so we only really know as much as ECONNREFUSED.
              sock.error = ERRNO_CODES.ECONNREFUSED; // Used in getsockopt for SOL_SOCKET/SO_ERROR test.
              Module['websocket'].emit('error', [sock.stream.fd, sock.error, 'ECONNREFUSED: Connection refused']);
            };
          }
        },poll:function (sock) {
          if (sock.type === 1 && sock.server) {
            // listen sockets should only say they're available for reading
            // if there are pending clients.
            return sock.pending.length ? (64 | 1) : 0;
          }
  
          var mask = 0;
          var dest = sock.type === 1 ?  // we only care about the socket state for connection-based sockets
            SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport) :
            null;
  
          if (sock.recv_queue.length ||
              !dest ||  // connection-less sockets are always ready to read
              (dest && dest.socket.readyState === dest.socket.CLOSING) ||
              (dest && dest.socket.readyState === dest.socket.CLOSED)) {  // let recv return 0 once closed
            mask |= (64 | 1);
          }
  
          if (!dest ||  // connection-less sockets are always ready to write
              (dest && dest.socket.readyState === dest.socket.OPEN)) {
            mask |= 4;
          }
  
          if ((dest && dest.socket.readyState === dest.socket.CLOSING) ||
              (dest && dest.socket.readyState === dest.socket.CLOSED)) {
            mask |= 16;
          }
  
          return mask;
        },ioctl:function (sock, request, arg) {
          switch (request) {
            case 21531:
              var bytes = 0;
              if (sock.recv_queue.length) {
                bytes = sock.recv_queue[0].data.length;
              }
              HEAP32[((arg)>>2)]=bytes;
              return 0;
            default:
              return ERRNO_CODES.EINVAL;
          }
        },close:function (sock) {
          // if we've spawned a listen server, close it
          if (sock.server) {
            try {
              sock.server.close();
            } catch (e) {
            }
            sock.server = null;
          }
          // close any peer connections
          var peers = Object.keys(sock.peers);
          for (var i = 0; i < peers.length; i++) {
            var peer = sock.peers[peers[i]];
            try {
              peer.socket.close();
            } catch (e) {
            }
            SOCKFS.websocket_sock_ops.removePeer(sock, peer);
          }
          return 0;
        },bind:function (sock, addr, port) {
          if (typeof sock.saddr !== 'undefined' || typeof sock.sport !== 'undefined') {
            throw new FS.ErrnoError(ERRNO_CODES.EINVAL);  // already bound
          }
          sock.saddr = addr;
          sock.sport = port || _mkport();
          // in order to emulate dgram sockets, we need to launch a listen server when
          // binding on a connection-less socket
          // note: this is only required on the server side
          if (sock.type === 2) {
            // close the existing server if it exists
            if (sock.server) {
              sock.server.close();
              sock.server = null;
            }
            // swallow error operation not supported error that occurs when binding in the
            // browser where this isn't supported
            try {
              sock.sock_ops.listen(sock, 0);
            } catch (e) {
              if (!(e instanceof FS.ErrnoError)) throw e;
              if (e.errno !== ERRNO_CODES.EOPNOTSUPP) throw e;
            }
          }
        },connect:function (sock, addr, port) {
          if (sock.server) {
            throw new FS.ErrnoError(ERRNO_CODES.EOPNOTSUPP);
          }
  
          // TODO autobind
          // if (!sock.addr && sock.type == 2) {
          // }
  
          // early out if we're already connected / in the middle of connecting
          if (typeof sock.daddr !== 'undefined' && typeof sock.dport !== 'undefined') {
            var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);
            if (dest) {
              if (dest.socket.readyState === dest.socket.CONNECTING) {
                throw new FS.ErrnoError(ERRNO_CODES.EALREADY);
              } else {
                throw new FS.ErrnoError(ERRNO_CODES.EISCONN);
              }
            }
          }
  
          // add the socket to our peer list and set our
          // destination address / port to match
          var peer = SOCKFS.websocket_sock_ops.createPeer(sock, addr, port);
          sock.daddr = peer.addr;
          sock.dport = peer.port;
  
          // always "fail" in non-blocking mode
          throw new FS.ErrnoError(ERRNO_CODES.EINPROGRESS);
        },listen:function (sock, backlog) {
          if (!ENVIRONMENT_IS_NODE) {
            throw new FS.ErrnoError(ERRNO_CODES.EOPNOTSUPP);
          }
          if (sock.server) {
             throw new FS.ErrnoError(ERRNO_CODES.EINVAL);  // already listening
          }
          var WebSocketServer = require('ws').Server;
          var host = sock.saddr;
          sock.server = new WebSocketServer({
            host: host,
            port: sock.sport
            // TODO support backlog
          });
          Module['websocket'].emit('listen', sock.stream.fd); // Send Event with listen fd.
  
          sock.server.on('connection', function(ws) {
            if (sock.type === 1) {
              var newsock = SOCKFS.createSocket(sock.family, sock.type, sock.protocol);
  
              // create a peer on the new socket
              var peer = SOCKFS.websocket_sock_ops.createPeer(newsock, ws);
              newsock.daddr = peer.addr;
              newsock.dport = peer.port;
  
              // push to queue for accept to pick up
              sock.pending.push(newsock);
              Module['websocket'].emit('connection', newsock.stream.fd);
            } else {
              // create a peer on the listen socket so calling sendto
              // with the listen socket and an address will resolve
              // to the correct client
              SOCKFS.websocket_sock_ops.createPeer(sock, ws);
              Module['websocket'].emit('connection', sock.stream.fd);
            }
          });
          sock.server.on('closed', function() {
            Module['websocket'].emit('close', sock.stream.fd);
            sock.server = null;
          });
          sock.server.on('error', function(error) {
            // Although the ws library may pass errors that may be more descriptive than
            // ECONNREFUSED they are not necessarily the expected error code e.g. 
            // ENOTFOUND on getaddrinfo seems to be node.js specific, so using EHOSTUNREACH
            // is still probably the most useful thing to do. This error shouldn't
            // occur in a well written app as errors should get trapped in the compiled
            // app's own getaddrinfo call.
            sock.error = ERRNO_CODES.EHOSTUNREACH; // Used in getsockopt for SOL_SOCKET/SO_ERROR test.
            Module['websocket'].emit('error', [sock.stream.fd, sock.error, 'EHOSTUNREACH: Host is unreachable']);
            // don't throw
          });
        },accept:function (listensock) {
          if (!listensock.server) {
            throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
          }
          var newsock = listensock.pending.shift();
          newsock.stream.flags = listensock.stream.flags;
          return newsock;
        },getname:function (sock, peer) {
          var addr, port;
          if (peer) {
            if (sock.daddr === undefined || sock.dport === undefined) {
              throw new FS.ErrnoError(ERRNO_CODES.ENOTCONN);
            }
            addr = sock.daddr;
            port = sock.dport;
          } else {
            // TODO saddr and sport will be set for bind()'d UDP sockets, but what
            // should we be returning for TCP sockets that've been connect()'d?
            addr = sock.saddr || 0;
            port = sock.sport || 0;
          }
          return { addr: addr, port: port };
        },sendmsg:function (sock, buffer, offset, length, addr, port) {
          if (sock.type === 2) {
            // connection-less sockets will honor the message address,
            // and otherwise fall back to the bound destination address
            if (addr === undefined || port === undefined) {
              addr = sock.daddr;
              port = sock.dport;
            }
            // if there was no address to fall back to, error out
            if (addr === undefined || port === undefined) {
              throw new FS.ErrnoError(ERRNO_CODES.EDESTADDRREQ);
            }
          } else {
            // connection-based sockets will only use the bound
            addr = sock.daddr;
            port = sock.dport;
          }
  
          // find the peer for the destination address
          var dest = SOCKFS.websocket_sock_ops.getPeer(sock, addr, port);
  
          // early out if not connected with a connection-based socket
          if (sock.type === 1) {
            if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              throw new FS.ErrnoError(ERRNO_CODES.ENOTCONN);
            } else if (dest.socket.readyState === dest.socket.CONNECTING) {
              throw new FS.ErrnoError(ERRNO_CODES.EAGAIN);
            }
          }
  
          // create a copy of the incoming data to send, as the WebSocket API
          // doesn't work entirely with an ArrayBufferView, it'll just send
          // the entire underlying buffer
          var data;
          if (buffer instanceof Array || buffer instanceof ArrayBuffer) {
            data = buffer.slice(offset, offset + length);
          } else {  // ArrayBufferView
            data = buffer.buffer.slice(buffer.byteOffset + offset, buffer.byteOffset + offset + length);
          }
  
          // if we're emulating a connection-less dgram socket and don't have
          // a cached connection, queue the buffer to send upon connect and
          // lie, saying the data was sent now.
          if (sock.type === 2) {
            if (!dest || dest.socket.readyState !== dest.socket.OPEN) {
              // if we're not connected, open a new connection
              if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
                dest = SOCKFS.websocket_sock_ops.createPeer(sock, addr, port);
              }
              dest.dgram_send_queue.push(data);
              return length;
            }
          }
  
          try {
            // send the actual data
            dest.socket.send(data);
            return length;
          } catch (e) {
            throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
          }
        },recvmsg:function (sock, length) {
          // http://pubs.opengroup.org/onlinepubs/7908799/xns/recvmsg.html
          if (sock.type === 1 && sock.server) {
            // tcp servers should not be recv()'ing on the listen socket
            throw new FS.ErrnoError(ERRNO_CODES.ENOTCONN);
          }
  
          var queued = sock.recv_queue.shift();
          if (!queued) {
            if (sock.type === 1) {
              var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);
  
              if (!dest) {
                // if we have a destination address but are not connected, error out
                throw new FS.ErrnoError(ERRNO_CODES.ENOTCONN);
              }
              else if (dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
                // return null if the socket has closed
                return null;
              }
              else {
                // else, our socket is in a valid state but truly has nothing available
                throw new FS.ErrnoError(ERRNO_CODES.EAGAIN);
              }
            } else {
              throw new FS.ErrnoError(ERRNO_CODES.EAGAIN);
            }
          }
  
          // queued.data will be an ArrayBuffer if it's unadulterated, but if it's
          // requeued TCP data it'll be an ArrayBufferView
          var queuedLength = queued.data.byteLength || queued.data.length;
          var queuedOffset = queued.data.byteOffset || 0;
          var queuedBuffer = queued.data.buffer || queued.data;
          var bytesRead = Math.min(length, queuedLength);
          var res = {
            buffer: new Uint8Array(queuedBuffer, queuedOffset, bytesRead),
            addr: queued.addr,
            port: queued.port
          };
  
  
          // push back any unread data for TCP connections
          if (sock.type === 1 && bytesRead < queuedLength) {
            var bytesRemaining = queuedLength - bytesRead;
            queued.data = new Uint8Array(queuedBuffer, queuedOffset + bytesRead, bytesRemaining);
            sock.recv_queue.unshift(queued);
          }
  
          return res;
        }}};function _send(fd, buf, len, flags) {
      var sock = SOCKFS.getSocket(fd);
      if (!sock) {
        ___setErrNo(ERRNO_CODES.EBADF);
        return -1;
      }
      // TODO honor flags
      return _write(fd, buf, len);
    }
  
  function _pwrite(fildes, buf, nbyte, offset) {
      // ssize_t pwrite(int fildes, const void *buf, size_t nbyte, off_t offset);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/write.html
      var stream = FS.getStream(fildes);
      if (!stream) {
        ___setErrNo(ERRNO_CODES.EBADF);
        return -1;
      }
      try {
        var slab = HEAP8;
        return FS.write(stream, slab, buf, nbyte, offset);
      } catch (e) {
        FS.handleFSError(e);
        return -1;
      }
    }function _write(fildes, buf, nbyte) {
      // ssize_t write(int fildes, const void *buf, size_t nbyte);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/write.html
      var stream = FS.getStream(fildes);
      if (!stream) {
        ___setErrNo(ERRNO_CODES.EBADF);
        return -1;
      }
  
  
      try {
        var slab = HEAP8;
        return FS.write(stream, slab, buf, nbyte);
      } catch (e) {
        FS.handleFSError(e);
        return -1;
      }
    }
  
  function _fileno(stream) {
      // int fileno(FILE *stream);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/fileno.html
      stream = FS.getStreamFromPtr(stream);
      if (!stream) return -1;
      return stream.fd;
    }function _fputc(c, stream) {
      // int fputc(int c, FILE *stream);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/fputc.html
      var chr = unSign(c & 0xFF);
      HEAP8[((_fputc.ret)>>0)]=chr;
      var fd = _fileno(stream);
      var ret = _write(fd, _fputc.ret, 1);
      if (ret == -1) {
        var streamObj = FS.getStreamFromPtr(stream);
        if (streamObj) streamObj.error = true;
        return -1;
      } else {
        return chr;
      }
    }

  
  var PTHREAD_SPECIFIC={};function _pthread_getspecific(key) {
      return PTHREAD_SPECIFIC[key] || 0;
    }

  function _sbrk(bytes) {
      // Implement a Linux-like 'memory area' for our 'process'.
      // Changes the size of the memory area by |bytes|; returns the
      // address of the previous top ('break') of the memory area
      // We control the "dynamic" memory - DYNAMIC_BASE to DYNAMICTOP
      var self = _sbrk;
      if (!self.called) {
        DYNAMICTOP = alignMemoryPage(DYNAMICTOP); // make sure we start out aligned
        self.called = true;
        assert(Runtime.dynamicAlloc);
        self.alloc = Runtime.dynamicAlloc;
        Runtime.dynamicAlloc = function() { abort('cannot dynamically allocate, sbrk now has control') };
      }
      var ret = DYNAMICTOP;
      if (bytes != 0) self.alloc(bytes);
      return ret;  // Previous break location.
    }

  var _emscripten_postinvoke=true;

  
  var PTHREAD_SPECIFIC_NEXT_KEY=1;function _pthread_key_create(key, destructor) {
      if (key == 0) {
        return ERRNO_CODES.EINVAL;
      }
      HEAP32[((key)>>2)]=PTHREAD_SPECIFIC_NEXT_KEY;
      // values start at 0
      PTHREAD_SPECIFIC[PTHREAD_SPECIFIC_NEXT_KEY] = 0;
      PTHREAD_SPECIFIC_NEXT_KEY++;
      return 0;
    }

  var _emscripten_preinvoke=true;

  function ___gxx_personality_v0() {
    }

  function ___cxa_call_unexpected(exception) {
      Module.printErr('Unexpected exception thrown, this is not properly supported - aborting');
      ABORT = true;
      throw exception;
    }

  
  
  function _emscripten_set_main_loop_timing(mode, value) {
      Browser.mainLoop.timingMode = mode;
      Browser.mainLoop.timingValue = value;
  
      if (!Browser.mainLoop.func) {
        console.error('emscripten_set_main_loop_timing: Cannot set timing mode for main loop since a main loop does not exist! Call emscripten_set_main_loop first to set one up.');
        return 1; // Return non-zero on failure, can't set timing mode when there is no main loop.
      }
  
      if (mode == 0 /*EM_TIMING_SETTIMEOUT*/) {
        Browser.mainLoop.scheduler = function Browser_mainLoop_scheduler() {
          setTimeout(Browser.mainLoop.runner, value); // doing this each time means that on exception, we stop
        };
        Browser.mainLoop.method = 'timeout';
      } else if (mode == 1 /*EM_TIMING_RAF*/) {
        Browser.mainLoop.scheduler = function Browser_mainLoop_scheduler() {
          Browser.requestAnimationFrame(Browser.mainLoop.runner);
        };
        Browser.mainLoop.method = 'rAF';
      }
      return 0;
    }function _emscripten_set_main_loop(func, fps, simulateInfiniteLoop, arg) {
      Module['noExitRuntime'] = true;
  
      assert(!Browser.mainLoop.func, 'emscripten_set_main_loop: there can only be one main loop function at once: call emscripten_cancel_main_loop to cancel the previous one before setting a new one with different parameters.');
  
      Browser.mainLoop.func = func;
      Browser.mainLoop.arg = arg;
  
      var thisMainLoopId = Browser.mainLoop.currentlyRunningMainloop;
  
      Browser.mainLoop.runner = function Browser_mainLoop_runner() {
        if (ABORT) return;
        if (Browser.mainLoop.queue.length > 0) {
          var start = Date.now();
          var blocker = Browser.mainLoop.queue.shift();
          blocker.func(blocker.arg);
          if (Browser.mainLoop.remainingBlockers) {
            var remaining = Browser.mainLoop.remainingBlockers;
            var next = remaining%1 == 0 ? remaining-1 : Math.floor(remaining);
            if (blocker.counted) {
              Browser.mainLoop.remainingBlockers = next;
            } else {
              // not counted, but move the progress along a tiny bit
              next = next + 0.5; // do not steal all the next one's progress
              Browser.mainLoop.remainingBlockers = (8*remaining + next)/9;
            }
          }
          console.log('main loop blocker "' + blocker.name + '" took ' + (Date.now() - start) + ' ms'); //, left: ' + Browser.mainLoop.remainingBlockers);
          Browser.mainLoop.updateStatus();
          setTimeout(Browser.mainLoop.runner, 0);
          return;
        }
  
        // catch pauses from non-main loop sources
        if (thisMainLoopId < Browser.mainLoop.currentlyRunningMainloop) return;
  
        // Implement very basic swap interval control
        Browser.mainLoop.currentFrameNumber = Browser.mainLoop.currentFrameNumber + 1 | 0;
        if (Browser.mainLoop.timingMode == 1/*EM_TIMING_RAF*/ && Browser.mainLoop.timingValue > 1 && Browser.mainLoop.currentFrameNumber % Browser.mainLoop.timingValue != 0) {
          // Not the scheduled time to render this frame - skip.
          Browser.mainLoop.scheduler();
          return;
        }
  
        // Signal GL rendering layer that processing of a new frame is about to start. This helps it optimize
        // VBO double-buffering and reduce GPU stalls.
  
        if (Browser.mainLoop.method === 'timeout' && Module.ctx) {
          Module.printErr('Looks like you are rendering without using requestAnimationFrame for the main loop. You should use 0 for the frame rate in emscripten_set_main_loop in order to use requestAnimationFrame, as that can greatly improve your frame rates!');
          Browser.mainLoop.method = ''; // just warn once per call to set main loop
        }
  
        Browser.mainLoop.runIter(function() {
          if (typeof arg !== 'undefined') {
            Runtime.dynCall('vi', func, [arg]);
          } else {
            Runtime.dynCall('v', func);
          }
        });
  
        // catch pauses from the main loop itself
        if (thisMainLoopId < Browser.mainLoop.currentlyRunningMainloop) return;
  
        // Queue new audio data. This is important to be right after the main loop invocation, so that we will immediately be able
        // to queue the newest produced audio samples.
        // TODO: Consider adding pre- and post- rAF callbacks so that GL.newRenderingFrameStarted() and SDL.audio.queueNewAudioData()
        //       do not need to be hardcoded into this function, but can be more generic.
        if (typeof SDL === 'object' && SDL.audio && SDL.audio.queueNewAudioData) SDL.audio.queueNewAudioData();
  
        Browser.mainLoop.scheduler();
      }
  
      if (fps && fps > 0) _emscripten_set_main_loop_timing(0/*EM_TIMING_SETTIMEOUT*/, 1000.0 / fps);
      else _emscripten_set_main_loop_timing(1/*EM_TIMING_RAF*/, 1); // Do rAF by rendering each frame (no decimating)
  
      Browser.mainLoop.scheduler();
  
      if (simulateInfiniteLoop) {
        throw 'SimulateInfiniteLoop';
      }
    }var Browser={mainLoop:{scheduler:null,method:"",currentlyRunningMainloop:0,func:null,arg:0,timingMode:0,timingValue:0,currentFrameNumber:0,queue:[],pause:function () {
          Browser.mainLoop.scheduler = null;
          Browser.mainLoop.currentlyRunningMainloop++; // Incrementing this signals the previous main loop that it's now become old, and it must return.
        },resume:function () {
          Browser.mainLoop.currentlyRunningMainloop++;
          var timingMode = Browser.mainLoop.timingMode;
          var timingValue = Browser.mainLoop.timingValue;
          var func = Browser.mainLoop.func;
          Browser.mainLoop.func = null;
          _emscripten_set_main_loop(func, 0, false, Browser.mainLoop.arg);
          _emscripten_set_main_loop_timing(timingMode, timingValue);
        },updateStatus:function () {
          if (Module['setStatus']) {
            var message = Module['statusMessage'] || 'Please wait...';
            var remaining = Browser.mainLoop.remainingBlockers;
            var expected = Browser.mainLoop.expectedBlockers;
            if (remaining) {
              if (remaining < expected) {
                Module['setStatus'](message + ' (' + (expected - remaining) + '/' + expected + ')');
              } else {
                Module['setStatus'](message);
              }
            } else {
              Module['setStatus']('');
            }
          }
        },runIter:function (func) {
          if (ABORT) return;
          if (Module['preMainLoop']) {
            var preRet = Module['preMainLoop']();
            if (preRet === false) {
              return; // |return false| skips a frame
            }
          }
          try {
            func();
          } catch (e) {
            if (e instanceof ExitStatus) {
              return;
            } else {
              if (e && typeof e === 'object' && e.stack) Module.printErr('exception thrown: ' + [e, e.stack]);
              throw e;
            }
          }
          if (Module['postMainLoop']) Module['postMainLoop']();
        }},isFullScreen:false,pointerLock:false,moduleContextCreatedCallbacks:[],workers:[],init:function () {
        if (!Module["preloadPlugins"]) Module["preloadPlugins"] = []; // needs to exist even in workers
  
        if (Browser.initted) return;
        Browser.initted = true;
  
        try {
          new Blob();
          Browser.hasBlobConstructor = true;
        } catch(e) {
          Browser.hasBlobConstructor = false;
          console.log("warning: no blob constructor, cannot create blobs with mimetypes");
        }
        Browser.BlobBuilder = typeof MozBlobBuilder != "undefined" ? MozBlobBuilder : (typeof WebKitBlobBuilder != "undefined" ? WebKitBlobBuilder : (!Browser.hasBlobConstructor ? console.log("warning: no BlobBuilder") : null));
        Browser.URLObject = typeof window != "undefined" ? (window.URL ? window.URL : window.webkitURL) : undefined;
        if (!Module.noImageDecoding && typeof Browser.URLObject === 'undefined') {
          console.log("warning: Browser does not support creating object URLs. Built-in browser image decoding will not be available.");
          Module.noImageDecoding = true;
        }
  
        // Support for plugins that can process preloaded files. You can add more of these to
        // your app by creating and appending to Module.preloadPlugins.
        //
        // Each plugin is asked if it can handle a file based on the file's name. If it can,
        // it is given the file's raw data. When it is done, it calls a callback with the file's
        // (possibly modified) data. For example, a plugin might decompress a file, or it
        // might create some side data structure for use later (like an Image element, etc.).
  
        var imagePlugin = {};
        imagePlugin['canHandle'] = function imagePlugin_canHandle(name) {
          return !Module.noImageDecoding && /\.(jpg|jpeg|png|bmp)$/i.test(name);
        };
        imagePlugin['handle'] = function imagePlugin_handle(byteArray, name, onload, onerror) {
          var b = null;
          if (Browser.hasBlobConstructor) {
            try {
              b = new Blob([byteArray], { type: Browser.getMimetype(name) });
              if (b.size !== byteArray.length) { // Safari bug #118630
                // Safari's Blob can only take an ArrayBuffer
                b = new Blob([(new Uint8Array(byteArray)).buffer], { type: Browser.getMimetype(name) });
              }
            } catch(e) {
              Runtime.warnOnce('Blob constructor present but fails: ' + e + '; falling back to blob builder');
            }
          }
          if (!b) {
            var bb = new Browser.BlobBuilder();
            bb.append((new Uint8Array(byteArray)).buffer); // we need to pass a buffer, and must copy the array to get the right data range
            b = bb.getBlob();
          }
          var url = Browser.URLObject.createObjectURL(b);
          assert(typeof url == 'string', 'createObjectURL must return a url as a string');
          var img = new Image();
          img.onload = function img_onload() {
            assert(img.complete, 'Image ' + name + ' could not be decoded');
            var canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            var ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);
            Module["preloadedImages"][name] = canvas;
            Browser.URLObject.revokeObjectURL(url);
            if (onload) onload(byteArray);
          };
          img.onerror = function img_onerror(event) {
            console.log('Image ' + url + ' could not be decoded');
            if (onerror) onerror();
          };
          img.src = url;
        };
        Module['preloadPlugins'].push(imagePlugin);
  
        var audioPlugin = {};
        audioPlugin['canHandle'] = function audioPlugin_canHandle(name) {
          return !Module.noAudioDecoding && name.substr(-4) in { '.ogg': 1, '.wav': 1, '.mp3': 1 };
        };
        audioPlugin['handle'] = function audioPlugin_handle(byteArray, name, onload, onerror) {
          var done = false;
          function finish(audio) {
            if (done) return;
            done = true;
            Module["preloadedAudios"][name] = audio;
            if (onload) onload(byteArray);
          }
          function fail() {
            if (done) return;
            done = true;
            Module["preloadedAudios"][name] = new Audio(); // empty shim
            if (onerror) onerror();
          }
          if (Browser.hasBlobConstructor) {
            try {
              var b = new Blob([byteArray], { type: Browser.getMimetype(name) });
            } catch(e) {
              return fail();
            }
            var url = Browser.URLObject.createObjectURL(b); // XXX we never revoke this!
            assert(typeof url == 'string', 'createObjectURL must return a url as a string');
            var audio = new Audio();
            audio.addEventListener('canplaythrough', function() { finish(audio) }, false); // use addEventListener due to chromium bug 124926
            audio.onerror = function audio_onerror(event) {
              if (done) return;
              console.log('warning: browser could not fully decode audio ' + name + ', trying slower base64 approach');
              function encode64(data) {
                var BASE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
                var PAD = '=';
                var ret = '';
                var leftchar = 0;
                var leftbits = 0;
                for (var i = 0; i < data.length; i++) {
                  leftchar = (leftchar << 8) | data[i];
                  leftbits += 8;
                  while (leftbits >= 6) {
                    var curr = (leftchar >> (leftbits-6)) & 0x3f;
                    leftbits -= 6;
                    ret += BASE[curr];
                  }
                }
                if (leftbits == 2) {
                  ret += BASE[(leftchar&3) << 4];
                  ret += PAD + PAD;
                } else if (leftbits == 4) {
                  ret += BASE[(leftchar&0xf) << 2];
                  ret += PAD;
                }
                return ret;
              }
              audio.src = 'data:audio/x-' + name.substr(-3) + ';base64,' + encode64(byteArray);
              finish(audio); // we don't wait for confirmation this worked - but it's worth trying
            };
            audio.src = url;
            // workaround for chrome bug 124926 - we do not always get oncanplaythrough or onerror
            Browser.safeSetTimeout(function() {
              finish(audio); // try to use it even though it is not necessarily ready to play
            }, 10000);
          } else {
            return fail();
          }
        };
        Module['preloadPlugins'].push(audioPlugin);
  
        // Canvas event setup
  
        var canvas = Module['canvas'];
        function pointerLockChange() {
          Browser.pointerLock = document['pointerLockElement'] === canvas ||
                                document['mozPointerLockElement'] === canvas ||
                                document['webkitPointerLockElement'] === canvas ||
                                document['msPointerLockElement'] === canvas;
        }
        if (canvas) {
          // forced aspect ratio can be enabled by defining 'forcedAspectRatio' on Module
          // Module['forcedAspectRatio'] = 4 / 3;
          
          canvas.requestPointerLock = canvas['requestPointerLock'] ||
                                      canvas['mozRequestPointerLock'] ||
                                      canvas['webkitRequestPointerLock'] ||
                                      canvas['msRequestPointerLock'] ||
                                      function(){};
          canvas.exitPointerLock = document['exitPointerLock'] ||
                                   document['mozExitPointerLock'] ||
                                   document['webkitExitPointerLock'] ||
                                   document['msExitPointerLock'] ||
                                   function(){}; // no-op if function does not exist
          canvas.exitPointerLock = canvas.exitPointerLock.bind(document);
  
  
          document.addEventListener('pointerlockchange', pointerLockChange, false);
          document.addEventListener('mozpointerlockchange', pointerLockChange, false);
          document.addEventListener('webkitpointerlockchange', pointerLockChange, false);
          document.addEventListener('mspointerlockchange', pointerLockChange, false);
  
          if (Module['elementPointerLock']) {
            canvas.addEventListener("click", function(ev) {
              if (!Browser.pointerLock && canvas.requestPointerLock) {
                canvas.requestPointerLock();
                ev.preventDefault();
              }
            }, false);
          }
        }
      },createContext:function (canvas, useWebGL, setInModule, webGLContextAttributes) {
        if (useWebGL && Module.ctx && canvas == Module.canvas) return Module.ctx; // no need to recreate GL context if it's already been created for this canvas.
  
        var ctx;
        var contextHandle;
        if (useWebGL) {
          // For GLES2/desktop GL compatibility, adjust a few defaults to be different to WebGL defaults, so that they align better with the desktop defaults.
          var contextAttributes = {
            antialias: false,
            alpha: false
          };
  
          if (webGLContextAttributes) {
            for (var attribute in webGLContextAttributes) {
              contextAttributes[attribute] = webGLContextAttributes[attribute];
            }
          }
  
          contextHandle = GL.createContext(canvas, contextAttributes);
          if (contextHandle) {
            ctx = GL.getContext(contextHandle).GLctx;
          }
          // Set the background of the WebGL canvas to black
          canvas.style.backgroundColor = "black";
        } else {
          ctx = canvas.getContext('2d');
        }
  
        if (!ctx) return null;
  
        if (setInModule) {
          if (!useWebGL) assert(typeof GLctx === 'undefined', 'cannot set in module if GLctx is used, but we are a non-GL context that would replace it');
  
          Module.ctx = ctx;
          if (useWebGL) GL.makeContextCurrent(contextHandle);
          Module.useWebGL = useWebGL;
          Browser.moduleContextCreatedCallbacks.forEach(function(callback) { callback() });
          Browser.init();
        }
        return ctx;
      },destroyContext:function (canvas, useWebGL, setInModule) {},fullScreenHandlersInstalled:false,lockPointer:undefined,resizeCanvas:undefined,requestFullScreen:function (lockPointer, resizeCanvas, vrDevice) {
        Browser.lockPointer = lockPointer;
        Browser.resizeCanvas = resizeCanvas;
        Browser.vrDevice = vrDevice;
        if (typeof Browser.lockPointer === 'undefined') Browser.lockPointer = true;
        if (typeof Browser.resizeCanvas === 'undefined') Browser.resizeCanvas = false;
        if (typeof Browser.vrDevice === 'undefined') Browser.vrDevice = null;
  
        var canvas = Module['canvas'];
        function fullScreenChange() {
          Browser.isFullScreen = false;
          var canvasContainer = canvas.parentNode;
          if ((document['webkitFullScreenElement'] || document['webkitFullscreenElement'] ||
               document['mozFullScreenElement'] || document['mozFullscreenElement'] ||
               document['fullScreenElement'] || document['fullscreenElement'] ||
               document['msFullScreenElement'] || document['msFullscreenElement'] ||
               document['webkitCurrentFullScreenElement']) === canvasContainer) {
            canvas.cancelFullScreen = document['cancelFullScreen'] ||
                                      document['mozCancelFullScreen'] ||
                                      document['webkitCancelFullScreen'] ||
                                      document['msExitFullscreen'] ||
                                      document['exitFullscreen'] ||
                                      function() {};
            canvas.cancelFullScreen = canvas.cancelFullScreen.bind(document);
            if (Browser.lockPointer) canvas.requestPointerLock();
            Browser.isFullScreen = true;
            if (Browser.resizeCanvas) Browser.setFullScreenCanvasSize();
          } else {
            
            // remove the full screen specific parent of the canvas again to restore the HTML structure from before going full screen
            canvasContainer.parentNode.insertBefore(canvas, canvasContainer);
            canvasContainer.parentNode.removeChild(canvasContainer);
            
            if (Browser.resizeCanvas) Browser.setWindowedCanvasSize();
          }
          if (Module['onFullScreen']) Module['onFullScreen'](Browser.isFullScreen);
          Browser.updateCanvasDimensions(canvas);
        }
  
        if (!Browser.fullScreenHandlersInstalled) {
          Browser.fullScreenHandlersInstalled = true;
          document.addEventListener('fullscreenchange', fullScreenChange, false);
          document.addEventListener('mozfullscreenchange', fullScreenChange, false);
          document.addEventListener('webkitfullscreenchange', fullScreenChange, false);
          document.addEventListener('MSFullscreenChange', fullScreenChange, false);
        }
  
        // create a new parent to ensure the canvas has no siblings. this allows browsers to optimize full screen performance when its parent is the full screen root
        var canvasContainer = document.createElement("div");
        canvas.parentNode.insertBefore(canvasContainer, canvas);
        canvasContainer.appendChild(canvas);
  
        // use parent of canvas as full screen root to allow aspect ratio correction (Firefox stretches the root to screen size)
        canvasContainer.requestFullScreen = canvasContainer['requestFullScreen'] ||
                                            canvasContainer['mozRequestFullScreen'] ||
                                            canvasContainer['msRequestFullscreen'] ||
                                           (canvasContainer['webkitRequestFullScreen'] ? function() { canvasContainer['webkitRequestFullScreen'](Element['ALLOW_KEYBOARD_INPUT']) } : null);
  
        if (vrDevice) {
          canvasContainer.requestFullScreen({ vrDisplay: vrDevice });
        } else {
          canvasContainer.requestFullScreen();
        }
      },nextRAF:0,fakeRequestAnimationFrame:function (func) {
        // try to keep 60fps between calls to here
        var now = Date.now();
        if (Browser.nextRAF === 0) {
          Browser.nextRAF = now + 1000/60;
        } else {
          while (now + 2 >= Browser.nextRAF) { // fudge a little, to avoid timer jitter causing us to do lots of delay:0
            Browser.nextRAF += 1000/60;
          }
        }
        var delay = Math.max(Browser.nextRAF - now, 0);
        setTimeout(func, delay);
      },requestAnimationFrame:function requestAnimationFrame(func) {
        if (typeof window === 'undefined') { // Provide fallback to setTimeout if window is undefined (e.g. in Node.js)
          Browser.fakeRequestAnimationFrame(func);
        } else {
          if (!window.requestAnimationFrame) {
            window.requestAnimationFrame = window['requestAnimationFrame'] ||
                                           window['mozRequestAnimationFrame'] ||
                                           window['webkitRequestAnimationFrame'] ||
                                           window['msRequestAnimationFrame'] ||
                                           window['oRequestAnimationFrame'] ||
                                           Browser.fakeRequestAnimationFrame;
          }
          window.requestAnimationFrame(func);
        }
      },safeCallback:function (func) {
        return function() {
          if (!ABORT) return func.apply(null, arguments);
        };
      },allowAsyncCallbacks:true,queuedAsyncCallbacks:[],pauseAsyncCallbacks:function () {
        Browser.allowAsyncCallbacks = false;
      },resumeAsyncCallbacks:function () { // marks future callbacks as ok to execute, and synchronously runs any remaining ones right now
        Browser.allowAsyncCallbacks = true;
        if (Browser.queuedAsyncCallbacks.length > 0) {
          var callbacks = Browser.queuedAsyncCallbacks;
          Browser.queuedAsyncCallbacks = [];
          callbacks.forEach(function(func) {
            func();
          });
        }
      },safeRequestAnimationFrame:function (func) {
        return Browser.requestAnimationFrame(function() {
          if (ABORT) return;
          if (Browser.allowAsyncCallbacks) {
            func();
          } else {
            Browser.queuedAsyncCallbacks.push(func);
          }
        });
      },safeSetTimeout:function (func, timeout) {
        Module['noExitRuntime'] = true;
        return setTimeout(function() {
          if (ABORT) return;
          if (Browser.allowAsyncCallbacks) {
            func();
          } else {
            Browser.queuedAsyncCallbacks.push(func);
          }
        }, timeout);
      },safeSetInterval:function (func, timeout) {
        Module['noExitRuntime'] = true;
        return setInterval(function() {
          if (ABORT) return;
          if (Browser.allowAsyncCallbacks) {
            func();
          } // drop it on the floor otherwise, next interval will kick in
        }, timeout);
      },getMimetype:function (name) {
        return {
          'jpg': 'image/jpeg',
          'jpeg': 'image/jpeg',
          'png': 'image/png',
          'bmp': 'image/bmp',
          'ogg': 'audio/ogg',
          'wav': 'audio/wav',
          'mp3': 'audio/mpeg'
        }[name.substr(name.lastIndexOf('.')+1)];
      },getUserMedia:function (func) {
        if(!window.getUserMedia) {
          window.getUserMedia = navigator['getUserMedia'] ||
                                navigator['mozGetUserMedia'];
        }
        window.getUserMedia(func);
      },getMovementX:function (event) {
        return event['movementX'] ||
               event['mozMovementX'] ||
               event['webkitMovementX'] ||
               0;
      },getMovementY:function (event) {
        return event['movementY'] ||
               event['mozMovementY'] ||
               event['webkitMovementY'] ||
               0;
      },getMouseWheelDelta:function (event) {
        var delta = 0;
        switch (event.type) {
          case 'DOMMouseScroll': 
            delta = event.detail;
            break;
          case 'mousewheel': 
            delta = event.wheelDelta;
            break;
          case 'wheel': 
            delta = event['deltaY'];
            break;
          default:
            throw 'unrecognized mouse wheel event: ' + event.type;
        }
        return delta;
      },mouseX:0,mouseY:0,mouseMovementX:0,mouseMovementY:0,touches:{},lastTouches:{},calculateMouseEvent:function (event) { // event should be mousemove, mousedown or mouseup
        if (Browser.pointerLock) {
          // When the pointer is locked, calculate the coordinates
          // based on the movement of the mouse.
          // Workaround for Firefox bug 764498
          if (event.type != 'mousemove' &&
              ('mozMovementX' in event)) {
            Browser.mouseMovementX = Browser.mouseMovementY = 0;
          } else {
            Browser.mouseMovementX = Browser.getMovementX(event);
            Browser.mouseMovementY = Browser.getMovementY(event);
          }
          
          // check if SDL is available
          if (typeof SDL != "undefined") {
          	Browser.mouseX = SDL.mouseX + Browser.mouseMovementX;
          	Browser.mouseY = SDL.mouseY + Browser.mouseMovementY;
          } else {
          	// just add the mouse delta to the current absolut mouse position
          	// FIXME: ideally this should be clamped against the canvas size and zero
          	Browser.mouseX += Browser.mouseMovementX;
          	Browser.mouseY += Browser.mouseMovementY;
          }        
        } else {
          // Otherwise, calculate the movement based on the changes
          // in the coordinates.
          var rect = Module["canvas"].getBoundingClientRect();
          var cw = Module["canvas"].width;
          var ch = Module["canvas"].height;
  
          // Neither .scrollX or .pageXOffset are defined in a spec, but
          // we prefer .scrollX because it is currently in a spec draft.
          // (see: http://www.w3.org/TR/2013/WD-cssom-view-20131217/)
          var scrollX = ((typeof window.scrollX !== 'undefined') ? window.scrollX : window.pageXOffset);
          var scrollY = ((typeof window.scrollY !== 'undefined') ? window.scrollY : window.pageYOffset);
          // If this assert lands, it's likely because the browser doesn't support scrollX or pageXOffset
          // and we have no viable fallback.
          assert((typeof scrollX !== 'undefined') && (typeof scrollY !== 'undefined'), 'Unable to retrieve scroll position, mouse positions likely broken.');
  
          if (event.type === 'touchstart' || event.type === 'touchend' || event.type === 'touchmove') {
            var touch = event.touch;
            if (touch === undefined) {
              return; // the "touch" property is only defined in SDL
  
            }
            var adjustedX = touch.pageX - (scrollX + rect.left);
            var adjustedY = touch.pageY - (scrollY + rect.top);
  
            adjustedX = adjustedX * (cw / rect.width);
            adjustedY = adjustedY * (ch / rect.height);
  
            var coords = { x: adjustedX, y: adjustedY };
            
            if (event.type === 'touchstart') {
              Browser.lastTouches[touch.identifier] = coords;
              Browser.touches[touch.identifier] = coords;
            } else if (event.type === 'touchend' || event.type === 'touchmove') {
              Browser.lastTouches[touch.identifier] = Browser.touches[touch.identifier];
              Browser.touches[touch.identifier] = { x: adjustedX, y: adjustedY };
            } 
            return;
          }
  
          var x = event.pageX - (scrollX + rect.left);
          var y = event.pageY - (scrollY + rect.top);
  
          // the canvas might be CSS-scaled compared to its backbuffer;
          // SDL-using content will want mouse coordinates in terms
          // of backbuffer units.
          x = x * (cw / rect.width);
          y = y * (ch / rect.height);
  
          Browser.mouseMovementX = x - Browser.mouseX;
          Browser.mouseMovementY = y - Browser.mouseY;
          Browser.mouseX = x;
          Browser.mouseY = y;
        }
      },xhrLoad:function (url, onload, onerror) {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', url, true);
        xhr.responseType = 'arraybuffer';
        xhr.onload = function xhr_onload() {
          if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) { // file URLs can return 0
            onload(xhr.response);
          } else {
            onerror();
          }
        };
        xhr.onerror = onerror;
        xhr.send(null);
      },asyncLoad:function (url, onload, onerror, noRunDep) {
        Browser.xhrLoad(url, function(arrayBuffer) {
          assert(arrayBuffer, 'Loading data file "' + url + '" failed (no arrayBuffer).');
          onload(new Uint8Array(arrayBuffer));
          if (!noRunDep) removeRunDependency('al ' + url);
        }, function(event) {
          if (onerror) {
            onerror();
          } else {
            throw 'Loading data file "' + url + '" failed.';
          }
        });
        if (!noRunDep) addRunDependency('al ' + url);
      },resizeListeners:[],updateResizeListeners:function () {
        var canvas = Module['canvas'];
        Browser.resizeListeners.forEach(function(listener) {
          listener(canvas.width, canvas.height);
        });
      },setCanvasSize:function (width, height, noUpdates) {
        var canvas = Module['canvas'];
        Browser.updateCanvasDimensions(canvas, width, height);
        if (!noUpdates) Browser.updateResizeListeners();
      },windowedWidth:0,windowedHeight:0,setFullScreenCanvasSize:function () {
        // check if SDL is available   
        if (typeof SDL != "undefined") {
        	var flags = HEAPU32[((SDL.screen+Runtime.QUANTUM_SIZE*0)>>2)];
        	flags = flags | 0x00800000; // set SDL_FULLSCREEN flag
        	HEAP32[((SDL.screen+Runtime.QUANTUM_SIZE*0)>>2)]=flags
        }
        Browser.updateResizeListeners();
      },setWindowedCanvasSize:function () {
        // check if SDL is available       
        if (typeof SDL != "undefined") {
        	var flags = HEAPU32[((SDL.screen+Runtime.QUANTUM_SIZE*0)>>2)];
        	flags = flags & ~0x00800000; // clear SDL_FULLSCREEN flag
        	HEAP32[((SDL.screen+Runtime.QUANTUM_SIZE*0)>>2)]=flags
        }
        Browser.updateResizeListeners();
      },updateCanvasDimensions:function (canvas, wNative, hNative) {
        if (wNative && hNative) {
          canvas.widthNative = wNative;
          canvas.heightNative = hNative;
        } else {
          wNative = canvas.widthNative;
          hNative = canvas.heightNative;
        }
        var w = wNative;
        var h = hNative;
        if (Module['forcedAspectRatio'] && Module['forcedAspectRatio'] > 0) {
          if (w/h < Module['forcedAspectRatio']) {
            w = Math.round(h * Module['forcedAspectRatio']);
          } else {
            h = Math.round(w / Module['forcedAspectRatio']);
          }
        }
        if (((document['webkitFullScreenElement'] || document['webkitFullscreenElement'] ||
             document['mozFullScreenElement'] || document['mozFullscreenElement'] ||
             document['fullScreenElement'] || document['fullscreenElement'] ||
             document['msFullScreenElement'] || document['msFullscreenElement'] ||
             document['webkitCurrentFullScreenElement']) === canvas.parentNode) && (typeof screen != 'undefined')) {
           var factor = Math.min(screen.width / w, screen.height / h);
           w = Math.round(w * factor);
           h = Math.round(h * factor);
        }
        if (Browser.resizeCanvas) {
          if (canvas.width  != w) canvas.width  = w;
          if (canvas.height != h) canvas.height = h;
          if (typeof canvas.style != 'undefined') {
            canvas.style.removeProperty( "width");
            canvas.style.removeProperty("height");
          }
        } else {
          if (canvas.width  != wNative) canvas.width  = wNative;
          if (canvas.height != hNative) canvas.height = hNative;
          if (typeof canvas.style != 'undefined') {
            if (w != wNative || h != hNative) {
              canvas.style.setProperty( "width", w + "px", "important");
              canvas.style.setProperty("height", h + "px", "important");
            } else {
              canvas.style.removeProperty( "width");
              canvas.style.removeProperty("height");
            }
          }
        }
      },wgetRequests:{},nextWgetRequestHandle:0,getNextWgetRequestHandle:function () {
        var handle = Browser.nextWgetRequestHandle;
        Browser.nextWgetRequestHandle++;
        return handle;
      }};

  function _pthread_setspecific(key, value) {
      if (!(key in PTHREAD_SPECIFIC)) {
        return ERRNO_CODES.EINVAL;
      }
      PTHREAD_SPECIFIC[key] = value;
      return 0;
    }

  function _time(ptr) {
      var ret = (Date.now()/1000)|0;
      if (ptr) {
        HEAP32[((ptr)>>2)]=ret;
      }
      return ret;
    }

  
  function _malloc(bytes) {
      /* Over-allocate to make sure it is byte-aligned by 8.
       * This will leak memory, but this is only the dummy
       * implementation (replaced by dlmalloc normally) so
       * not an issue.
       */
      var ptr = Runtime.dynamicAlloc(bytes + 8);
      return (ptr+8) & 0xFFFFFFF8;
    }
  Module["_malloc"] = _malloc;function ___cxa_allocate_exception(size) {
      return _malloc(size);
    }

  
  
  function _fwrite(ptr, size, nitems, stream) {
      // size_t fwrite(const void *restrict ptr, size_t size, size_t nitems, FILE *restrict stream);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/fwrite.html
      var bytesToWrite = nitems * size;
      if (bytesToWrite == 0) return 0;
      var fd = _fileno(stream);
      var bytesWritten = _write(fd, ptr, bytesToWrite);
      if (bytesWritten == -1) {
        var streamObj = FS.getStreamFromPtr(stream);
        if (streamObj) streamObj.error = true;
        return 0;
      } else {
        return (bytesWritten / size)|0;
      }
    }
  
  
  function __reallyNegative(x) {
      return x < 0 || (x === 0 && (1/x) === -Infinity);
    }function __formatString(format, varargs) {
      var textIndex = format;
      var argIndex = 0;
      function getNextArg(type) {
        // NOTE: Explicitly ignoring type safety. Otherwise this fails:
        //       int x = 4; printf("%c\n", (char)x);
        var ret;
        if (type === 'double') {
          ret = (HEAP32[((tempDoublePtr)>>2)]=HEAP32[(((varargs)+(argIndex))>>2)],HEAP32[(((tempDoublePtr)+(4))>>2)]=HEAP32[(((varargs)+((argIndex)+(4)))>>2)],(+(HEAPF64[(tempDoublePtr)>>3])));
        } else if (type == 'i64') {
          ret = [HEAP32[(((varargs)+(argIndex))>>2)],
                 HEAP32[(((varargs)+(argIndex+4))>>2)]];
  
        } else {
          type = 'i32'; // varargs are always i32, i64, or double
          ret = HEAP32[(((varargs)+(argIndex))>>2)];
        }
        argIndex += Runtime.getNativeFieldSize(type);
        return ret;
      }
  
      var ret = [];
      var curr, next, currArg;
      while(1) {
        var startTextIndex = textIndex;
        curr = HEAP8[((textIndex)>>0)];
        if (curr === 0) break;
        next = HEAP8[((textIndex+1)>>0)];
        if (curr == 37) {
          // Handle flags.
          var flagAlwaysSigned = false;
          var flagLeftAlign = false;
          var flagAlternative = false;
          var flagZeroPad = false;
          var flagPadSign = false;
          flagsLoop: while (1) {
            switch (next) {
              case 43:
                flagAlwaysSigned = true;
                break;
              case 45:
                flagLeftAlign = true;
                break;
              case 35:
                flagAlternative = true;
                break;
              case 48:
                if (flagZeroPad) {
                  break flagsLoop;
                } else {
                  flagZeroPad = true;
                  break;
                }
              case 32:
                flagPadSign = true;
                break;
              default:
                break flagsLoop;
            }
            textIndex++;
            next = HEAP8[((textIndex+1)>>0)];
          }
  
          // Handle width.
          var width = 0;
          if (next == 42) {
            width = getNextArg('i32');
            textIndex++;
            next = HEAP8[((textIndex+1)>>0)];
          } else {
            while (next >= 48 && next <= 57) {
              width = width * 10 + (next - 48);
              textIndex++;
              next = HEAP8[((textIndex+1)>>0)];
            }
          }
  
          // Handle precision.
          var precisionSet = false, precision = -1;
          if (next == 46) {
            precision = 0;
            precisionSet = true;
            textIndex++;
            next = HEAP8[((textIndex+1)>>0)];
            if (next == 42) {
              precision = getNextArg('i32');
              textIndex++;
            } else {
              while(1) {
                var precisionChr = HEAP8[((textIndex+1)>>0)];
                if (precisionChr < 48 ||
                    precisionChr > 57) break;
                precision = precision * 10 + (precisionChr - 48);
                textIndex++;
              }
            }
            next = HEAP8[((textIndex+1)>>0)];
          }
          if (precision < 0) {
            precision = 6; // Standard default.
            precisionSet = false;
          }
  
          // Handle integer sizes. WARNING: These assume a 32-bit architecture!
          var argSize;
          switch (String.fromCharCode(next)) {
            case 'h':
              var nextNext = HEAP8[((textIndex+2)>>0)];
              if (nextNext == 104) {
                textIndex++;
                argSize = 1; // char (actually i32 in varargs)
              } else {
                argSize = 2; // short (actually i32 in varargs)
              }
              break;
            case 'l':
              var nextNext = HEAP8[((textIndex+2)>>0)];
              if (nextNext == 108) {
                textIndex++;
                argSize = 8; // long long
              } else {
                argSize = 4; // long
              }
              break;
            case 'L': // long long
            case 'q': // int64_t
            case 'j': // intmax_t
              argSize = 8;
              break;
            case 'z': // size_t
            case 't': // ptrdiff_t
            case 'I': // signed ptrdiff_t or unsigned size_t
              argSize = 4;
              break;
            default:
              argSize = null;
          }
          if (argSize) textIndex++;
          next = HEAP8[((textIndex+1)>>0)];
  
          // Handle type specifier.
          switch (String.fromCharCode(next)) {
            case 'd': case 'i': case 'u': case 'o': case 'x': case 'X': case 'p': {
              // Integer.
              var signed = next == 100 || next == 105;
              argSize = argSize || 4;
              var currArg = getNextArg('i' + (argSize * 8));
              var origArg = currArg;
              var argText;
              // Flatten i64-1 [low, high] into a (slightly rounded) double
              if (argSize == 8) {
                currArg = Runtime.makeBigInt(currArg[0], currArg[1], next == 117);
              }
              // Truncate to requested size.
              if (argSize <= 4) {
                var limit = Math.pow(256, argSize) - 1;
                currArg = (signed ? reSign : unSign)(currArg & limit, argSize * 8);
              }
              // Format the number.
              var currAbsArg = Math.abs(currArg);
              var prefix = '';
              if (next == 100 || next == 105) {
                if (argSize == 8 && i64Math) argText = i64Math.stringify(origArg[0], origArg[1], null); else
                argText = reSign(currArg, 8 * argSize, 1).toString(10);
              } else if (next == 117) {
                if (argSize == 8 && i64Math) argText = i64Math.stringify(origArg[0], origArg[1], true); else
                argText = unSign(currArg, 8 * argSize, 1).toString(10);
                currArg = Math.abs(currArg);
              } else if (next == 111) {
                argText = (flagAlternative ? '0' : '') + currAbsArg.toString(8);
              } else if (next == 120 || next == 88) {
                prefix = (flagAlternative && currArg != 0) ? '0x' : '';
                if (argSize == 8 && i64Math) {
                  if (origArg[1]) {
                    argText = (origArg[1]>>>0).toString(16);
                    var lower = (origArg[0]>>>0).toString(16);
                    while (lower.length < 8) lower = '0' + lower;
                    argText += lower;
                  } else {
                    argText = (origArg[0]>>>0).toString(16);
                  }
                } else
                if (currArg < 0) {
                  // Represent negative numbers in hex as 2's complement.
                  currArg = -currArg;
                  argText = (currAbsArg - 1).toString(16);
                  var buffer = [];
                  for (var i = 0; i < argText.length; i++) {
                    buffer.push((0xF - parseInt(argText[i], 16)).toString(16));
                  }
                  argText = buffer.join('');
                  while (argText.length < argSize * 2) argText = 'f' + argText;
                } else {
                  argText = currAbsArg.toString(16);
                }
                if (next == 88) {
                  prefix = prefix.toUpperCase();
                  argText = argText.toUpperCase();
                }
              } else if (next == 112) {
                if (currAbsArg === 0) {
                  argText = '(nil)';
                } else {
                  prefix = '0x';
                  argText = currAbsArg.toString(16);
                }
              }
              if (precisionSet) {
                while (argText.length < precision) {
                  argText = '0' + argText;
                }
              }
  
              // Add sign if needed
              if (currArg >= 0) {
                if (flagAlwaysSigned) {
                  prefix = '+' + prefix;
                } else if (flagPadSign) {
                  prefix = ' ' + prefix;
                }
              }
  
              // Move sign to prefix so we zero-pad after the sign
              if (argText.charAt(0) == '-') {
                prefix = '-' + prefix;
                argText = argText.substr(1);
              }
  
              // Add padding.
              while (prefix.length + argText.length < width) {
                if (flagLeftAlign) {
                  argText += ' ';
                } else {
                  if (flagZeroPad) {
                    argText = '0' + argText;
                  } else {
                    prefix = ' ' + prefix;
                  }
                }
              }
  
              // Insert the result into the buffer.
              argText = prefix + argText;
              argText.split('').forEach(function(chr) {
                ret.push(chr.charCodeAt(0));
              });
              break;
            }
            case 'f': case 'F': case 'e': case 'E': case 'g': case 'G': {
              // Float.
              var currArg = getNextArg('double');
              var argText;
              if (isNaN(currArg)) {
                argText = 'nan';
                flagZeroPad = false;
              } else if (!isFinite(currArg)) {
                argText = (currArg < 0 ? '-' : '') + 'inf';
                flagZeroPad = false;
              } else {
                var isGeneral = false;
                var effectivePrecision = Math.min(precision, 20);
  
                // Convert g/G to f/F or e/E, as per:
                // http://pubs.opengroup.org/onlinepubs/9699919799/functions/printf.html
                if (next == 103 || next == 71) {
                  isGeneral = true;
                  precision = precision || 1;
                  var exponent = parseInt(currArg.toExponential(effectivePrecision).split('e')[1], 10);
                  if (precision > exponent && exponent >= -4) {
                    next = ((next == 103) ? 'f' : 'F').charCodeAt(0);
                    precision -= exponent + 1;
                  } else {
                    next = ((next == 103) ? 'e' : 'E').charCodeAt(0);
                    precision--;
                  }
                  effectivePrecision = Math.min(precision, 20);
                }
  
                if (next == 101 || next == 69) {
                  argText = currArg.toExponential(effectivePrecision);
                  // Make sure the exponent has at least 2 digits.
                  if (/[eE][-+]\d$/.test(argText)) {
                    argText = argText.slice(0, -1) + '0' + argText.slice(-1);
                  }
                } else if (next == 102 || next == 70) {
                  argText = currArg.toFixed(effectivePrecision);
                  if (currArg === 0 && __reallyNegative(currArg)) {
                    argText = '-' + argText;
                  }
                }
  
                var parts = argText.split('e');
                if (isGeneral && !flagAlternative) {
                  // Discard trailing zeros and periods.
                  while (parts[0].length > 1 && parts[0].indexOf('.') != -1 &&
                         (parts[0].slice(-1) == '0' || parts[0].slice(-1) == '.')) {
                    parts[0] = parts[0].slice(0, -1);
                  }
                } else {
                  // Make sure we have a period in alternative mode.
                  if (flagAlternative && argText.indexOf('.') == -1) parts[0] += '.';
                  // Zero pad until required precision.
                  while (precision > effectivePrecision++) parts[0] += '0';
                }
                argText = parts[0] + (parts.length > 1 ? 'e' + parts[1] : '');
  
                // Capitalize 'E' if needed.
                if (next == 69) argText = argText.toUpperCase();
  
                // Add sign.
                if (currArg >= 0) {
                  if (flagAlwaysSigned) {
                    argText = '+' + argText;
                  } else if (flagPadSign) {
                    argText = ' ' + argText;
                  }
                }
              }
  
              // Add padding.
              while (argText.length < width) {
                if (flagLeftAlign) {
                  argText += ' ';
                } else {
                  if (flagZeroPad && (argText[0] == '-' || argText[0] == '+')) {
                    argText = argText[0] + '0' + argText.slice(1);
                  } else {
                    argText = (flagZeroPad ? '0' : ' ') + argText;
                  }
                }
              }
  
              // Adjust case.
              if (next < 97) argText = argText.toUpperCase();
  
              // Insert the result into the buffer.
              argText.split('').forEach(function(chr) {
                ret.push(chr.charCodeAt(0));
              });
              break;
            }
            case 's': {
              // String.
              var arg = getNextArg('i8*');
              var argLength = arg ? _strlen(arg) : '(null)'.length;
              if (precisionSet) argLength = Math.min(argLength, precision);
              if (!flagLeftAlign) {
                while (argLength < width--) {
                  ret.push(32);
                }
              }
              if (arg) {
                for (var i = 0; i < argLength; i++) {
                  ret.push(HEAPU8[((arg++)>>0)]);
                }
              } else {
                ret = ret.concat(intArrayFromString('(null)'.substr(0, argLength), true));
              }
              if (flagLeftAlign) {
                while (argLength < width--) {
                  ret.push(32);
                }
              }
              break;
            }
            case 'c': {
              // Character.
              if (flagLeftAlign) ret.push(getNextArg('i8'));
              while (--width > 0) {
                ret.push(32);
              }
              if (!flagLeftAlign) ret.push(getNextArg('i8'));
              break;
            }
            case 'n': {
              // Write the length written so far to the next parameter.
              var ptr = getNextArg('i32*');
              HEAP32[((ptr)>>2)]=ret.length;
              break;
            }
            case '%': {
              // Literal percent sign.
              ret.push(curr);
              break;
            }
            default: {
              // Unknown specifiers remain untouched.
              for (var i = startTextIndex; i < textIndex + 2; i++) {
                ret.push(HEAP8[((i)>>0)]);
              }
            }
          }
          textIndex += 2;
          // TODO: Support a/A (hex float) and m (last error) specifiers.
          // TODO: Support %1${specifier} for arg selection.
        } else {
          ret.push(curr);
          textIndex += 1;
        }
      }
      return ret;
    }function _fprintf(stream, format, varargs) {
      // int fprintf(FILE *restrict stream, const char *restrict format, ...);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/printf.html
      var result = __formatString(format, varargs);
      var stack = Runtime.stackSave();
      var ret = _fwrite(allocate(result, 'i8', ALLOC_STACK), 1, result.length, stream);
      Runtime.stackRestore(stack);
      return ret;
    }function _vfprintf(s, f, va_arg) {
      return _fprintf(s, f, HEAP32[((va_arg)>>2)]);
    }

___errno_state = Runtime.staticAlloc(4); HEAP32[((___errno_state)>>2)]=0;
_fputc.ret = allocate([0], "i8", ALLOC_STATIC);
FS.staticInit();__ATINIT__.unshift({ func: function() { if (!Module["noFSInit"] && !FS.init.initialized) FS.init() } });__ATMAIN__.push({ func: function() { FS.ignorePermissions = false } });__ATEXIT__.push({ func: function() { FS.quit() } });Module["FS_createFolder"] = FS.createFolder;Module["FS_createPath"] = FS.createPath;Module["FS_createDataFile"] = FS.createDataFile;Module["FS_createPreloadedFile"] = FS.createPreloadedFile;Module["FS_createLazyFile"] = FS.createLazyFile;Module["FS_createLink"] = FS.createLink;Module["FS_createDevice"] = FS.createDevice;
__ATINIT__.unshift({ func: function() { TTY.init() } });__ATEXIT__.push({ func: function() { TTY.shutdown() } });
if (ENVIRONMENT_IS_NODE) { var fs = require("fs"); NODEFS.staticInit(); }
__ATINIT__.push({ func: function() { SOCKFS.root = FS.mount(SOCKFS, {}, null); } });
Module["requestFullScreen"] = function Module_requestFullScreen(lockPointer, resizeCanvas, vrDevice) { Browser.requestFullScreen(lockPointer, resizeCanvas, vrDevice) };
  Module["requestAnimationFrame"] = function Module_requestAnimationFrame(func) { Browser.requestAnimationFrame(func) };
  Module["setCanvasSize"] = function Module_setCanvasSize(width, height, noUpdates) { Browser.setCanvasSize(width, height, noUpdates) };
  Module["pauseMainLoop"] = function Module_pauseMainLoop() { Browser.mainLoop.pause() };
  Module["resumeMainLoop"] = function Module_resumeMainLoop() { Browser.mainLoop.resume() };
  Module["getUserMedia"] = function Module_getUserMedia() { Browser.getUserMedia() }
STACK_BASE = STACKTOP = Runtime.alignMemory(STATICTOP);

staticSealed = true; // seal the static portion of memory

STACK_MAX = STACK_BASE + TOTAL_STACK;

DYNAMIC_BASE = DYNAMICTOP = Runtime.alignMemory(STACK_MAX);

assert(DYNAMIC_BASE < TOTAL_MEMORY, "TOTAL_MEMORY not big enough for stack");



function nullFunc_iiii(x) { Module["printErr"]("Invalid function pointer called with signature 'iiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");  Module["printErr"]("Build with ASSERTIONS=2 for more info."); abort(x) }

function nullFunc_viiiii(x) { Module["printErr"]("Invalid function pointer called with signature 'viiiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");  Module["printErr"]("Build with ASSERTIONS=2 for more info."); abort(x) }

function nullFunc_i(x) { Module["printErr"]("Invalid function pointer called with signature 'i'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");  Module["printErr"]("Build with ASSERTIONS=2 for more info."); abort(x) }

function nullFunc_vi(x) { Module["printErr"]("Invalid function pointer called with signature 'vi'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");  Module["printErr"]("Build with ASSERTIONS=2 for more info."); abort(x) }

function nullFunc_vii(x) { Module["printErr"]("Invalid function pointer called with signature 'vii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");  Module["printErr"]("Build with ASSERTIONS=2 for more info."); abort(x) }

function nullFunc_ii(x) { Module["printErr"]("Invalid function pointer called with signature 'ii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");  Module["printErr"]("Build with ASSERTIONS=2 for more info."); abort(x) }

function nullFunc_viii(x) { Module["printErr"]("Invalid function pointer called with signature 'viii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");  Module["printErr"]("Build with ASSERTIONS=2 for more info."); abort(x) }

function nullFunc_v(x) { Module["printErr"]("Invalid function pointer called with signature 'v'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");  Module["printErr"]("Build with ASSERTIONS=2 for more info."); abort(x) }

function nullFunc_viiiiii(x) { Module["printErr"]("Invalid function pointer called with signature 'viiiiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");  Module["printErr"]("Build with ASSERTIONS=2 for more info."); abort(x) }

function nullFunc_iii(x) { Module["printErr"]("Invalid function pointer called with signature 'iii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");  Module["printErr"]("Build with ASSERTIONS=2 for more info."); abort(x) }

function nullFunc_viiii(x) { Module["printErr"]("Invalid function pointer called with signature 'viiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");  Module["printErr"]("Build with ASSERTIONS=2 for more info."); abort(x) }

function invoke_iiii(index,a1,a2,a3) {
  try {
    return Module["dynCall_iiii"](index,a1,a2,a3);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setThrew"](1, 0);
  }
}

function invoke_viiiii(index,a1,a2,a3,a4,a5) {
  try {
    Module["dynCall_viiiii"](index,a1,a2,a3,a4,a5);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setThrew"](1, 0);
  }
}

function invoke_i(index) {
  try {
    return Module["dynCall_i"](index);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setThrew"](1, 0);
  }
}

function invoke_vi(index,a1) {
  try {
    Module["dynCall_vi"](index,a1);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setThrew"](1, 0);
  }
}

function invoke_vii(index,a1,a2) {
  try {
    Module["dynCall_vii"](index,a1,a2);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setThrew"](1, 0);
  }
}

function invoke_ii(index,a1) {
  try {
    return Module["dynCall_ii"](index,a1);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setThrew"](1, 0);
  }
}

function invoke_viii(index,a1,a2,a3) {
  try {
    Module["dynCall_viii"](index,a1,a2,a3);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setThrew"](1, 0);
  }
}

function invoke_v(index) {
  try {
    Module["dynCall_v"](index);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setThrew"](1, 0);
  }
}

function invoke_viiiiii(index,a1,a2,a3,a4,a5,a6) {
  try {
    Module["dynCall_viiiiii"](index,a1,a2,a3,a4,a5,a6);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setThrew"](1, 0);
  }
}

function invoke_iii(index,a1,a2) {
  try {
    return Module["dynCall_iii"](index,a1,a2);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setThrew"](1, 0);
  }
}

function invoke_viiii(index,a1,a2,a3,a4) {
  try {
    Module["dynCall_viiii"](index,a1,a2,a3,a4);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setThrew"](1, 0);
  }
}

Module.asmGlobalArg = { "Math": Math, "Int8Array": Int8Array, "Int16Array": Int16Array, "Int32Array": Int32Array, "Uint8Array": Uint8Array, "Uint16Array": Uint16Array, "Uint32Array": Uint32Array, "Float32Array": Float32Array, "Float64Array": Float64Array, "NaN": NaN, "Infinity": Infinity };
Module.asmLibraryArg = { "abort": abort, "assert": assert, "jsCall": jsCall, "nullFunc_iiii": nullFunc_iiii, "nullFunc_viiiii": nullFunc_viiiii, "nullFunc_i": nullFunc_i, "nullFunc_vi": nullFunc_vi, "nullFunc_vii": nullFunc_vii, "nullFunc_ii": nullFunc_ii, "nullFunc_viii": nullFunc_viii, "nullFunc_v": nullFunc_v, "nullFunc_viiiiii": nullFunc_viiiiii, "nullFunc_iii": nullFunc_iii, "nullFunc_viiii": nullFunc_viiii, "invoke_iiii": invoke_iiii, "invoke_viiiii": invoke_viiiii, "invoke_i": invoke_i, "invoke_vi": invoke_vi, "invoke_vii": invoke_vii, "invoke_ii": invoke_ii, "invoke_viii": invoke_viii, "invoke_v": invoke_v, "invoke_viiiiii": invoke_viiiiii, "invoke_iii": invoke_iii, "invoke_viiii": invoke_viiii, "_pthread_getspecific": _pthread_getspecific, "_send": _send, "___gxx_personality_v0": ___gxx_personality_v0, "__reallyNegative": __reallyNegative, "_vfprintf": _vfprintf, "_emscripten_set_main_loop_timing": _emscripten_set_main_loop_timing, "___cxa_free_exception": ___cxa_free_exception, "___cxa_allocate_exception": ___cxa_allocate_exception, "__ZSt18uncaught_exceptionv": __ZSt18uncaught_exceptionv, "_fflush": _fflush, "_pwrite": _pwrite, "___setErrNo": ___setErrNo, "_sbrk": _sbrk, "___cxa_begin_catch": ___cxa_begin_catch, "_emscripten_memcpy_big": _emscripten_memcpy_big, "___cxa_end_catch": ___cxa_end_catch, "___resumeException": ___resumeException, "___cxa_find_matching_catch": ___cxa_find_matching_catch, "_sysconf": _sysconf, "___cxa_call_unexpected": ___cxa_call_unexpected, "_fileno": _fileno, "_pthread_once": _pthread_once, "_mkport": _mkport, "_pthread_key_create": _pthread_key_create, "_write": _write, "_emscripten_set_main_loop": _emscripten_set_main_loop, "___errno_location": ___errno_location, "_pthread_setspecific": _pthread_setspecific, "_fputc": _fputc, "___cxa_throw": ___cxa_throw, "_abort": _abort, "_fwrite": _fwrite, "_time": _time, "_fprintf": _fprintf, "__formatString": __formatString, "___cxa_pure_virtual": ___cxa_pure_virtual, "STACKTOP": STACKTOP, "STACK_MAX": STACK_MAX, "tempDoublePtr": tempDoublePtr, "ABORT": ABORT, "_stderr": _stderr };
// EMSCRIPTEN_START_ASM
var asm = (function(global, env, buffer) {
  'almost asm';
  
  var HEAP8 = new global.Int8Array(buffer);
  var HEAP16 = new global.Int16Array(buffer);
  var HEAP32 = new global.Int32Array(buffer);
  var HEAPU8 = new global.Uint8Array(buffer);
  var HEAPU16 = new global.Uint16Array(buffer);
  var HEAPU32 = new global.Uint32Array(buffer);
  var HEAPF32 = new global.Float32Array(buffer);
  var HEAPF64 = new global.Float64Array(buffer);


  var STACKTOP=env.STACKTOP|0;
  var STACK_MAX=env.STACK_MAX|0;
  var tempDoublePtr=env.tempDoublePtr|0;
  var ABORT=env.ABORT|0;
  var _stderr=env._stderr|0;

  var __THREW__ = 0;
  var threwValue = 0;
  var setjmpId = 0;
  var undef = 0;
  var nan = global.NaN, inf = global.Infinity;
  var tempInt = 0, tempBigInt = 0, tempBigIntP = 0, tempBigIntS = 0, tempBigIntR = 0.0, tempBigIntI = 0, tempBigIntD = 0, tempValue = 0, tempDouble = 0.0;

  var tempRet0 = 0;
  var tempRet1 = 0;
  var tempRet2 = 0;
  var tempRet3 = 0;
  var tempRet4 = 0;
  var tempRet5 = 0;
  var tempRet6 = 0;
  var tempRet7 = 0;
  var tempRet8 = 0;
  var tempRet9 = 0;
  var Math_floor=global.Math.floor;
  var Math_abs=global.Math.abs;
  var Math_sqrt=global.Math.sqrt;
  var Math_pow=global.Math.pow;
  var Math_cos=global.Math.cos;
  var Math_sin=global.Math.sin;
  var Math_tan=global.Math.tan;
  var Math_acos=global.Math.acos;
  var Math_asin=global.Math.asin;
  var Math_atan=global.Math.atan;
  var Math_atan2=global.Math.atan2;
  var Math_exp=global.Math.exp;
  var Math_log=global.Math.log;
  var Math_ceil=global.Math.ceil;
  var Math_imul=global.Math.imul;
  var Math_min=global.Math.min;
  var Math_clz32=global.Math.clz32;
  var abort=env.abort;
  var assert=env.assert;
  var jsCall=env.jsCall;
  var nullFunc_iiii=env.nullFunc_iiii;
  var nullFunc_viiiii=env.nullFunc_viiiii;
  var nullFunc_i=env.nullFunc_i;
  var nullFunc_vi=env.nullFunc_vi;
  var nullFunc_vii=env.nullFunc_vii;
  var nullFunc_ii=env.nullFunc_ii;
  var nullFunc_viii=env.nullFunc_viii;
  var nullFunc_v=env.nullFunc_v;
  var nullFunc_viiiiii=env.nullFunc_viiiiii;
  var nullFunc_iii=env.nullFunc_iii;
  var nullFunc_viiii=env.nullFunc_viiii;
  var invoke_iiii=env.invoke_iiii;
  var invoke_viiiii=env.invoke_viiiii;
  var invoke_i=env.invoke_i;
  var invoke_vi=env.invoke_vi;
  var invoke_vii=env.invoke_vii;
  var invoke_ii=env.invoke_ii;
  var invoke_viii=env.invoke_viii;
  var invoke_v=env.invoke_v;
  var invoke_viiiiii=env.invoke_viiiiii;
  var invoke_iii=env.invoke_iii;
  var invoke_viiii=env.invoke_viiii;
  var _pthread_getspecific=env._pthread_getspecific;
  var _send=env._send;
  var ___gxx_personality_v0=env.___gxx_personality_v0;
  var __reallyNegative=env.__reallyNegative;
  var _vfprintf=env._vfprintf;
  var _emscripten_set_main_loop_timing=env._emscripten_set_main_loop_timing;
  var ___cxa_free_exception=env.___cxa_free_exception;
  var ___cxa_allocate_exception=env.___cxa_allocate_exception;
  var __ZSt18uncaught_exceptionv=env.__ZSt18uncaught_exceptionv;
  var _fflush=env._fflush;
  var _pwrite=env._pwrite;
  var ___setErrNo=env.___setErrNo;
  var _sbrk=env._sbrk;
  var ___cxa_begin_catch=env.___cxa_begin_catch;
  var _emscripten_memcpy_big=env._emscripten_memcpy_big;
  var ___cxa_end_catch=env.___cxa_end_catch;
  var ___resumeException=env.___resumeException;
  var ___cxa_find_matching_catch=env.___cxa_find_matching_catch;
  var _sysconf=env._sysconf;
  var ___cxa_call_unexpected=env.___cxa_call_unexpected;
  var _fileno=env._fileno;
  var _pthread_once=env._pthread_once;
  var _mkport=env._mkport;
  var _pthread_key_create=env._pthread_key_create;
  var _write=env._write;
  var _emscripten_set_main_loop=env._emscripten_set_main_loop;
  var ___errno_location=env.___errno_location;
  var _pthread_setspecific=env._pthread_setspecific;
  var _fputc=env._fputc;
  var ___cxa_throw=env.___cxa_throw;
  var _abort=env._abort;
  var _fwrite=env._fwrite;
  var _time=env._time;
  var _fprintf=env._fprintf;
  var __formatString=env.__formatString;
  var ___cxa_pure_virtual=env.___cxa_pure_virtual;
  var tempFloat = 0.0;

// EMSCRIPTEN_START_FUNCS
function stackAlloc(size) {
  size = size|0;
  var ret = 0;
  ret = STACKTOP;
  STACKTOP = (STACKTOP + size)|0;
STACKTOP = (STACKTOP + 15)&-16;
if ((STACKTOP|0) >= (STACK_MAX|0)) abort();

  return ret|0;
}
function stackSave() {
  return STACKTOP|0;
}
function stackRestore(top) {
  top = top|0;
  STACKTOP = top;
}

function setThrew(threw, value) {
  threw = threw|0;
  value = value|0;
  if ((__THREW__|0) == 0) {
    __THREW__ = threw;
    threwValue = value;
  }
}
function copyTempFloat(ptr) {
  ptr = ptr|0;
  HEAP8[tempDoublePtr>>0] = HEAP8[ptr>>0];
  HEAP8[tempDoublePtr+1>>0] = HEAP8[ptr+1>>0];
  HEAP8[tempDoublePtr+2>>0] = HEAP8[ptr+2>>0];
  HEAP8[tempDoublePtr+3>>0] = HEAP8[ptr+3>>0];
}
function copyTempDouble(ptr) {
  ptr = ptr|0;
  HEAP8[tempDoublePtr>>0] = HEAP8[ptr>>0];
  HEAP8[tempDoublePtr+1>>0] = HEAP8[ptr+1>>0];
  HEAP8[tempDoublePtr+2>>0] = HEAP8[ptr+2>>0];
  HEAP8[tempDoublePtr+3>>0] = HEAP8[ptr+3>>0];
  HEAP8[tempDoublePtr+4>>0] = HEAP8[ptr+4>>0];
  HEAP8[tempDoublePtr+5>>0] = HEAP8[ptr+5>>0];
  HEAP8[tempDoublePtr+6>>0] = HEAP8[ptr+6>>0];
  HEAP8[tempDoublePtr+7>>0] = HEAP8[ptr+7>>0];
}
function setTempRet0(value) {
  value = value|0;
  tempRet0 = value;
}
function getTempRet0() {
  return tempRet0|0;
}

function __ZNK6Packet6asBoolEv($this) {
 $this = $this|0;
 var $$expand_i1_val = 0, $$expand_i1_val2 = 0, $$pre_trunc = 0, $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $1 = $this;
 $2 = $1;
 $3 = (($2) + 4|0);
 $4 = HEAP32[$3>>2]|0;
 $5 = ($4|0)==(3);
 if ($5) {
  $$expand_i1_val = 1;
  $0 = $$expand_i1_val;
 } else {
  $6 = HEAP8[$2>>0]|0;
  $7 = $6&1;
  $$expand_i1_val2 = $7&1;
  $0 = $$expand_i1_val2;
 }
 $$pre_trunc = $0;
 $8 = $$pre_trunc&1;
 STACKTOP = sp;return ($8|0);
}
function __ZNK6Packet9asIntegerEv($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $1 = $this;
 $2 = $1;
 $3 = (($2) + 4|0);
 $4 = HEAP32[$3>>2]|0;
 $5 = ($4|0)==(3);
 if ($5) {
  $0 = 0;
 } else {
  $6 = HEAP32[$2>>2]|0;
  $0 = $6;
 }
 $7 = $0;
 STACKTOP = sp;return ($7|0);
}
function __ZNK6Packet7asFloatEv($this) {
 $this = $this|0;
 var $0 = 0.0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0.0, $7 = 0.0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $1 = $this;
 $2 = $1;
 $3 = (($2) + 4|0);
 $4 = HEAP32[$3>>2]|0;
 $5 = ($4|0)==(3);
 if ($5) {
  $0 = 0.0;
 } else {
  $6 = +HEAPF32[$2>>2];
  $0 = $6;
 }
 $7 = $0;
 STACKTOP = sp;return (+$7);
}
function __ZNK6Packet6asByteEv($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $1 = $this;
 $2 = $1;
 $3 = (($2) + 4|0);
 $4 = HEAP32[$3>>2]|0;
 $5 = ($4|0)==(3);
 if ($5) {
  $0 = 0;
 } else {
  $6 = HEAP8[$2>>0]|0;
  $0 = $6;
 }
 $7 = $0;
 STACKTOP = sp;return ($7|0);
}
function __ZN17HostCommunicationC2Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 __ZN26NetworkNotificationHandlerC2Ev($1);
 $2 = (8 + 8|0);
 HEAP32[$1>>2] = $2;
 $3 = (($1) + 4|0);
 HEAP32[$3>>2] = 0;
 $4 = (($1) + 8|0);
 HEAP32[$4>>2] = 0;
 $5 = (($1) + 12|0);
 HEAP8[$5>>0] = 0;
 $6 = (($1) + 24|0);
 HEAP32[$6>>2] = 2;
 $7 = (($1) + 28|0);
 HEAP32[$7>>2] = 1;
 STACKTOP = sp;return;
}
function __ZN26NetworkNotificationHandlerC2Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 __ZN12DebugHandlerC2Ev($1);
 $2 = (2832 + 8|0);
 HEAP32[$1>>2] = $2;
 STACKTOP = sp;return;
}
function __ZN17HostCommunication5setupEP7NetworkP13HostTransport($this,$net,$t) {
 $this = $this|0;
 $net = $net|0;
 $t = $t|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $net;
 $2 = $t;
 $3 = $0;
 $4 = $1;
 $5 = (($3) + 4|0);
 HEAP32[$5>>2] = $4;
 $6 = $2;
 $7 = (($3) + 8|0);
 HEAP32[$7>>2] = $6;
 __ZL14microflo_debugP12DebugHandler10DebugLevel7DebugId($3,2,1);
 $8 = (($3) + 4|0);
 $9 = HEAP32[$8>>2]|0;
 __ZN7Network22setNotificationHandlerEP26NetworkNotificationHandler($9,$3);
 STACKTOP = sp;return;
}
function __ZL14microflo_debugP12DebugHandler10DebugLevel7DebugId($handler,$level,$code) {
 $handler = $handler|0;
 $level = $level|0;
 $code = $code|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $handler;
 $1 = $level;
 $2 = $code;
 $3 = $0;
 $4 = ($3|0)!=(0|0);
 if (!($4)) {
  STACKTOP = sp;return;
 }
 $5 = $0;
 $6 = HEAP32[$5>>2]|0;
 $7 = HEAP32[$6>>2]|0;
 $8 = $1;
 $9 = $2;
 FUNCTION_TABLE_viii[$7 & 255]($5,$8,$9);
 STACKTOP = sp;return;
}
function __ZN7Network22setNotificationHandlerEP26NetworkNotificationHandler($this,$handler) {
 $this = $this|0;
 $handler = $handler|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $handler;
 $2 = $0;
 $3 = $1;
 $4 = (($2) + 1008|0);
 HEAP32[$4>>2] = $3;
 $5 = $1;
 $6 = (($2) + 1012|0);
 $7 = HEAP32[$6>>2]|0;
 $8 = (($7) + 4|0);
 HEAP32[$8>>2] = $5;
 STACKTOP = sp;return;
}
function __ZN17HostCommunication9parseByteEc($this,$b) {
 $this = $this|0;
 $b = $b|0;
 var $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0;
 var $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0;
 var $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0;
 var $63 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $b;
 $2 = $0;
 $3 = $1;
 $4 = (($2) + 12|0);
 $5 = HEAP8[$4>>0]|0;
 $6 = (($5) + 1)<<24>>24;
 HEAP8[$4>>0] = $6;
 $7 = $5&255;
 $8 = (($2) + 13|0);
 $9 = (($8) + ($7)|0);
 HEAP8[$9>>0] = $3;
 $10 = (($2) + 24|0);
 $11 = HEAP32[$10>>2]|0;
 $12 = ($11|0)==(0);
 if ($12) {
  __ZL14microflo_debugP12DebugHandler10DebugLevel7DebugId($2,4,6);
  $13 = (($2) + 12|0);
  $14 = HEAP8[$13>>0]|0;
  $15 = $14&255;
  $16 = ($15|0)==(8);
  if ($16) {
   $17 = (($2) + 13|0);
   $18 = (_memcmp($17,56,8)|0);
   $19 = ($18|0)==(0);
   if ($19) {
    __ZL14microflo_debugP12DebugHandler10DebugLevel7DebugId($2,3,31);
    $20 = (($2) + 8|0);
    $21 = HEAP32[$20>>2]|0;
    $22 = HEAP32[$21>>2]|0;
    $23 = (($22) + 8|0);
    $24 = HEAP32[$23>>2]|0;
    FUNCTION_TABLE_viii[$24 & 255]($21,64,1);
    $25 = (($2) + 24|0);
    HEAP32[$25>>2] = 1;
   } else {
    __ZL14microflo_debugP12DebugHandler10DebugLevel7DebugId($2,1,18);
    $26 = (($2) + 24|0);
    HEAP32[$26>>2] = -1;
   }
   $27 = (($2) + 12|0);
   HEAP8[$27>>0] = 0;
  }
  STACKTOP = sp;return;
 }
 $28 = (($2) + 24|0);
 $29 = HEAP32[$28>>2]|0;
 $30 = ($29|0)==(1);
 if ($30) {
  __ZL14microflo_debugP12DebugHandler10DebugLevel7DebugId($2,4,7);
  $31 = (($2) + 12|0);
  $32 = HEAP8[$31>>0]|0;
  $33 = $32&255;
  $34 = ($33|0)==(8);
  if ($34) {
   $35 = (($2) + 13|0);
   $36 = (_memcmp($35,56,8)|0);
   $37 = ($36|0)==(0);
   if ($37) {
    __ZL14microflo_debugP12DebugHandler10DebugLevel7DebugId($2,3,31);
    $38 = (($2) + 8|0);
    $39 = HEAP32[$38>>2]|0;
    $40 = HEAP32[$39>>2]|0;
    $41 = (($40) + 8|0);
    $42 = HEAP32[$41>>2]|0;
    FUNCTION_TABLE_viii[$42 & 255]($39,72,1);
   } else {
    __ZN17HostCommunication8parseCmdEv($2);
   }
   $43 = (($2) + 12|0);
   HEAP8[$43>>0] = 0;
  }
 } else {
  $44 = (($2) + 24|0);
  $45 = HEAP32[$44>>2]|0;
  $46 = ($45|0)==(2);
  if ($46) {
   __ZL14microflo_debugP12DebugHandler10DebugLevel7DebugId($2,4,17);
   $47 = $1;
   $48 = $47 << 24 >> 24;
   $49 = HEAP8[56>>0]|0;
   $50 = $49 << 24 >> 24;
   $51 = ($48|0)==($50|0);
   if ($51) {
    $52 = (($2) + 24|0);
    HEAP32[$52>>2] = 0;
    $53 = $1;
    $54 = (($2) + 13|0);
    HEAP8[$54>>0] = $53;
    $55 = (($2) + 12|0);
    HEAP8[$55>>0] = 1;
   } else {
    $56 = (($2) + 12|0);
    HEAP8[$56>>0] = 0;
   }
  } else {
   $57 = (($2) + 24|0);
   $58 = HEAP32[$57>>2]|0;
   $59 = ($58|0)==(-1);
   if ($59) {
    __ZL14microflo_debugP12DebugHandler10DebugLevel7DebugId($2,1,4);
    $60 = (($2) + 12|0);
    HEAP8[$60>>0] = 0;
    $61 = (($2) + 24|0);
    HEAP32[$61>>2] = 2;
   } else {
    __ZL14microflo_debugP12DebugHandler10DebugLevel7DebugId($2,1,5);
    $62 = (($2) + 12|0);
    HEAP8[$62>>0] = 0;
    $63 = (($2) + 24|0);
    HEAP32[$63>>2] = 2;
   }
  }
 }
 STACKTOP = sp;return;
}
function __ZN17HostCommunication8parseCmdEv($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0;
 var $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0;
 var $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0;
 var $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0, $165 = 0, $166 = 0, $167 = 0, $168 = 0, $169 = 0, $17 = 0;
 var $170 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0, $178 = 0, $179 = 0, $18 = 0, $180 = 0, $181 = 0, $182 = 0, $183 = 0, $184 = 0, $185 = 0, $186 = 0, $187 = 0, $188 = 0;
 var $189 = 0, $19 = 0, $190 = 0, $191 = 0, $192 = 0, $193 = 0, $194 = 0, $195 = 0, $196 = 0, $197 = 0, $198 = 0, $199 = 0, $2 = 0, $20 = 0, $200 = 0, $201 = 0, $202 = 0, $203 = 0, $204 = 0, $205 = 0;
 var $206 = 0, $207 = 0, $208 = 0, $209 = 0, $21 = 0, $210 = 0, $211 = 0, $212 = 0, $213 = 0, $214 = 0, $215 = 0, $216 = 0, $217 = 0, $218 = 0, $219 = 0, $22 = 0, $220 = 0, $221 = 0, $222 = 0, $223 = 0;
 var $224 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0;
 var $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0;
 var $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0;
 var $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0;
 var $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $c = 0, $childNode = 0, $childPort = 0, $cmd = 0, $cmd1 = 0, $cmd2 = 0, $isOutput = 0, $p = 0, $packetType = 0, $subgraphNode = 0, $subgraphPort = 0, $val = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 96|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $p = sp + 56|0;
 $1 = sp + 48|0;
 $2 = sp + 32|0;
 $3 = sp + 24|0;
 $4 = sp + 16|0;
 $cmd1 = sp + 92|0;
 $cmd2 = sp + 80|0;
 $0 = $this;
 $5 = $0;
 $6 = (($5) + 13|0);
 $7 = HEAP8[$6>>0]|0;
 $8 = $7&255;
 $cmd = $8;
 $9 = $cmd;
 $10 = ($9|0)==(14);
 if ($10) {
  __ZL14microflo_debugP12DebugHandler10DebugLevel7DebugId($5,3,32);
  $11 = (($5) + 8|0);
  $12 = HEAP32[$11>>2]|0;
  $13 = HEAP32[$12>>2]|0;
  $14 = (($13) + 8|0);
  $15 = HEAP32[$14>>2]|0;
  FUNCTION_TABLE_viii[$15 & 255]($12,80,1);
  $16 = (($5) + 24|0);
  HEAP32[$16>>2] = 2;
  STACKTOP = sp;return;
 }
 $17 = $cmd;
 $18 = ($17|0)==(10);
 if ($18) {
  $19 = (($5) + 4|0);
  $20 = HEAP32[$19>>2]|0;
  __ZN7Network5resetEv($20);
 } else {
  $21 = $cmd;
  $22 = ($21|0)==(20);
  if ($22) {
   $23 = (($5) + 4|0);
   $24 = HEAP32[$23>>2]|0;
   __ZN7Network5startEv($24);
  } else {
   $25 = $cmd;
   $26 = ($25|0)==(11);
   if ($26) {
    __ZL14microflo_debugP12DebugHandler10DebugLevel7DebugId($5,3,2);
    $27 = (($5) + 13|0);
    $28 = (($27) + 1|0);
    $29 = HEAP8[$28>>0]|0;
    $30 = (__Z15createComponenth($29)|0);
    $c = $30;
    __ZL14microflo_debugP12DebugHandler10DebugLevel7DebugId($5,3,3);
    $31 = (($5) + 4|0);
    $32 = HEAP32[$31>>2]|0;
    $33 = $c;
    $34 = (($5) + 13|0);
    $35 = (($34) + 2|0);
    $36 = HEAP8[$35>>0]|0;
    (__ZN7Network7addNodeEP9Componenth($32,$33,$36)|0);
   } else {
    $37 = $cmd;
    $38 = ($37|0)==(12);
    if ($38) {
     __ZL14microflo_debugP12DebugHandler10DebugLevel7DebugId($5,3,13);
     $39 = (($5) + 4|0);
     $40 = HEAP32[$39>>2]|0;
     $41 = (($5) + 13|0);
     $42 = (($41) + 1|0);
     $43 = HEAP8[$42>>0]|0;
     $44 = (($5) + 13|0);
     $45 = (($44) + 3|0);
     $46 = HEAP8[$45>>0]|0;
     $47 = (($5) + 13|0);
     $48 = (($47) + 2|0);
     $49 = HEAP8[$48>>0]|0;
     $50 = (($5) + 13|0);
     $51 = (($50) + 4|0);
     $52 = HEAP8[$51>>0]|0;
     __ZN7Network7connectEhaha($40,$43,$46,$49,$52);
    } else {
     $53 = $cmd;
     $54 = ($53|0)==(13);
     if ($54) {
      $55 = (($5) + 13|0);
      $56 = (($55) + 3|0);
      $57 = HEAP8[$56>>0]|0;
      $58 = $57&255;
      $packetType = $58;
      __ZN6PacketC2Ev($p);
      $59 = $packetType;
      $60 = ($59|0)==(9);
      if ($60) {
       label = 23;
      } else {
       $61 = $packetType;
       $62 = ($61|0)==(10);
       if ($62) {
        label = 23;
       } else {
        $63 = $packetType;
        $64 = ($63|0)==(3);
        if ($64) {
         label = 23;
        } else {
         $66 = $packetType;
         $67 = ($66|0)==(7);
         if ($67) {
          $68 = (($5) + 13|0);
          $69 = (($68) + 4|0);
          $70 = HEAP8[$69>>0]|0;
          $71 = $70&255;
          $72 = (($5) + 13|0);
          $73 = (($72) + 5|0);
          $74 = HEAP8[$73>>0]|0;
          $75 = $74&255;
          $76 = $75 << 8;
          $77 = (($71) + ($76))|0;
          $78 = (($5) + 13|0);
          $79 = (($78) + 6|0);
          $80 = HEAP8[$79>>0]|0;
          $81 = $80&255;
          $82 = $81 << 16;
          $83 = (($77) + ($82))|0;
          $84 = (($5) + 13|0);
          $85 = (($84) + 7|0);
          $86 = HEAP8[$85>>0]|0;
          $87 = $86&255;
          $88 = $87 << 24;
          $89 = (($83) + ($88))|0;
          $val = $89;
          $90 = $val;
          __ZN6PacketC2El($2,$90);
          ;HEAP32[$p+0>>2]=HEAP32[$2+0>>2]|0;HEAP32[$p+4>>2]=HEAP32[$2+4>>2]|0;
         } else {
          $91 = $packetType;
          $92 = ($91|0)==(4);
          if ($92) {
           $93 = (($5) + 13|0);
           $94 = (($93) + 4|0);
           $95 = HEAP8[$94>>0]|0;
           __ZN6PacketC2Eh($3,$95);
           ;HEAP32[$p+0>>2]=HEAP32[$3+0>>2]|0;HEAP32[$p+4>>2]=HEAP32[$3+4>>2]|0;
          } else {
           $96 = $packetType;
           $97 = ($96|0)==(6);
           if ($97) {
            $98 = (($5) + 13|0);
            $99 = (($98) + 4|0);
            $100 = HEAP8[$99>>0]|0;
            $101 = $100&255;
            $102 = ($101|0)==(0);
            $103 = $102 ^ 1;
            __ZN6PacketC2Eb($4,$103);
            ;HEAP32[$p+0>>2]=HEAP32[$4+0>>2]|0;HEAP32[$p+4>>2]=HEAP32[$4+4>>2]|0;
           }
          }
         }
        }
       }
      }
      if ((label|0) == 23) {
       $65 = $packetType;
       __ZN6PacketC2E3Msg($1,$65);
       ;HEAP32[$p+0>>2]=HEAP32[$1+0>>2]|0;HEAP32[$p+4>>2]=HEAP32[$1+4>>2]|0;
      }
      $104 = (__ZNK6Packet7isValidEv($p)|0);
      if ($104) {
       $105 = (($5) + 4|0);
       $106 = HEAP32[$105>>2]|0;
       $107 = (($5) + 13|0);
       $108 = (($107) + 1|0);
       $109 = HEAP8[$108>>0]|0;
       $110 = (($5) + 13|0);
       $111 = (($110) + 2|0);
       $112 = HEAP8[$111>>0]|0;
       __ZN7Network13sendMessageIdEhaRK6Packet($106,$109,$112,$p);
       HEAP8[$cmd1>>0] = 114;
       $113 = (($cmd1) + 1|0);
       $114 = (($5) + 13|0);
       $115 = (($114) + 1|0);
       $116 = HEAP8[$115>>0]|0;
       HEAP8[$113>>0] = $116;
       $117 = (($113) + 1|0);
       $118 = (($5) + 13|0);
       $119 = (($118) + 2|0);
       $120 = HEAP8[$119>>0]|0;
       HEAP8[$117>>0] = $120;
       $121 = (($117) + 1|0);
       $122 = $packetType;
       $123 = $122&255;
       HEAP8[$121>>0] = $123;
       $124 = (($5) + 8|0);
       $125 = HEAP32[$124>>2]|0;
       $126 = HEAP32[$125>>2]|0;
       $127 = (($126) + 8|0);
       $128 = HEAP32[$127>>2]|0;
       FUNCTION_TABLE_viii[$128 & 255]($125,$cmd1,4);
      } else {
       __ZL14microflo_debugP12DebugHandler10DebugLevel7DebugId($5,1,11);
      }
     } else {
      $129 = $cmd;
      $130 = ($129|0)==(15);
      if ($130) {
       $131 = (($5) + 4|0);
       $132 = HEAP32[$131>>2]|0;
       $133 = (($5) + 13|0);
       $134 = (($133) + 1|0);
       $135 = HEAP8[$134>>0]|0;
       $136 = $135&255;
       __ZN7Network13setDebugLevelE10DebugLevel($132,$136);
      } else {
       $137 = $cmd;
       $138 = ($137|0)==(16);
       if ($138) {
        $139 = (($5) + 4|0);
        $140 = HEAP32[$139>>2]|0;
        $141 = (($5) + 13|0);
        $142 = (($141) + 1|0);
        $143 = HEAP8[$142>>0]|0;
        $144 = (($5) + 13|0);
        $145 = (($144) + 2|0);
        $146 = HEAP8[$145>>0]|0;
        $147 = (($5) + 13|0);
        $148 = (($147) + 3|0);
        $149 = HEAP8[$148>>0]|0;
        $150 = ($149<<24>>24)!=(0);
        __ZN7Network15subscribeToPortEhab($140,$143,$146,$150);
       } else {
        $151 = $cmd;
        $152 = ($151|0)==(17);
        if ($152) {
         $153 = (($5) + 13|0);
         $154 = (($153) + 1|0);
         $155 = HEAP8[$154>>0]|0;
         $156 = $155&255;
         $157 = ($156|0)!=(0);
         $158 = $157&1;
         $isOutput = $158;
         $159 = (($5) + 13|0);
         $160 = (($159) + 2|0);
         $161 = HEAP8[$160>>0]|0;
         $162 = $161&255;
         $subgraphNode = $162;
         $163 = (($5) + 13|0);
         $164 = (($163) + 3|0);
         $165 = HEAP8[$164>>0]|0;
         $166 = $165&255;
         $subgraphPort = $166;
         $167 = (($5) + 13|0);
         $168 = (($167) + 4|0);
         $169 = HEAP8[$168>>0]|0;
         $170 = $169&255;
         $childNode = $170;
         $171 = (($5) + 13|0);
         $172 = (($171) + 5|0);
         $173 = HEAP8[$172>>0]|0;
         $174 = $173&255;
         $childPort = $174;
         $175 = (($5) + 4|0);
         $176 = HEAP32[$175>>2]|0;
         $177 = $isOutput;
         $178 = $177&1;
         $179 = $subgraphNode;
         $180 = $179&255;
         $181 = $subgraphPort;
         $182 = $181&255;
         $183 = $childNode;
         $184 = $183&255;
         $185 = $childPort;
         $186 = $185&255;
         __ZN7Network15connectSubgraphEbhaha($176,$178,$180,$182,$184,$186);
        } else {
         $187 = $cmd;
         $188 = ($187|0)==(18);
         if ($188) {
          HEAP8[$cmd2>>0] = 109;
          $189 = (($cmd2) + 1|0);
          $190 = (($cmd2) + 1|0);
          $191 = HEAP8[$190>>0]|0;
          HEAP8[$189>>0] = $191;
          $192 = (($189) + 1|0);
          $193 = (($cmd2) + 2|0);
          $194 = HEAP8[$193>>0]|0;
          HEAP8[$192>>0] = $194;
          $195 = (($192) + 1|0);
          $196 = (($cmd2) + 3|0);
          $197 = HEAP8[$196>>0]|0;
          HEAP8[$195>>0] = $197;
          $198 = (($195) + 1|0);
          $199 = (($cmd2) + 4|0);
          $200 = HEAP8[$199>>0]|0;
          HEAP8[$198>>0] = $200;
          $201 = (($198) + 1|0);
          $202 = (($cmd2) + 5|0);
          $203 = HEAP8[$202>>0]|0;
          HEAP8[$201>>0] = $203;
          $204 = (($201) + 1|0);
          $205 = (($cmd2) + 6|0);
          $206 = HEAP8[$205>>0]|0;
          HEAP8[$204>>0] = $206;
          $207 = (($204) + 1|0);
          $208 = (($cmd2) + 7|0);
          $209 = HEAP8[$208>>0]|0;
          HEAP8[$207>>0] = $209;
          $210 = (($5) + 8|0);
          $211 = HEAP32[$210>>2]|0;
          $212 = HEAP32[$211>>2]|0;
          $213 = (($212) + 8|0);
          $214 = HEAP32[$213>>2]|0;
          FUNCTION_TABLE_viii[$214 & 255]($211,$cmd2,8);
         } else {
          $215 = $cmd;
          $216 = ($215|0)==(21);
          if ($216) {
           $217 = (($5) + 4|0);
           $218 = HEAP32[$217>>2]|0;
           $219 = (($5) + 13|0);
           __ZN7Network10setIoValueEPKhh($218,$219,8);
          } else {
           $220 = $cmd;
           $221 = ($220|0)>=(115);
           if ($221) {
            $222 = (($5) + 13|0);
            $223 = (_memcmp($222,56,8)|0);
            $224 = ($223|0)==(0);
            if (!($224)) {
             __ZL14microflo_debugP12DebugHandler10DebugLevel7DebugId($5,1,10);
            }
           } else {
            __ZL14microflo_debugP12DebugHandler10DebugLevel7DebugId($5,1,9);
           }
          }
         }
        }
       }
      }
     }
    }
   }
  }
 }
 STACKTOP = sp;return;
}
function __ZN7Network5resetEv($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0;
 var $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $i = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 $2 = (($1) + 1016|0);
 HEAP32[$2>>2] = 0;
 $3 = (($1) + 1008|0);
 $4 = HEAP32[$3>>2]|0;
 $5 = ($4|0)!=(0|0);
 if ($5) {
  $6 = (($1) + 1008|0);
  $7 = HEAP32[$6>>2]|0;
  $8 = HEAP32[$7>>2]|0;
  $9 = (($8) + 24|0);
  $10 = HEAP32[$9>>2]|0;
  $11 = (($1) + 1016|0);
  $12 = HEAP32[$11>>2]|0;
  FUNCTION_TABLE_vii[$10 & 255]($7,$12);
 }
 $i = 0;
 while(1) {
  $13 = $i;
  $14 = ($13|0)<(50);
  if (!($14)) {
   break;
  }
  $15 = $i;
  $16 = (($1) + ($15<<2)|0);
  $17 = HEAP32[$16>>2]|0;
  $18 = ($17|0)!=(0|0);
  if ($18) {
   $19 = $i;
   $20 = (($1) + ($19<<2)|0);
   $21 = HEAP32[$20>>2]|0;
   $22 = ($21|0)==(0|0);
   if (!($22)) {
    $23 = HEAP32[$21>>2]|0;
    $24 = (($23) + 4|0);
    $25 = HEAP32[$24>>2]|0;
    FUNCTION_TABLE_vi[$25 & 255]($21);
   }
   $26 = $i;
   $27 = (($1) + ($26<<2)|0);
   HEAP32[$27>>2] = 0;
  }
  $28 = $i;
  $29 = (($28) + 1)|0;
  $i = $29;
 }
 $30 = (($1) + 200|0);
 HEAP8[$30>>0] = 1;
 $31 = (($1) + 1004|0);
 HEAP8[$31>>0] = 0;
 $32 = (($1) + 1005|0);
 HEAP8[$32>>0] = 0;
 STACKTOP = sp;return;
}
function __ZN7Network5startEv($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 $2 = (($1) + 1016|0);
 HEAP32[$2>>2] = 1;
 $3 = (($1) + 1008|0);
 $4 = HEAP32[$3>>2]|0;
 $5 = ($4|0)!=(0|0);
 if (!($5)) {
  __ZN7Network8runSetupEv($1);
  STACKTOP = sp;return;
 }
 $6 = (($1) + 1008|0);
 $7 = HEAP32[$6>>2]|0;
 $8 = HEAP32[$7>>2]|0;
 $9 = (($8) + 24|0);
 $10 = HEAP32[$9>>2]|0;
 $11 = (($1) + 1016|0);
 $12 = HEAP32[$11>>2]|0;
 FUNCTION_TABLE_vii[$10 & 255]($7,$12);
 __ZN7Network8runSetupEv($1);
 STACKTOP = sp;return;
}
function __Z15createComponenth($id) {
 $id = $id|0;
 var $0 = 0, $1 = 0, $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0;
 var $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0;
 var $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0;
 var $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0, $165 = 0, $166 = 0, $167 = 0, $168 = 0, $169 = 0, $17 = 0;
 var $170 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0, $178 = 0, $179 = 0, $18 = 0, $180 = 0, $181 = 0, $182 = 0, $183 = 0, $184 = 0, $185 = 0, $186 = 0, $187 = 0, $188 = 0;
 var $189 = 0, $19 = 0, $190 = 0, $191 = 0, $192 = 0, $193 = 0, $194 = 0, $195 = 0, $196 = 0, $197 = 0, $198 = 0, $199 = 0, $2 = 0, $20 = 0, $200 = 0, $201 = 0, $202 = 0, $203 = 0, $204 = 0, $205 = 0;
 var $206 = 0, $207 = 0, $208 = 0, $209 = 0, $21 = 0, $210 = 0, $211 = 0, $212 = 0, $213 = 0, $214 = 0, $215 = 0, $216 = 0, $217 = 0, $218 = 0, $219 = 0, $22 = 0, $220 = 0, $221 = 0, $222 = 0, $223 = 0;
 var $224 = 0, $225 = 0, $226 = 0, $227 = 0, $228 = 0, $229 = 0, $23 = 0, $230 = 0, $231 = 0, $232 = 0, $233 = 0, $234 = 0, $235 = 0, $236 = 0, $237 = 0, $238 = 0, $239 = 0, $24 = 0, $240 = 0, $25 = 0;
 var $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0;
 var $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0;
 var $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0;
 var $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0;
 var $99 = 0, $c = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $1 = $id;
 $4 = $1;
 $5 = $4&255;
 L1: do {
  switch ($5|0) {
  case 2:  {
   $14 = (__Znwj(184)|0);
   __THREW__ = 0;
   invoke_vi(164,($14|0));
   $15 = __THREW__; __THREW__ = 0;
   $16 = $15&1;
   if ($16) {
    $20 = ___cxa_find_matching_catch()|0;
    $21 = tempRet0;
    $2 = $20;
    $3 = $21;
    __ZdlPv($14);
    break L1;
   }
   $c = $14;
   $17 = $c;
   $18 = $1;
   __ZN9Component14setComponentIdEh($17,$18);
   $19 = $c;
   $0 = $19;
   $238 = $0;
   STACKTOP = sp;return ($238|0);
   break;
  }
  case 15:  {
   $118 = (__Znwj(48)|0);
   __THREW__ = 0;
   invoke_vi(177,($118|0));
   $119 = __THREW__; __THREW__ = 0;
   $120 = $119&1;
   if ($120) {
    $124 = ___cxa_find_matching_catch()|0;
    $125 = tempRet0;
    $2 = $124;
    $3 = $125;
    __ZdlPv($118);
    break L1;
   }
   $c = $118;
   $121 = $c;
   $122 = $1;
   __ZN9Component14setComponentIdEh($121,$122);
   $123 = $c;
   $0 = $123;
   $238 = $0;
   STACKTOP = sp;return ($238|0);
   break;
  }
  case 16:  {
   $126 = (__Znwj(44)|0);
   __THREW__ = 0;
   invoke_vi(178,($126|0));
   $127 = __THREW__; __THREW__ = 0;
   $128 = $127&1;
   if ($128) {
    $132 = ___cxa_find_matching_catch()|0;
    $133 = tempRet0;
    $2 = $132;
    $3 = $133;
    __ZdlPv($126);
    break L1;
   }
   $c = $126;
   $129 = $c;
   $130 = $1;
   __ZN9Component14setComponentIdEh($129,$130);
   $131 = $c;
   $0 = $131;
   $238 = $0;
   STACKTOP = sp;return ($238|0);
   break;
  }
  case 17:  {
   $134 = (__Znwj(44)|0);
   __THREW__ = 0;
   invoke_vi(179,($134|0));
   $135 = __THREW__; __THREW__ = 0;
   $136 = $135&1;
   if ($136) {
    $140 = ___cxa_find_matching_catch()|0;
    $141 = tempRet0;
    $2 = $140;
    $3 = $141;
    __ZdlPv($134);
    break L1;
   }
   $c = $134;
   $137 = $c;
   $138 = $1;
   __ZN9Component14setComponentIdEh($137,$138);
   $139 = $c;
   $0 = $139;
   $238 = $0;
   STACKTOP = sp;return ($238|0);
   break;
  }
  case 13:  {
   $102 = (__Znwj(32)|0);
   __THREW__ = 0;
   invoke_vi(175,($102|0));
   $103 = __THREW__; __THREW__ = 0;
   $104 = $103&1;
   if ($104) {
    $108 = ___cxa_find_matching_catch()|0;
    $109 = tempRet0;
    $2 = $108;
    $3 = $109;
    __ZdlPv($102);
    break L1;
   }
   $c = $102;
   $105 = $c;
   $106 = $1;
   __ZN9Component14setComponentIdEh($105,$106);
   $107 = $c;
   $0 = $107;
   $238 = $0;
   STACKTOP = sp;return ($238|0);
   break;
  }
  case 18:  {
   $142 = (__Znwj(36)|0);
   __THREW__ = 0;
   invoke_vi(180,($142|0));
   $143 = __THREW__; __THREW__ = 0;
   $144 = $143&1;
   if ($144) {
    $148 = ___cxa_find_matching_catch()|0;
    $149 = tempRet0;
    $2 = $148;
    $3 = $149;
    __ZdlPv($142);
    break L1;
   }
   $c = $142;
   $145 = $c;
   $146 = $1;
   __ZN9Component14setComponentIdEh($145,$146);
   $147 = $c;
   $0 = $147;
   $238 = $0;
   STACKTOP = sp;return ($238|0);
   break;
  }
  case 19:  {
   $150 = (__Znwj(44)|0);
   __THREW__ = 0;
   invoke_vi(181,($150|0));
   $151 = __THREW__; __THREW__ = 0;
   $152 = $151&1;
   if ($152) {
    $156 = ___cxa_find_matching_catch()|0;
    $157 = tempRet0;
    $2 = $156;
    $3 = $157;
    __ZdlPv($150);
    break L1;
   }
   $c = $150;
   $153 = $c;
   $154 = $1;
   __ZN9Component14setComponentIdEh($153,$154);
   $155 = $c;
   $0 = $155;
   $238 = $0;
   STACKTOP = sp;return ($238|0);
   break;
  }
  case 14:  {
   $110 = (__Znwj(48)|0);
   __THREW__ = 0;
   invoke_vi(176,($110|0));
   $111 = __THREW__; __THREW__ = 0;
   $112 = $111&1;
   if ($112) {
    $116 = ___cxa_find_matching_catch()|0;
    $117 = tempRet0;
    $2 = $116;
    $3 = $117;
    __ZdlPv($110);
    break L1;
   }
   $c = $110;
   $113 = $c;
   $114 = $1;
   __ZN9Component14setComponentIdEh($113,$114);
   $115 = $c;
   $0 = $115;
   $238 = $0;
   STACKTOP = sp;return ($238|0);
   break;
  }
  case 3:  {
   $22 = (__Znwj(36)|0);
   __THREW__ = 0;
   invoke_vi(165,($22|0));
   $23 = __THREW__; __THREW__ = 0;
   $24 = $23&1;
   if ($24) {
    $28 = ___cxa_find_matching_catch()|0;
    $29 = tempRet0;
    $2 = $28;
    $3 = $29;
    __ZdlPv($22);
    break L1;
   }
   $c = $22;
   $25 = $c;
   $26 = $1;
   __ZN9Component14setComponentIdEh($25,$26);
   $27 = $c;
   $0 = $27;
   $238 = $0;
   STACKTOP = sp;return ($238|0);
   break;
  }
  case 4:  {
   $30 = (__Znwj(36)|0);
   __THREW__ = 0;
   invoke_vi(166,($30|0));
   $31 = __THREW__; __THREW__ = 0;
   $32 = $31&1;
   if ($32) {
    $36 = ___cxa_find_matching_catch()|0;
    $37 = tempRet0;
    $2 = $36;
    $3 = $37;
    __ZdlPv($30);
    break L1;
   }
   $c = $30;
   $33 = $c;
   $34 = $1;
   __ZN9Component14setComponentIdEh($33,$34);
   $35 = $c;
   $0 = $35;
   $238 = $0;
   STACKTOP = sp;return ($238|0);
   break;
  }
  case 5:  {
   $38 = (__Znwj(44)|0);
   __THREW__ = 0;
   invoke_vi(167,($38|0));
   $39 = __THREW__; __THREW__ = 0;
   $40 = $39&1;
   if ($40) {
    $44 = ___cxa_find_matching_catch()|0;
    $45 = tempRet0;
    $2 = $44;
    $3 = $45;
    __ZdlPv($38);
    break L1;
   }
   $c = $38;
   $41 = $c;
   $42 = $1;
   __ZN9Component14setComponentIdEh($41,$42);
   $43 = $c;
   $0 = $43;
   $238 = $0;
   STACKTOP = sp;return ($238|0);
   break;
  }
  case 6:  {
   $46 = (__Znwj(44)|0);
   __THREW__ = 0;
   invoke_vi(168,($46|0));
   $47 = __THREW__; __THREW__ = 0;
   $48 = $47&1;
   if ($48) {
    $52 = ___cxa_find_matching_catch()|0;
    $53 = tempRet0;
    $2 = $52;
    $3 = $53;
    __ZdlPv($46);
    break L1;
   }
   $c = $46;
   $49 = $c;
   $50 = $1;
   __ZN9Component14setComponentIdEh($49,$50);
   $51 = $c;
   $0 = $51;
   $238 = $0;
   STACKTOP = sp;return ($238|0);
   break;
  }
  case 1:  {
   $6 = (__Znwj(36)|0);
   __THREW__ = 0;
   invoke_vi(163,($6|0));
   $7 = __THREW__; __THREW__ = 0;
   $8 = $7&1;
   if ($8) {
    $12 = ___cxa_find_matching_catch()|0;
    $13 = tempRet0;
    $2 = $12;
    $3 = $13;
    __ZdlPv($6);
    break L1;
   }
   $c = $6;
   $9 = $c;
   $10 = $1;
   __ZN9Component14setComponentIdEh($9,$10);
   $11 = $c;
   $0 = $11;
   $238 = $0;
   STACKTOP = sp;return ($238|0);
   break;
  }
  case 21:  {
   $166 = (__Znwj(24)|0);
   __THREW__ = 0;
   invoke_vi(183,($166|0));
   $167 = __THREW__; __THREW__ = 0;
   $168 = $167&1;
   if ($168) {
    $172 = ___cxa_find_matching_catch()|0;
    $173 = tempRet0;
    $2 = $172;
    $3 = $173;
    __ZdlPv($166);
    break L1;
   }
   $c = $166;
   $169 = $c;
   $170 = $1;
   __ZN9Component14setComponentIdEh($169,$170);
   $171 = $c;
   $0 = $171;
   $238 = $0;
   STACKTOP = sp;return ($238|0);
   break;
  }
  case 22:  {
   $174 = (__Znwj(108)|0);
   __THREW__ = 0;
   invoke_vi(184,($174|0));
   $175 = __THREW__; __THREW__ = 0;
   $176 = $175&1;
   if ($176) {
    $180 = ___cxa_find_matching_catch()|0;
    $181 = tempRet0;
    $2 = $180;
    $3 = $181;
    __ZdlPv($174);
    break L1;
   }
   $c = $174;
   $177 = $c;
   $178 = $1;
   __ZN9Component14setComponentIdEh($177,$178);
   $179 = $c;
   $0 = $179;
   $238 = $0;
   STACKTOP = sp;return ($238|0);
   break;
  }
  case 20:  {
   $158 = (__Znwj(36)|0);
   __THREW__ = 0;
   invoke_vi(182,($158|0));
   $159 = __THREW__; __THREW__ = 0;
   $160 = $159&1;
   if ($160) {
    $164 = ___cxa_find_matching_catch()|0;
    $165 = tempRet0;
    $2 = $164;
    $3 = $165;
    __ZdlPv($158);
    break L1;
   }
   $c = $158;
   $161 = $c;
   $162 = $1;
   __ZN9Component14setComponentIdEh($161,$162);
   $163 = $c;
   $0 = $163;
   $238 = $0;
   STACKTOP = sp;return ($238|0);
   break;
  }
  case 26:  {
   $206 = (__Znwj(184)|0);
   __THREW__ = 0;
   invoke_vi(188,($206|0));
   $207 = __THREW__; __THREW__ = 0;
   $208 = $207&1;
   if ($208) {
    $212 = ___cxa_find_matching_catch()|0;
    $213 = tempRet0;
    $2 = $212;
    $3 = $213;
    __ZdlPv($206);
    break L1;
   }
   $c = $206;
   $209 = $c;
   $210 = $1;
   __ZN9Component14setComponentIdEh($209,$210);
   $211 = $c;
   $0 = $211;
   $238 = $0;
   STACKTOP = sp;return ($238|0);
   break;
  }
  case 27:  {
   $214 = (__Znwj(40)|0);
   __THREW__ = 0;
   invoke_vi(189,($214|0));
   $215 = __THREW__; __THREW__ = 0;
   $216 = $215&1;
   if ($216) {
    $220 = ___cxa_find_matching_catch()|0;
    $221 = tempRet0;
    $2 = $220;
    $3 = $221;
    __ZdlPv($214);
    break L1;
   }
   $c = $214;
   $217 = $c;
   $218 = $1;
   __ZN9Component14setComponentIdEh($217,$218);
   $219 = $c;
   $0 = $219;
   $238 = $0;
   STACKTOP = sp;return ($238|0);
   break;
  }
  case 28:  {
   $222 = (__Znwj(36)|0);
   __THREW__ = 0;
   invoke_vi(190,($222|0));
   $223 = __THREW__; __THREW__ = 0;
   $224 = $223&1;
   if ($224) {
    $228 = ___cxa_find_matching_catch()|0;
    $229 = tempRet0;
    $2 = $228;
    $3 = $229;
    __ZdlPv($222);
    break L1;
   }
   $c = $222;
   $225 = $c;
   $226 = $1;
   __ZN9Component14setComponentIdEh($225,$226);
   $227 = $c;
   $0 = $227;
   $238 = $0;
   STACKTOP = sp;return ($238|0);
   break;
  }
  case 23:  {
   $182 = (__Znwj(32)|0);
   __THREW__ = 0;
   invoke_vi(185,($182|0));
   $183 = __THREW__; __THREW__ = 0;
   $184 = $183&1;
   if ($184) {
    $188 = ___cxa_find_matching_catch()|0;
    $189 = tempRet0;
    $2 = $188;
    $3 = $189;
    __ZdlPv($182);
    break L1;
   }
   $c = $182;
   $185 = $c;
   $186 = $1;
   __ZN9Component14setComponentIdEh($185,$186);
   $187 = $c;
   $0 = $187;
   $238 = $0;
   STACKTOP = sp;return ($238|0);
   break;
  }
  case 24:  {
   $190 = (__Znwj(32)|0);
   __THREW__ = 0;
   invoke_vi(186,($190|0));
   $191 = __THREW__; __THREW__ = 0;
   $192 = $191&1;
   if ($192) {
    $196 = ___cxa_find_matching_catch()|0;
    $197 = tempRet0;
    $2 = $196;
    $3 = $197;
    __ZdlPv($190);
    break L1;
   }
   $c = $190;
   $193 = $c;
   $194 = $1;
   __ZN9Component14setComponentIdEh($193,$194);
   $195 = $c;
   $0 = $195;
   $238 = $0;
   STACKTOP = sp;return ($238|0);
   break;
  }
  case 25:  {
   $198 = (__Znwj(96)|0);
   __THREW__ = 0;
   invoke_vi(187,($198|0));
   $199 = __THREW__; __THREW__ = 0;
   $200 = $199&1;
   if ($200) {
    $204 = ___cxa_find_matching_catch()|0;
    $205 = tempRet0;
    $2 = $204;
    $3 = $205;
    __ZdlPv($198);
    break L1;
   }
   $c = $198;
   $201 = $c;
   $202 = $1;
   __ZN9Component14setComponentIdEh($201,$202);
   $203 = $c;
   $0 = $203;
   $238 = $0;
   STACKTOP = sp;return ($238|0);
   break;
  }
  case 8:  {
   $62 = (__Znwj(36)|0);
   __THREW__ = 0;
   invoke_vi(170,($62|0));
   $63 = __THREW__; __THREW__ = 0;
   $64 = $63&1;
   if ($64) {
    $68 = ___cxa_find_matching_catch()|0;
    $69 = tempRet0;
    $2 = $68;
    $3 = $69;
    __ZdlPv($62);
    break L1;
   }
   $c = $62;
   $65 = $c;
   $66 = $1;
   __ZN9Component14setComponentIdEh($65,$66);
   $67 = $c;
   $0 = $67;
   $238 = $0;
   STACKTOP = sp;return ($238|0);
   break;
  }
  case 9:  {
   $70 = (__Znwj(36)|0);
   __THREW__ = 0;
   invoke_vi(171,($70|0));
   $71 = __THREW__; __THREW__ = 0;
   $72 = $71&1;
   if ($72) {
    $76 = ___cxa_find_matching_catch()|0;
    $77 = tempRet0;
    $2 = $76;
    $3 = $77;
    __ZdlPv($70);
    break L1;
   }
   $c = $70;
   $73 = $c;
   $74 = $1;
   __ZN9Component14setComponentIdEh($73,$74);
   $75 = $c;
   $0 = $75;
   $238 = $0;
   STACKTOP = sp;return ($238|0);
   break;
  }
  case 10:  {
   $78 = (__Znwj(32)|0);
   __THREW__ = 0;
   invoke_vi(172,($78|0));
   $79 = __THREW__; __THREW__ = 0;
   $80 = $79&1;
   if ($80) {
    $84 = ___cxa_find_matching_catch()|0;
    $85 = tempRet0;
    $2 = $84;
    $3 = $85;
    __ZdlPv($78);
    break L1;
   }
   $c = $78;
   $81 = $c;
   $82 = $1;
   __ZN9Component14setComponentIdEh($81,$82);
   $83 = $c;
   $0 = $83;
   $238 = $0;
   STACKTOP = sp;return ($238|0);
   break;
  }
  case 7:  {
   $54 = (__Znwj(40)|0);
   __THREW__ = 0;
   invoke_vi(169,($54|0));
   $55 = __THREW__; __THREW__ = 0;
   $56 = $55&1;
   if ($56) {
    $60 = ___cxa_find_matching_catch()|0;
    $61 = tempRet0;
    $2 = $60;
    $3 = $61;
    __ZdlPv($54);
    break L1;
   }
   $c = $54;
   $57 = $c;
   $58 = $1;
   __ZN9Component14setComponentIdEh($57,$58);
   $59 = $c;
   $0 = $59;
   $238 = $0;
   STACKTOP = sp;return ($238|0);
   break;
  }
  case 11:  {
   $86 = (__Znwj(44)|0);
   __THREW__ = 0;
   invoke_vi(173,($86|0));
   $87 = __THREW__; __THREW__ = 0;
   $88 = $87&1;
   if ($88) {
    $92 = ___cxa_find_matching_catch()|0;
    $93 = tempRet0;
    $2 = $92;
    $3 = $93;
    __ZdlPv($86);
    break L1;
   }
   $c = $86;
   $89 = $c;
   $90 = $1;
   __ZN9Component14setComponentIdEh($89,$90);
   $91 = $c;
   $0 = $91;
   $238 = $0;
   STACKTOP = sp;return ($238|0);
   break;
  }
  case 12:  {
   $94 = (__Znwj(44)|0);
   __THREW__ = 0;
   invoke_vi(174,($94|0));
   $95 = __THREW__; __THREW__ = 0;
   $96 = $95&1;
   if ($96) {
    $100 = ___cxa_find_matching_catch()|0;
    $101 = tempRet0;
    $2 = $100;
    $3 = $101;
    __ZdlPv($94);
    break L1;
   }
   $c = $94;
   $97 = $c;
   $98 = $1;
   __ZN9Component14setComponentIdEh($97,$98);
   $99 = $c;
   $0 = $99;
   $238 = $0;
   STACKTOP = sp;return ($238|0);
   break;
  }
  case 29:  {
   $230 = (__Znwj(32)|0);
   __THREW__ = 0;
   invoke_vi(191,($230|0));
   $231 = __THREW__; __THREW__ = 0;
   $232 = $231&1;
   if ($232) {
    $236 = ___cxa_find_matching_catch()|0;
    $237 = tempRet0;
    $2 = $236;
    $3 = $237;
    __ZdlPv($230);
    break L1;
   }
   $c = $230;
   $233 = $c;
   $234 = $1;
   __ZN9Component14setComponentIdEh($233,$234);
   $235 = $c;
   $0 = $235;
   $238 = $0;
   STACKTOP = sp;return ($238|0);
   break;
  }
  default: {
   $0 = 0;
   $238 = $0;
   STACKTOP = sp;return ($238|0);
  }
  }
 } while(0);
 $239 = $2;
 $240 = $3;
 ___resumeException($239|0);
 // unreachable;
 return (0)|0;
}
function __ZN7Network7addNodeEP9Componenth($this,$node,$parentId) {
 $this = $this|0;
 $node = $node|0;
 $parentId = $parentId|0;
 var $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0;
 var $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0;
 var $45 = 0, $46 = 0, $47 = 0, $48 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $nodeId = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $1 = $this;
 $2 = $node;
 $3 = $parentId;
 $4 = $1;
 $5 = $2;
 $6 = ($5|0)!=(0|0);
 if (!($6)) {
  $7 = (($4) + 1008|0);
  $8 = HEAP32[$7>>2]|0;
  __ZL14microflo_debugP12DebugHandler10DebugLevel7DebugId($8,1,15);
  $0 = 0;
  $48 = $0;
  STACKTOP = sp;return ($48|0);
 }
 $9 = $3;
 $10 = $9&255;
 $11 = (($4) + 200|0);
 $12 = HEAP8[$11>>0]|0;
 $13 = $12&255;
 $14 = ($10|0)<=($13|0);
 if (!($14)) {
  $15 = (($4) + 1008|0);
  $16 = HEAP32[$15>>2]|0;
  __ZL14microflo_debugP12DebugHandler10DebugLevel7DebugId($16,1,24);
  $0 = 0;
  $48 = $0;
  STACKTOP = sp;return ($48|0);
 }
 $17 = (($4) + 200|0);
 $18 = HEAP8[$17>>0]|0;
 $19 = $18&255;
 $nodeId = $19;
 $20 = $2;
 $21 = $nodeId;
 $22 = (($4) + ($21<<2)|0);
 HEAP32[$22>>2] = $20;
 $23 = $2;
 $24 = $nodeId;
 $25 = (($4) + 1012|0);
 $26 = HEAP32[$25>>2]|0;
 __ZN9Component10setNetworkEP7NetworkiP2IO($23,$4,$24,$26);
 $27 = $3;
 $28 = $27&255;
 $29 = ($28|0)>(0);
 if ($29) {
  $30 = $2;
  $31 = $3;
  $32 = $31&255;
  __ZN9Component9setParentEi($30,$32);
 }
 $33 = (($4) + 1008|0);
 $34 = HEAP32[$33>>2]|0;
 $35 = ($34|0)!=(0|0);
 if ($35) {
  $36 = (($4) + 1008|0);
  $37 = HEAP32[$36>>2]|0;
  $38 = HEAP32[$37>>2]|0;
  $39 = (($38) + 16|0);
  $40 = HEAP32[$39>>2]|0;
  $41 = $2;
  $42 = $3;
  FUNCTION_TABLE_viii[$40 & 255]($37,$41,$42);
 }
 $43 = (($4) + 200|0);
 $44 = HEAP8[$43>>0]|0;
 $45 = (($44) + 1)<<24>>24;
 HEAP8[$43>>0] = $45;
 $46 = $nodeId;
 $47 = $46&255;
 $0 = $47;
 $48 = $0;
 STACKTOP = sp;return ($48|0);
}
function __ZN7Network7connectEhaha($this,$srcId,$srcPort,$targetId,$targetPort) {
 $this = $this|0;
 $srcId = $srcId|0;
 $srcPort = $srcPort|0;
 $targetId = $targetId|0;
 $targetPort = $targetPort|0;
 var $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0;
 var $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $srcId;
 $2 = $srcPort;
 $3 = $targetId;
 $4 = $targetPort;
 $5 = $0;
 $6 = $1;
 $7 = $6&255;
 $8 = ($7|0)>=(1);
 if ($8) {
  $9 = $1;
  $10 = $9&255;
  $11 = (($5) + 200|0);
  $12 = HEAP8[$11>>0]|0;
  $13 = $12&255;
  $14 = ($10|0)<=($13|0);
  if ($14) {
   $15 = $3;
   $16 = $15&255;
   $17 = ($16|0)>=(1);
   if ($17) {
    $18 = $3;
    $19 = $18&255;
    $20 = (($5) + 200|0);
    $21 = HEAP8[$20>>0]|0;
    $22 = $21&255;
    $23 = ($19|0)<=($22|0);
    if ($23) {
     $26 = $1;
     $27 = $26&255;
     $28 = (($5) + ($27<<2)|0);
     $29 = HEAP32[$28>>2]|0;
     $30 = $2;
     $31 = $3;
     $32 = $31&255;
     $33 = (($5) + ($32<<2)|0);
     $34 = HEAP32[$33>>2]|0;
     $35 = $4;
     __ZN7Network7connectEP9ComponentaS1_a($5,$29,$30,$34,$35);
     STACKTOP = sp;return;
    }
   }
  }
 }
 $24 = (($5) + 1008|0);
 $25 = HEAP32[$24>>2]|0;
 __ZL14microflo_debugP12DebugHandler10DebugLevel7DebugId($25,1,12);
 STACKTOP = sp;return;
}
function __ZN6PacketC2Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 $2 = (($1) + 4|0);
 HEAP32[$2>>2] = 3;
 STACKTOP = sp;return;
}
function __ZN6PacketC2E3Msg($this,$m) {
 $this = $this|0;
 $m = $m|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $m;
 $2 = $0;
 $3 = (($2) + 4|0);
 $4 = $1;
 HEAP32[$3>>2] = $4;
 STACKTOP = sp;return;
}
function __ZN6PacketC2El($this,$l) {
 $this = $this|0;
 $l = $l|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $l;
 $2 = $0;
 $3 = (($2) + 4|0);
 HEAP32[$3>>2] = 7;
 $4 = $1;
 HEAP32[$2>>2] = $4;
 STACKTOP = sp;return;
}
function __ZN6PacketC2Eh($this,$by) {
 $this = $this|0;
 $by = $by|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $by;
 $2 = $0;
 $3 = (($2) + 4|0);
 HEAP32[$3>>2] = 4;
 $4 = $1;
 HEAP8[$2>>0] = $4;
 STACKTOP = sp;return;
}
function __ZN6PacketC2Eb($this,$b) {
 $this = $this|0;
 $b = $b|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $2 = $b&1;
 $1 = $2;
 $3 = $0;
 $4 = (($3) + 4|0);
 HEAP32[$4>>2] = 6;
 $5 = $1;
 $6 = $5&1;
 $7 = $6&1;
 HEAP8[$3>>0] = $7;
 STACKTOP = sp;return;
}
function __ZNK6Packet7isValidEv($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 $2 = (($1) + 4|0);
 $3 = HEAP32[$2>>2]|0;
 $4 = ($3|0)>(0);
 if (!($4)) {
  $8 = 0;
  STACKTOP = sp;return ($8|0);
 }
 $5 = (($1) + 4|0);
 $6 = HEAP32[$5>>2]|0;
 $7 = ($6|0)<(11);
 $8 = $7;
 STACKTOP = sp;return ($8|0);
}
function __ZN7Network13sendMessageIdEhaRK6Packet($this,$targetId,$targetPort,$pkg) {
 $this = $this|0;
 $targetId = $targetId|0;
 $targetPort = $targetPort|0;
 $pkg = $pkg|0;
 var $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 var $8 = 0, $9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $targetId;
 $2 = $targetPort;
 $3 = $pkg;
 $4 = $0;
 $5 = $1;
 $6 = $5&255;
 $7 = ($6|0)>=(1);
 if ($7) {
  $8 = $1;
  $9 = $8&255;
  $10 = (($4) + 200|0);
  $11 = HEAP8[$10>>0]|0;
  $12 = $11&255;
  $13 = ($9|0)<=($12|0);
  if ($13) {
   $16 = $1;
   $17 = $16&255;
   $18 = (($4) + ($17<<2)|0);
   $19 = HEAP32[$18>>2]|0;
   $20 = $2;
   $21 = $3;
   __ZN7Network11sendMessageEP9ComponentaRK6PacketS1_a($4,$19,$20,$21,0,-1);
   STACKTOP = sp;return;
  }
 }
 $14 = (($4) + 1008|0);
 $15 = HEAP32[$14>>2]|0;
 __ZL14microflo_debugP12DebugHandler10DebugLevel7DebugId($15,1,23);
 STACKTOP = sp;return;
}
function __ZN7Network13setDebugLevelE10DebugLevel($this,$level) {
 $this = $this|0;
 $level = $level|0;
 var $0 = 0, $1 = 0, $10 = 0, $11 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $level;
 $2 = $0;
 $3 = (($2) + 1008|0);
 $4 = HEAP32[$3>>2]|0;
 $5 = ($4|0)!=(0|0);
 if (!($5)) {
  STACKTOP = sp;return;
 }
 $6 = (($2) + 1008|0);
 $7 = HEAP32[$6>>2]|0;
 $8 = HEAP32[$7>>2]|0;
 $9 = (($8) + 4|0);
 $10 = HEAP32[$9>>2]|0;
 $11 = $1;
 FUNCTION_TABLE_vii[$10 & 255]($7,$11);
 STACKTOP = sp;return;
}
function __ZN7Network15subscribeToPortEhab($this,$nodeId,$portId,$enable) {
 $this = $this|0;
 $nodeId = $nodeId|0;
 $portId = $portId|0;
 $enable = $enable|0;
 var $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0;
 var $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0;
 var $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $c = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $nodeId;
 $2 = $portId;
 $4 = $enable&1;
 $3 = $4;
 $5 = $0;
 $6 = $1;
 $7 = $6&255;
 $8 = ($7|0)>=(1);
 if ($8) {
  $9 = $1;
  $10 = $9&255;
  $11 = (($5) + 200|0);
  $12 = HEAP8[$11>>0]|0;
  $13 = $12&255;
  $14 = ($10|0)<=($13|0);
  if ($14) {
   $17 = $1;
   $18 = $17&255;
   $19 = (($5) + ($18<<2)|0);
   $20 = HEAP32[$19>>2]|0;
   $c = $20;
   $21 = $2;
   $22 = $21 << 24 >> 24;
   $23 = $c;
   $24 = (($23) + 12|0);
   $25 = HEAP8[$24>>0]|0;
   $26 = $25 << 24 >> 24;
   $27 = ($22|0)>=($26|0);
   if ($27) {
    STACKTOP = sp;return;
   }
   $28 = $3;
   $29 = $28&1;
   $30 = $2;
   $31 = $30 << 24 >> 24;
   $32 = $c;
   $33 = (($32) + 8|0);
   $34 = HEAP32[$33>>2]|0;
   $35 = (($34) + ($31<<3)|0);
   $36 = (($35) + 5|0);
   $37 = $29&1;
   HEAP8[$36>>0] = $37;
   $38 = (($5) + 1008|0);
   $39 = HEAP32[$38>>2]|0;
   $40 = ($39|0)!=(0|0);
   if (!($40)) {
    STACKTOP = sp;return;
   }
   $41 = (($5) + 1008|0);
   $42 = HEAP32[$41>>2]|0;
   $43 = HEAP32[$42>>2]|0;
   $44 = (($43) + 32|0);
   $45 = HEAP32[$44>>2]|0;
   $46 = $1;
   $47 = $2;
   $48 = $3;
   $49 = $48&1;
   FUNCTION_TABLE_viiii[$45 & 255]($42,$46,$47,$49);
   STACKTOP = sp;return;
  }
 }
 $15 = (($5) + 1008|0);
 $16 = HEAP32[$15>>2]|0;
 __ZL14microflo_debugP12DebugHandler10DebugLevel7DebugId($16,1,25);
 STACKTOP = sp;return;
}
function __ZN7Network15connectSubgraphEbhaha($this,$isOutput,$subgraphNode,$subgraphPort,$childNode,$childPort) {
 $this = $this|0;
 $isOutput = $isOutput|0;
 $subgraphNode = $subgraphNode|0;
 $subgraphPort = $subgraphPort|0;
 $childNode = $childNode|0;
 $childPort = $childPort|0;
 var $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0;
 var $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0;
 var $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0;
 var $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $8 = 0, $9 = 0, $child = 0, $comp = 0, $subgraph = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $6 = $isOutput&1;
 $1 = $6;
 $2 = $subgraphNode;
 $3 = $subgraphPort;
 $4 = $childNode;
 $5 = $childPort;
 $7 = $0;
 $8 = $2;
 $9 = $8&255;
 $10 = ($9|0)>=(1);
 if ($10) {
  $11 = $2;
  $12 = $11&255;
  $13 = (($7) + 200|0);
  $14 = HEAP8[$13>>0]|0;
  $15 = $14&255;
  $16 = ($12|0)<=($15|0);
  if ($16) {
   $17 = $4;
   $18 = $17&255;
   $19 = ($18|0)>=(1);
   if ($19) {
    $20 = $4;
    $21 = $20&255;
    $22 = (($7) + 200|0);
    $23 = HEAP8[$22>>0]|0;
    $24 = $23&255;
    $25 = ($21|0)<=($24|0);
    if ($25) {
     $28 = $2;
     $29 = $28&255;
     $30 = (($7) + ($29<<2)|0);
     $31 = HEAP32[$30>>2]|0;
     $comp = $31;
     $32 = $4;
     $33 = $32&255;
     $34 = (($7) + ($33<<2)|0);
     $35 = HEAP32[$34>>2]|0;
     $child = $35;
     $36 = $comp;
     $37 = (__ZNK9Component9componentEv($36)|0);
     $38 = $37&255;
     $39 = ($38|0)==(100);
     if ($39) {
      $40 = $child;
      $41 = (($40) + 22|0);
      $42 = HEAP8[$41>>0]|0;
      $43 = $42&255;
      $44 = ($43|0)>=(1);
      if (!($44)) {
       label = 11;
      }
     } else {
      label = 11;
     }
     if ((label|0) == 11) {
      $45 = (($7) + 1008|0);
      $46 = HEAP32[$45>>2]|0;
      __ZL14microflo_debugP12DebugHandler10DebugLevel7DebugId($46,1,20);
     }
     $47 = $comp;
     $subgraph = $47;
     $48 = $1;
     $49 = $48&1;
     if ($49) {
      $50 = $subgraph;
      $51 = $3;
      $52 = $child;
      $53 = $5;
      __ZN8SubGraph14connectOutportEaP9Componenta($50,$51,$52,$53);
     } else {
      $54 = $subgraph;
      $55 = $3;
      $56 = $child;
      $57 = $5;
      __ZN8SubGraph13connectInportEaP9Componenta($54,$55,$56,$57);
     }
     $58 = (($7) + 1008|0);
     $59 = HEAP32[$58>>2]|0;
     $60 = ($59|0)!=(0|0);
     if (!($60)) {
      STACKTOP = sp;return;
     }
     $61 = (($7) + 1008|0);
     $62 = HEAP32[$61>>2]|0;
     $63 = HEAP32[$62>>2]|0;
     $64 = (($63) + 28|0);
     $65 = HEAP32[$64>>2]|0;
     $66 = $1;
     $67 = $66&1;
     $68 = $2;
     $69 = $3;
     $70 = $4;
     $71 = $5;
     FUNCTION_TABLE_viiiiii[$65 & 255]($62,$67,$68,$69,$70,$71);
     STACKTOP = sp;return;
    }
   }
  }
 }
 $26 = (($7) + 1008|0);
 $27 = HEAP32[$26>>2]|0;
 __ZL14microflo_debugP12DebugHandler10DebugLevel7DebugId($27,1,21);
 STACKTOP = sp;return;
}
function __ZN7Network10setIoValueEPKhh($this,$buf,$len) {
 $this = $this|0;
 $buf = $buf|0;
 $len = $len|0;
 var $0 = 0, $1 = 0, $10 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $buf;
 $2 = $len;
 $3 = $0;
 $4 = (($3) + 1012|0);
 $5 = HEAP32[$4>>2]|0;
 $6 = HEAP32[$5>>2]|0;
 $7 = (($6) + 8|0);
 $8 = HEAP32[$7>>2]|0;
 $9 = $1;
 $10 = $2;
 FUNCTION_TABLE_viii[$8 & 255]($5,$9,$10);
 STACKTOP = sp;return;
}
function __ZN9Component14setComponentIdEh($this,$id) {
 $this = $this|0;
 $id = $id|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $id;
 $2 = $0;
 $3 = $1;
 $4 = (($2) + 21|0);
 HEAP8[$4>>0] = $3;
 STACKTOP = sp;return;
}
function __ZN9Component4sendE6Packeta($this,$out,$port) {
 $this = $this|0;
 $out = $out|0;
 $port = $port|0;
 var $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0;
 var $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0;
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $port;
 $2 = $0;
 $3 = $1;
 $4 = $3 << 24 >> 24;
 $5 = (($2) + 12|0);
 $6 = HEAP8[$5>>0]|0;
 $7 = $6 << 24 >> 24;
 $8 = ($4|0)<($7|0);
 if (!($8)) {
  $9 = (($2) + 16|0);
  $10 = HEAP32[$9>>2]|0;
  $11 = (($10) + 1008|0);
  $12 = HEAP32[$11>>2]|0;
  __ZL14microflo_debugP12DebugHandler10DebugLevel7DebugId($12,1,16);
  STACKTOP = sp;return;
 }
 $13 = $1;
 $14 = $13 << 24 >> 24;
 $15 = (($2) + 8|0);
 $16 = HEAP32[$15>>2]|0;
 $17 = (($16) + ($14<<3)|0);
 $18 = HEAP32[$17>>2]|0;
 $19 = ($18|0)!=(0|0);
 if (!($19)) {
  STACKTOP = sp;return;
 }
 $20 = $1;
 $21 = $20 << 24 >> 24;
 $22 = (($2) + 8|0);
 $23 = HEAP32[$22>>2]|0;
 $24 = (($23) + ($21<<3)|0);
 $25 = (($24) + 4|0);
 $26 = HEAP8[$25>>0]|0;
 $27 = $26 << 24 >> 24;
 $28 = ($27|0)>=(0);
 if (!($28)) {
  STACKTOP = sp;return;
 }
 $29 = (($2) + 16|0);
 $30 = HEAP32[$29>>2]|0;
 $31 = $1;
 $32 = $31 << 24 >> 24;
 $33 = (($2) + 8|0);
 $34 = HEAP32[$33>>2]|0;
 $35 = (($34) + ($32<<3)|0);
 $36 = HEAP32[$35>>2]|0;
 $37 = $1;
 $38 = $37 << 24 >> 24;
 $39 = (($2) + 8|0);
 $40 = HEAP32[$39>>2]|0;
 $41 = (($40) + ($38<<3)|0);
 $42 = (($41) + 4|0);
 $43 = HEAP8[$42>>0]|0;
 $44 = $1;
 __ZN7Network11sendMessageEP9ComponentaRK6PacketS1_a($30,$36,$43,$out,$2,$44);
 STACKTOP = sp;return;
}
function __ZN7Network11sendMessageEP9ComponentaRK6PacketS1_a($this,$target,$targetPort,$pkg,$sender,$senderPort) {
 $this = $this|0;
 $target = $target|0;
 $targetPort = $targetPort|0;
 $pkg = $pkg|0;
 $sender = $sender|0;
 $senderPort = $senderPort|0;
 var $$byval_copy = 0, $0 = 0, $1 = 0, $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $12 = 0, $13 = 0;
 var $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0;
 var $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0;
 var $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0;
 var $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0;
 var $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $msg = 0, $msgIndex = 0, $parent = 0, $sendNotification = 0, $senderIsChild = 0, $targetIsSubGraph = 0;
 var $targetSubGraph = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 80|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $$byval_copy = sp + 48|0;
 $6 = sp;
 $0 = $this;
 $1 = $target;
 $2 = $targetPort;
 $3 = $pkg;
 $4 = $sender;
 $5 = $senderPort;
 $7 = $0;
 $8 = $1;
 $9 = ($8|0)!=(0|0);
 if (!($9)) {
  STACKTOP = sp;return;
 }
 $10 = (($7) + 1004|0);
 $11 = HEAP8[$10>>0]|0;
 $12 = $11&255;
 $13 = ($12|0)>(49);
 if ($13) {
  $14 = (($7) + 1004|0);
  HEAP8[$14>>0] = 0;
 }
 $15 = (($7) + 1004|0);
 $16 = HEAP8[$15>>0]|0;
 $17 = (($16) + 1)<<24>>24;
 HEAP8[$15>>0] = $17;
 $msgIndex = $16;
 $18 = $4;
 $19 = ($18|0)!=(0|0);
 if ($19) {
  $20 = $4;
  $21 = (($20) + 22|0);
  $22 = HEAP8[$21>>0]|0;
  $23 = $22&255;
  $24 = ($23|0)>=(1);
  $26 = $24;
 } else {
  $26 = 0;
 }
 $25 = $26&1;
 $senderIsChild = $25;
 $27 = $senderIsChild;
 $28 = $27&1;
 if ($28) {
  $29 = $4;
  $30 = (($29) + 22|0);
  $31 = HEAP8[$30>>0]|0;
  $32 = $31&255;
  $33 = (($7) + ($32<<2)|0);
  $34 = HEAP32[$33>>2]|0;
  $parent = $34;
  $35 = $1;
  $36 = $parent;
  $37 = ($35|0)==($36|0);
  if ($37) {
   $38 = $2;
   $39 = $38 << 24 >> 24;
   $40 = $parent;
   $41 = (($40) + 104|0);
   $42 = (($41) + ($39<<3)|0);
   $43 = HEAP32[$42>>2]|0;
   $1 = $43;
   $44 = $2;
   $45 = $44 << 24 >> 24;
   $46 = $parent;
   $47 = (($46) + 104|0);
   $48 = (($47) + ($45<<3)|0);
   $49 = (($48) + 4|0);
   $50 = HEAP8[$49>>0]|0;
   $2 = $50;
  }
 }
 $51 = $1;
 $52 = (($51) + 21|0);
 $53 = HEAP8[$52>>0]|0;
 $54 = $53&255;
 $55 = ($54|0)==(100);
 $56 = $55&1;
 $targetIsSubGraph = $56;
 $57 = $targetIsSubGraph;
 $58 = $57&1;
 if ($58) {
  $59 = $1;
  $targetSubGraph = $59;
  $60 = $2;
  $61 = $60 << 24 >> 24;
  $62 = $targetSubGraph;
  $63 = (($62) + 24|0);
  $64 = (($63) + ($61<<3)|0);
  $65 = HEAP32[$64>>2]|0;
  $1 = $65;
  $66 = $2;
  $67 = $66 << 24 >> 24;
  $68 = $targetSubGraph;
  $69 = (($68) + 24|0);
  $70 = (($69) + ($67<<3)|0);
  $71 = (($70) + 4|0);
  $72 = HEAP8[$71>>0]|0;
  $2 = $72;
 }
 $73 = $msgIndex;
 $74 = $73&255;
 $75 = (($7) + 204|0);
 $76 = (($75) + ($74<<4)|0);
 $msg = $76;
 $77 = $1;
 $78 = $msg;
 HEAP32[$78>>2] = $77;
 $79 = $2;
 $80 = $msg;
 $81 = (($80) + 4|0);
 HEAP8[$81>>0] = $79;
 $82 = $msg;
 $83 = (($82) + 8|0);
 $84 = $3;
 ;HEAP32[$83+0>>2]=HEAP32[$84+0>>2]|0;HEAP32[$83+4>>2]=HEAP32[$84+4>>2]|0;
 $85 = $4;
 $86 = ($85|0)!=(0|0);
 if ($86) {
  $87 = $5;
  $88 = $87 << 24 >> 24;
  $89 = $4;
  $90 = (($89) + 8|0);
  $91 = HEAP32[$90>>2]|0;
  $92 = (($91) + ($88<<3)|0);
  $93 = (($92) + 5|0);
  $94 = HEAP8[$93>>0]|0;
  $95 = $94&1;
  $97 = $95;
 } else {
  $97 = 0;
 }
 $96 = $97&1;
 $sendNotification = $96;
 $98 = $sendNotification;
 $99 = $98&1;
 if (!($99)) {
  STACKTOP = sp;return;
 }
 $100 = (($7) + 1008|0);
 $101 = HEAP32[$100>>2]|0;
 $102 = ($101|0)!=(0|0);
 if (!($102)) {
  STACKTOP = sp;return;
 }
 $103 = (($7) + 1008|0);
 $104 = HEAP32[$103>>2]|0;
 $105 = HEAP32[$104>>2]|0;
 $106 = (($105) + 8|0);
 $107 = HEAP32[$106>>2]|0;
 $108 = $msgIndex;
 $109 = $108&255;
 $110 = $msg;
 ;HEAP32[$6+0>>2]=HEAP32[$110+0>>2]|0;HEAP32[$6+4>>2]=HEAP32[$110+4>>2]|0;HEAP32[$6+8>>2]=HEAP32[$110+8>>2]|0;HEAP32[$6+12>>2]=HEAP32[$110+12>>2]|0;
 $111 = $4;
 $112 = $5;
 ;HEAP32[$$byval_copy+0>>2]=HEAP32[$6+0>>2]|0;HEAP32[$$byval_copy+4>>2]=HEAP32[$6+4>>2]|0;HEAP32[$$byval_copy+8>>2]=HEAP32[$6+8>>2]|0;HEAP32[$$byval_copy+12>>2]=HEAP32[$6+12>>2]|0;
 FUNCTION_TABLE_viiiii[$107 & 255]($104,$109,$$byval_copy,$111,$112);
 STACKTOP = sp;return;
}
function __ZN9Component7connectEaPS_a($this,$outPort,$target,$targetPort) {
 $this = $this|0;
 $outPort = $outPort|0;
 $target = $target|0;
 $targetPort = $targetPort|0;
 var $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $outPort;
 $2 = $target;
 $3 = $targetPort;
 $4 = $0;
 $5 = $2;
 $6 = $1;
 $7 = $6 << 24 >> 24;
 $8 = (($4) + 8|0);
 $9 = HEAP32[$8>>2]|0;
 $10 = (($9) + ($7<<3)|0);
 HEAP32[$10>>2] = $5;
 $11 = $3;
 $12 = $1;
 $13 = $12 << 24 >> 24;
 $14 = (($4) + 8|0);
 $15 = HEAP32[$14>>2]|0;
 $16 = (($15) + ($13<<3)|0);
 $17 = (($16) + 4|0);
 HEAP8[$17>>0] = $11;
 STACKTOP = sp;return;
}
function __ZN9Component10setNetworkEP7NetworkiP2IO($this,$net,$n,$i) {
 $this = $this|0;
 $net = $net|0;
 $n = $n|0;
 $i = $i|0;
 var $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0;
 var $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $i1 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $net;
 $2 = $n;
 $3 = $i;
 $4 = $0;
 $5 = (($4) + 22|0);
 HEAP8[$5>>0] = 0;
 $6 = $1;
 $7 = (($4) + 16|0);
 HEAP32[$7>>2] = $6;
 $8 = $2;
 $9 = $8&255;
 $10 = (($4) + 20|0);
 HEAP8[$10>>0] = $9;
 $11 = $3;
 $12 = (($4) + 4|0);
 HEAP32[$12>>2] = $11;
 $i1 = 0;
 while(1) {
  $13 = $i1;
  $14 = (($4) + 12|0);
  $15 = HEAP8[$14>>0]|0;
  $16 = $15 << 24 >> 24;
  $17 = ($13|0)<($16|0);
  if (!($17)) {
   break;
  }
  $18 = $i1;
  $19 = (($4) + 8|0);
  $20 = HEAP32[$19>>2]|0;
  $21 = (($20) + ($18<<3)|0);
  HEAP32[$21>>2] = 0;
  $22 = $i1;
  $23 = (($4) + 8|0);
  $24 = HEAP32[$23>>2]|0;
  $25 = (($24) + ($22<<3)|0);
  $26 = (($25) + 4|0);
  HEAP8[$26>>0] = -1;
  $27 = $i1;
  $28 = (($4) + 8|0);
  $29 = HEAP32[$28>>2]|0;
  $30 = (($29) + ($27<<3)|0);
  $31 = (($30) + 5|0);
  HEAP8[$31>>0] = 0;
  $32 = $i1;
  $33 = (($32) + 1)|0;
  $i1 = $33;
 }
 STACKTOP = sp;return;
}
function __ZN7NetworkC2EP2IO($this,$io) {
 $this = $this|0;
 $io = $io|0;
 var $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 var $9 = 0, $i = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $io;
 $2 = $0;
 $3 = (($2) + 200|0);
 HEAP8[$3>>0] = 1;
 $4 = (($2) + 204|0);
 $5 = (($4) + 800|0);
 $6 = $4;
 while(1) {
  __ZN7MessageC2Ev($6);
  $7 = (($6) + 16|0);
  $8 = ($7|0)==($5|0);
  if ($8) {
   break;
  } else {
   $6 = $7;
  }
 }
 $9 = (($2) + 1004|0);
 HEAP8[$9>>0] = 0;
 $10 = (($2) + 1005|0);
 HEAP8[$10>>0] = 0;
 $11 = (($2) + 1008|0);
 HEAP32[$11>>2] = 0;
 $12 = (($2) + 1012|0);
 $13 = $1;
 HEAP32[$12>>2] = $13;
 $14 = (($2) + 1016|0);
 HEAP32[$14>>2] = 0;
 $i = 0;
 while(1) {
  $15 = $i;
  $16 = ($15|0)<(50);
  if (!($16)) {
   break;
  }
  $17 = $i;
  $18 = (($2) + ($17<<2)|0);
  HEAP32[$18>>2] = 0;
  $19 = $i;
  $20 = (($19) + 1)|0;
  $i = $20;
 }
 STACKTOP = sp;return;
}
function __ZN7MessageC2Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 $2 = (($1) + 8|0);
 __ZN6PacketC2Ev($2);
 STACKTOP = sp;return;
}
function __ZN7Network15deliverMessagesEhh($this,$firstIndex,$lastIndex) {
 $this = $this|0;
 $firstIndex = $firstIndex|0;
 $lastIndex = $lastIndex|0;
 var $$byval_copy = 0, $$byval_copy1 = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0;
 var $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0;
 var $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 var $i = 0, $target = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $$byval_copy1 = sp + 40|0;
 $$byval_copy = sp + 32|0;
 $3 = sp + 16|0;
 $4 = sp;
 $0 = $this;
 $1 = $firstIndex;
 $2 = $lastIndex;
 $5 = $0;
 $6 = $1;
 $7 = $6&255;
 $8 = ($7|0)<(50);
 if ($8) {
  $9 = $2;
  $10 = $9&255;
  $11 = ($10|0)<(50);
  if ($11) {
   $14 = $1;
   $i = $14;
   while(1) {
    $15 = $i;
    $16 = $15&255;
    $17 = $2;
    $18 = $17&255;
    $19 = ($16|0)<=($18|0);
    if (!($19)) {
     break;
    }
    $20 = $i;
    $21 = $20&255;
    $22 = (($5) + 204|0);
    $23 = (($22) + ($21<<4)|0);
    $24 = HEAP32[$23>>2]|0;
    $target = $24;
    $25 = $target;
    $26 = ($25|0)!=(0|0);
    if ($26) {
     $27 = $target;
     $28 = HEAP32[$27>>2]|0;
     $29 = (($28) + 8|0);
     $30 = HEAP32[$29>>2]|0;
     $31 = $i;
     $32 = $31&255;
     $33 = (($5) + 204|0);
     $34 = (($33) + ($32<<4)|0);
     $35 = (($34) + 8|0);
     ;HEAP32[$3+0>>2]=HEAP32[$35+0>>2]|0;HEAP32[$3+4>>2]=HEAP32[$35+4>>2]|0;
     $36 = $i;
     $37 = $36&255;
     $38 = (($5) + 204|0);
     $39 = (($38) + ($37<<4)|0);
     $40 = (($39) + 4|0);
     $41 = HEAP8[$40>>0]|0;
     ;HEAP32[$$byval_copy+0>>2]=HEAP32[$3+0>>2]|0;HEAP32[$$byval_copy+4>>2]=HEAP32[$3+4>>2]|0;
     FUNCTION_TABLE_viii[$30 & 255]($27,$$byval_copy,$41);
     $42 = (($5) + 1008|0);
     $43 = HEAP32[$42>>2]|0;
     $44 = ($43|0)!=(0|0);
     if ($44) {
      $45 = (($5) + 1008|0);
      $46 = HEAP32[$45>>2]|0;
      $47 = HEAP32[$46>>2]|0;
      $48 = (($47) + 12|0);
      $49 = HEAP32[$48>>2]|0;
      $50 = $i;
      $51 = $50&255;
      $52 = $i;
      $53 = $52&255;
      $54 = (($5) + 204|0);
      $55 = (($54) + ($53<<4)|0);
      ;HEAP32[$4+0>>2]=HEAP32[$55+0>>2]|0;HEAP32[$4+4>>2]=HEAP32[$55+4>>2]|0;HEAP32[$4+8>>2]=HEAP32[$55+8>>2]|0;HEAP32[$4+12>>2]=HEAP32[$55+12>>2]|0;
      ;HEAP32[$$byval_copy1+0>>2]=HEAP32[$4+0>>2]|0;HEAP32[$$byval_copy1+4>>2]=HEAP32[$4+4>>2]|0;HEAP32[$$byval_copy1+8>>2]=HEAP32[$4+8>>2]|0;HEAP32[$$byval_copy1+12>>2]=HEAP32[$4+12>>2]|0;
      FUNCTION_TABLE_viii[$49 & 255]($46,$51,$$byval_copy1);
     }
    } else {
    }
    $56 = $i;
    $57 = (($56) + 1)<<24>>24;
    $i = $57;
   }
   STACKTOP = sp;return;
  }
 }
 $12 = (($5) + 1008|0);
 $13 = HEAP32[$12>>2]|0;
 __ZL14microflo_debugP12DebugHandler10DebugLevel7DebugId($13,1,29);
 STACKTOP = sp;return;
}
function __ZN7Network15processMessagesEv($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0;
 var $27 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $readIndex = 0, $writeIndex = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 $2 = (($1) + 1005|0);
 $3 = HEAP8[$2>>0]|0;
 $readIndex = $3;
 $4 = (($1) + 1004|0);
 $5 = HEAP8[$4>>0]|0;
 $writeIndex = $5;
 $6 = $readIndex;
 $7 = $6&255;
 $8 = $writeIndex;
 $9 = $8&255;
 $10 = ($7|0)>($9|0);
 if ($10) {
  $11 = $readIndex;
  __ZN7Network15deliverMessagesEhh($1,$11,49);
  $12 = $writeIndex;
  $13 = $12&255;
  $14 = (($13) - 1)|0;
  $15 = $14&255;
  __ZN7Network15deliverMessagesEhh($1,0,$15);
  $26 = $writeIndex;
  $27 = (($1) + 1005|0);
  HEAP8[$27>>0] = $26;
  STACKTOP = sp;return;
 }
 $16 = $readIndex;
 $17 = $16&255;
 $18 = $writeIndex;
 $19 = $18&255;
 $20 = ($17|0)<($19|0);
 if ($20) {
  $21 = $readIndex;
  $22 = $writeIndex;
  $23 = $22&255;
  $24 = (($23) - 1)|0;
  $25 = $24&255;
  __ZN7Network15deliverMessagesEhh($1,$21,$25);
 } else {
 }
 $26 = $writeIndex;
 $27 = (($1) + 1005|0);
 HEAP8[$27>>0] = $26;
 STACKTOP = sp;return;
}
function __ZN7Network16distributePacketERK6Packeta($this,$packet,$port) {
 $this = $this|0;
 $packet = $packet|0;
 $port = $port|0;
 var $$byval_copy = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $3 = 0, $4 = 0;
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $i = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $$byval_copy = sp + 16|0;
 $3 = sp;
 $0 = $this;
 $1 = $packet;
 $2 = $port;
 $4 = $0;
 $i = 0;
 while(1) {
  $5 = $i;
  $6 = $5&255;
  $7 = ($6|0)<(50);
  if (!($7)) {
   break;
  }
  $8 = $i;
  $9 = $8&255;
  $10 = (($4) + ($9<<2)|0);
  $11 = HEAP32[$10>>2]|0;
  $12 = ($11|0)!=(0|0);
  if ($12) {
   $13 = $i;
   $14 = $13&255;
   $15 = (($4) + ($14<<2)|0);
   $16 = HEAP32[$15>>2]|0;
   $17 = HEAP32[$16>>2]|0;
   $18 = (($17) + 8|0);
   $19 = HEAP32[$18>>2]|0;
   $20 = $1;
   ;HEAP32[$3+0>>2]=HEAP32[$20+0>>2]|0;HEAP32[$3+4>>2]=HEAP32[$20+4>>2]|0;
   $21 = $2;
   ;HEAP32[$$byval_copy+0>>2]=HEAP32[$3+0>>2]|0;HEAP32[$$byval_copy+4>>2]=HEAP32[$3+4>>2]|0;
   FUNCTION_TABLE_viii[$19 & 255]($16,$$byval_copy,$21);
  }
  $22 = $i;
  $23 = (($22) + 1)<<24>>24;
  $i = $23;
 }
 STACKTOP = sp;return;
}
function __ZN7Network8runSetupEv($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $1 = sp;
 $0 = $this;
 $2 = $0;
 $3 = (($2) + 1016|0);
 $4 = HEAP32[$3>>2]|0;
 $5 = ($4|0)!=(1);
 if ($5) {
  STACKTOP = sp;return;
 } else {
  __ZN6PacketC2E3Msg($1,1);
  __ZN7Network16distributePacketERK6Packeta($2,$1,-1);
  STACKTOP = sp;return;
 }
}
function __ZN7Network7runTickEv($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $1 = sp;
 $0 = $this;
 $2 = $0;
 $3 = (($2) + 1016|0);
 $4 = HEAP32[$3>>2]|0;
 $5 = ($4|0)!=(1);
 if ($5) {
  STACKTOP = sp;return;
 } else {
  __ZN7Network15processMessagesEv($2);
  __ZN6PacketC2E3Msg($1,2);
  __ZN7Network16distributePacketERK6Packeta($2,$1,-1);
  STACKTOP = sp;return;
 }
}
function __ZN7Network7connectEP9ComponentaS1_a($this,$src,$srcPort,$target,$targetPort) {
 $this = $this|0;
 $src = $src|0;
 $srcPort = $srcPort|0;
 $target = $target|0;
 $targetPort = $targetPort|0;
 var $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 var $8 = 0, $9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $src;
 $2 = $srcPort;
 $3 = $target;
 $4 = $targetPort;
 $5 = $0;
 $6 = $1;
 $7 = $2;
 $8 = $3;
 $9 = $4;
 __ZN9Component7connectEaPS_a($6,$7,$8,$9);
 $10 = (($5) + 1008|0);
 $11 = HEAP32[$10>>2]|0;
 $12 = ($11|0)!=(0|0);
 if (!($12)) {
  STACKTOP = sp;return;
 }
 $13 = (($5) + 1008|0);
 $14 = HEAP32[$13>>2]|0;
 $15 = HEAP32[$14>>2]|0;
 $16 = (($15) + 20|0);
 $17 = HEAP32[$16>>2]|0;
 $18 = $1;
 $19 = $2;
 $20 = $3;
 $21 = $4;
 FUNCTION_TABLE_viiiii[$17 & 255]($14,$18,$19,$20,$21);
 STACKTOP = sp;return;
}
function __ZN9Component9setParentEi($this,$parentId) {
 $this = $this|0;
 $parentId = $parentId|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $parentId;
 $2 = $0;
 $3 = $1;
 $4 = $3&255;
 $5 = (($2) + 22|0);
 HEAP8[$5>>0] = $4;
 STACKTOP = sp;return;
}
function __ZNK9Component9componentEv($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 $2 = (($1) + 21|0);
 $3 = HEAP8[$2>>0]|0;
 STACKTOP = sp;return ($3|0);
}
function __ZN8SubGraph14connectOutportEaP9Componenta($this,$outPort,$child,$childOutPort) {
 $this = $this|0;
 $outPort = $outPort|0;
 $child = $child|0;
 $childOutPort = $childOutPort|0;
 var $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 var $8 = 0, $9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $outPort;
 $2 = $child;
 $3 = $childOutPort;
 $4 = $0;
 $5 = $1;
 $6 = $5 << 24 >> 24;
 $7 = ($6|0)<(0);
 if (!($7)) {
  $8 = $1;
  $9 = $8 << 24 >> 24;
  $10 = ($9|0)>=(10);
  if (!($10)) {
   $11 = $2;
   $12 = $1;
   $13 = $12 << 24 >> 24;
   $14 = (($4) + 104|0);
   $15 = (($14) + ($13<<3)|0);
   HEAP32[$15>>2] = $11;
   $16 = $3;
   $17 = $1;
   $18 = $17 << 24 >> 24;
   $19 = (($4) + 104|0);
   $20 = (($19) + ($18<<3)|0);
   $21 = (($20) + 4|0);
   HEAP8[$21>>0] = $16;
   STACKTOP = sp;return;
  }
 }
 STACKTOP = sp;return;
}
function __ZN8SubGraph13connectInportEaP9Componenta($this,$inPort,$child,$childInPort) {
 $this = $this|0;
 $inPort = $inPort|0;
 $child = $child|0;
 $childInPort = $childInPort|0;
 var $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 var $8 = 0, $9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $inPort;
 $2 = $child;
 $3 = $childInPort;
 $4 = $0;
 $5 = $1;
 $6 = $5 << 24 >> 24;
 $7 = ($6|0)<(0);
 if (!($7)) {
  $8 = $1;
  $9 = $8 << 24 >> 24;
  $10 = ($9|0)>=(10);
  if (!($10)) {
   $11 = $2;
   $12 = $1;
   $13 = $12 << 24 >> 24;
   $14 = (($4) + 24|0);
   $15 = (($14) + ($13<<3)|0);
   HEAP32[$15>>2] = $11;
   $16 = $3;
   $17 = $1;
   $18 = $17 << 24 >> 24;
   $19 = (($4) + 24|0);
   $20 = (($19) + ($18<<3)|0);
   $21 = (($20) + 4|0);
   HEAP8[$21>>0] = $16;
   STACKTOP = sp;return;
  }
 }
 STACKTOP = sp;return;
}
function __ZN17HostCommunication9nodeAddedEP9Componenth($this,$c,$parentId) {
 $this = $this|0;
 $c = $c|0;
 $parentId = $parentId|0;
 var $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $cmd = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $cmd = sp + 8|0;
 $0 = $this;
 $1 = $c;
 $2 = $parentId;
 $3 = $0;
 HEAP8[$cmd>>0] = 101;
 $4 = (($cmd) + 1|0);
 $5 = $1;
 $6 = (__ZNK9Component9componentEv($5)|0);
 HEAP8[$4>>0] = $6;
 $7 = (($4) + 1|0);
 $8 = $1;
 $9 = (__ZNK9Component2idEv($8)|0);
 HEAP8[$7>>0] = $9;
 $10 = (($7) + 1|0);
 $11 = $2;
 HEAP8[$10>>0] = $11;
 $12 = (($3) + 8|0);
 $13 = HEAP32[$12>>2]|0;
 $14 = HEAP32[$13>>2]|0;
 $15 = (($14) + 8|0);
 $16 = HEAP32[$15>>2]|0;
 FUNCTION_TABLE_viii[$16 & 255]($13,$cmd,4);
 STACKTOP = sp;return;
}
function __ZNK9Component2idEv($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 $2 = (($1) + 20|0);
 $3 = HEAP8[$2>>0]|0;
 STACKTOP = sp;return ($3|0);
}
function __ZN17HostCommunication14nodesConnectedEP9ComponentaS1_a($this,$src,$srcPort,$target,$targetPort) {
 $this = $this|0;
 $src = $src|0;
 $srcPort = $srcPort|0;
 $target = $target|0;
 $targetPort = $targetPort|0;
 var $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 var $9 = 0, $cmd = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $cmd = sp + 12|0;
 $0 = $this;
 $1 = $src;
 $2 = $srcPort;
 $3 = $target;
 $4 = $targetPort;
 $5 = $0;
 HEAP8[$cmd>>0] = 102;
 $6 = (($cmd) + 1|0);
 $7 = $1;
 $8 = (__ZNK9Component2idEv($7)|0);
 HEAP8[$6>>0] = $8;
 $9 = (($6) + 1|0);
 $10 = $2;
 HEAP8[$9>>0] = $10;
 $11 = (($9) + 1|0);
 $12 = $3;
 $13 = (__ZNK9Component2idEv($12)|0);
 HEAP8[$11>>0] = $13;
 $14 = (($11) + 1|0);
 $15 = $4;
 HEAP8[$14>>0] = $15;
 $16 = (($5) + 8|0);
 $17 = HEAP32[$16>>2]|0;
 $18 = HEAP32[$17>>2]|0;
 $19 = (($18) + 8|0);
 $20 = HEAP32[$19>>2]|0;
 FUNCTION_TABLE_viii[$20 & 255]($17,$cmd,5);
 STACKTOP = sp;return;
}
function __ZN17HostCommunication19networkStateChangedEN7Network5StateE($this,$s) {
 $this = $this|0;
 $s = $s|0;
 var $0 = 0, $1 = 0, $10 = 0, $11 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $cmd = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $cmd = sp;
 $0 = $this;
 $1 = $s;
 $2 = $0;
 HEAP32[$cmd>>2] = 115;
 $3 = $1;
 $4 = ($3|0)==(1);
 if ($4) {
  HEAP32[$cmd>>2] = 104;
 } else {
  $5 = $1;
  $6 = ($5|0)==(0);
  if ($6) {
   HEAP32[$cmd>>2] = 100;
  }
 }
 $7 = (($2) + 8|0);
 $8 = HEAP32[$7>>2]|0;
 $9 = HEAP32[$8>>2]|0;
 $10 = (($9) + 8|0);
 $11 = HEAP32[$10>>2]|0;
 FUNCTION_TABLE_viii[$11 & 255]($8,$cmd,1);
 STACKTOP = sp;return;
}
function __ZN17HostCommunication10packetSentEi7MessageP9Componenta($this,$index,$m,$src,$srcPort) {
 $this = $this|0;
 $index = $index|0;
 $m = $m|0;
 $src = $src|0;
 $srcPort = $srcPort|0;
 var $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0;
 var $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0;
 var $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $cmd = 0, $i = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $cmd = sp + 16|0;
 $0 = $this;
 $1 = $index;
 $2 = $src;
 $3 = $srcPort;
 $4 = $0;
 $5 = $2;
 $6 = ($5|0)!=(0|0);
 if (!($6)) {
  STACKTOP = sp;return;
 }
 HEAP8[$cmd>>0] = 103;
 $7 = (($cmd) + 1|0);
 $8 = $2;
 $9 = (__ZNK9Component2idEv($8)|0);
 HEAP8[$7>>0] = $9;
 $10 = (($7) + 1|0);
 $11 = $3;
 HEAP8[$10>>0] = $11;
 $12 = (($10) + 1|0);
 $13 = HEAP32[$m>>2]|0;
 $14 = (__ZNK9Component2idEv($13)|0);
 HEAP8[$12>>0] = $14;
 $15 = (($12) + 1|0);
 $16 = (($m) + 4|0);
 $17 = HEAP8[$16>>0]|0;
 HEAP8[$15>>0] = $17;
 $18 = (($15) + 1|0);
 $19 = (($m) + 8|0);
 $20 = (__ZNK6Packet4typeEv($19)|0);
 $21 = $20&255;
 HEAP8[$18>>0] = $21;
 $22 = (($18) + 1|0);
 HEAP8[$22>>0] = 0;
 $23 = (($22) + 1|0);
 HEAP8[$23>>0] = 0;
 $24 = (($m) + 8|0);
 $25 = (__ZNK6Packet6isDataEv($24)|0);
 if ($25) {
  $26 = (($m) + 8|0);
  $27 = (__ZNK6Packet6isBoolEv($26)|0);
  if ($27) {
   $28 = (($m) + 8|0);
   $29 = (__ZNK6Packet6asBoolEv($28)|0);
   $30 = $29&1;
   $31 = (($cmd) + 6|0);
   HEAP8[$31>>0] = $30;
  } else {
   $32 = (($m) + 8|0);
   $33 = (__ZNK6Packet8isNumberEv($32)|0);
   if ($33) {
    $34 = (($m) + 8|0);
    $35 = (__ZNK6Packet9asIntegerEv($34)|0);
    $i = $35;
    $36 = $i;
    $37 = $36 >> 0;
    $38 = $37&255;
    $39 = (($cmd) + 6|0);
    HEAP8[$39>>0] = $38;
    $40 = $i;
    $41 = $40 >> 8;
    $42 = $41&255;
    $43 = (($cmd) + 7|0);
    HEAP8[$43>>0] = $42;
   } else {
    $44 = (($m) + 8|0);
    $45 = (__ZNK6Packet6isVoidEv($44)|0);
    if ($45) {
    } else {
     __ZL14microflo_debugP12DebugHandler10DebugLevel7DebugId($4,1,19);
    }
   }
  }
 }
 $46 = (($4) + 8|0);
 $47 = HEAP32[$46>>2]|0;
 $48 = HEAP32[$47>>2]|0;
 $49 = (($48) + 8|0);
 $50 = HEAP32[$49>>2]|0;
 FUNCTION_TABLE_viii[$50 & 255]($47,$cmd,8);
 STACKTOP = sp;return;
}
function __ZNK6Packet4typeEv($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 $2 = (($1) + 4|0);
 $3 = HEAP32[$2>>2]|0;
 STACKTOP = sp;return ($3|0);
}
function __ZNK6Packet6isDataEv($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 $2 = (__ZNK6Packet7isValidEv($1)|0);
 if ($2) {
  $3 = (__ZNK6Packet9isSpecialEv($1)|0);
  $4 = $3 ^ 1;
  $5 = $4;
 } else {
  $5 = 0;
 }
 STACKTOP = sp;return ($5|0);
}
function __ZNK6Packet6isBoolEv($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 $2 = (($1) + 4|0);
 $3 = HEAP32[$2>>2]|0;
 $4 = ($3|0)==(6);
 STACKTOP = sp;return ($4|0);
}
function __ZNK6Packet8isNumberEv($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 $2 = (__ZNK6Packet9isIntegerEv($1)|0);
 if ($2) {
  $4 = 1;
 } else {
  $3 = (__ZNK6Packet7isFloatEv($1)|0);
  $4 = $3;
 }
 STACKTOP = sp;return ($4|0);
}
function __ZNK6Packet6isVoidEv($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 $2 = (($1) + 4|0);
 $3 = HEAP32[$2>>2]|0;
 $4 = ($3|0)==(3);
 STACKTOP = sp;return ($4|0);
}
function __ZN17HostCommunication15packetDeliveredEi7Message($this,$index,$m) {
 $this = $this|0;
 $index = $index|0;
 $m = $m|0;
 var $0 = 0, $1 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $index;
 STACKTOP = sp;return;
}
function __ZN17HostCommunication9emitDebugE10DebugLevel7DebugId($this,$level,$id) {
 $this = $this|0;
 $level = $level|0;
 $id = $id|0;
 var $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $cmd = 0;
 var label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $cmd = sp + 12|0;
 $0 = $this;
 $1 = $level;
 $2 = $id;
 $3 = $0;
 $4 = $1;
 $5 = (($3) + 28|0);
 $6 = HEAP32[$5>>2]|0;
 $7 = ($4|0)<=($6|0);
 if (!($7)) {
  STACKTOP = sp;return;
 }
 HEAP8[$cmd>>0] = 106;
 $8 = (($cmd) + 1|0);
 $9 = $1;
 $10 = $9&255;
 HEAP8[$8>>0] = $10;
 $11 = (($8) + 1|0);
 $12 = $2;
 $13 = $12&255;
 HEAP8[$11>>0] = $13;
 $14 = (($3) + 8|0);
 $15 = HEAP32[$14>>2]|0;
 $16 = HEAP32[$15>>2]|0;
 $17 = (($16) + 8|0);
 $18 = HEAP32[$17>>2]|0;
 FUNCTION_TABLE_viii[$18 & 255]($15,$cmd,3);
 STACKTOP = sp;return;
}
function __ZN17HostCommunication12debugChangedE10DebugLevel($this,$level) {
 $this = $this|0;
 $level = $level|0;
 var $0 = 0, $1 = 0, $10 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $cmd = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $cmd = sp + 8|0;
 $0 = $this;
 $1 = $level;
 $2 = $0;
 HEAP8[$cmd>>0] = 105;
 $3 = (($cmd) + 1|0);
 $4 = $1;
 $5 = $4&255;
 HEAP8[$3>>0] = $5;
 $6 = (($2) + 8|0);
 $7 = HEAP32[$6>>2]|0;
 $8 = HEAP32[$7>>2]|0;
 $9 = (($8) + 8|0);
 $10 = HEAP32[$9>>2]|0;
 FUNCTION_TABLE_viii[$10 & 255]($7,$cmd,2);
 STACKTOP = sp;return;
}
function __ZN17HostCommunication23portSubscriptionChangedEhab($this,$nodeId,$portId,$enable) {
 $this = $this|0;
 $nodeId = $nodeId|0;
 $portId = $portId|0;
 $enable = $enable|0;
 var $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $cmd = 0;
 var label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $cmd = sp + 4|0;
 $0 = $this;
 $1 = $nodeId;
 $2 = $portId;
 $4 = $enable&1;
 $3 = $4;
 $5 = $0;
 HEAP8[$cmd>>0] = 107;
 $6 = (($cmd) + 1|0);
 $7 = $1;
 HEAP8[$6>>0] = $7;
 $8 = (($6) + 1|0);
 $9 = $2;
 HEAP8[$8>>0] = $9;
 $10 = (($8) + 1|0);
 $11 = $3;
 $12 = $11&1;
 $13 = $12&1;
 HEAP8[$10>>0] = $13;
 $14 = (($5) + 8|0);
 $15 = HEAP32[$14>>2]|0;
 $16 = HEAP32[$15>>2]|0;
 $17 = (($16) + 8|0);
 $18 = HEAP32[$17>>2]|0;
 FUNCTION_TABLE_viii[$18 & 255]($15,$cmd,4);
 STACKTOP = sp;return;
}
function __ZN17HostCommunication17subgraphConnectedEbhaha($this,$isOutput,$subgraphNode,$subgraphPort,$childNode,$childPort) {
 $this = $this|0;
 $isOutput = $isOutput|0;
 $subgraphNode = $subgraphNode|0;
 $subgraphPort = $subgraphPort|0;
 $childNode = $childNode|0;
 $childPort = $childPort|0;
 var $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $3 = 0, $4 = 0;
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $cmd = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $cmd = sp + 4|0;
 $0 = $this;
 $6 = $isOutput&1;
 $1 = $6;
 $2 = $subgraphNode;
 $3 = $subgraphPort;
 $4 = $childNode;
 $5 = $childPort;
 $7 = $0;
 HEAP8[$cmd>>0] = 108;
 $8 = (($cmd) + 1|0);
 $9 = $1;
 $10 = $9&1;
 $11 = $10&1;
 HEAP8[$8>>0] = $11;
 $12 = (($8) + 1|0);
 $13 = $2;
 HEAP8[$12>>0] = $13;
 $14 = (($12) + 1|0);
 $15 = $3;
 HEAP8[$14>>0] = $15;
 $16 = (($14) + 1|0);
 $17 = $4;
 HEAP8[$16>>0] = $17;
 $18 = (($16) + 1|0);
 $19 = $5;
 HEAP8[$18>>0] = $19;
 $20 = (($7) + 8|0);
 $21 = HEAP32[$20>>2]|0;
 $22 = HEAP32[$21>>2]|0;
 $23 = (($22) + 8|0);
 $24 = HEAP32[$23>>2]|0;
 FUNCTION_TABLE_viii[$24 & 255]($21,$cmd,6);
 STACKTOP = sp;return;
}
function __ZN13HostTransportC2Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 $2 = (2808 + 8|0);
 HEAP32[$1>>2] = $2;
 STACKTOP = sp;return;
}
function __ZN8SubGraphC2Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 $2 = (88 + 8|0);
 HEAP32[$1>>2] = $2;
 $3 = (($1) + 104|0);
 __ZN9ComponentC2EP10Connectioni($1,$3,10);
 $4 = (88 + 8|0);
 HEAP32[$1>>2] = $4;
 STACKTOP = sp;return;
}
function __ZN9ComponentC2EP10Connectioni($this,$outPorts,$ports) {
 $this = $this|0;
 $outPorts = $outPorts|0;
 $ports = $ports|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $outPorts;
 $2 = $ports;
 $3 = $0;
 $4 = (2784 + 8|0);
 HEAP32[$3>>2] = $4;
 $5 = (($3) + 8|0);
 $6 = $1;
 HEAP32[$5>>2] = $6;
 $7 = (($3) + 12|0);
 $8 = $2;
 $9 = $8&255;
 HEAP8[$7>>0] = $9;
 STACKTOP = sp;return;
}
function __ZN8SubGraph7processE6Packeta($this,$in,$port) {
 $this = $this|0;
 $in = $in|0;
 $port = $port|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $port;
 $2 = $0;
 $3 = $1;
 $4 = $3 << 24 >> 24;
 $5 = ($4|0)<(0);
 if (!($5)) {
  $6 = (($2) + 16|0);
  $7 = HEAP32[$6>>2]|0;
  $8 = (($7) + 1008|0);
  $9 = HEAP32[$8>>2]|0;
  __ZL14microflo_debugP12DebugHandler10DebugLevel7DebugId($9,1,22);
 }
 STACKTOP = sp;return;
}
function __Z14loadFromEEPROMP17HostCommunication($controller) {
 $controller = $controller|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $c = 0, $i = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $controller;
 $i = 0;
 while(1) {
  $1 = $i;
  $2 = ($1>>>0)<(96);
  if (!($2)) {
   break;
  }
  $3 = $i;
  $4 = (112 + ($3)|0);
  $5 = HEAP8[$4>>0]|0;
  $c = $5;
  $6 = $0;
  $7 = $c;
  __ZN17HostCommunication9parseByteEc($6,$7);
  $8 = $i;
  $9 = (($8) + 1)|0;
  $i = $9;
 }
 STACKTOP = sp;return;
}
function __Znwj($n) {
 $n = $n|0;
 var $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 var $p = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $n;
 $3 = $0;
 __THREW__ = 0;
 $4 = (invoke_ii(192,($3|0))|0);
 $5 = __THREW__; __THREW__ = 0;
 $6 = $5&1;
 if (!($6)) {
  $p = $4;
  $7 = $p;
  $8 = ($7|0)!=(0|0);
  if ($8) {
   $17 = $p;
   STACKTOP = sp;return ($17|0);
  }
  $9 = (___cxa_allocate_exception(4)|0);
  __ZNSt9bad_allocC2Ev($9);
  __THREW__ = 0;
  invoke_viii(193,($9|0),(3320|0),(148|0));
  $10 = __THREW__; __THREW__ = 0;
  $11 = $10&1;
  if (!($11)) {
   // unreachable;
  }
 }
 $12 = ___cxa_find_matching_catch(3320|0)|0;
 $13 = tempRet0;
 $1 = $12;
 $2 = $13;
 $14 = $2;
 $15 = ($14|0)<(0);
 if ($15) {
  $16 = $1;
  ___cxa_call_unexpected(($16|0));
  // unreachable;
 } else {
  $18 = $1;
  $19 = $2;
  ___resumeException($18|0);
  // unreachable;
 }
 return (0)|0;
}
function __ZdlPv($p) {
 $p = $p|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $p;
 $3 = $0;
 __THREW__ = 0;
 invoke_vi(194,($3|0));
 $4 = __THREW__; __THREW__ = 0;
 $5 = $4&1;
 if (!($5)) {
  STACKTOP = sp;return;
 }
 $6 = ___cxa_find_matching_catch()|0;
 $7 = tempRet0;
 $1 = $6;
 $2 = $7;
 $8 = $1;
 ___cxa_call_unexpected(($8|0));
 // unreachable;
}
function __ZN23EmscriptenHostTransport5setupEP2IOP17HostCommunication($this,$i,$c) {
 $this = $this|0;
 $i = $i|0;
 $c = $c|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $i;
 $2 = $c;
 $3 = $0;
 $4 = $1;
 $5 = (($3) + 12|0);
 HEAP32[$5>>2] = $4;
 $6 = $2;
 $7 = (($3) + 16|0);
 HEAP32[$7>>2] = $6;
 STACKTOP = sp;return;
}
function __ZN23EmscriptenHostTransport7runTickEv($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 $2 = (($1) + 8|0);
 $3 = HEAP32[$2>>2]|0;
 $4 = ($3|0)!=(0|0);
 if (!($4)) {
  STACKTOP = sp;return;
 }
 $5 = (($1) + 8|0);
 $6 = HEAP32[$5>>2]|0;
 FUNCTION_TABLE_v[$6 & 255]();
 STACKTOP = sp;return;
}
function __ZN23EmscriptenHostTransport13sendToRuntimeEh($this,$b) {
 $this = $this|0;
 $b = $b|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $b;
 $2 = $0;
 $3 = (($2) + 16|0);
 $4 = HEAP32[$3>>2]|0;
 $5 = $1;
 __ZN17HostCommunication9parseByteEc($4,$5);
 STACKTOP = sp;return;
}
function __ZN23EmscriptenHostTransport11sendCommandEPKhh($this,$b,$len) {
 $this = $this|0;
 $b = $b|0;
 $len = $len|0;
 var $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0;
 var $27 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $d = 0, $i = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $b;
 $2 = $len;
 $3 = $0;
 $i = 0;
 while(1) {
  $4 = $i;
  $5 = $4&255;
  $6 = ($5>>>0)<(8);
  if (!($6)) {
   break;
  }
  $7 = $i;
  $8 = $7&255;
  $9 = $2;
  $10 = $9&255;
  $11 = ($8|0)<($10|0);
  if ($11) {
   $12 = $i;
   $13 = $12&255;
   $14 = $1;
   $15 = (($14) + ($13)|0);
   $16 = HEAP8[$15>>0]|0;
   $17 = $16&255;
   $19 = $17;
  } else {
   $19 = 0;
  }
  $18 = $19&255;
  $d = $18;
  $20 = (($3) + 4|0);
  $21 = HEAP32[$20>>2]|0;
  $22 = ($21|0)!=(0|0);
  if ($22) {
   $23 = (($3) + 4|0);
   $24 = HEAP32[$23>>2]|0;
   $25 = $d;
   FUNCTION_TABLE_vi[$24 & 255]($25);
  }
  $26 = $i;
  $27 = (($26) + 1)<<24>>24;
  $i = $27;
 }
 STACKTOP = sp;return;
}
function _emscripten_runtime_new() {
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $2 = (__Znwj(1108)|0);
 __THREW__ = 0;
 invoke_vi(195,($2|0));
 $3 = __THREW__; __THREW__ = 0;
 $4 = $3&1;
 if (!($4)) {
  STACKTOP = sp;return ($2|0);
 }
 $5 = ___cxa_find_matching_catch()|0;
 $6 = tempRet0;
 $0 = $5;
 $1 = $6;
 __ZdlPv($2);
 $7 = $0;
 $8 = $1;
 ___resumeException($7|0);
 // unreachable;
 return (0)|0;
}
function __ZN17EmscriptenRuntimeC2Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 var $9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $3 = $0;
 __ZN12EmscriptenIOC2Ev($3);
 $4 = (($3) + 36|0);
 __THREW__ = 0;
 invoke_vi(196,($4|0));
 $5 = __THREW__; __THREW__ = 0;
 $6 = $5&1;
 if (!($6)) {
  $7 = (($3) + 56|0);
  __THREW__ = 0;
  invoke_vii(197,($7|0),($3|0));
  $8 = __THREW__; __THREW__ = 0;
  $9 = $8&1;
  if (!($9)) {
   $10 = (($3) + 1076|0);
   __THREW__ = 0;
   invoke_vi(198,($10|0));
   $11 = __THREW__; __THREW__ = 0;
   $12 = $11&1;
   if (!($12)) {
    STACKTOP = sp;return;
   }
  }
 }
 $13 = ___cxa_find_matching_catch()|0;
 $14 = tempRet0;
 $1 = $13;
 $2 = $14;
 __THREW__ = 0;
 invoke_vi(126,($3|0));
 $15 = __THREW__; __THREW__ = 0;
 $16 = $15&1;
 if ($16) {
  $19 = ___cxa_find_matching_catch(0|0)|0;
  $20 = tempRet0;
  ___clang_call_terminate($19);
  // unreachable;
 }
 $17 = $1;
 $18 = $2;
 ___resumeException($17|0);
 // unreachable;
}
function _emscripten_runtime_free($self) {
 $self = $self|0;
 var $0 = 0, $1 = 0, $10 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $self;
 $3 = $0;
 $4 = ($3|0)==(0|0);
 if ($4) {
  STACKTOP = sp;return;
 }
 __THREW__ = 0;
 invoke_vi(199,($3|0));
 $5 = __THREW__; __THREW__ = 0;
 $6 = $5&1;
 if ($6) {
  $7 = ___cxa_find_matching_catch()|0;
  $8 = tempRet0;
  $1 = $7;
  $2 = $8;
  __ZdlPv($3);
  $9 = $1;
  $10 = $2;
  ___resumeException($9|0);
  // unreachable;
 } else {
  __ZdlPv($3);
  STACKTOP = sp;return;
 }
}
function __ZN17EmscriptenRuntimeD2Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 __ZN12EmscriptenIOD2Ev($1);
 STACKTOP = sp;return;
}
function _emscripten_runtime_send($self,$b) {
 $self = $self|0;
 $b = $b|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $self;
 $1 = $b;
 $2 = $0;
 $3 = (($2) + 36|0);
 $4 = $1;
 __ZN23EmscriptenHostTransport13sendToRuntimeEh($3,$4);
 STACKTOP = sp;return;
}
function _emscripten_runtime_setup($self,$sendFuncAddress,$pullFuncAddress) {
 $self = $self|0;
 $sendFuncAddress = $sendFuncAddress|0;
 $pullFuncAddress = $pullFuncAddress|0;
 var $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $self;
 $1 = $sendFuncAddress;
 $2 = $pullFuncAddress;
 $3 = $1;
 $4 = $3;
 $5 = $0;
 $6 = (($5) + 36|0);
 $7 = (($6) + 4|0);
 HEAP32[$7>>2] = $4;
 $8 = $2;
 $9 = $8;
 $10 = $0;
 $11 = (($10) + 36|0);
 $12 = (($11) + 8|0);
 HEAP32[$12>>2] = $9;
 $13 = $0;
 __ZN17EmscriptenRuntime5setupEv($13);
 STACKTOP = sp;return;
}
function __ZN17EmscriptenRuntime5setupEv($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 $2 = (($1) + 36|0);
 $3 = (($1) + 1076|0);
 __ZN23EmscriptenHostTransport5setupEP2IOP17HostCommunication($2,$1,$3);
 $4 = (($1) + 1076|0);
 $5 = (($1) + 56|0);
 $6 = (($1) + 36|0);
 __ZN17HostCommunication5setupEP7NetworkP13HostTransport($4,$5,$6);
 $7 = (($1) + 36|0);
 __ZN12EmscriptenIO5setupEP13HostTransport($1,$7);
 $8 = (($1) + 1076|0);
 __Z14loadFromEEPROMP17HostCommunication($8);
 STACKTOP = sp;return;
}
function _emscripten_runtime_run($self,$timeIncrementMs) {
 $self = $self|0;
 $timeIncrementMs = $timeIncrementMs|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $self;
 $1 = $timeIncrementMs;
 $2 = $0;
 $3 = $1;
 __ZN17EmscriptenRuntime12runIterationEi($2,$3);
 STACKTOP = sp;return;
}
function __ZN17EmscriptenRuntime12runIterationEi($this,$timeIncrementMs) {
 $this = $this|0;
 $timeIncrementMs = $timeIncrementMs|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $timeIncrementMs;
 $2 = $0;
 $3 = (($2) + 36|0);
 __ZN23EmscriptenHostTransport7runTickEv($3);
 $4 = (($2) + 56|0);
 __ZN7Network7runTickEv($4);
 $5 = $1;
 $6 = (($2) + 8|0);
 $7 = HEAP32[$6>>2]|0;
 $8 = (($7) + ($5))|0;
 HEAP32[$6>>2] = $8;
 STACKTOP = sp;return;
}
function __ZN10AnalogReadC2Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 __ZN21SingleOutputComponentC2Ev($1);
 $2 = (2536 + 8|0);
 HEAP32[$1>>2] = $2;
 STACKTOP = sp;return;
}
function __ZN10ArduinoUnoC2Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 $2 = (2480 + 8|0);
 HEAP32[$1>>2] = $2;
 $3 = (($1) + 24|0);
 __ZN9ComponentC2EP10Connectioni($1,$3,20);
 $4 = (2480 + 8|0);
 HEAP32[$1>>2] = $4;
 STACKTOP = sp;return;
}
function __ZN22PureFunctionComponent2I10BooleanAndbbEC2Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 $2 = (800 + 8|0);
 HEAP32[$1>>2] = $2;
 $3 = (($1) + 24|0);
 __ZN9ComponentC2EP10Connectioni($1,$3,1);
 $4 = (800 + 8|0);
 HEAP32[$1>>2] = $4;
 STACKTOP = sp;return;
}
function __ZN22PureFunctionComponent2I9BooleanOrbbEC2Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 $2 = (720 + 8|0);
 HEAP32[$1>>2] = $2;
 $3 = (($1) + 24|0);
 __ZN9ComponentC2EP10Connectioni($1,$3,1);
 $4 = (720 + 8|0);
 HEAP32[$1>>2] = $4;
 STACKTOP = sp;return;
}
function __ZN15BreakBeforeMakeC2Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 $2 = (2416 + 8|0);
 HEAP32[$1>>2] = $2;
 $3 = (($1) + 28|0);
 __ZN9ComponentC2EP10Connectioni($1,$3,2);
 $4 = (2416 + 8|0);
 HEAP32[$1>>2] = $4;
 $5 = (($1) + 24|0);
 HEAP32[$5>>2] = 0;
 STACKTOP = sp;return;
}
function __ZN9ConstrainC2Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 __ZN21SingleOutputComponentC2Ev($1);
 $2 = (2360 + 8|0);
 HEAP32[$1>>2] = $2;
 STACKTOP = sp;return;
}
function __ZN5CountC2Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 __ZN21SingleOutputComponentC2Ev($1);
 $2 = (2312 + 8|0);
 HEAP32[$1>>2] = $2;
 STACKTOP = sp;return;
}
function __ZN11DigitalReadC2Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 __ZN21SingleOutputComponentC2Ev($1);
 $2 = (2256 + 8|0);
 HEAP32[$1>>2] = $2;
 STACKTOP = sp;return;
}
function __ZN12DigitalWriteC2Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 __ZN21SingleOutputComponentC2Ev($1);
 $2 = (2200 + 8|0);
 HEAP32[$1>>2] = $2;
 STACKTOP = sp;return;
}
function __ZN7ForwardC2Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 __ZN21SingleOutputComponentC2Ev($1);
 $2 = (2144 + 8|0);
 HEAP32[$1>>2] = $2;
 STACKTOP = sp;return;
}
function __ZN4GateC2Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $3 = $0;
 __ZN21SingleOutputComponentC2Ev($3);
 $4 = (2096 + 8|0);
 HEAP32[$3>>2] = $4;
 $5 = (($3) + 32|0);
 HEAP8[$5>>0] = 0;
 $6 = (($3) + 36|0);
 __THREW__ = 0;
 invoke_vii(200,($6|0),0);
 $7 = __THREW__; __THREW__ = 0;
 $8 = $7&1;
 if (!($8)) {
  STACKTOP = sp;return;
 }
 $9 = ___cxa_find_matching_catch()|0;
 $10 = tempRet0;
 $1 = $9;
 $2 = $10;
 __THREW__ = 0;
 invoke_vi(55,($3|0));
 $11 = __THREW__; __THREW__ = 0;
 $12 = $11&1;
 if ($12) {
  $15 = ___cxa_find_matching_catch(0|0)|0;
  $16 = tempRet0;
  ___clang_call_terminate($15);
  // unreachable;
 }
 $13 = $1;
 $14 = $2;
 ___resumeException($13|0);
 // unreachable;
}
function __ZN15HysteresisLatchC2Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 __ZN21SingleOutputComponentC2Ev($1);
 $2 = (2032 + 8|0);
 HEAP32[$1>>2] = $2;
 STACKTOP = sp;return;
}
function __ZN13InvertBooleanC2Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 __ZN21SingleOutputComponentC2Ev($1);
 $2 = (1976 + 8|0);
 HEAP32[$1>>2] = $2;
 STACKTOP = sp;return;
}
function __ZN12LedMatrixMaxC2Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 __ZN21SingleOutputComponentC2Ev($1);
 $2 = (1616 + 8|0);
 HEAP32[$1>>2] = $2;
 $3 = (($1) + 32|0);
 HEAP32[$3>>2] = -1;
 $4 = (($1) + 36|0);
 HEAP32[$4>>2] = -1;
 $5 = (($1) + 40|0);
 HEAP32[$5>>2] = -1;
 $6 = (($1) + 44|0);
 HEAP8[$6>>0] = 0;
 STACKTOP = sp;return;
}
function __ZN9MapLinearC2Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 __ZN21SingleOutputComponentC2Ev($1);
 $2 = (1560 + 8|0);
 HEAP32[$1>>2] = $2;
 STACKTOP = sp;return;
}
function __ZN22PureFunctionComponent2I3MaxllEC2Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 $2 = (640 + 8|0);
 HEAP32[$1>>2] = $2;
 $3 = (($1) + 24|0);
 __ZN9ComponentC2EP10Connectioni($1,$3,1);
 $4 = (640 + 8|0);
 HEAP32[$1>>2] = $4;
 STACKTOP = sp;return;
}
function __ZN22PureFunctionComponent2I3MinllEC2Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 $2 = (560 + 8|0);
 HEAP32[$1>>2] = $2;
 $3 = (($1) + 24|0);
 __ZN9ComponentC2EP10Connectioni($1,$3,1);
 $4 = (560 + 8|0);
 HEAP32[$1>>2] = $4;
 STACKTOP = sp;return;
}
function __ZN10MonitorPinC2Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 __ZN21SingleOutputComponentC2Ev($1);
 $2 = (1504 + 8|0);
 HEAP32[$1>>2] = $2;
 STACKTOP = sp;return;
}
function __ZN22PureFunctionComponent2I12NumberEqualsllEC2Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 $2 = (472 + 8|0);
 HEAP32[$1>>2] = $2;
 $3 = (($1) + 24|0);
 __ZN9ComponentC2EP10Connectioni($1,$3,1);
 $4 = (472 + 8|0);
 HEAP32[$1>>2] = $4;
 STACKTOP = sp;return;
}
function __ZN8PwmWriteC2Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 __ZN21SingleOutputComponentC2Ev($1);
 $2 = (1448 + 8|0);
 HEAP32[$1>>2] = $2;
 STACKTOP = sp;return;
}
function __ZN17ReadCapacitivePinC2Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 __ZN14DummyComponentC2Ev($1);
 $2 = (1320 + 8|0);
 HEAP32[$1>>2] = $2;
 STACKTOP = sp;return;
}
function __ZN5RouteC2Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0;
 var $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $i = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $3 = sp;
 $0 = $this;
 $4 = $0;
 __ZN21SingleOutputComponentC2Ev($4);
 $5 = (1272 + 8|0);
 HEAP32[$4>>2] = $5;
 $6 = (($4) + 32|0);
 $7 = (($6) + 72|0);
 $8 = $6;
 while(1) {
  __THREW__ = 0;
  invoke_vi(201,($8|0));
  $9 = __THREW__; __THREW__ = 0;
  $10 = $9&1;
  if ($10) {
   break;
  }
  $11 = (($8) + 8|0);
  $12 = ($11|0)==($7|0);
  if ($12) {
   label = 4;
   break;
  } else {
   $8 = $11;
  }
 }
 L4: do {
  if ((label|0) == 4) {
   $13 = (($4) + 104|0);
   HEAP8[$13>>0] = 0;
   $i = 0;
   while(1) {
    $14 = $i;
    $15 = $14 << 24 >> 24;
    $16 = ($15|0)<(9);
    if (!($16)) {
     break;
    }
    $17 = $i;
    $18 = $17 << 24 >> 24;
    $19 = (($4) + 32|0);
    $20 = (($19) + ($18<<3)|0);
    __THREW__ = 0;
    invoke_vii(200,($3|0),0);
    $21 = __THREW__; __THREW__ = 0;
    $22 = $21&1;
    if ($22) {
     break L4;
    }
    ;HEAP32[$20+0>>2]=HEAP32[$3+0>>2]|0;HEAP32[$20+4>>2]=HEAP32[$3+4>>2]|0;
    $23 = $i;
    $24 = (($23) + 1)<<24>>24;
    $i = $24;
   }
   STACKTOP = sp;return;
  }
 } while(0);
 $25 = ___cxa_find_matching_catch()|0;
 $26 = tempRet0;
 $1 = $25;
 $2 = $26;
 __THREW__ = 0;
 invoke_vi(55,($4|0));
 $27 = __THREW__; __THREW__ = 0;
 $28 = $27&1;
 if ($28) {
  $31 = ___cxa_find_matching_catch(0|0)|0;
  $32 = tempRet0;
  ___clang_call_terminate($31);
  // unreachable;
 }
 $29 = $1;
 $30 = $2;
 ___resumeException($29|0);
 // unreachable;
}
function __ZN8SerialInC2Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 __ZN21SingleOutputComponentC2Ev($1);
 $2 = (1216 + 8|0);
 HEAP32[$1>>2] = $2;
 STACKTOP = sp;return;
}
function __ZN9SerialOutC2Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 __ZN21SingleOutputComponentC2Ev($1);
 $2 = (1160 + 8|0);
 HEAP32[$1>>2] = $2;
 STACKTOP = sp;return;
}
function __ZN5SplitC2Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 $2 = (1112 + 8|0);
 HEAP32[$1>>2] = $2;
 $3 = (($1) + 24|0);
 __ZN9ComponentC2EP10Connectioni($1,$3,9);
 $4 = (1112 + 8|0);
 HEAP32[$1>>2] = $4;
 STACKTOP = sp;return;
}
function __ZN5TimerC2Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 __ZN21SingleOutputComponentC2Ev($1);
 $2 = (1064 + 8|0);
 HEAP32[$1>>2] = $2;
 STACKTOP = sp;return;
}
function __ZN13ToggleBooleanC2Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 __ZN21SingleOutputComponentC2Ev($1);
 $2 = (1008 + 8|0);
 HEAP32[$1>>2] = $2;
 STACKTOP = sp;return;
}
function __ZN9BoolToIntC2Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 __ZN21SingleOutputComponentC2Ev($1);
 $2 = (888 + 8|0);
 HEAP32[$1>>2] = $2;
 STACKTOP = sp;return;
}
function __ZN8SubGraphD2Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 __ZN9ComponentD2Ev($1);
 STACKTOP = sp;return;
}
function __ZN8SubGraphD0Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $3 = $0;
 __THREW__ = 0;
 invoke_vi(31,($3|0));
 $4 = __THREW__; __THREW__ = 0;
 $5 = $4&1;
 if (!($5)) {
  __ZdlPv($3);
  STACKTOP = sp;return;
 }
 $6 = ___cxa_find_matching_catch()|0;
 $7 = tempRet0;
 $1 = $6;
 $2 = $7;
 __ZdlPv($3);
 $8 = $1;
 $9 = $2;
 ___resumeException($8|0);
 // unreachable;
}
function __ZN22PureFunctionComponent2I12NumberEqualsllED2Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 __ZN9ComponentD2Ev($1);
 STACKTOP = sp;return;
}
function __ZN22PureFunctionComponent2I12NumberEqualsllED0Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $3 = $0;
 __THREW__ = 0;
 invoke_vi(37,($3|0));
 $4 = __THREW__; __THREW__ = 0;
 $5 = $4&1;
 if (!($5)) {
  __ZdlPv($3);
  STACKTOP = sp;return;
 }
 $6 = ___cxa_find_matching_catch()|0;
 $7 = tempRet0;
 $1 = $6;
 $2 = $7;
 __ZdlPv($3);
 $8 = $1;
 $9 = $2;
 ___resumeException($8|0);
 // unreachable;
}
function __ZN22PureFunctionComponent2I12NumberEqualsllE7processE6Packeta($this,$in,$port) {
 $this = $this|0;
 $in = $in|0;
 $port = $port|0;
 var $$byval_copy = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 var $8 = 0, $9 = 0, $ret = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $$byval_copy = sp + 24|0;
 $ret = sp + 8|0;
 $2 = sp;
 $0 = $this;
 $1 = $port;
 $3 = $0;
 $4 = (__ZNK6Packet6isDataEv($in)|0);
 if (!($4)) {
  STACKTOP = sp;return;
 }
 $5 = $1;
 $6 = $5 << 24 >> 24;
 $7 = ($6|0)==(0);
 if ($7) {
  $8 = (__ZN6PacketcvlEv($in)|0);
  $9 = (($3) + 36|0);
  HEAP32[$9>>2] = $8;
 } else {
  $10 = $1;
  $11 = $10 << 24 >> 24;
  $12 = ($11|0)==(1);
  if ($12) {
   $13 = (__ZN6PacketcvlEv($in)|0);
   $14 = (($3) + 40|0);
   HEAP32[$14>>2] = $13;
  }
 }
 $15 = (($3) + 32|0);
 $16 = (($3) + 36|0);
 $17 = HEAP32[$16>>2]|0;
 $18 = (($3) + 40|0);
 $19 = HEAP32[$18>>2]|0;
 __ZN12NumberEqualsclEll($ret,$15,$17,$19);
 $20 = (__ZNK6Packet7isValidEv($ret)|0);
 if ($20) {
  ;HEAP32[$2+0>>2]=HEAP32[$ret+0>>2]|0;HEAP32[$2+4>>2]=HEAP32[$ret+4>>2]|0;
  ;HEAP32[$$byval_copy+0>>2]=HEAP32[$2+0>>2]|0;HEAP32[$$byval_copy+4>>2]=HEAP32[$2+4>>2]|0;
  __ZN9Component4sendE6Packeta($3,$$byval_copy,0);
 }
 STACKTOP = sp;return;
}
function __ZN6PacketcvlEv($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 $2 = HEAP32[$1>>2]|0;
 STACKTOP = sp;return ($2|0);
}
function __ZN12NumberEqualsclEll($agg$result,$this,$a,$b) {
 $agg$result = $agg$result|0;
 $this = $this|0;
 $a = $a|0;
 $b = $b|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $a;
 $2 = $b;
 $3 = $1;
 $4 = $2;
 $5 = ($3|0)==($4|0);
 __ZN6PacketC2Eb($agg$result,$5);
 STACKTOP = sp;return;
}
function __ZN22PureFunctionComponent2I3MinllED2Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 __ZN9ComponentD2Ev($1);
 STACKTOP = sp;return;
}
function __ZN22PureFunctionComponent2I3MinllED0Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $3 = $0;
 __THREW__ = 0;
 invoke_vi(40,($3|0));
 $4 = __THREW__; __THREW__ = 0;
 $5 = $4&1;
 if (!($5)) {
  __ZdlPv($3);
  STACKTOP = sp;return;
 }
 $6 = ___cxa_find_matching_catch()|0;
 $7 = tempRet0;
 $1 = $6;
 $2 = $7;
 __ZdlPv($3);
 $8 = $1;
 $9 = $2;
 ___resumeException($8|0);
 // unreachable;
}
function __ZN22PureFunctionComponent2I3MinllE7processE6Packeta($this,$in,$port) {
 $this = $this|0;
 $in = $in|0;
 $port = $port|0;
 var $$byval_copy = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 var $8 = 0, $9 = 0, $ret = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $$byval_copy = sp + 24|0;
 $ret = sp + 8|0;
 $2 = sp;
 $0 = $this;
 $1 = $port;
 $3 = $0;
 $4 = (__ZNK6Packet6isDataEv($in)|0);
 if (!($4)) {
  STACKTOP = sp;return;
 }
 $5 = $1;
 $6 = $5 << 24 >> 24;
 $7 = ($6|0)==(0);
 if ($7) {
  $8 = (__ZN6PacketcvlEv($in)|0);
  $9 = (($3) + 36|0);
  HEAP32[$9>>2] = $8;
 } else {
  $10 = $1;
  $11 = $10 << 24 >> 24;
  $12 = ($11|0)==(1);
  if ($12) {
   $13 = (__ZN6PacketcvlEv($in)|0);
   $14 = (($3) + 40|0);
   HEAP32[$14>>2] = $13;
  }
 }
 $15 = (($3) + 32|0);
 $16 = (($3) + 36|0);
 $17 = HEAP32[$16>>2]|0;
 $18 = (($3) + 40|0);
 $19 = HEAP32[$18>>2]|0;
 __ZN3MinclEll($ret,$15,$17,$19);
 $20 = (__ZNK6Packet7isValidEv($ret)|0);
 if ($20) {
  ;HEAP32[$2+0>>2]=HEAP32[$ret+0>>2]|0;HEAP32[$2+4>>2]=HEAP32[$ret+4>>2]|0;
  ;HEAP32[$$byval_copy+0>>2]=HEAP32[$2+0>>2]|0;HEAP32[$$byval_copy+4>>2]=HEAP32[$2+4>>2]|0;
  __ZN9Component4sendE6Packeta($3,$$byval_copy,0);
 }
 STACKTOP = sp;return;
}
function __ZN3MinclEll($agg$result,$this,$input,$threshold) {
 $agg$result = $agg$result|0;
 $this = $this|0;
 $input = $input|0;
 $threshold = $threshold|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $input;
 $2 = $threshold;
 $3 = $1;
 $4 = $2;
 $5 = ($3|0)>=($4|0);
 if ($5) {
  $6 = $2;
  __ZN6PacketC2El($agg$result,$6);
  STACKTOP = sp;return;
 } else {
  $7 = $1;
  __ZN6PacketC2El($agg$result,$7);
  STACKTOP = sp;return;
 }
}
function __ZN22PureFunctionComponent2I3MaxllED2Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 __ZN9ComponentD2Ev($1);
 STACKTOP = sp;return;
}
function __ZN22PureFunctionComponent2I3MaxllED0Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $3 = $0;
 __THREW__ = 0;
 invoke_vi(43,($3|0));
 $4 = __THREW__; __THREW__ = 0;
 $5 = $4&1;
 if (!($5)) {
  __ZdlPv($3);
  STACKTOP = sp;return;
 }
 $6 = ___cxa_find_matching_catch()|0;
 $7 = tempRet0;
 $1 = $6;
 $2 = $7;
 __ZdlPv($3);
 $8 = $1;
 $9 = $2;
 ___resumeException($8|0);
 // unreachable;
}
function __ZN22PureFunctionComponent2I3MaxllE7processE6Packeta($this,$in,$port) {
 $this = $this|0;
 $in = $in|0;
 $port = $port|0;
 var $$byval_copy = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 var $8 = 0, $9 = 0, $ret = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $$byval_copy = sp + 24|0;
 $ret = sp + 8|0;
 $2 = sp;
 $0 = $this;
 $1 = $port;
 $3 = $0;
 $4 = (__ZNK6Packet6isDataEv($in)|0);
 if (!($4)) {
  STACKTOP = sp;return;
 }
 $5 = $1;
 $6 = $5 << 24 >> 24;
 $7 = ($6|0)==(0);
 if ($7) {
  $8 = (__ZN6PacketcvlEv($in)|0);
  $9 = (($3) + 36|0);
  HEAP32[$9>>2] = $8;
 } else {
  $10 = $1;
  $11 = $10 << 24 >> 24;
  $12 = ($11|0)==(1);
  if ($12) {
   $13 = (__ZN6PacketcvlEv($in)|0);
   $14 = (($3) + 40|0);
   HEAP32[$14>>2] = $13;
  }
 }
 $15 = (($3) + 32|0);
 $16 = (($3) + 36|0);
 $17 = HEAP32[$16>>2]|0;
 $18 = (($3) + 40|0);
 $19 = HEAP32[$18>>2]|0;
 __ZN3MaxclEll($ret,$15,$17,$19);
 $20 = (__ZNK6Packet7isValidEv($ret)|0);
 if ($20) {
  ;HEAP32[$2+0>>2]=HEAP32[$ret+0>>2]|0;HEAP32[$2+4>>2]=HEAP32[$ret+4>>2]|0;
  ;HEAP32[$$byval_copy+0>>2]=HEAP32[$2+0>>2]|0;HEAP32[$$byval_copy+4>>2]=HEAP32[$2+4>>2]|0;
  __ZN9Component4sendE6Packeta($3,$$byval_copy,0);
 }
 STACKTOP = sp;return;
}
function __ZN3MaxclEll($agg$result,$this,$input,$threshold) {
 $agg$result = $agg$result|0;
 $this = $this|0;
 $input = $input|0;
 $threshold = $threshold|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $input;
 $2 = $threshold;
 $3 = $1;
 $4 = $2;
 $5 = ($3|0)<=($4|0);
 if ($5) {
  $6 = $2;
  __ZN6PacketC2El($agg$result,$6);
  STACKTOP = sp;return;
 } else {
  $7 = $1;
  __ZN6PacketC2El($agg$result,$7);
  STACKTOP = sp;return;
 }
}
function __ZN22PureFunctionComponent2I9BooleanOrbbED2Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 __ZN9ComponentD2Ev($1);
 STACKTOP = sp;return;
}
function __ZN22PureFunctionComponent2I9BooleanOrbbED0Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $3 = $0;
 __THREW__ = 0;
 invoke_vi(46,($3|0));
 $4 = __THREW__; __THREW__ = 0;
 $5 = $4&1;
 if (!($5)) {
  __ZdlPv($3);
  STACKTOP = sp;return;
 }
 $6 = ___cxa_find_matching_catch()|0;
 $7 = tempRet0;
 $1 = $6;
 $2 = $7;
 __ZdlPv($3);
 $8 = $1;
 $9 = $2;
 ___resumeException($8|0);
 // unreachable;
}
function __ZN22PureFunctionComponent2I9BooleanOrbbE7processE6Packeta($this,$in,$port) {
 $this = $this|0;
 $in = $in|0;
 $port = $port|0;
 var $$byval_copy = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $3 = 0;
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $ret = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $$byval_copy = sp + 24|0;
 $ret = sp + 8|0;
 $2 = sp;
 $0 = $this;
 $1 = $port;
 $3 = $0;
 $4 = (__ZNK6Packet6isDataEv($in)|0);
 if (!($4)) {
  STACKTOP = sp;return;
 }
 $5 = $1;
 $6 = $5 << 24 >> 24;
 $7 = ($6|0)==(0);
 if ($7) {
  $8 = (__ZN6PacketcvbEv($in)|0);
  $9 = (($3) + 33|0);
  $10 = $8&1;
  HEAP8[$9>>0] = $10;
 } else {
  $11 = $1;
  $12 = $11 << 24 >> 24;
  $13 = ($12|0)==(1);
  if ($13) {
   $14 = (__ZN6PacketcvbEv($in)|0);
   $15 = (($3) + 34|0);
   $16 = $14&1;
   HEAP8[$15>>0] = $16;
  }
 }
 $17 = (($3) + 32|0);
 $18 = (($3) + 33|0);
 $19 = HEAP8[$18>>0]|0;
 $20 = $19&1;
 $21 = (($3) + 34|0);
 $22 = HEAP8[$21>>0]|0;
 $23 = $22&1;
 __ZN9BooleanOrclEbb($ret,$17,$20,$23);
 $24 = (__ZNK6Packet7isValidEv($ret)|0);
 if ($24) {
  ;HEAP32[$2+0>>2]=HEAP32[$ret+0>>2]|0;HEAP32[$2+4>>2]=HEAP32[$ret+4>>2]|0;
  ;HEAP32[$$byval_copy+0>>2]=HEAP32[$2+0>>2]|0;HEAP32[$$byval_copy+4>>2]=HEAP32[$2+4>>2]|0;
  __ZN9Component4sendE6Packeta($3,$$byval_copy,0);
 }
 STACKTOP = sp;return;
}
function __ZN6PacketcvbEv($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 $2 = HEAP8[$1>>0]|0;
 $3 = $2&1;
 STACKTOP = sp;return ($3|0);
}
function __ZN9BooleanOrclEbb($agg$result,$this,$a,$b) {
 $agg$result = $agg$result|0;
 $this = $this|0;
 $a = $a|0;
 $b = $b|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $3 = $a&1;
 $1 = $3;
 $4 = $b&1;
 $2 = $4;
 $5 = $1;
 $6 = $5&1;
 if ($6) {
  $9 = 1;
 } else {
  $7 = $2;
  $8 = $7&1;
  $9 = $8;
 }
 __ZN6PacketC2Eb($agg$result,$9);
 STACKTOP = sp;return;
}
function __ZN22PureFunctionComponent2I10BooleanAndbbED2Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 __ZN9ComponentD2Ev($1);
 STACKTOP = sp;return;
}
function __ZN22PureFunctionComponent2I10BooleanAndbbED0Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $3 = $0;
 __THREW__ = 0;
 invoke_vi(49,($3|0));
 $4 = __THREW__; __THREW__ = 0;
 $5 = $4&1;
 if (!($5)) {
  __ZdlPv($3);
  STACKTOP = sp;return;
 }
 $6 = ___cxa_find_matching_catch()|0;
 $7 = tempRet0;
 $1 = $6;
 $2 = $7;
 __ZdlPv($3);
 $8 = $1;
 $9 = $2;
 ___resumeException($8|0);
 // unreachable;
}
function __ZN22PureFunctionComponent2I10BooleanAndbbE7processE6Packeta($this,$in,$port) {
 $this = $this|0;
 $in = $in|0;
 $port = $port|0;
 var $$byval_copy = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $3 = 0;
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $ret = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $$byval_copy = sp + 24|0;
 $ret = sp + 8|0;
 $2 = sp;
 $0 = $this;
 $1 = $port;
 $3 = $0;
 $4 = (__ZNK6Packet6isDataEv($in)|0);
 if (!($4)) {
  STACKTOP = sp;return;
 }
 $5 = $1;
 $6 = $5 << 24 >> 24;
 $7 = ($6|0)==(0);
 if ($7) {
  $8 = (__ZN6PacketcvbEv($in)|0);
  $9 = (($3) + 33|0);
  $10 = $8&1;
  HEAP8[$9>>0] = $10;
 } else {
  $11 = $1;
  $12 = $11 << 24 >> 24;
  $13 = ($12|0)==(1);
  if ($13) {
   $14 = (__ZN6PacketcvbEv($in)|0);
   $15 = (($3) + 34|0);
   $16 = $14&1;
   HEAP8[$15>>0] = $16;
  }
 }
 $17 = (($3) + 32|0);
 $18 = (($3) + 33|0);
 $19 = HEAP8[$18>>0]|0;
 $20 = $19&1;
 $21 = (($3) + 34|0);
 $22 = HEAP8[$21>>0]|0;
 $23 = $22&1;
 __ZN10BooleanAndclEbb($ret,$17,$20,$23);
 $24 = (__ZNK6Packet7isValidEv($ret)|0);
 if ($24) {
  ;HEAP32[$2+0>>2]=HEAP32[$ret+0>>2]|0;HEAP32[$2+4>>2]=HEAP32[$ret+4>>2]|0;
  ;HEAP32[$$byval_copy+0>>2]=HEAP32[$2+0>>2]|0;HEAP32[$$byval_copy+4>>2]=HEAP32[$2+4>>2]|0;
  __ZN9Component4sendE6Packeta($3,$$byval_copy,0);
 }
 STACKTOP = sp;return;
}
function __ZN10BooleanAndclEbb($agg$result,$this,$a,$b) {
 $agg$result = $agg$result|0;
 $this = $this|0;
 $a = $a|0;
 $b = $b|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $3 = $a&1;
 $1 = $3;
 $4 = $b&1;
 $2 = $4;
 $5 = $1;
 $6 = $5&1;
 if ($6) {
  $7 = $2;
  $8 = $7&1;
  $9 = $8;
 } else {
  $9 = 0;
 }
 __ZN6PacketC2Eb($agg$result,$9);
 STACKTOP = sp;return;
}
function __ZN21SingleOutputComponentC2Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 $2 = (984 + 8|0);
 HEAP32[$1>>2] = $2;
 $3 = (($1) + 24|0);
 __ZN9ComponentC2EP10Connectioni($1,$3,1);
 $4 = (984 + 8|0);
 HEAP32[$1>>2] = $4;
 STACKTOP = sp;return;
}
function __ZN9BoolToIntD2Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 __ZN21SingleOutputComponentD2Ev($1);
 STACKTOP = sp;return;
}
function __ZN9BoolToIntD0Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $3 = $0;
 __THREW__ = 0;
 invoke_vi(52,($3|0));
 $4 = __THREW__; __THREW__ = 0;
 $5 = $4&1;
 if (!($5)) {
  __ZdlPv($3);
  STACKTOP = sp;return;
 }
 $6 = ___cxa_find_matching_catch()|0;
 $7 = tempRet0;
 $1 = $6;
 $2 = $7;
 __ZdlPv($3);
 $8 = $1;
 $9 = $2;
 ___resumeException($8|0);
 // unreachable;
}
function __ZN9BoolToInt7processE6Packeta($this,$in,$port) {
 $this = $this|0;
 $in = $in|0;
 $port = $port|0;
 var $$byval_copy = 0, $$byval_copy1 = 0, $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $$byval_copy1 = sp + 32|0;
 $$byval_copy = sp + 24|0;
 $2 = sp + 8|0;
 $3 = sp + 40|0;
 $4 = sp;
 $0 = $this;
 $1 = $port;
 $5 = $0;
 $6 = (__ZNK6Packet6isBoolEv($in)|0);
 if (!($6)) {
  STACKTOP = sp;return;
 }
 ;HEAP32[$4+0>>2]=HEAP32[$in+0>>2]|0;HEAP32[$4+4>>2]=HEAP32[$in+4>>2]|0;
 ;HEAP32[$$byval_copy+0>>2]=HEAP32[$4+0>>2]|0;HEAP32[$$byval_copy+4>>2]=HEAP32[$4+4>>2]|0;
 __ZN10BoolToIntFclE6Packet($2,$3,$$byval_copy);
 ;HEAP32[$$byval_copy1+0>>2]=HEAP32[$2+0>>2]|0;HEAP32[$$byval_copy1+4>>2]=HEAP32[$2+4>>2]|0;
 __ZN9Component4sendE6Packeta($5,$$byval_copy1,0);
 STACKTOP = sp;return;
}
function __ZN10BoolToIntFclE6Packet($agg$result,$this,$in) {
 $agg$result = $agg$result|0;
 $this = $this|0;
 $in = $in|0;
 var $0 = 0, $1 = 0, $2 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = (__ZNK6Packet6asBoolEv($in)|0);
 $2 = $1 ? 1 : 0;
 __ZN6PacketC2El($agg$result,$2);
 STACKTOP = sp;return;
}
function __ZN21SingleOutputComponentD2Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 __ZN9ComponentD2Ev($1);
 STACKTOP = sp;return;
}
function __ZN21SingleOutputComponentD0Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $3 = $0;
 __THREW__ = 0;
 invoke_vi(55,($3|0));
 $4 = __THREW__; __THREW__ = 0;
 $5 = $4&1;
 if (!($5)) {
  __ZdlPv($3);
  STACKTOP = sp;return;
 }
 $6 = ___cxa_find_matching_catch()|0;
 $7 = tempRet0;
 $1 = $6;
 $2 = $7;
 __ZdlPv($3);
 $8 = $1;
 $9 = $2;
 ___resumeException($8|0);
 // unreachable;
}
function __ZN13ToggleBooleanD2Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 __ZN21SingleOutputComponentD2Ev($1);
 STACKTOP = sp;return;
}
function __ZN13ToggleBooleanD0Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $3 = $0;
 __THREW__ = 0;
 invoke_vi(58,($3|0));
 $4 = __THREW__; __THREW__ = 0;
 $5 = $4&1;
 if (!($5)) {
  __ZdlPv($3);
  STACKTOP = sp;return;
 }
 $6 = ___cxa_find_matching_catch()|0;
 $7 = tempRet0;
 $1 = $6;
 $2 = $7;
 __ZdlPv($3);
 $8 = $1;
 $9 = $2;
 ___resumeException($8|0);
 // unreachable;
}
function __ZN13ToggleBoolean7processE6Packeta($this,$in,$port) {
 $this = $this|0;
 $in = $in|0;
 $port = $port|0;
 var $$byval_copy = 0, $$byval_copy1 = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0;
 var $25 = 0, $26 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $$byval_copy1 = sp + 32|0;
 $$byval_copy = sp + 24|0;
 $2 = sp + 8|0;
 $3 = sp;
 $0 = $this;
 $1 = $port;
 $4 = $0;
 $5 = (__ZNK6Packet7isSetupEv($in)|0);
 if ($5) {
  $6 = (($4) + 32|0);
  HEAP8[$6>>0] = 0;
  STACKTOP = sp;return;
 }
 $7 = $1;
 $8 = $7 << 24 >> 24;
 $9 = ($8|0)==(0);
 if ($9) {
  $10 = (__ZNK6Packet6isDataEv($in)|0);
  if ($10) {
   $11 = (($4) + 32|0);
   $12 = HEAP8[$11>>0]|0;
   $13 = $12&1;
   $14 = $13 ^ 1;
   $15 = (($4) + 32|0);
   $16 = $14&1;
   HEAP8[$15>>0] = $16;
   $17 = (($4) + 32|0);
   $18 = HEAP8[$17>>0]|0;
   $19 = $18&1;
   __ZN6PacketC2Eb($2,$19);
   ;HEAP32[$$byval_copy+0>>2]=HEAP32[$2+0>>2]|0;HEAP32[$$byval_copy+4>>2]=HEAP32[$2+4>>2]|0;
   __ZN9Component4sendE6Packeta($4,$$byval_copy,0);
  } else {
   label = 6;
  }
 } else {
  label = 6;
 }
 if ((label|0) == 6) {
  $20 = $1;
  $21 = $20 << 24 >> 24;
  $22 = ($21|0)==(1);
  if ($22) {
   $23 = (($4) + 32|0);
   HEAP8[$23>>0] = 0;
   $24 = (($4) + 32|0);
   $25 = HEAP8[$24>>0]|0;
   $26 = $25&1;
   __ZN6PacketC2Eb($3,$26);
   ;HEAP32[$$byval_copy1+0>>2]=HEAP32[$3+0>>2]|0;HEAP32[$$byval_copy1+4>>2]=HEAP32[$3+4>>2]|0;
   __ZN9Component4sendE6Packeta($4,$$byval_copy1,0);
  }
 }
 STACKTOP = sp;return;
}
function __ZNK6Packet7isSetupEv($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 $2 = (($1) + 4|0);
 $3 = HEAP32[$2>>2]|0;
 $4 = ($3|0)==(1);
 STACKTOP = sp;return ($4|0);
}
function __ZN5TimerD2Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 __ZN21SingleOutputComponentD2Ev($1);
 STACKTOP = sp;return;
}
function __ZN5TimerD0Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $3 = $0;
 __THREW__ = 0;
 invoke_vi(61,($3|0));
 $4 = __THREW__; __THREW__ = 0;
 $5 = $4&1;
 if (!($5)) {
  __ZdlPv($3);
  STACKTOP = sp;return;
 }
 $6 = ___cxa_find_matching_catch()|0;
 $7 = tempRet0;
 $1 = $6;
 $2 = $7;
 __ZdlPv($3);
 $8 = $1;
 $9 = $2;
 ___resumeException($8|0);
 // unreachable;
}
function __ZN5Timer7processE6Packeta($this,$in,$port) {
 $this = $this|0;
 $in = $in|0;
 $port = $port|0;
 var $$byval_copy = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0;
 var $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 var $9 = 0, $currentMillis = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $$byval_copy = sp + 16|0;
 $2 = sp;
 $0 = $this;
 $1 = $port;
 $3 = $0;
 $4 = (__ZNK6Packet7isSetupEv($in)|0);
 if ($4) {
  $5 = (($3) + 32|0);
  HEAP32[$5>>2] = 0;
  $6 = (($3) + 36|0);
  HEAP32[$6>>2] = 1000;
  STACKTOP = sp;return;
 }
 $7 = (__ZNK6Packet6isTickEv($in)|0);
 if ($7) {
  $8 = (($3) + 4|0);
  $9 = HEAP32[$8>>2]|0;
  $10 = HEAP32[$9>>2]|0;
  $11 = (($10) + 52|0);
  $12 = HEAP32[$11>>2]|0;
  $13 = (FUNCTION_TABLE_ii[$12 & 255]($9)|0);
  $currentMillis = $13;
  $14 = $currentMillis;
  $15 = (($3) + 32|0);
  $16 = HEAP32[$15>>2]|0;
  $17 = (($14) - ($16))|0;
  $18 = (($3) + 36|0);
  $19 = HEAP32[$18>>2]|0;
  $20 = ($17>>>0)>=($19>>>0);
  if ($20) {
   $21 = $currentMillis;
   $22 = (($3) + 32|0);
   HEAP32[$22>>2] = $21;
   __ZN6PacketC2Ev($2);
   ;HEAP32[$$byval_copy+0>>2]=HEAP32[$2+0>>2]|0;HEAP32[$$byval_copy+4>>2]=HEAP32[$2+4>>2]|0;
   __ZN9Component4sendE6Packeta($3,$$byval_copy,0);
  }
 } else {
  $23 = $1;
  $24 = $23 << 24 >> 24;
  $25 = ($24|0)==(0);
  if ($25) {
   $26 = (__ZNK6Packet6isDataEv($in)|0);
   if ($26) {
    $27 = (__ZNK6Packet9asIntegerEv($in)|0);
    $28 = (($3) + 36|0);
    HEAP32[$28>>2] = $27;
   } else {
    label = 10;
   }
  } else {
   label = 10;
  }
  if ((label|0) == 10) {
   $29 = $1;
   $30 = $29 << 24 >> 24;
   $31 = ($30|0)==(1);
   if ($31) {
    $32 = (__ZNK6Packet6isDataEv($in)|0);
    if ($32) {
     $33 = (($3) + 4|0);
     $34 = HEAP32[$33>>2]|0;
     $35 = HEAP32[$34>>2]|0;
     $36 = (($35) + 52|0);
     $37 = HEAP32[$36>>2]|0;
     $38 = (FUNCTION_TABLE_ii[$37 & 255]($34)|0);
     $39 = (($3) + 32|0);
     HEAP32[$39>>2] = $38;
    }
   }
  }
 }
 STACKTOP = sp;return;
}
function __ZNK6Packet6isTickEv($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 $2 = (($1) + 4|0);
 $3 = HEAP32[$2>>2]|0;
 $4 = ($3|0)==(2);
 STACKTOP = sp;return ($4|0);
}
function __ZN5SplitD2Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 __ZN9ComponentD2Ev($1);
 STACKTOP = sp;return;
}
function __ZN5SplitD0Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $3 = $0;
 __THREW__ = 0;
 invoke_vi(64,($3|0));
 $4 = __THREW__; __THREW__ = 0;
 $5 = $4&1;
 if (!($5)) {
  __ZdlPv($3);
  STACKTOP = sp;return;
 }
 $6 = ___cxa_find_matching_catch()|0;
 $7 = tempRet0;
 $1 = $6;
 $2 = $7;
 __ZdlPv($3);
 $8 = $1;
 $9 = $2;
 ___resumeException($8|0);
 // unreachable;
}
function __ZN5Split7processE6Packeta($this,$in,$inport) {
 $this = $this|0;
 $in = $in|0;
 $inport = $inport|0;
 var $$byval_copy = 0, $0 = 0, $1 = 0, $10 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $first = 0, $last = 0, $port = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $$byval_copy = sp + 16|0;
 $2 = sp;
 $0 = $this;
 $1 = $inport;
 $3 = $0;
 $4 = (__ZNK6Packet6isDataEv($in)|0);
 if (!($4)) {
  STACKTOP = sp;return;
 }
 $first = 0;
 $last = 8;
 $port = 0;
 while(1) {
  $5 = $port;
  $6 = $5 << 24 >> 24;
  $7 = ($6|0)<=(8);
  if (!($7)) {
   break;
  }
  ;HEAP32[$2+0>>2]=HEAP32[$in+0>>2]|0;HEAP32[$2+4>>2]=HEAP32[$in+4>>2]|0;
  $8 = $port;
  ;HEAP32[$$byval_copy+0>>2]=HEAP32[$2+0>>2]|0;HEAP32[$$byval_copy+4>>2]=HEAP32[$2+4>>2]|0;
  __ZN9Component4sendE6Packeta($3,$$byval_copy,$8);
  $9 = $port;
  $10 = (($9) + 1)<<24>>24;
  $port = $10;
 }
 STACKTOP = sp;return;
}
function __ZN9SerialOutD2Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 __ZN21SingleOutputComponentD2Ev($1);
 STACKTOP = sp;return;
}
function __ZN9SerialOutD0Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $3 = $0;
 __THREW__ = 0;
 invoke_vi(67,($3|0));
 $4 = __THREW__; __THREW__ = 0;
 $5 = $4&1;
 if (!($5)) {
  __ZdlPv($3);
  STACKTOP = sp;return;
 }
 $6 = ___cxa_find_matching_catch()|0;
 $7 = tempRet0;
 $1 = $6;
 $2 = $7;
 __ZdlPv($3);
 $8 = $1;
 $9 = $2;
 ___resumeException($8|0);
 // unreachable;
}
function __ZN9SerialOut7processE6Packeta($this,$in,$port) {
 $this = $this|0;
 $in = $in|0;
 $port = $port|0;
 var $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $serialDevice = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $port;
 $2 = $0;
 $serialDevice = -1;
 $3 = (__ZNK6Packet7isSetupEv($in)|0);
 if ($3) {
  $4 = (($2) + 4|0);
  $5 = HEAP32[$4>>2]|0;
  $6 = HEAP32[$5>>2]|0;
  $7 = (($6) + 12|0);
  $8 = HEAP32[$7>>2]|0;
  FUNCTION_TABLE_viii[$8 & 255]($5,-1,9600);
  STACKTOP = sp;return;
 }
 $9 = (__ZNK6Packet6isByteEv($in)|0);
 if ($9) {
  $10 = (($2) + 4|0);
  $11 = HEAP32[$10>>2]|0;
  $12 = HEAP32[$11>>2]|0;
  $13 = (($12) + 24|0);
  $14 = HEAP32[$13>>2]|0;
  $15 = (__ZNK6Packet6asByteEv($in)|0);
  FUNCTION_TABLE_viii[$14 & 255]($11,-1,$15);
 }
 STACKTOP = sp;return;
}
function __ZNK6Packet6isByteEv($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 $2 = (($1) + 4|0);
 $3 = HEAP32[$2>>2]|0;
 $4 = ($3|0)==(4);
 STACKTOP = sp;return ($4|0);
}
function __ZN8SerialInD2Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 __ZN21SingleOutputComponentD2Ev($1);
 STACKTOP = sp;return;
}
function __ZN8SerialInD0Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $3 = $0;
 __THREW__ = 0;
 invoke_vi(70,($3|0));
 $4 = __THREW__; __THREW__ = 0;
 $5 = $4&1;
 if (!($5)) {
  __ZdlPv($3);
  STACKTOP = sp;return;
 }
 $6 = ___cxa_find_matching_catch()|0;
 $7 = tempRet0;
 $1 = $6;
 $2 = $7;
 __ZdlPv($3);
 $8 = $1;
 $9 = $2;
 ___resumeException($8|0);
 // unreachable;
}
function __ZN8SerialIn7processE6Packeta($this,$in,$port) {
 $this = $this|0;
 $in = $in|0;
 $port = $port|0;
 var $$byval_copy = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $3 = 0;
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $c = 0, $serialDevice = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $$byval_copy = sp + 16|0;
 $2 = sp;
 $0 = $this;
 $1 = $port;
 $3 = $0;
 $serialDevice = -1;
 $4 = (__ZNK6Packet7isSetupEv($in)|0);
 if ($4) {
  $5 = (($3) + 4|0);
  $6 = HEAP32[$5>>2]|0;
  $7 = HEAP32[$6>>2]|0;
  $8 = (($7) + 12|0);
  $9 = HEAP32[$8>>2]|0;
  FUNCTION_TABLE_viii[$9 & 255]($6,-1,9600);
  STACKTOP = sp;return;
 }
 $10 = (__ZNK6Packet6isTickEv($in)|0);
 if ($10) {
  $11 = (($3) + 4|0);
  $12 = HEAP32[$11>>2]|0;
  $13 = HEAP32[$12>>2]|0;
  $14 = (($13) + 16|0);
  $15 = HEAP32[$14>>2]|0;
  $16 = (FUNCTION_TABLE_iii[$15 & 255]($12,-1)|0);
  $17 = ($16|0)>(0);
  if ($17) {
   $18 = (($3) + 4|0);
   $19 = HEAP32[$18>>2]|0;
   $20 = HEAP32[$19>>2]|0;
   $21 = (($20) + 20|0);
   $22 = HEAP32[$21>>2]|0;
   $23 = (FUNCTION_TABLE_iii[$22 & 255]($19,-1)|0);
   $c = $23;
   $24 = $c;
   __ZN6PacketC2Eh($2,$24);
   ;HEAP32[$$byval_copy+0>>2]=HEAP32[$2+0>>2]|0;HEAP32[$$byval_copy+4>>2]=HEAP32[$2+4>>2]|0;
   __ZN9Component4sendE6Packeta($3,$$byval_copy,0);
  }
 }
 STACKTOP = sp;return;
}
function ___clang_call_terminate($0) {
 $0 = $0|0;
 var label = 0, sp = 0;
 sp = STACKTOP;
 (___cxa_begin_catch(($0|0))|0);
 __ZSt9terminatev();
 // unreachable;
}
function __ZN5RouteD2Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 __ZN21SingleOutputComponentD2Ev($1);
 STACKTOP = sp;return;
}
function __ZN5RouteD0Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $3 = $0;
 __THREW__ = 0;
 invoke_vi(73,($3|0));
 $4 = __THREW__; __THREW__ = 0;
 $5 = $4&1;
 if (!($5)) {
  __ZdlPv($3);
  STACKTOP = sp;return;
 }
 $6 = ___cxa_find_matching_catch()|0;
 $7 = tempRet0;
 $1 = $6;
 $2 = $7;
 __ZdlPv($3);
 $8 = $1;
 $9 = $2;
 ___resumeException($8|0);
 // unreachable;
}
function __ZN5Route7processE6Packeta($this,$in,$port) {
 $this = $this|0;
 $in = $in|0;
 $port = $port|0;
 var $$byval_copy = 0, $$byval_copy1 = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0;
 var $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 var $9 = 0, $p = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $$byval_copy1 = sp + 32|0;
 $$byval_copy = sp + 24|0;
 $2 = sp + 8|0;
 $3 = sp;
 $0 = $this;
 $1 = $port;
 $4 = $0;
 $5 = $1;
 $6 = $5 << 24 >> 24;
 $7 = ($6|0)==(0);
 if (!($7)) {
  $28 = (__ZNK6Packet6isDataEv($in)|0);
  if ($28) {
   $29 = $1;
   $30 = $29 << 24 >> 24;
   $31 = (($4) + 32|0);
   $32 = (($31) + ($30<<3)|0);
   ;HEAP32[$32+0>>2]=HEAP32[$in+0>>2]|0;HEAP32[$32+4>>2]=HEAP32[$in+4>>2]|0;
   $33 = $1;
   $34 = $33 << 24 >> 24;
   $35 = (($4) + 104|0);
   $36 = HEAP8[$35>>0]|0;
   $37 = $36 << 24 >> 24;
   $38 = ($34|0)==($37|0);
   if ($38) {
    ;HEAP32[$3+0>>2]=HEAP32[$in+0>>2]|0;HEAP32[$3+4>>2]=HEAP32[$in+4>>2]|0;
    ;HEAP32[$$byval_copy1+0>>2]=HEAP32[$3+0>>2]|0;HEAP32[$$byval_copy1+4>>2]=HEAP32[$3+4>>2]|0;
    __ZN9Component4sendE6Packeta($4,$$byval_copy1,0);
   }
  }
  STACKTOP = sp;return;
 }
 $8 = (__ZNK6Packet9asIntegerEv($in)|0);
 $9 = $8&255;
 $10 = (($4) + 104|0);
 HEAP8[$10>>0] = $9;
 $11 = (($4) + 104|0);
 $12 = HEAP8[$11>>0]|0;
 $13 = $12 << 24 >> 24;
 $14 = ($13|0)>(0);
 if ($14) {
  $15 = (($4) + 104|0);
  $16 = HEAP8[$15>>0]|0;
  $17 = $16 << 24 >> 24;
  $18 = ($17|0)<(9);
  if ($18) {
   $19 = (($4) + 104|0);
   $20 = HEAP8[$19>>0]|0;
   $21 = $20 << 24 >> 24;
   $22 = (($4) + 32|0);
   $23 = (($22) + ($21<<3)|0);
   $p = $23;
   $24 = $p;
   $25 = (__ZNK6Packet4typeEv($24)|0);
   $26 = ($25|0)!=(0);
   if ($26) {
    $27 = $p;
    ;HEAP32[$2+0>>2]=HEAP32[$27+0>>2]|0;HEAP32[$2+4>>2]=HEAP32[$27+4>>2]|0;
    ;HEAP32[$$byval_copy+0>>2]=HEAP32[$2+0>>2]|0;HEAP32[$$byval_copy+4>>2]=HEAP32[$2+4>>2]|0;
    __ZN9Component4sendE6Packeta($4,$$byval_copy,0);
   }
  }
 }
 STACKTOP = sp;return;
}
function __ZN14DummyComponentC2Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 __ZN9ComponentC2EP10Connectioni($1,0,0);
 $2 = (1424 + 8|0);
 HEAP32[$1>>2] = $2;
 STACKTOP = sp;return;
}
function __ZN17ReadCapacitivePinD2Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 __ZN14DummyComponentD2Ev($1);
 STACKTOP = sp;return;
}
function __ZN17ReadCapacitivePinD0Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $3 = $0;
 __THREW__ = 0;
 invoke_vi(76,($3|0));
 $4 = __THREW__; __THREW__ = 0;
 $5 = $4&1;
 if (!($5)) {
  __ZdlPv($3);
  STACKTOP = sp;return;
 }
 $6 = ___cxa_find_matching_catch()|0;
 $7 = tempRet0;
 $1 = $6;
 $2 = $7;
 __ZdlPv($3);
 $8 = $1;
 $9 = $2;
 ___resumeException($8|0);
 // unreachable;
}
function __ZN14DummyComponent7processE6Packeta($this,$in,$port) {
 $this = $this|0;
 $in = $in|0;
 $port = $port|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $port;
 $2 = $0;
 $3 = (($2) + 16|0);
 $4 = HEAP32[$3>>2]|0;
 $5 = (($4) + 1008|0);
 $6 = HEAP32[$5>>2]|0;
 __ZL14microflo_debugP12DebugHandler10DebugLevel7DebugId($6,1,27);
 STACKTOP = sp;return;
}
function __ZN14DummyComponentD2Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 __ZN9ComponentD2Ev($1);
 STACKTOP = sp;return;
}
function __ZN14DummyComponentD0Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $3 = $0;
 __THREW__ = 0;
 invoke_vi(79,($3|0));
 $4 = __THREW__; __THREW__ = 0;
 $5 = $4&1;
 if (!($5)) {
  __ZdlPv($3);
  STACKTOP = sp;return;
 }
 $6 = ___cxa_find_matching_catch()|0;
 $7 = tempRet0;
 $1 = $6;
 $2 = $7;
 __ZdlPv($3);
 $8 = $1;
 $9 = $2;
 ___resumeException($8|0);
 // unreachable;
}
function __ZN8PwmWriteD2Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 __ZN21SingleOutputComponentD2Ev($1);
 STACKTOP = sp;return;
}
function __ZN8PwmWriteD0Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $3 = $0;
 __THREW__ = 0;
 invoke_vi(81,($3|0));
 $4 = __THREW__; __THREW__ = 0;
 $5 = $4&1;
 if (!($5)) {
  __ZdlPv($3);
  STACKTOP = sp;return;
 }
 $6 = ___cxa_find_matching_catch()|0;
 $7 = tempRet0;
 $1 = $6;
 $2 = $7;
 __ZdlPv($3);
 $8 = $1;
 $9 = $2;
 ___resumeException($8|0);
 // unreachable;
}
function __ZN8PwmWrite7processE6Packeta($this,$in,$port) {
 $this = $this|0;
 $in = $in|0;
 $port = $port|0;
 var $$byval_copy = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0;
 var $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $$byval_copy = sp + 16|0;
 $2 = sp;
 $0 = $this;
 $1 = $port;
 $3 = $0;
 $4 = (__ZNK6Packet7isSetupEv($in)|0);
 if ($4) {
  STACKTOP = sp;return;
 }
 $5 = $1;
 $6 = $5 << 24 >> 24;
 $7 = ($6|0)==(0);
 if ($7) {
  $8 = (__ZNK6Packet6isDataEv($in)|0);
  if ($8) {
   $9 = (($3) + 4|0);
   $10 = HEAP32[$9>>2]|0;
   $11 = HEAP32[$10>>2]|0;
   $12 = (($11) + 48|0);
   $13 = HEAP32[$12>>2]|0;
   $14 = (($3) + 32|0);
   $15 = HEAP8[$14>>0]|0;
   $16 = (__ZNK6Packet9asIntegerEv($in)|0);
   FUNCTION_TABLE_viii[$13 & 255]($10,$15,$16);
   ;HEAP32[$2+0>>2]=HEAP32[$in+0>>2]|0;HEAP32[$2+4>>2]=HEAP32[$in+4>>2]|0;
   ;HEAP32[$$byval_copy+0>>2]=HEAP32[$2+0>>2]|0;HEAP32[$$byval_copy+4>>2]=HEAP32[$2+4>>2]|0;
   __ZN9Component4sendE6Packeta($3,$$byval_copy,0);
  } else {
   label = 6;
  }
 } else {
  label = 6;
 }
 if ((label|0) == 6) {
  $17 = $1;
  $18 = $17 << 24 >> 24;
  $19 = ($18|0)==(1);
  if ($19) {
   $20 = (__ZNK6Packet8isNumberEv($in)|0);
   if ($20) {
    $21 = (__ZNK6Packet9asIntegerEv($in)|0);
    $22 = $21&255;
    $23 = (($3) + 32|0);
    HEAP8[$23>>0] = $22;
    $24 = (($3) + 4|0);
    $25 = HEAP32[$24>>2]|0;
    $26 = HEAP32[$25>>2]|0;
    $27 = (($26) + 28|0);
    $28 = HEAP32[$27>>2]|0;
    $29 = (($3) + 32|0);
    $30 = HEAP8[$29>>0]|0;
    FUNCTION_TABLE_viii[$28 & 255]($25,$30,1);
   }
  }
 }
 STACKTOP = sp;return;
}
function __ZN10MonitorPinD2Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 __ZN21SingleOutputComponentD2Ev($1);
 STACKTOP = sp;return;
}
function __ZN10MonitorPinD0Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $3 = $0;
 __THREW__ = 0;
 invoke_vi(84,($3|0));
 $4 = __THREW__; __THREW__ = 0;
 $5 = $4&1;
 if (!($5)) {
  __ZdlPv($3);
  STACKTOP = sp;return;
 }
 $6 = ___cxa_find_matching_catch()|0;
 $7 = tempRet0;
 $1 = $6;
 $2 = $7;
 __ZdlPv($3);
 $8 = $1;
 $9 = $2;
 ___resumeException($8|0);
 // unreachable;
}
function __ZN10MonitorPin7processE6Packeta($this,$in,$port) {
 $this = $this|0;
 $in = $in|0;
 $port = $port|0;
 var $$byval_copy = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0;
 var $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 var $intr = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $$byval_copy = sp + 16|0;
 $2 = sp;
 $0 = $this;
 $1 = $port;
 $3 = $0;
 $4 = $1;
 $5 = $4 << 24 >> 24;
 $6 = ($5|0)==(0);
 if (!($6)) {
  STACKTOP = sp;return;
 }
 $7 = (__ZNK6Packet9asIntegerEv($in)|0);
 $8 = $7&255;
 $9 = (($3) + 32|0);
 HEAP8[$9>>0] = $8;
 $intr = 0;
 $10 = (($3) + 32|0);
 $11 = HEAP8[$10>>0]|0;
 $12 = $11 << 24 >> 24;
 $13 = ($12|0)==(2);
 if ($13) {
  $intr = 0;
 } else {
  $14 = (($3) + 32|0);
  $15 = HEAP8[$14>>0]|0;
  $16 = $15 << 24 >> 24;
  $17 = ($16|0)==(3);
  if ($17) {
   $intr = 1;
  }
 }
 $18 = (($3) + 4|0);
 $19 = HEAP32[$18>>2]|0;
 $20 = HEAP32[$19>>2]|0;
 $21 = (($20) + 32|0);
 $22 = HEAP32[$21>>2]|0;
 $23 = (($3) + 32|0);
 $24 = HEAP8[$23>>0]|0;
 FUNCTION_TABLE_viii[$22 & 255]($19,$24,1);
 $25 = (($3) + 4|0);
 $26 = HEAP32[$25>>2]|0;
 $27 = HEAP32[$26>>2]|0;
 $28 = (($27) + 60|0);
 $29 = HEAP32[$28>>2]|0;
 $30 = $intr;
 FUNCTION_TABLE_viiiii[$29 & 255]($26,$30,2,202,$3);
 $31 = (($3) + 4|0);
 $32 = HEAP32[$31>>2]|0;
 $33 = HEAP32[$32>>2]|0;
 $34 = (($33) + 40|0);
 $35 = HEAP32[$34>>2]|0;
 $36 = (($3) + 32|0);
 $37 = HEAP8[$36>>0]|0;
 $38 = (FUNCTION_TABLE_iii[$35 & 255]($32,$37)|0);
 __ZN6PacketC2Eb($2,$38);
 ;HEAP32[$$byval_copy+0>>2]=HEAP32[$2+0>>2]|0;HEAP32[$$byval_copy+4>>2]=HEAP32[$2+4>>2]|0;
 __ZN9Component4sendE6Packeta($3,$$byval_copy,0);
 STACKTOP = sp;return;
}
function __ZN10MonitorPin9interruptEPv($user) {
 $user = $user|0;
 var $$byval_copy = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $thisptr = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $$byval_copy = sp + 16|0;
 $1 = sp;
 $0 = $user;
 $2 = $0;
 $thisptr = $2;
 $3 = $thisptr;
 $4 = $thisptr;
 $5 = (($4) + 4|0);
 $6 = HEAP32[$5>>2]|0;
 $7 = HEAP32[$6>>2]|0;
 $8 = (($7) + 40|0);
 $9 = HEAP32[$8>>2]|0;
 $10 = $thisptr;
 $11 = (($10) + 32|0);
 $12 = HEAP8[$11>>0]|0;
 $13 = (FUNCTION_TABLE_iii[$9 & 255]($6,$12)|0);
 __ZN6PacketC2Eb($1,$13);
 ;HEAP32[$$byval_copy+0>>2]=HEAP32[$1+0>>2]|0;HEAP32[$$byval_copy+4>>2]=HEAP32[$1+4>>2]|0;
 __ZN9Component4sendE6Packeta($3,$$byval_copy,0);
 STACKTOP = sp;return;
}
function __ZN9MapLinearD2Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 __ZN21SingleOutputComponentD2Ev($1);
 STACKTOP = sp;return;
}
function __ZN9MapLinearD0Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $3 = $0;
 __THREW__ = 0;
 invoke_vi(87,($3|0));
 $4 = __THREW__; __THREW__ = 0;
 $5 = $4&1;
 if (!($5)) {
  __ZdlPv($3);
  STACKTOP = sp;return;
 }
 $6 = ___cxa_find_matching_catch()|0;
 $7 = tempRet0;
 $1 = $6;
 $2 = $7;
 __ZdlPv($3);
 $8 = $1;
 $9 = $2;
 ___resumeException($8|0);
 // unreachable;
}
function __ZN9MapLinear7processE6Packeta($this,$in,$port) {
 $this = $this|0;
 $in = $in|0;
 $port = $port|0;
 var $$byval_copy = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0;
 var $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $$byval_copy = sp + 16|0;
 $2 = sp;
 $0 = $this;
 $1 = $port;
 $3 = $0;
 $4 = (__ZNK6Packet7isSetupEv($in)|0);
 if ($4) {
  STACKTOP = sp;return;
 }
 $5 = $1;
 $6 = $5 << 24 >> 24;
 $7 = ($6|0)==(1);
 if ($7) {
  $8 = (__ZNK6Packet6isDataEv($in)|0);
  if ($8) {
   $9 = (__ZNK6Packet9asIntegerEv($in)|0);
   $10 = (($3) + 32|0);
   HEAP32[$10>>2] = $9;
  } else {
   label = 6;
  }
 } else {
  label = 6;
 }
 if ((label|0) == 6) {
  $11 = $1;
  $12 = $11 << 24 >> 24;
  $13 = ($12|0)==(2);
  if ($13) {
   $14 = (__ZNK6Packet6isDataEv($in)|0);
   if ($14) {
    $15 = (__ZNK6Packet9asIntegerEv($in)|0);
    $16 = (($3) + 36|0);
    HEAP32[$16>>2] = $15;
   } else {
    label = 9;
   }
  } else {
   label = 9;
  }
  if ((label|0) == 9) {
   $17 = $1;
   $18 = $17 << 24 >> 24;
   $19 = ($18|0)==(3);
   if ($19) {
    $20 = (__ZNK6Packet6isDataEv($in)|0);
    if ($20) {
     $21 = (__ZNK6Packet9asIntegerEv($in)|0);
     $22 = (($3) + 44|0);
     HEAP32[$22>>2] = $21;
    } else {
     label = 12;
    }
   } else {
    label = 12;
   }
   if ((label|0) == 12) {
    $23 = $1;
    $24 = $23 << 24 >> 24;
    $25 = ($24|0)==(4);
    if ($25) {
     $26 = (__ZNK6Packet6isDataEv($in)|0);
     if ($26) {
      $27 = (__ZNK6Packet9asIntegerEv($in)|0);
      $28 = (($3) + 40|0);
      HEAP32[$28>>2] = $27;
     } else {
      label = 15;
     }
    } else {
     label = 15;
    }
    if ((label|0) == 15) {
     $29 = $1;
     $30 = $29 << 24 >> 24;
     $31 = ($30|0)==(0);
     if ($31) {
      $32 = (__ZNK6Packet8isNumberEv($in)|0);
      if ($32) {
       $33 = (__ZNK6Packet9asIntegerEv($in)|0);
       $34 = (__ZN9MapLinear3mapEl($3,$33)|0);
       __ZN6PacketC2El($2,$34);
       ;HEAP32[$$byval_copy+0>>2]=HEAP32[$2+0>>2]|0;HEAP32[$$byval_copy+4>>2]=HEAP32[$2+4>>2]|0;
       __ZN9Component4sendE6Packeta($3,$$byval_copy,0);
      }
     }
    }
   }
  }
 }
 STACKTOP = sp;return;
}
function __ZN9MapLinear3mapEl($this,$in) {
 $this = $this|0;
 $in = $in|0;
 var $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 var $8 = 0, $9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $in;
 $2 = $0;
 $3 = $1;
 $4 = (($2) + 32|0);
 $5 = HEAP32[$4>>2]|0;
 $6 = (($3) - ($5))|0;
 $7 = (($2) + 40|0);
 $8 = HEAP32[$7>>2]|0;
 $9 = (($2) + 44|0);
 $10 = HEAP32[$9>>2]|0;
 $11 = (($8) - ($10))|0;
 $12 = Math_imul($6, $11)|0;
 $13 = (($2) + 36|0);
 $14 = HEAP32[$13>>2]|0;
 $15 = (($2) + 32|0);
 $16 = HEAP32[$15>>2]|0;
 $17 = (($14) - ($16))|0;
 $18 = (($12|0) / ($17|0))&-1;
 $19 = (($2) + 44|0);
 $20 = HEAP32[$19>>2]|0;
 $21 = (($18) + ($20))|0;
 STACKTOP = sp;return ($21|0);
}
function __ZN12LedMatrixMaxD2Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 __ZN21SingleOutputComponentD2Ev($1);
 STACKTOP = sp;return;
}
function __ZN12LedMatrixMaxD0Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $3 = $0;
 __THREW__ = 0;
 invoke_vi(90,($3|0));
 $4 = __THREW__; __THREW__ = 0;
 $5 = $4&1;
 if (!($5)) {
  __ZdlPv($3);
  STACKTOP = sp;return;
 }
 $6 = ___cxa_find_matching_catch()|0;
 $7 = tempRet0;
 $1 = $6;
 $2 = $7;
 __ZdlPv($3);
 $8 = $1;
 $9 = $2;
 ___resumeException($8|0);
 // unreachable;
}
function __ZN12LedMatrixMax7processE6Packeta($this,$in,$port) {
 $this = $this|0;
 $in = $in|0;
 $port = $port|0;
 var $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0;
 var $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $5 = 0;
 var $6 = 0, $7 = 0, $8 = 0, $9 = 0, $c = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $port;
 $2 = $0;
 $3 = $1;
 $4 = $3 << 24 >> 24;
 $5 = ($4|0)==(0);
 if (!($5)) {
  $26 = $1;
  $27 = $26 << 24 >> 24;
  $28 = ($27|0)==(3);
  if ($28) {
   $29 = (__ZNK6Packet9asIntegerEv($in)|0);
   $30 = (($2) + 40|0);
   HEAP32[$30>>2] = $29;
   $31 = (($2) + 44|0);
   HEAP8[$31>>0] = 0;
   __ZN12LedMatrixMax6updateEv($2);
  } else {
   $32 = $1;
   $33 = $32 << 24 >> 24;
   $34 = ($33|0)==(1);
   if ($34) {
    $35 = (__ZNK6Packet9asIntegerEv($in)|0);
    $36 = (($2) + 32|0);
    HEAP32[$36>>2] = $35;
    $37 = (($2) + 44|0);
    HEAP8[$37>>0] = 0;
    __ZN12LedMatrixMax6updateEv($2);
   } else {
    $38 = $1;
    $39 = $38 << 24 >> 24;
    $40 = ($39|0)==(2);
    if ($40) {
     $41 = (__ZNK6Packet9asIntegerEv($in)|0);
     $42 = (($2) + 36|0);
     HEAP32[$42>>2] = $41;
     $43 = (($2) + 44|0);
     HEAP8[$43>>0] = 0;
     __ZN12LedMatrixMax6updateEv($2);
    }
   }
  }
  STACKTOP = sp;return;
 }
 $6 = (__ZNK6Packet9isIntegerEv($in)|0);
 if ($6) {
  $7 = (__ZNK6Packet9asIntegerEv($in)|0);
  $8 = ($7|0)<(38);
  if ($8) {
   $9 = (__ZNK6Packet9asIntegerEv($in)|0);
   $10 = $9&255;
   $11 = (($2) + 45|0);
   HEAP8[$11>>0] = $10;
  } else {
   label = 5;
  }
 } else {
  label = 5;
 }
 if ((label|0) == 5) {
  $12 = (__ZNK6Packet6isByteEv($in)|0);
  if ($12) {
   $13 = (__ZNK6Packet6asByteEv($in)|0);
   $c = $13;
   $14 = $c;
   $15 = $14&255;
   $16 = ($15|0)>(65);
   if ($16) {
    $17 = $c;
    $18 = $17&255;
    $19 = ($18|0)<=(90);
    if ($19) {
     $20 = $c;
     $21 = $20&255;
     $22 = (10 + ($21))|0;
     $23 = (($22) - 65)|0;
     $24 = $23&255;
     $25 = (($2) + 45|0);
     HEAP8[$25>>0] = $24;
    }
   }
  }
 }
 __ZN12LedMatrixMax6updateEv($2);
 STACKTOP = sp;return;
}
function __ZNK6Packet9isIntegerEv($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 $2 = (($1) + 4|0);
 $3 = HEAP32[$2>>2]|0;
 $4 = ($3|0)==(7);
 STACKTOP = sp;return ($4|0);
}
function __ZN12LedMatrixMax6updateEv($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0;
 var $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0;
 var $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $i = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 $2 = (($1) + 32|0);
 $3 = HEAP32[$2>>2]|0;
 $4 = ($3|0)<(0);
 if (!($4)) {
  $5 = (($1) + 36|0);
  $6 = HEAP32[$5>>2]|0;
  $7 = ($6|0)<(0);
  if (!($7)) {
   $8 = (($1) + 40|0);
   $9 = HEAP32[$8>>2]|0;
   $10 = ($9|0)<(0);
   if (!($10)) {
    $11 = (($1) + 44|0);
    $12 = HEAP8[$11>>0]|0;
    $13 = $12&1;
    if (!($13)) {
     $14 = (($1) + 4|0);
     $15 = HEAP32[$14>>2]|0;
     $16 = HEAP32[$15>>2]|0;
     $17 = (($16) + 28|0);
     $18 = HEAP32[$17>>2]|0;
     $19 = (($1) + 32|0);
     $20 = HEAP32[$19>>2]|0;
     $21 = $20&255;
     FUNCTION_TABLE_viii[$18 & 255]($15,$21,1);
     $22 = (($1) + 4|0);
     $23 = HEAP32[$22>>2]|0;
     $24 = HEAP32[$23>>2]|0;
     $25 = (($24) + 28|0);
     $26 = HEAP32[$25>>2]|0;
     $27 = (($1) + 36|0);
     $28 = HEAP32[$27>>2]|0;
     $29 = $28&255;
     FUNCTION_TABLE_viii[$26 & 255]($23,$29,1);
     $30 = (($1) + 4|0);
     $31 = HEAP32[$30>>2]|0;
     $32 = HEAP32[$31>>2]|0;
     $33 = (($32) + 28|0);
     $34 = HEAP32[$33>>2]|0;
     $35 = (($1) + 40|0);
     $36 = HEAP32[$35>>2]|0;
     $37 = $36&255;
     FUNCTION_TABLE_viii[$34 & 255]($31,$37,1);
     __ZN12LedMatrixMax12max7219_initEv($1);
     $38 = (($1) + 44|0);
     HEAP8[$38>>0] = 1;
    }
    $i = 1;
    while(1) {
     $39 = $i;
     $40 = $39&255;
     $41 = ($40|0)<(9);
     if (!($41)) {
      break;
     }
     $42 = $i;
     $43 = $i;
     $44 = $43&255;
     $45 = (($44) - 1)|0;
     $46 = (($1) + 45|0);
     $47 = HEAP8[$46>>0]|0;
     $48 = $47&255;
     $49 = (1672 + ($48<<3)|0);
     $50 = (($49) + ($45)|0);
     $51 = HEAP8[$50>>0]|0;
     __ZN12LedMatrixMax13max7219_writeEhh($1,$42,$51);
     $52 = $i;
     $53 = (($52) + 1)<<24>>24;
     $i = $53;
    }
    STACKTOP = sp;return;
   }
  }
 }
 STACKTOP = sp;return;
}
function __ZN12LedMatrixMax12max7219_initEv($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 __ZN12LedMatrixMax13max7219_writeEhh($1,9,0);
 __ZN12LedMatrixMax13max7219_writeEhh($1,10,3);
 __ZN12LedMatrixMax13max7219_writeEhh($1,11,7);
 __ZN12LedMatrixMax13max7219_writeEhh($1,12,1);
 __ZN12LedMatrixMax13max7219_writeEhh($1,15,0);
 STACKTOP = sp;return;
}
function __ZN12LedMatrixMax13max7219_writeEhh($this,$address,$dat) {
 $this = $this|0;
 $address = $address|0;
 $dat = $dat|0;
 var $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 var $8 = 0, $9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $address;
 $2 = $dat;
 $3 = $0;
 $4 = (($3) + 4|0);
 $5 = HEAP32[$4>>2]|0;
 $6 = HEAP32[$5>>2]|0;
 $7 = (($6) + 36|0);
 $8 = HEAP32[$7>>2]|0;
 $9 = (($3) + 32|0);
 $10 = HEAP32[$9>>2]|0;
 $11 = $10&255;
 FUNCTION_TABLE_viii[$8 & 255]($5,$11,0);
 $12 = $1;
 __ZN12LedMatrixMax18max7219_write_byteEh($3,$12);
 $13 = $2;
 __ZN12LedMatrixMax18max7219_write_byteEh($3,$13);
 $14 = (($3) + 4|0);
 $15 = HEAP32[$14>>2]|0;
 $16 = HEAP32[$15>>2]|0;
 $17 = (($16) + 36|0);
 $18 = HEAP32[$17>>2]|0;
 $19 = (($3) + 32|0);
 $20 = HEAP32[$19>>2]|0;
 $21 = $20&255;
 FUNCTION_TABLE_viii[$18 & 255]($15,$21,1);
 STACKTOP = sp;return;
}
function __ZN12LedMatrixMax18max7219_write_byteEh($this,$DATA) {
 $this = $this|0;
 $DATA = $DATA|0;
 var $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0;
 var $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 var $i = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $DATA;
 $2 = $0;
 $i = 8;
 while(1) {
  $3 = $i;
  $4 = $3&255;
  $5 = ($4|0)>=(1);
  if (!($5)) {
   break;
  }
  $6 = (($2) + 4|0);
  $7 = HEAP32[$6>>2]|0;
  $8 = HEAP32[$7>>2]|0;
  $9 = (($8) + 36|0);
  $10 = HEAP32[$9>>2]|0;
  $11 = (($2) + 40|0);
  $12 = HEAP32[$11>>2]|0;
  $13 = $12&255;
  FUNCTION_TABLE_viii[$10 & 255]($7,$13,0);
  $14 = (($2) + 4|0);
  $15 = HEAP32[$14>>2]|0;
  $16 = HEAP32[$15>>2]|0;
  $17 = (($16) + 36|0);
  $18 = HEAP32[$17>>2]|0;
  $19 = (($2) + 36|0);
  $20 = HEAP32[$19>>2]|0;
  $21 = $20&255;
  $22 = $1;
  $23 = $22&255;
  $24 = $23 & 128;
  $25 = ($24|0)!=(0);
  FUNCTION_TABLE_viii[$18 & 255]($15,$21,$25);
  $26 = (($2) + 4|0);
  $27 = HEAP32[$26>>2]|0;
  $28 = HEAP32[$27>>2]|0;
  $29 = (($28) + 36|0);
  $30 = HEAP32[$29>>2]|0;
  $31 = (($2) + 40|0);
  $32 = HEAP32[$31>>2]|0;
  $33 = $32&255;
  FUNCTION_TABLE_viii[$30 & 255]($27,$33,1);
  $34 = $1;
  $35 = $34&255;
  $36 = $35 << 1;
  $37 = $36&255;
  $1 = $37;
  $38 = $i;
  $39 = (($38) + -1)<<24>>24;
  $i = $39;
 }
 STACKTOP = sp;return;
}
function __ZN13InvertBooleanD2Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 __ZN21SingleOutputComponentD2Ev($1);
 STACKTOP = sp;return;
}
function __ZN13InvertBooleanD0Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $3 = $0;
 __THREW__ = 0;
 invoke_vi(93,($3|0));
 $4 = __THREW__; __THREW__ = 0;
 $5 = $4&1;
 if (!($5)) {
  __ZdlPv($3);
  STACKTOP = sp;return;
 }
 $6 = ___cxa_find_matching_catch()|0;
 $7 = tempRet0;
 $1 = $6;
 $2 = $7;
 __ZdlPv($3);
 $8 = $1;
 $9 = $2;
 ___resumeException($8|0);
 // unreachable;
}
function __ZN13InvertBoolean7processE6Packeta($this,$in,$port) {
 $this = $this|0;
 $in = $in|0;
 $port = $port|0;
 var $$byval_copy = 0, $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $p = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $$byval_copy = sp + 24|0;
 $p = sp + 8|0;
 $2 = sp;
 $0 = $this;
 $1 = $port;
 $3 = $0;
 $4 = (__ZNK6Packet6isDataEv($in)|0);
 if (!($4)) {
  STACKTOP = sp;return;
 }
 $5 = (__ZNK6Packet6asBoolEv($in)|0);
 $6 = $5 ^ 1;
 __ZN6PacketC2Eb($p,$6);
 ;HEAP32[$2+0>>2]=HEAP32[$p+0>>2]|0;HEAP32[$2+4>>2]=HEAP32[$p+4>>2]|0;
 ;HEAP32[$$byval_copy+0>>2]=HEAP32[$2+0>>2]|0;HEAP32[$$byval_copy+4>>2]=HEAP32[$2+4>>2]|0;
 __ZN9Component4sendE6Packeta($3,$$byval_copy,0);
 STACKTOP = sp;return;
}
function __ZN15HysteresisLatchD2Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 __ZN21SingleOutputComponentD2Ev($1);
 STACKTOP = sp;return;
}
function __ZN15HysteresisLatchD0Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $3 = $0;
 __THREW__ = 0;
 invoke_vi(96,($3|0));
 $4 = __THREW__; __THREW__ = 0;
 $5 = $4&1;
 if (!($5)) {
  __ZdlPv($3);
  STACKTOP = sp;return;
 }
 $6 = ___cxa_find_matching_catch()|0;
 $7 = tempRet0;
 $1 = $6;
 $2 = $7;
 __ZdlPv($3);
 $8 = $1;
 $9 = $2;
 ___resumeException($8|0);
 // unreachable;
}
function __ZN15HysteresisLatch7processE6Packeta($this,$in,$port) {
 $this = $this|0;
 $in = $in|0;
 $port = $port|0;
 var $0 = 0, $1 = 0, $10 = 0, $11 = 0.0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0.0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0.0, $3 = 0, $4 = 0, $5 = 0;
 var $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $port;
 $2 = $0;
 $3 = (__ZNK6Packet7isSetupEv($in)|0);
 if ($3) {
  $4 = (($2) + 32|0);
  HEAPF32[$4>>2] = 30.0;
  $5 = (($2) + 36|0);
  HEAPF32[$5>>2] = 24.0;
  $6 = (($2) + 40|0);
  HEAP8[$6>>0] = 1;
  STACKTOP = sp;return;
 }
 $7 = $1;
 $8 = $7 << 24 >> 24;
 $9 = ($8|0)==(1);
 if ($9) {
  $10 = (__ZNK6Packet8isNumberEv($in)|0);
  if ($10) {
   $11 = (+__ZNK6Packet7asFloatEv($in));
   $12 = (($2) + 36|0);
   HEAPF32[$12>>2] = $11;
  } else {
   label = 6;
  }
 } else {
  label = 6;
 }
 if ((label|0) == 6) {
  $13 = $1;
  $14 = $13 << 24 >> 24;
  $15 = ($14|0)==(2);
  if ($15) {
   $16 = (__ZNK6Packet8isNumberEv($in)|0);
   if ($16) {
    $17 = (+__ZNK6Packet7asFloatEv($in));
    $18 = (($2) + 32|0);
    HEAPF32[$18>>2] = $17;
   } else {
    label = 9;
   }
  } else {
   label = 9;
  }
  if ((label|0) == 9) {
   $19 = $1;
   $20 = $19 << 24 >> 24;
   $21 = ($20|0)==(0);
   if ($21) {
    $22 = (__ZNK6Packet8isNumberEv($in)|0);
    if ($22) {
     $23 = (+__ZNK6Packet7asFloatEv($in));
     __ZN15HysteresisLatch11updateValueEf($2,$23);
    }
   }
  }
 }
 STACKTOP = sp;return;
}
function __ZN15HysteresisLatch11updateValueEf($this,$input) {
 $this = $this|0;
 $input = +$input;
 var $$byval_copy = 0, $0 = 0, $1 = 0.0, $10 = 0, $11 = 0, $12 = 0.0, $13 = 0, $14 = 0.0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0.0, $8 = 0;
 var $9 = 0.0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $$byval_copy = sp + 16|0;
 $2 = sp;
 $0 = $this;
 $1 = $input;
 $3 = $0;
 $4 = (($3) + 40|0);
 $5 = HEAP8[$4>>0]|0;
 $6 = $5&1;
 if ($6) {
  $7 = $1;
  $8 = (($3) + 36|0);
  $9 = +HEAPF32[$8>>2];
  $10 = $7 <= $9;
  if ($10) {
   $11 = (($3) + 40|0);
   HEAP8[$11>>0] = 0;
  }
 } else {
  $12 = $1;
  $13 = (($3) + 32|0);
  $14 = +HEAPF32[$13>>2];
  $15 = $12 >= $14;
  if ($15) {
   $16 = (($3) + 40|0);
   HEAP8[$16>>0] = 1;
  }
 }
 $17 = (($3) + 40|0);
 $18 = HEAP8[$17>>0]|0;
 $19 = $18&1;
 __ZN6PacketC2Eb($2,$19);
 ;HEAP32[$$byval_copy+0>>2]=HEAP32[$2+0>>2]|0;HEAP32[$$byval_copy+4>>2]=HEAP32[$2+4>>2]|0;
 __ZN9Component4sendE6Packeta($3,$$byval_copy,0);
 STACKTOP = sp;return;
}
function __ZN4GateD2Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 __ZN21SingleOutputComponentD2Ev($1);
 STACKTOP = sp;return;
}
function __ZN4GateD0Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $3 = $0;
 __THREW__ = 0;
 invoke_vi(99,($3|0));
 $4 = __THREW__; __THREW__ = 0;
 $5 = $4&1;
 if (!($5)) {
  __ZdlPv($3);
  STACKTOP = sp;return;
 }
 $6 = ___cxa_find_matching_catch()|0;
 $7 = tempRet0;
 $1 = $6;
 $2 = $7;
 __ZdlPv($3);
 $8 = $1;
 $9 = $2;
 ___resumeException($8|0);
 // unreachable;
}
function __ZN4Gate7processE6Packeta($this,$in,$port) {
 $this = $this|0;
 $in = $in|0;
 $port = $port|0;
 var $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $port;
 $2 = $0;
 $3 = $1;
 $4 = $3 << 24 >> 24;
 $5 = ($4|0)==(0);
 if ($5) {
  $6 = (($2) + 36|0);
  ;HEAP32[$6+0>>2]=HEAP32[$in+0>>2]|0;HEAP32[$6+4>>2]=HEAP32[$in+4>>2]|0;
  __ZN4Gate13sendIfEnabledEv($2);
  STACKTOP = sp;return;
 }
 $7 = $1;
 $8 = $7 << 24 >> 24;
 $9 = ($8|0)==(1);
 if ($9) {
  $10 = (__ZNK6Packet6asBoolEv($in)|0);
  $11 = (($2) + 32|0);
  $12 = $10&1;
  HEAP8[$11>>0] = $12;
  __ZN4Gate13sendIfEnabledEv($2);
 }
 STACKTOP = sp;return;
}
function __ZN4Gate13sendIfEnabledEv($this) {
 $this = $this|0;
 var $$byval_copy = 0, $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $$byval_copy = sp + 16|0;
 $1 = sp;
 $0 = $this;
 $2 = $0;
 $3 = (($2) + 32|0);
 $4 = HEAP8[$3>>0]|0;
 $5 = $4&1;
 if (!($5)) {
  STACKTOP = sp;return;
 }
 $6 = (($2) + 36|0);
 $7 = (__ZNK6Packet7isValidEv($6)|0);
 if (!($7)) {
  STACKTOP = sp;return;
 }
 $8 = (($2) + 36|0);
 ;HEAP32[$1+0>>2]=HEAP32[$8+0>>2]|0;HEAP32[$1+4>>2]=HEAP32[$8+4>>2]|0;
 ;HEAP32[$$byval_copy+0>>2]=HEAP32[$1+0>>2]|0;HEAP32[$$byval_copy+4>>2]=HEAP32[$1+4>>2]|0;
 __ZN9Component4sendE6Packeta($2,$$byval_copy,0);
 STACKTOP = sp;return;
}
function __ZN7ForwardD2Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 __ZN21SingleOutputComponentD2Ev($1);
 STACKTOP = sp;return;
}
function __ZN7ForwardD0Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $3 = $0;
 __THREW__ = 0;
 invoke_vi(102,($3|0));
 $4 = __THREW__; __THREW__ = 0;
 $5 = $4&1;
 if (!($5)) {
  __ZdlPv($3);
  STACKTOP = sp;return;
 }
 $6 = ___cxa_find_matching_catch()|0;
 $7 = tempRet0;
 $1 = $6;
 $2 = $7;
 __ZdlPv($3);
 $8 = $1;
 $9 = $2;
 ___resumeException($8|0);
 // unreachable;
}
function __ZN7Forward7processE6Packeta($this,$in,$port) {
 $this = $this|0;
 $in = $in|0;
 $port = $port|0;
 var $$byval_copy = 0, $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $$byval_copy = sp + 16|0;
 $2 = sp;
 $0 = $this;
 $1 = $port;
 $3 = $0;
 $4 = (__ZNK6Packet6isDataEv($in)|0);
 if (!($4)) {
  STACKTOP = sp;return;
 }
 ;HEAP32[$2+0>>2]=HEAP32[$in+0>>2]|0;HEAP32[$2+4>>2]=HEAP32[$in+4>>2]|0;
 $5 = $1;
 ;HEAP32[$$byval_copy+0>>2]=HEAP32[$2+0>>2]|0;HEAP32[$$byval_copy+4>>2]=HEAP32[$2+4>>2]|0;
 __ZN9Component4sendE6Packeta($3,$$byval_copy,$5);
 STACKTOP = sp;return;
}
function __ZN12DigitalWriteD2Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 __ZN21SingleOutputComponentD2Ev($1);
 STACKTOP = sp;return;
}
function __ZN12DigitalWriteD0Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $3 = $0;
 __THREW__ = 0;
 invoke_vi(105,($3|0));
 $4 = __THREW__; __THREW__ = 0;
 $5 = $4&1;
 if (!($5)) {
  __ZdlPv($3);
  STACKTOP = sp;return;
 }
 $6 = ___cxa_find_matching_catch()|0;
 $7 = tempRet0;
 $1 = $6;
 $2 = $7;
 __ZdlPv($3);
 $8 = $1;
 $9 = $2;
 ___resumeException($8|0);
 // unreachable;
}
function __ZN12DigitalWrite7processE6Packeta($this,$in,$port) {
 $this = $this|0;
 $in = $in|0;
 $port = $port|0;
 var $$byval_copy = 0, $$byval_copy1 = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0;
 var $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0;
 var $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0;
 var sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $$byval_copy1 = sp + 32|0;
 $$byval_copy = sp + 24|0;
 $2 = sp + 8|0;
 $3 = sp;
 $0 = $this;
 $1 = $port;
 $4 = $0;
 $5 = (__ZNK6Packet7isSetupEv($in)|0);
 if ($5) {
  $6 = (($4) + 32|0);
  HEAP8[$6>>0] = -1;
  $7 = (($4) + 33|0);
  HEAP8[$7>>0] = 0;
  STACKTOP = sp;return;
 }
 $8 = $1;
 $9 = $8 << 24 >> 24;
 $10 = ($9|0)==(0);
 if ($10) {
  $11 = (__ZNK6Packet6isBoolEv($in)|0);
  if ($11) {
   $12 = (__ZNK6Packet6asBoolEv($in)|0);
   $13 = (($4) + 33|0);
   $14 = $12&1;
   HEAP8[$13>>0] = $14;
   $15 = (($4) + 32|0);
   $16 = HEAP8[$15>>0]|0;
   $17 = $16 << 24 >> 24;
   $18 = ($17|0)>=(0);
   if ($18) {
    $19 = (($4) + 4|0);
    $20 = HEAP32[$19>>2]|0;
    $21 = HEAP32[$20>>2]|0;
    $22 = (($21) + 36|0);
    $23 = HEAP32[$22>>2]|0;
    $24 = (($4) + 32|0);
    $25 = HEAP8[$24>>0]|0;
    $26 = (($4) + 33|0);
    $27 = HEAP8[$26>>0]|0;
    $28 = $27&1;
    FUNCTION_TABLE_viii[$23 & 255]($20,$25,$28);
    ;HEAP32[$2+0>>2]=HEAP32[$in+0>>2]|0;HEAP32[$2+4>>2]=HEAP32[$in+4>>2]|0;
    ;HEAP32[$$byval_copy+0>>2]=HEAP32[$2+0>>2]|0;HEAP32[$$byval_copy+4>>2]=HEAP32[$2+4>>2]|0;
    __ZN9Component4sendE6Packeta($4,$$byval_copy,0);
   }
  } else {
   label = 8;
  }
 } else {
  label = 8;
 }
 if ((label|0) == 8) {
  $29 = $1;
  $30 = $29 << 24 >> 24;
  $31 = ($30|0)==(1);
  if ($31) {
   $32 = (__ZNK6Packet8isNumberEv($in)|0);
   if ($32) {
    $33 = (__ZNK6Packet9asIntegerEv($in)|0);
    $34 = $33&255;
    $35 = (($4) + 32|0);
    HEAP8[$35>>0] = $34;
    $36 = (($4) + 4|0);
    $37 = HEAP32[$36>>2]|0;
    $38 = HEAP32[$37>>2]|0;
    $39 = (($38) + 28|0);
    $40 = HEAP32[$39>>2]|0;
    $41 = (($4) + 32|0);
    $42 = HEAP8[$41>>0]|0;
    FUNCTION_TABLE_viii[$40 & 255]($37,$42,1);
    $43 = (($4) + 32|0);
    $44 = HEAP8[$43>>0]|0;
    $45 = $44 << 24 >> 24;
    $46 = ($45|0)>=(0);
    if ($46) {
     $47 = (($4) + 4|0);
     $48 = HEAP32[$47>>2]|0;
     $49 = HEAP32[$48>>2]|0;
     $50 = (($49) + 36|0);
     $51 = HEAP32[$50>>2]|0;
     $52 = (($4) + 32|0);
     $53 = HEAP8[$52>>0]|0;
     $54 = (($4) + 33|0);
     $55 = HEAP8[$54>>0]|0;
     $56 = $55&1;
     FUNCTION_TABLE_viii[$51 & 255]($48,$53,$56);
     ;HEAP32[$3+0>>2]=HEAP32[$in+0>>2]|0;HEAP32[$3+4>>2]=HEAP32[$in+4>>2]|0;
     ;HEAP32[$$byval_copy1+0>>2]=HEAP32[$3+0>>2]|0;HEAP32[$$byval_copy1+4>>2]=HEAP32[$3+4>>2]|0;
     __ZN9Component4sendE6Packeta($4,$$byval_copy1,0);
    }
   }
  }
 }
 STACKTOP = sp;return;
}
function __ZN11DigitalReadD2Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 __ZN21SingleOutputComponentD2Ev($1);
 STACKTOP = sp;return;
}
function __ZN11DigitalReadD0Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $3 = $0;
 __THREW__ = 0;
 invoke_vi(108,($3|0));
 $4 = __THREW__; __THREW__ = 0;
 $5 = $4&1;
 if (!($5)) {
  __ZdlPv($3);
  STACKTOP = sp;return;
 }
 $6 = ___cxa_find_matching_catch()|0;
 $7 = tempRet0;
 $1 = $6;
 $2 = $7;
 __ZdlPv($3);
 $8 = $1;
 $9 = $2;
 ___resumeException($8|0);
 // unreachable;
}
function __ZN11DigitalRead7processE6Packeta($this,$in,$port) {
 $this = $this|0;
 $in = $in|0;
 $port = $port|0;
 var $$byval_copy = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0;
 var $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $isHigh = 0, $pinConfigPort = 0, $pullupConfigPort = 0;
 var $triggerPort = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $$byval_copy = sp + 24|0;
 $2 = sp;
 $0 = $this;
 $1 = $port;
 $3 = $0;
 $triggerPort = 0;
 $pinConfigPort = 1;
 $pullupConfigPort = 2;
 $4 = (__ZNK6Packet7isSetupEv($in)|0);
 if ($4) {
  __ZN11DigitalRead15setPinAndPullupEib($3,12,1);
  STACKTOP = sp;return;
 }
 $5 = $1;
 $6 = $5 << 24 >> 24;
 $7 = ($6|0)==(0);
 if ($7) {
  $8 = (__ZNK6Packet6isDataEv($in)|0);
  if ($8) {
   $9 = (($3) + 4|0);
   $10 = HEAP32[$9>>2]|0;
   $11 = HEAP32[$10>>2]|0;
   $12 = (($11) + 40|0);
   $13 = HEAP32[$12>>2]|0;
   $14 = (($3) + 32|0);
   $15 = HEAP8[$14>>0]|0;
   $16 = (FUNCTION_TABLE_iii[$13 & 255]($10,$15)|0);
   $17 = $16&1;
   $isHigh = $17;
   $18 = $isHigh;
   $19 = $18&1;
   __ZN6PacketC2Eb($2,$19);
   ;HEAP32[$$byval_copy+0>>2]=HEAP32[$2+0>>2]|0;HEAP32[$$byval_copy+4>>2]=HEAP32[$2+4>>2]|0;
   __ZN9Component4sendE6Packeta($3,$$byval_copy,0);
  } else {
   label = 6;
  }
 } else {
  label = 6;
 }
 if ((label|0) == 6) {
  $20 = $1;
  $21 = $20 << 24 >> 24;
  $22 = ($21|0)==(1);
  if ($22) {
   $23 = (__ZNK6Packet8isNumberEv($in)|0);
   if ($23) {
    $24 = (__ZNK6Packet9asIntegerEv($in)|0);
    $25 = (($3) + 33|0);
    $26 = HEAP8[$25>>0]|0;
    $27 = $26&1;
    __ZN11DigitalRead15setPinAndPullupEib($3,$24,$27);
   } else {
    label = 9;
   }
  } else {
   label = 9;
  }
  if ((label|0) == 9) {
   $28 = $1;
   $29 = $28 << 24 >> 24;
   $30 = ($29|0)==(2);
   if ($30) {
    $31 = (__ZNK6Packet6isBoolEv($in)|0);
    if ($31) {
     $32 = (($3) + 32|0);
     $33 = HEAP8[$32>>0]|0;
     $34 = $33 << 24 >> 24;
     $35 = (__ZNK6Packet6asBoolEv($in)|0);
     __ZN11DigitalRead15setPinAndPullupEib($3,$34,$35);
    }
   }
  }
 }
 STACKTOP = sp;return;
}
function __ZN11DigitalRead15setPinAndPullupEib($this,$newPin,$newPullup) {
 $this = $this|0;
 $newPin = $newPin|0;
 $newPullup = $newPullup|0;
 var $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0;
 var $27 = 0, $28 = 0, $29 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $newPin;
 $3 = $newPullup&1;
 $2 = $3;
 $4 = $0;
 $5 = $1;
 $6 = $5&255;
 $7 = (($4) + 32|0);
 HEAP8[$7>>0] = $6;
 $8 = $2;
 $9 = $8&1;
 $10 = (($4) + 33|0);
 $11 = $9&1;
 HEAP8[$10>>0] = $11;
 $12 = (($4) + 4|0);
 $13 = HEAP32[$12>>2]|0;
 $14 = HEAP32[$13>>2]|0;
 $15 = (($14) + 28|0);
 $16 = HEAP32[$15>>2]|0;
 $17 = (($4) + 32|0);
 $18 = HEAP8[$17>>0]|0;
 FUNCTION_TABLE_viii[$16 & 255]($13,$18,0);
 $19 = (($4) + 4|0);
 $20 = HEAP32[$19>>2]|0;
 $21 = HEAP32[$20>>2]|0;
 $22 = (($21) + 32|0);
 $23 = HEAP32[$22>>2]|0;
 $24 = (($4) + 32|0);
 $25 = HEAP8[$24>>0]|0;
 $26 = (($4) + 33|0);
 $27 = HEAP8[$26>>0]|0;
 $28 = $27&1;
 $29 = $28 ? 1 : 0;
 FUNCTION_TABLE_viii[$23 & 255]($20,$25,$29);
 STACKTOP = sp;return;
}
function __ZN5CountD2Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 __ZN21SingleOutputComponentD2Ev($1);
 STACKTOP = sp;return;
}
function __ZN5CountD0Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $3 = $0;
 __THREW__ = 0;
 invoke_vi(111,($3|0));
 $4 = __THREW__; __THREW__ = 0;
 $5 = $4&1;
 if (!($5)) {
  __ZdlPv($3);
  STACKTOP = sp;return;
 }
 $6 = ___cxa_find_matching_catch()|0;
 $7 = tempRet0;
 $1 = $6;
 $2 = $7;
 __ZdlPv($3);
 $8 = $1;
 $9 = $2;
 ___resumeException($8|0);
 // unreachable;
}
function __ZN5Count7processE6Packeta($this,$in,$port) {
 $this = $this|0;
 $in = $in|0;
 $port = $port|0;
 var $$byval_copy = 0, $$byval_copy1 = 0, $$byval_copy2 = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0;
 var $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0;
 var sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $$byval_copy2 = sp + 48|0;
 $$byval_copy1 = sp + 40|0;
 $$byval_copy = sp + 32|0;
 $2 = sp + 16|0;
 $3 = sp + 8|0;
 $4 = sp;
 $0 = $this;
 $1 = $port;
 $5 = $0;
 $6 = (__ZNK6Packet7isSetupEv($in)|0);
 if ($6) {
  $7 = (($5) + 32|0);
  HEAP32[$7>>2] = 0;
  $8 = (($5) + 36|0);
  HEAP8[$8>>0] = 0;
  $9 = (($5) + 32|0);
  $10 = HEAP32[$9>>2]|0;
  __ZN6PacketC2El($2,$10);
  ;HEAP32[$$byval_copy+0>>2]=HEAP32[$2+0>>2]|0;HEAP32[$$byval_copy+4>>2]=HEAP32[$2+4>>2]|0;
  __ZN9Component4sendE6Packeta($5,$$byval_copy,0);
  STACKTOP = sp;return;
 }
 $11 = $1;
 $12 = $11 << 24 >> 24;
 $13 = ($12|0)==(0);
 if ($13) {
  $14 = (($5) + 36|0);
  $15 = HEAP8[$14>>0]|0;
  $16 = $15&1;
  if (!($16)) {
   $17 = (($5) + 32|0);
   $18 = HEAP32[$17>>2]|0;
   $19 = (($18) + 1)|0;
   HEAP32[$17>>2] = $19;
   $20 = (($5) + 32|0);
   $21 = HEAP32[$20>>2]|0;
   __ZN6PacketC2El($3,$21);
   ;HEAP32[$$byval_copy1+0>>2]=HEAP32[$3+0>>2]|0;HEAP32[$$byval_copy1+4>>2]=HEAP32[$3+4>>2]|0;
   __ZN9Component4sendE6Packeta($5,$$byval_copy1,0);
  }
 } else {
  $22 = $1;
  $23 = $22 << 24 >> 24;
  $24 = ($23|0)==(1);
  if ($24) {
   $25 = (__ZNK6Packet6isBoolEv($in)|0);
   if ($25) {
    $26 = (__ZNK6Packet6asBoolEv($in)|0);
    $27 = (($5) + 36|0);
    $28 = $26&1;
    HEAP8[$27>>0] = $28;
   }
   $29 = (($5) + 36|0);
   $30 = HEAP8[$29>>0]|0;
   $31 = $30&1;
   if ($31) {
    label = 12;
   } else {
    $32 = (__ZNK6Packet6isVoidEv($in)|0);
    if ($32) {
     label = 12;
    }
   }
   if ((label|0) == 12) {
    $33 = (($5) + 32|0);
    HEAP32[$33>>2] = 0;
    $34 = (($5) + 32|0);
    $35 = HEAP32[$34>>2]|0;
    __ZN6PacketC2El($4,$35);
    ;HEAP32[$$byval_copy2+0>>2]=HEAP32[$4+0>>2]|0;HEAP32[$$byval_copy2+4>>2]=HEAP32[$4+4>>2]|0;
    __ZN9Component4sendE6Packeta($5,$$byval_copy2,0);
   }
  }
 }
 STACKTOP = sp;return;
}
function __ZN9ConstrainD2Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 __ZN21SingleOutputComponentD2Ev($1);
 STACKTOP = sp;return;
}
function __ZN9ConstrainD0Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $3 = $0;
 __THREW__ = 0;
 invoke_vi(114,($3|0));
 $4 = __THREW__; __THREW__ = 0;
 $5 = $4&1;
 if (!($5)) {
  __ZdlPv($3);
  STACKTOP = sp;return;
 }
 $6 = ___cxa_find_matching_catch()|0;
 $7 = tempRet0;
 $1 = $6;
 $2 = $7;
 __ZdlPv($3);
 $8 = $1;
 $9 = $2;
 ___resumeException($8|0);
 // unreachable;
}
function __ZN9Constrain7processE6Packeta($this,$in,$port) {
 $this = $this|0;
 $in = $in|0;
 $port = $port|0;
 var $$byval_copy = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0;
 var $26 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $$byval_copy = sp + 16|0;
 $2 = sp;
 $0 = $this;
 $1 = $port;
 $3 = $0;
 $4 = (__ZNK6Packet7isSetupEv($in)|0);
 if ($4) {
  $5 = (($3) + 32|0);
  HEAP32[$5>>2] = 0;
  $6 = (($3) + 36|0);
  HEAP32[$6>>2] = 0;
  $7 = (($3) + 40|0);
  HEAP32[$7>>2] = 0;
  STACKTOP = sp;return;
 }
 $8 = $1;
 $9 = $8 << 24 >> 24;
 $10 = ($9|0)==(1);
 if ($10) {
  $11 = (__ZNK6Packet6isDataEv($in)|0);
  if ($11) {
   $12 = (__ZNK6Packet9asIntegerEv($in)|0);
   $13 = (($3) + 32|0);
   HEAP32[$13>>2] = $12;
  } else {
   label = 6;
  }
 } else {
  label = 6;
 }
 if ((label|0) == 6) {
  $14 = $1;
  $15 = $14 << 24 >> 24;
  $16 = ($15|0)==(2);
  if ($16) {
   $17 = (__ZNK6Packet6isDataEv($in)|0);
   if ($17) {
    $18 = (__ZNK6Packet9asIntegerEv($in)|0);
    $19 = (($3) + 36|0);
    HEAP32[$19>>2] = $18;
   } else {
    label = 9;
   }
  } else {
   label = 9;
  }
  if ((label|0) == 9) {
   $20 = $1;
   $21 = $20 << 24 >> 24;
   $22 = ($21|0)==(0);
   if ($22) {
    $23 = (__ZNK6Packet8isNumberEv($in)|0);
    if ($23) {
     $24 = (__ZNK6Packet9asIntegerEv($in)|0);
     $25 = (($3) + 40|0);
     HEAP32[$25>>2] = $24;
     $26 = (__ZN9Constrain10_constrainEv($3)|0);
     __ZN6PacketC2El($2,$26);
     ;HEAP32[$$byval_copy+0>>2]=HEAP32[$2+0>>2]|0;HEAP32[$$byval_copy+4>>2]=HEAP32[$2+4>>2]|0;
     __ZN9Component4sendE6Packeta($3,$$byval_copy,0);
    }
   }
  }
 }
 STACKTOP = sp;return;
}
function __ZN9Constrain10_constrainEv($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 var label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $1 = $this;
 $2 = $1;
 $3 = (($2) + 40|0);
 $4 = HEAP32[$3>>2]|0;
 $5 = (($2) + 36|0);
 $6 = HEAP32[$5>>2]|0;
 $7 = ($4|0)>($6|0);
 if ($7) {
  $8 = (($2) + 36|0);
  $9 = HEAP32[$8>>2]|0;
  $0 = $9;
  $19 = $0;
  STACKTOP = sp;return ($19|0);
 }
 $10 = (($2) + 40|0);
 $11 = HEAP32[$10>>2]|0;
 $12 = (($2) + 32|0);
 $13 = HEAP32[$12>>2]|0;
 $14 = ($11|0)<($13|0);
 if ($14) {
  $15 = (($2) + 32|0);
  $16 = HEAP32[$15>>2]|0;
  $0 = $16;
  $19 = $0;
  STACKTOP = sp;return ($19|0);
 } else {
  $17 = (($2) + 40|0);
  $18 = HEAP32[$17>>2]|0;
  $0 = $18;
  $19 = $0;
  STACKTOP = sp;return ($19|0);
 }
 return (0)|0;
}
function __ZN15BreakBeforeMakeD2Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 __ZN9ComponentD2Ev($1);
 STACKTOP = sp;return;
}
function __ZN15BreakBeforeMakeD0Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $3 = $0;
 __THREW__ = 0;
 invoke_vi(117,($3|0));
 $4 = __THREW__; __THREW__ = 0;
 $5 = $4&1;
 if (!($5)) {
  __ZdlPv($3);
  STACKTOP = sp;return;
 }
 $6 = ___cxa_find_matching_catch()|0;
 $7 = tempRet0;
 $1 = $6;
 $2 = $7;
 __ZdlPv($3);
 $8 = $1;
 $9 = $2;
 ___resumeException($8|0);
 // unreachable;
}
function __ZN15BreakBeforeMake7processE6Packeta($this,$in,$port) {
 $this = $this|0;
 $in = $in|0;
 $port = $port|0;
 var $$byval_copy = 0, $$byval_copy1 = 0, $$byval_copy2 = 0, $$byval_copy3 = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0;
 var $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $5 = 0;
 var $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 80|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $$byval_copy3 = sp + 64|0;
 $$byval_copy2 = sp + 56|0;
 $$byval_copy1 = sp + 48|0;
 $$byval_copy = sp + 40|0;
 $2 = sp + 24|0;
 $3 = sp + 16|0;
 $4 = sp + 8|0;
 $5 = sp;
 $0 = $this;
 $1 = $port;
 $6 = $0;
 $7 = (($6) + 24|0);
 $8 = HEAP32[$7>>2]|0;
 switch ($8|0) {
 case 2:  {
  $25 = $1;
  $26 = $25 << 24 >> 24;
  $27 = ($26|0)==(1);
  if ($27) {
   $28 = (__ZNK6Packet6asBoolEv($in)|0);
   if (!($28)) {
    __ZN6PacketC2Eb($4,1);
    ;HEAP32[$$byval_copy2+0>>2]=HEAP32[$4+0>>2]|0;HEAP32[$$byval_copy2+4>>2]=HEAP32[$4+4>>2]|0;
    __ZN9Component4sendE6Packeta($6,$$byval_copy2,1);
    $29 = (($6) + 24|0);
    HEAP32[$29>>2] = 3;
   }
  }
  STACKTOP = sp;return;
  break;
 }
 case 5:  {
  $35 = $1;
  $36 = $35 << 24 >> 24;
  $37 = ($36|0)==(0);
  if ($37) {
   $38 = (__ZNK6Packet6asBoolEv($in)|0);
   if (!($38)) {
    __ZN6PacketC2Eb($5,0);
    ;HEAP32[$$byval_copy3+0>>2]=HEAP32[$5+0>>2]|0;HEAP32[$$byval_copy3+4>>2]=HEAP32[$5+4>>2]|0;
    __ZN9Component4sendE6Packeta($6,$$byval_copy3,1);
    $39 = (($6) + 24|0);
    HEAP32[$39>>2] = 4;
   }
  }
  break;
 }
 case 3:  {
  $30 = $1;
  $31 = $30 << 24 >> 24;
  $32 = ($31|0)==(2);
  if ($32) {
   $33 = (__ZNK6Packet6asBoolEv($in)|0);
   if ($33) {
    $34 = (($6) + 24|0);
    HEAP32[$34>>2] = 5;
   }
  }
  STACKTOP = sp;return;
  break;
 }
 case 6:  {
  $20 = $1;
  $21 = $20 << 24 >> 24;
  $22 = ($21|0)==(0);
  if ($22) {
   $23 = (__ZNK6Packet6asBoolEv($in)|0);
   if ($23) {
    __ZN6PacketC2Eb($3,0);
    ;HEAP32[$$byval_copy1+0>>2]=HEAP32[$3+0>>2]|0;HEAP32[$$byval_copy1+4>>2]=HEAP32[$3+4>>2]|0;
    __ZN9Component4sendE6Packeta($6,$$byval_copy1,0);
    $24 = (($6) + 24|0);
    HEAP32[$24>>2] = 2;
   }
  }
  STACKTOP = sp;return;
  break;
 }
 case 0:  {
  $9 = (($6) + 24|0);
  HEAP32[$9>>2] = 6;
  STACKTOP = sp;return;
  break;
 }
 case 1:  {
  $15 = $1;
  $16 = $15 << 24 >> 24;
  $17 = ($16|0)==(1);
  if ($17) {
   $18 = (__ZNK6Packet6asBoolEv($in)|0);
   if ($18) {
    $19 = (($6) + 24|0);
    HEAP32[$19>>2] = 6;
   }
  }
  STACKTOP = sp;return;
  break;
 }
 case 4:  {
  $10 = $1;
  $11 = $10 << 24 >> 24;
  $12 = ($11|0)==(2);
  if ($12) {
   $13 = (__ZNK6Packet6asBoolEv($in)|0);
   if (!($13)) {
    __ZN6PacketC2Eb($2,1);
    ;HEAP32[$$byval_copy+0>>2]=HEAP32[$2+0>>2]|0;HEAP32[$$byval_copy+4>>2]=HEAP32[$2+4>>2]|0;
    __ZN9Component4sendE6Packeta($6,$$byval_copy,0);
    $14 = (($6) + 24|0);
    HEAP32[$14>>2] = 1;
   }
  }
  STACKTOP = sp;return;
  break;
 }
 default: {
 }
 }
 STACKTOP = sp;return;
}
function __ZN10ArduinoUnoD2Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 __ZN9ComponentD2Ev($1);
 STACKTOP = sp;return;
}
function __ZN10ArduinoUnoD0Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $3 = $0;
 __THREW__ = 0;
 invoke_vi(120,($3|0));
 $4 = __THREW__; __THREW__ = 0;
 $5 = $4&1;
 if (!($5)) {
  __ZdlPv($3);
  STACKTOP = sp;return;
 }
 $6 = ___cxa_find_matching_catch()|0;
 $7 = tempRet0;
 $1 = $6;
 $2 = $7;
 __ZdlPv($3);
 $8 = $1;
 $9 = $2;
 ___resumeException($8|0);
 // unreachable;
}
function __ZN10ArduinoUno7processE6Packeta($this,$in,$port) {
 $this = $this|0;
 $in = $in|0;
 $port = $port|0;
 var $$byval_copy = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 var $8 = 0, $9 = 0, $analogPins = 0, $digitalPins = 0, $outPort = 0, $val = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $$byval_copy = sp + 16|0;
 $2 = sp;
 $0 = $this;
 $1 = $port;
 $3 = $0;
 $digitalPins = 14;
 $analogPins = 6;
 $4 = (__ZNK6Packet7isSetupEv($in)|0);
 if (!($4)) {
  STACKTOP = sp;return;
 }
 $outPort = 0;
 while(1) {
  $5 = $outPort;
  $6 = $5 << 24 >> 24;
  $7 = ($6|0)<(20);
  if (!($7)) {
   break;
  }
  $8 = $outPort;
  $9 = $8 << 24 >> 24;
  $10 = ($9|0)<(14);
  if ($10) {
   $11 = $outPort;
   $12 = $11 << 24 >> 24;
   $16 = $12;
  } else {
   $13 = $outPort;
   $14 = $13 << 24 >> 24;
   $15 = (($14) - 14)|0;
   $16 = $15;
  }
  $val = $16;
  $17 = $val;
  __ZN6PacketC2El($2,$17);
  $18 = $outPort;
  ;HEAP32[$$byval_copy+0>>2]=HEAP32[$2+0>>2]|0;HEAP32[$$byval_copy+4>>2]=HEAP32[$2+4>>2]|0;
  __ZN9Component4sendE6Packeta($3,$$byval_copy,$18);
  $19 = $outPort;
  $20 = (($19) + 1)<<24>>24;
  $outPort = $20;
 }
 STACKTOP = sp;return;
}
function __ZN10AnalogReadD2Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 __ZN21SingleOutputComponentD2Ev($1);
 STACKTOP = sp;return;
}
function __ZN10AnalogReadD0Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $3 = $0;
 __THREW__ = 0;
 invoke_vi(123,($3|0));
 $4 = __THREW__; __THREW__ = 0;
 $5 = $4&1;
 if (!($5)) {
  __ZdlPv($3);
  STACKTOP = sp;return;
 }
 $6 = ___cxa_find_matching_catch()|0;
 $7 = tempRet0;
 $1 = $6;
 $2 = $7;
 __ZdlPv($3);
 $8 = $1;
 $9 = $2;
 ___resumeException($8|0);
 // unreachable;
}
function __ZN10AnalogRead7processE6Packeta($this,$in,$port) {
 $this = $this|0;
 $in = $in|0;
 $port = $port|0;
 var $$byval_copy = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0;
 var $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $val = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $$byval_copy = sp + 16|0;
 $2 = sp;
 $0 = $this;
 $1 = $port;
 $3 = $0;
 $4 = (__ZNK6Packet7isSetupEv($in)|0);
 if ($4) {
  STACKTOP = sp;return;
 }
 $5 = $1;
 $6 = $5 << 24 >> 24;
 $7 = ($6|0)==(0);
 if ($7) {
  $8 = (__ZNK6Packet6isDataEv($in)|0);
  if ($8) {
   $9 = (($3) + 4|0);
   $10 = HEAP32[$9>>2]|0;
   $11 = HEAP32[$10>>2]|0;
   $12 = (($11) + 44|0);
   $13 = HEAP32[$12>>2]|0;
   $14 = (($3) + 32|0);
   $15 = HEAP8[$14>>0]|0;
   $16 = (FUNCTION_TABLE_iii[$13 & 255]($10,$15)|0);
   $val = $16;
   $17 = $val;
   __ZN6PacketC2El($2,$17);
   ;HEAP32[$$byval_copy+0>>2]=HEAP32[$2+0>>2]|0;HEAP32[$$byval_copy+4>>2]=HEAP32[$2+4>>2]|0;
   __ZN9Component4sendE6Packeta($3,$$byval_copy,0);
  } else {
   label = 6;
  }
 } else {
  label = 6;
 }
 if ((label|0) == 6) {
  $18 = $1;
  $19 = $18 << 24 >> 24;
  $20 = ($19|0)==(1);
  if ($20) {
   $21 = (__ZNK6Packet8isNumberEv($in)|0);
   if ($21) {
    $22 = (__ZNK6Packet9asIntegerEv($in)|0);
    $23 = $22&255;
    $24 = (($3) + 32|0);
    HEAP8[$24>>0] = $23;
    $25 = (($3) + 4|0);
    $26 = HEAP32[$25>>2]|0;
    $27 = HEAP32[$26>>2]|0;
    $28 = (($27) + 28|0);
    $29 = HEAP32[$28>>2]|0;
    $30 = (($3) + 32|0);
    $31 = HEAP8[$30>>0]|0;
    FUNCTION_TABLE_viii[$29 & 255]($26,$31,0);
   }
  }
 }
 STACKTOP = sp;return;
}
function __ZN12EmscriptenIO5setupEP13HostTransport($this,$t) {
 $this = $this|0;
 $t = $t|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $t;
 $2 = $0;
 $3 = $1;
 $4 = (($2) + 32|0);
 HEAP32[$4>>2] = $3;
 STACKTOP = sp;return;
}
function __ZN12EmscriptenIOD2Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 __ZN2IOD2Ev($1);
 STACKTOP = sp;return;
}
function __ZN12EmscriptenIOC2Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $i = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 __ZN2IOC2Ev($1);
 $2 = (2592 + 8|0);
 HEAP32[$1>>2] = $2;
 $3 = (($1) + 8|0);
 HEAP32[$3>>2] = 0;
 $4 = (($1) + 32|0);
 HEAP32[$4>>2] = 0;
 $i = 0;
 while(1) {
  $5 = $i;
  $6 = $5&255;
  $7 = ($6|0)<(20);
  if (!($7)) {
   break;
  }
  $8 = $i;
  $9 = $8&255;
  $10 = (($1) + 12|0);
  $11 = (($10) + ($9)|0);
  HEAP8[$11>>0] = 0;
  $12 = $i;
  $13 = (($12) + 1)<<24>>24;
  $i = $13;
 }
 STACKTOP = sp;return;
}
function __ZN23EmscriptenHostTransportC2Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 __ZN13HostTransportC2Ev($1);
 $2 = (400 + 8|0);
 HEAP32[$1>>2] = $2;
 $3 = (($1) + 4|0);
 HEAP32[$3>>2] = 0;
 $4 = (($1) + 8|0);
 HEAP32[$4>>2] = 0;
 STACKTOP = sp;return;
}
function __ZN2IOC2Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 $2 = (2712 + 8|0);
 HEAP32[$1>>2] = $2;
 STACKTOP = sp;return;
}
function __ZN12EmscriptenIOD0Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $3 = $0;
 __THREW__ = 0;
 invoke_vi(126,($3|0));
 $4 = __THREW__; __THREW__ = 0;
 $5 = $4&1;
 if (!($5)) {
  __ZdlPv($3);
  STACKTOP = sp;return;
 }
 $6 = ___cxa_find_matching_catch()|0;
 $7 = tempRet0;
 $1 = $6;
 $2 = $7;
 __ZdlPv($3);
 $8 = $1;
 $9 = $2;
 ___resumeException($8|0);
 // unreachable;
}
function __ZN12EmscriptenIO10setIoValueEPKhh($this,$buf,$len) {
 $this = $this|0;
 $buf = $buf|0;
 $len = $len|0;
 var $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0;
 var $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0;
 var $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0;
 var $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0;
 var $81 = 0, $82 = 0, $83 = 0, $9 = 0, $b = 0, $b1 = 0, $pin = 0, $type = 0, $val = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $b = sp + 17|0;
 $b1 = sp + 12|0;
 $0 = $this;
 $1 = $buf;
 $2 = $len;
 $3 = $0;
 $4 = $1;
 $5 = (($4) + 1|0);
 $6 = HEAP8[$5>>0]|0;
 $7 = $6&255;
 $type = $7;
 $8 = $type;
 $9 = ($8|0)==(1);
 if ($9) {
  $10 = (($3) + 4|0);
  $11 = HEAP32[$10>>2]|0;
  __ZL14microflo_debugP12DebugHandler10DebugLevel7DebugId($11,1,34);
  STACKTOP = sp;return;
 }
 $12 = $type;
 $13 = ($12|0)==(2);
 if ($13) {
  $14 = $1;
  $15 = (($14) + 2|0);
  $16 = HEAP8[$15>>0]|0;
  $pin = $16;
  $17 = $1;
  $18 = (($17) + 3|0);
  $19 = HEAP8[$18>>0]|0;
  $20 = ($19<<24>>24)!=(0);
  $21 = $20&1;
  $val = $21;
  $22 = $pin;
  $23 = $22&255;
  $24 = ($23|0)<(20);
  if ($24) {
   $25 = $val;
   $26 = $25&1;
   $27 = $pin;
   $28 = $27&255;
   $29 = (($3) + 12|0);
   $30 = (($29) + ($28)|0);
   $31 = $26&1;
   HEAP8[$30>>0] = $31;
   HEAP8[$b>>0] = 112;
   $32 = (($b) + 1|0);
   $33 = $1;
   $34 = (($33) + 1|0);
   $35 = HEAP8[$34>>0]|0;
   HEAP8[$32>>0] = $35;
   $36 = (($32) + 1|0);
   $37 = $1;
   $38 = (($37) + 2|0);
   $39 = HEAP8[$38>>0]|0;
   HEAP8[$36>>0] = $39;
   $40 = (($36) + 1|0);
   $41 = $1;
   $42 = (($41) + 3|0);
   $43 = HEAP8[$42>>0]|0;
   HEAP8[$40>>0] = $43;
   $44 = (($40) + 1|0);
   $45 = $1;
   $46 = (($45) + 4|0);
   $47 = HEAP8[$46>>0]|0;
   HEAP8[$44>>0] = $47;
   $48 = (($3) + 32|0);
   $49 = HEAP32[$48>>2]|0;
   $50 = HEAP32[$49>>2]|0;
   $51 = (($50) + 8|0);
   $52 = HEAP32[$51>>2]|0;
   FUNCTION_TABLE_viii[$52 & 255]($49,$b,5);
  } else {
   $53 = (($3) + 4|0);
   $54 = HEAP32[$53>>2]|0;
   __ZL14microflo_debugP12DebugHandler10DebugLevel7DebugId($54,1,33);
  }
 } else {
  $55 = $type;
  $56 = ($55|0)==(3);
  if ($56) {
   $57 = $1;
   $58 = (($57) + 2|0);
   $59 = (__ZL8readLongPKh($58)|0);
   $60 = (($3) + 8|0);
   HEAP32[$60>>2] = $59;
   HEAP8[$b1>>0] = 112;
   $61 = (($b1) + 1|0);
   $62 = $1;
   $63 = (($62) + 1|0);
   $64 = HEAP8[$63>>0]|0;
   HEAP8[$61>>0] = $64;
   $65 = (($61) + 1|0);
   $66 = $1;
   $67 = (($66) + 2|0);
   $68 = HEAP8[$67>>0]|0;
   HEAP8[$65>>0] = $68;
   $69 = (($65) + 1|0);
   $70 = $1;
   $71 = (($70) + 3|0);
   $72 = HEAP8[$71>>0]|0;
   HEAP8[$69>>0] = $72;
   $73 = (($69) + 1|0);
   $74 = $1;
   $75 = (($74) + 4|0);
   $76 = HEAP8[$75>>0]|0;
   HEAP8[$73>>0] = $76;
   $77 = (($3) + 32|0);
   $78 = HEAP32[$77>>2]|0;
   $79 = HEAP32[$78>>2]|0;
   $80 = (($79) + 8|0);
   $81 = HEAP32[$80>>2]|0;
   FUNCTION_TABLE_viii[$81 & 255]($78,$b1,5);
  } else {
   $82 = (($3) + 4|0);
   $83 = HEAP32[$82>>2]|0;
   __ZL14microflo_debugP12DebugHandler10DebugLevel7DebugId($83,1,34);
  }
 }
 STACKTOP = sp;return;
}
function __ZN12EmscriptenIO11SerialBeginEhi($this,$serialDevice,$baudrate) {
 $this = $this|0;
 $serialDevice = $serialDevice|0;
 $baudrate = $baudrate|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $serialDevice;
 $2 = $baudrate;
 $3 = $0;
 $4 = (($3) + 4|0);
 $5 = HEAP32[$4>>2]|0;
 __ZL14microflo_debugP12DebugHandler10DebugLevel7DebugId($5,1,26);
 STACKTOP = sp;return;
}
function __ZN12EmscriptenIO19SerialDataAvailableEh($this,$serialDevice) {
 $this = $this|0;
 $serialDevice = $serialDevice|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $serialDevice;
 $2 = $0;
 $3 = (($2) + 4|0);
 $4 = HEAP32[$3>>2]|0;
 __ZL14microflo_debugP12DebugHandler10DebugLevel7DebugId($4,1,26);
 STACKTOP = sp;return 0;
}
function __ZN12EmscriptenIO10SerialReadEh($this,$serialDevice) {
 $this = $this|0;
 $serialDevice = $serialDevice|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $serialDevice;
 $2 = $0;
 $3 = (($2) + 4|0);
 $4 = HEAP32[$3>>2]|0;
 __ZL14microflo_debugP12DebugHandler10DebugLevel7DebugId($4,1,26);
 STACKTOP = sp;return 0;
}
function __ZN12EmscriptenIO11SerialWriteEhh($this,$serialDevice,$b) {
 $this = $this|0;
 $serialDevice = $serialDevice|0;
 $b = $b|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $serialDevice;
 $2 = $b;
 $3 = $0;
 $4 = (($3) + 4|0);
 $5 = HEAP32[$4>>2]|0;
 __ZL14microflo_debugP12DebugHandler10DebugLevel7DebugId($5,1,26);
 STACKTOP = sp;return;
}
function __ZN12EmscriptenIO10PinSetModeEaN2IO7PinModeE($this,$pin,$mode) {
 $this = $this|0;
 $pin = $pin|0;
 $mode = $mode|0;
 var $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $b = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $b = sp + 8|0;
 $0 = $this;
 $1 = $pin;
 $2 = $mode;
 $3 = $0;
 HEAP8[$b>>0] = 113;
 $4 = (($b) + 1|0);
 HEAP8[$4>>0] = 4;
 $5 = (($4) + 1|0);
 $6 = $1;
 HEAP8[$5>>0] = $6;
 $7 = (($5) + 1|0);
 $8 = $2;
 $9 = $8&255;
 HEAP8[$7>>0] = $9;
 $10 = (($3) + 32|0);
 $11 = HEAP32[$10>>2]|0;
 $12 = HEAP32[$11>>2]|0;
 $13 = (($12) + 8|0);
 $14 = HEAP32[$13>>2]|0;
 FUNCTION_TABLE_viii[$14 & 255]($11,$b,4);
 STACKTOP = sp;return;
}
function __ZN12EmscriptenIO12PinSetPullupEaN2IO10PullupModeE($this,$pin,$mode) {
 $this = $this|0;
 $pin = $pin|0;
 $mode = $mode|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $pin;
 $2 = $mode;
 $3 = $0;
 $4 = (($3) + 4|0);
 $5 = HEAP32[$4>>2]|0;
 __ZL14microflo_debugP12DebugHandler10DebugLevel7DebugId($5,1,26);
 STACKTOP = sp;return;
}
function __ZN12EmscriptenIO12DigitalWriteEab($this,$pin,$val) {
 $this = $this|0;
 $pin = $pin|0;
 $val = $val|0;
 var $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $b = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $b = sp + 4|0;
 $0 = $this;
 $1 = $pin;
 $3 = $val&1;
 $2 = $3;
 $4 = $0;
 HEAP8[$b>>0] = 113;
 $5 = (($b) + 1|0);
 HEAP8[$5>>0] = 2;
 $6 = (($5) + 1|0);
 $7 = $1;
 HEAP8[$6>>0] = $7;
 $8 = (($6) + 1|0);
 $9 = $2;
 $10 = $9&1;
 $11 = $10&1;
 HEAP8[$8>>0] = $11;
 $12 = (($4) + 32|0);
 $13 = HEAP32[$12>>2]|0;
 $14 = HEAP32[$13>>2]|0;
 $15 = (($14) + 8|0);
 $16 = HEAP32[$15>>2]|0;
 FUNCTION_TABLE_viii[$16 & 255]($13,$b,4);
 STACKTOP = sp;return;
}
function __ZN12EmscriptenIO11DigitalReadEa($this,$pin) {
 $this = $this|0;
 $pin = $pin|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $pin;
 $2 = $0;
 $3 = $1;
 $4 = $3 << 24 >> 24;
 $5 = (($2) + 12|0);
 $6 = (($5) + ($4)|0);
 $7 = HEAP8[$6>>0]|0;
 $8 = $7&1;
 STACKTOP = sp;return ($8|0);
}
function __ZN12EmscriptenIO10AnalogReadEa($this,$pin) {
 $this = $this|0;
 $pin = $pin|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $pin;
 $2 = $0;
 $3 = (($2) + 4|0);
 $4 = HEAP32[$3>>2]|0;
 __ZL14microflo_debugP12DebugHandler10DebugLevel7DebugId($4,1,26);
 STACKTOP = sp;return 0;
}
function __ZN12EmscriptenIO8PwmWriteEal($this,$pin,$dutyPercent) {
 $this = $this|0;
 $pin = $pin|0;
 $dutyPercent = $dutyPercent|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $pin;
 $2 = $dutyPercent;
 $3 = $0;
 $4 = (($3) + 4|0);
 $5 = HEAP32[$4>>2]|0;
 __ZL14microflo_debugP12DebugHandler10DebugLevel7DebugId($5,1,26);
 STACKTOP = sp;return;
}
function __ZN12EmscriptenIO14TimerCurrentMsEv($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 $2 = (($1) + 8|0);
 $3 = HEAP32[$2>>2]|0;
 STACKTOP = sp;return ($3|0);
}
function __ZN2IO18TimerCurrentMicrosEv($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 $2 = HEAP32[$1>>2]|0;
 $3 = (($2) + 52|0);
 $4 = HEAP32[$3>>2]|0;
 $5 = (FUNCTION_TABLE_ii[$4 & 255]($1)|0);
 $6 = ($5*1000)|0;
 STACKTOP = sp;return ($6|0);
}
function __ZN12EmscriptenIO23AttachExternalInterruptEhN2IO9Interrupt4ModeEPFvPvES3_($this,$interrupt,$mode,$func,$user) {
 $this = $this|0;
 $interrupt = $interrupt|0;
 $mode = $mode|0;
 $func = $func|0;
 $user = $user|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $interrupt;
 $2 = $mode;
 $3 = $func;
 $4 = $user;
 $5 = $0;
 $6 = (($5) + 4|0);
 $7 = HEAP32[$6>>2]|0;
 __ZL14microflo_debugP12DebugHandler10DebugLevel7DebugId($7,1,26);
 STACKTOP = sp;return;
}
function __ZL8readLongPKh($buf) {
 $buf = $buf|0;
 var $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 var $8 = 0, $9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $buf;
 $1 = $0;
 $2 = HEAP8[$1>>0]|0;
 $3 = $2&255;
 $4 = $0;
 $5 = (($4) + 1|0);
 $6 = HEAP8[$5>>0]|0;
 $7 = $6&255;
 $8 = $7<<8;
 $9 = (($3) + ($8))|0;
 $10 = $0;
 $11 = (($10) + 2|0);
 $12 = HEAP8[$11>>0]|0;
 $13 = $12&255;
 $14 = $13<<16;
 $15 = (($9) + ($14))|0;
 $16 = $0;
 $17 = (($16) + 3|0);
 $18 = HEAP8[$17>>0]|0;
 $19 = $18&255;
 $20 = $19<<24;
 $21 = (($15) + ($20))|0;
 STACKTOP = sp;return ($21|0);
}
function __ZN2IOD2Ev($this) {
 $this = $this|0;
 var $0 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 STACKTOP = sp;return;
}
function __ZN2IOD0Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $3 = $0;
 __THREW__ = 0;
 invoke_vi(142,($3|0));
 $4 = __THREW__; __THREW__ = 0;
 $5 = $4&1;
 if (!($5)) {
  __ZdlPv($3);
  STACKTOP = sp;return;
 }
 $6 = ___cxa_find_matching_catch()|0;
 $7 = tempRet0;
 $1 = $6;
 $2 = $7;
 __ZdlPv($3);
 $8 = $1;
 $9 = $2;
 ___resumeException($8|0);
 // unreachable;
}
function __ZN2IO10setIoValueEPKhh($this,$0,$1) {
 $this = $this|0;
 $0 = $0|0;
 $1 = $1|0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $2 = $this;
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $6 = (($5) + 4|0);
 $7 = HEAP32[$6>>2]|0;
 __ZL14microflo_debugP12DebugHandler10DebugLevel7DebugId($7,1,26);
 STACKTOP = sp;return;
}
function __ZN9ComponentD2Ev($this) {
 $this = $this|0;
 var $0 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 STACKTOP = sp;return;
}
function __ZN9ComponentD0Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $3 = $0;
 __THREW__ = 0;
 invoke_vi(145,($3|0));
 $4 = __THREW__; __THREW__ = 0;
 $5 = $4&1;
 if (!($5)) {
  __ZdlPv($3);
  STACKTOP = sp;return;
 }
 $6 = ___cxa_find_matching_catch()|0;
 $7 = tempRet0;
 $1 = $6;
 $2 = $7;
 __ZdlPv($3);
 $8 = $1;
 $9 = $2;
 ___resumeException($8|0);
 // unreachable;
}
function __ZNK6Packet7isFloatEv($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 $2 = (($1) + 4|0);
 $3 = HEAP32[$2>>2]|0;
 $4 = ($3|0)==(8);
 STACKTOP = sp;return ($4|0);
}
function __ZNK6Packet9isSpecialEv($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 $2 = (__ZNK6Packet7isSetupEv($1)|0);
 if ($2) {
  $4 = 1;
 } else {
  $3 = (__ZNK6Packet6isTickEv($1)|0);
  $4 = $3;
 }
 STACKTOP = sp;return ($4|0);
}
function __ZN12DebugHandlerC2Ev($this) {
 $this = $this|0;
 var $0 = 0, $1 = 0, $2 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $0 = $this;
 $1 = $0;
 $2 = (2880 + 8|0);
 HEAP32[$1>>2] = $2;
 STACKTOP = sp;return;
}
function _abort_message($format,$varargs) {
 $format = $format|0;
 $varargs = $varargs|0;
 var $0 = 0, $list = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $list = sp;
 HEAP32[$list>>2] = $varargs;
 $0 = HEAP32[_stderr>>2]|0;
 (_vfprintf(($0|0),($format|0),($list|0))|0);
 (_fputc(10,($0|0))|0);
 _abort();
 // unreachable;
}
function ___cxa_get_globals_fast() {
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $vararg_buffer = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $vararg_buffer = sp;
 $0 = (_pthread_once((3088|0),(203|0))|0);
 $1 = ($0|0)==(0);
 if ($1) {
  $2 = HEAP32[3080>>2]|0;
  $3 = (_pthread_getspecific(($2|0))|0);
  STACKTOP = sp;return ($3|0);
 } else {
  _abort_message(3096,$vararg_buffer);
  // unreachable;
 }
 return (0)|0;
}
function __ZNSt9bad_allocC2Ev($this) {
 $this = $this|0;
 var label = 0, sp = 0;
 sp = STACKTOP;
 HEAP32[$this>>2] = ((3264 + 8|0));
 STACKTOP = sp;return;
}
function __ZNSt9bad_allocD2Ev($this) {
 $this = $this|0;
 var label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = sp;return;
}
function __ZNSt9bad_allocD0Ev($this) {
 $this = $this|0;
 var label = 0, sp = 0;
 sp = STACKTOP;
 __ZdlPv($this);
 STACKTOP = sp;return;
}
function __ZNKSt9bad_alloc4whatEv($this) {
 $this = $this|0;
 var label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = sp;return (3288|0);
}
function __ZSt11__terminatePFvvE($func) {
 $func = $func|0;
 var $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $vararg_buffer = 0, $vararg_buffer1 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $vararg_buffer1 = sp + 8|0;
 $vararg_buffer = sp;
 __THREW__ = 0;
 invoke_v($func|0);
 $0 = __THREW__; __THREW__ = 0;
 $1 = $0&1;
 if (!($1)) {
  __THREW__ = 0;
  invoke_vii(204,(3336|0),($vararg_buffer|0));
  $2 = __THREW__; __THREW__ = 0;
  $3 = $2&1;
  if (!($3)) {
   // unreachable;
  }
 }
 $4 = ___cxa_find_matching_catch(0|0)|0;
 $5 = tempRet0;
 (___cxa_begin_catch(($4|0))|0);
 __THREW__ = 0;
 invoke_vii(204,(3376|0),($vararg_buffer1|0));
 $6 = __THREW__; __THREW__ = 0;
 $7 = $6&1;
 if (!($7)) {
  // unreachable;
 }
 $8 = ___cxa_find_matching_catch(0|0)|0;
 $9 = tempRet0;
 __THREW__ = 0;
 invoke_v(205);
 $10 = __THREW__; __THREW__ = 0;
 $11 = $10&1;
 if ($11) {
  $12 = ___cxa_find_matching_catch(0|0)|0;
  $13 = tempRet0;
  ___clang_call_terminate($12);
  // unreachable;
 } else {
  ___clang_call_terminate($8);
  // unreachable;
 }
}
function __ZSt9terminatev() {
 var $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 var $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 __THREW__ = 0;
 $0 = (invoke_i(206)|0);
 $1 = __THREW__; __THREW__ = 0;
 $2 = $1&1;
 if ($2) {
  $21 = ___cxa_find_matching_catch(0|0)|0;
  $22 = tempRet0;
  ___clang_call_terminate($21);
  // unreachable;
 }
 $3 = ($0|0)==(0|0);
 if (!($3)) {
  $4 = HEAP32[$0>>2]|0;
  $5 = ($4|0)==(0|0);
  if (!($5)) {
   $6 = (($4) + 48|0);
   $7 = $6;
   $8 = $7;
   $9 = HEAP32[$8>>2]|0;
   $10 = (($7) + 4)|0;
   $11 = $10;
   $12 = HEAP32[$11>>2]|0;
   $13 = $9 & -256;
   $14 = ($13|0)==(1126902528);
   $15 = ($12|0)==(1129074247);
   $16 = $14 & $15;
   if ($16) {
    $17 = (($4) + 12|0);
    $18 = HEAP32[$17>>2]|0;
    __ZSt11__terminatePFvvE($18);
    // unreachable;
   }
  }
 }
 $19 = HEAP32[724]|0;HEAP32[724] = (($19+0)|0);
 $20 = $19;
 __ZSt11__terminatePFvvE($20);
 // unreachable;
}
function __ZNSt9exceptionD2Ev($this) {
 $this = $this|0;
 var label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = sp;return;
}
function __ZNSt9type_infoD2Ev($this) {
 $this = $this|0;
 var label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = sp;return;
}
function __ZN10__cxxabiv116__shim_type_infoD2Ev($this) {
 $this = $this|0;
 var label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = sp;return;
}
function __ZNK10__cxxabiv116__shim_type_info5noop1Ev($this) {
 $this = $this|0;
 var label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = sp;return;
}
function __ZNK10__cxxabiv116__shim_type_info5noop2Ev($this) {
 $this = $this|0;
 var label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = sp;return;
}
function __ZN10__cxxabiv117__class_type_infoD0Ev($this) {
 $this = $this|0;
 var label = 0, sp = 0;
 sp = STACKTOP;
 __ZdlPv($this);
 STACKTOP = sp;return;
}
function __ZN10__cxxabiv120__si_class_type_infoD0Ev($this) {
 $this = $this|0;
 var label = 0, sp = 0;
 sp = STACKTOP;
 __ZdlPv($this);
 STACKTOP = sp;return;
}
function __ZNK10__cxxabiv117__class_type_info9can_catchEPKNS_16__shim_type_infoERPv($this,$thrown_type,$adjustedPtr) {
 $this = $this|0;
 $thrown_type = $thrown_type|0;
 $adjustedPtr = $adjustedPtr|0;
 var $$1 = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $info = 0, dest = 0, label = 0;
 var sp = 0, stop = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $info = sp;
 $0 = ($this|0)==($thrown_type|0);
 if ($0) {
  $$1 = 1;
  STACKTOP = sp;return ($$1|0);
 }
 $1 = ($thrown_type|0)==(0|0);
 if ($1) {
  $$1 = 0;
  STACKTOP = sp;return ($$1|0);
 }
 $2 = (___dynamic_cast($thrown_type,3520,3576,0)|0);
 $3 = ($2|0)==(0|0);
 if ($3) {
  $$1 = 0;
  STACKTOP = sp;return ($$1|0);
 }
 dest=$info+0|0; stop=dest+56|0; do { HEAP32[dest>>2]=0|0; dest=dest+4|0; } while ((dest|0) < (stop|0));
 HEAP32[$info>>2] = $2;
 $4 = (($info) + 8|0);
 HEAP32[$4>>2] = $this;
 $5 = (($info) + 12|0);
 HEAP32[$5>>2] = -1;
 $6 = (($info) + 48|0);
 HEAP32[$6>>2] = 1;
 $7 = HEAP32[$2>>2]|0;
 $8 = (($7) + 28|0);
 $9 = HEAP32[$8>>2]|0;
 $10 = HEAP32[$adjustedPtr>>2]|0;
 FUNCTION_TABLE_viiii[$9 & 255]($2,$info,$10,1);
 $11 = (($info) + 24|0);
 $12 = HEAP32[$11>>2]|0;
 $13 = ($12|0)==(1);
 if (!($13)) {
  $$1 = 0;
  STACKTOP = sp;return ($$1|0);
 }
 $14 = (($info) + 16|0);
 $15 = HEAP32[$14>>2]|0;
 HEAP32[$adjustedPtr>>2] = $15;
 $$1 = 1;
 STACKTOP = sp;return ($$1|0);
}
function __ZNK10__cxxabiv117__class_type_info24process_found_base_classEPNS_19__dynamic_cast_infoEPvi($this,$info,$adjustedPtr,$path_below) {
 $this = $this|0;
 $info = $info|0;
 $adjustedPtr = $adjustedPtr|0;
 $path_below = $path_below|0;
 var $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = (($info) + 16|0);
 $1 = HEAP32[$0>>2]|0;
 $2 = ($1|0)==(0|0);
 if ($2) {
  HEAP32[$0>>2] = $adjustedPtr;
  $3 = (($info) + 24|0);
  HEAP32[$3>>2] = $path_below;
  $4 = (($info) + 36|0);
  HEAP32[$4>>2] = 1;
  STACKTOP = sp;return;
 }
 $5 = ($1|0)==($adjustedPtr|0);
 if (!($5)) {
  $9 = (($info) + 36|0);
  $10 = HEAP32[$9>>2]|0;
  $11 = (($10) + 1)|0;
  HEAP32[$9>>2] = $11;
  $12 = (($info) + 24|0);
  HEAP32[$12>>2] = 2;
  $13 = (($info) + 54|0);
  HEAP8[$13>>0] = 1;
  STACKTOP = sp;return;
 }
 $6 = (($info) + 24|0);
 $7 = HEAP32[$6>>2]|0;
 $8 = ($7|0)==(2);
 if (!($8)) {
  STACKTOP = sp;return;
 }
 HEAP32[$6>>2] = $path_below;
 STACKTOP = sp;return;
}
function __ZNK10__cxxabiv117__class_type_info27has_unambiguous_public_baseEPNS_19__dynamic_cast_infoEPvi($this,$info,$adjustedPtr,$path_below) {
 $this = $this|0;
 $info = $info|0;
 $adjustedPtr = $adjustedPtr|0;
 $path_below = $path_below|0;
 var $0 = 0, $1 = 0, $2 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = (($info) + 8|0);
 $1 = HEAP32[$0>>2]|0;
 $2 = ($1|0)==($this|0);
 if (!($2)) {
  STACKTOP = sp;return;
 }
 __ZNK10__cxxabiv117__class_type_info24process_found_base_classEPNS_19__dynamic_cast_infoEPvi(0,$info,$adjustedPtr,$path_below);
 STACKTOP = sp;return;
}
function __ZNK10__cxxabiv120__si_class_type_info27has_unambiguous_public_baseEPNS_19__dynamic_cast_infoEPvi($this,$info,$adjustedPtr,$path_below) {
 $this = $this|0;
 $info = $info|0;
 $adjustedPtr = $adjustedPtr|0;
 $path_below = $path_below|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = (($info) + 8|0);
 $1 = HEAP32[$0>>2]|0;
 $2 = ($this|0)==($1|0);
 if ($2) {
  __ZNK10__cxxabiv117__class_type_info24process_found_base_classEPNS_19__dynamic_cast_infoEPvi(0,$info,$adjustedPtr,$path_below);
  STACKTOP = sp;return;
 } else {
  $3 = (($this) + 8|0);
  $4 = HEAP32[$3>>2]|0;
  $5 = HEAP32[$4>>2]|0;
  $6 = (($5) + 28|0);
  $7 = HEAP32[$6>>2]|0;
  FUNCTION_TABLE_viiii[$7 & 255]($4,$info,$adjustedPtr,$path_below);
  STACKTOP = sp;return;
 }
}
function ___dynamic_cast($static_ptr,$static_type,$dst_type,$src2dst_offset) {
 $static_ptr = $static_ptr|0;
 $static_type = $static_type|0;
 $dst_type = $dst_type|0;
 $src2dst_offset = $src2dst_offset|0;
 var $$ = 0, $$8 = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0;
 var $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0;
 var $43 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $dst_ptr$0 = 0, $info = 0, $or$cond = 0, $or$cond3 = 0, $or$cond5 = 0, $or$cond7 = 0, dest = 0, label = 0, sp = 0, stop = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $info = sp;
 $0 = HEAP32[$static_ptr>>2]|0;
 $1 = (($0) + -8|0);
 $2 = HEAP32[$1>>2]|0;
 $3 = $2;
 $4 = (($static_ptr) + ($3)|0);
 $5 = (($0) + -4|0);
 $6 = HEAP32[$5>>2]|0;
 HEAP32[$info>>2] = $dst_type;
 $7 = (($info) + 4|0);
 HEAP32[$7>>2] = $static_ptr;
 $8 = (($info) + 8|0);
 HEAP32[$8>>2] = $static_type;
 $9 = (($info) + 12|0);
 HEAP32[$9>>2] = $src2dst_offset;
 $10 = (($info) + 16|0);
 $11 = (($info) + 20|0);
 $12 = (($info) + 24|0);
 $13 = (($info) + 28|0);
 $14 = (($info) + 32|0);
 $15 = (($info) + 40|0);
 $16 = ($6|0)==($dst_type|0);
 dest=$10+0|0; stop=dest+36|0; do { HEAP32[dest>>2]=0|0; dest=dest+4|0; } while ((dest|0) < (stop|0));HEAP16[$10+36>>1]=0|0;HEAP8[$10+38>>0]=0|0;
 if ($16) {
  $17 = (($info) + 48|0);
  HEAP32[$17>>2] = 1;
  $18 = HEAP32[$6>>2]|0;
  $19 = (($18) + 20|0);
  $20 = HEAP32[$19>>2]|0;
  FUNCTION_TABLE_viiiiii[$20 & 255]($6,$info,$4,$4,1,0);
  $21 = HEAP32[$12>>2]|0;
  $22 = ($21|0)==(1);
  $$ = $22 ? $4 : 0;
  $dst_ptr$0 = $$;
  STACKTOP = sp;return ($dst_ptr$0|0);
 }
 $23 = (($info) + 36|0);
 $24 = HEAP32[$6>>2]|0;
 $25 = (($24) + 24|0);
 $26 = HEAP32[$25>>2]|0;
 FUNCTION_TABLE_viiiii[$26 & 255]($6,$info,$4,1,0);
 $27 = HEAP32[$23>>2]|0;
 if ((($27|0) == 0)) {
  $28 = HEAP32[$15>>2]|0;
  $29 = ($28|0)==(1);
  $30 = HEAP32[$13>>2]|0;
  $31 = ($30|0)==(1);
  $or$cond = $29 & $31;
  $32 = HEAP32[$14>>2]|0;
  $33 = ($32|0)==(1);
  $or$cond3 = $or$cond & $33;
  $34 = HEAP32[$11>>2]|0;
  $$8 = $or$cond3 ? $34 : 0;
  $dst_ptr$0 = $$8;
  STACKTOP = sp;return ($dst_ptr$0|0);
 } else if ((($27|0) == 1)) {
  $35 = HEAP32[$12>>2]|0;
  $36 = ($35|0)==(1);
  if (!($36)) {
   $37 = HEAP32[$15>>2]|0;
   $38 = ($37|0)==(0);
   $39 = HEAP32[$13>>2]|0;
   $40 = ($39|0)==(1);
   $or$cond5 = $38 & $40;
   $41 = HEAP32[$14>>2]|0;
   $42 = ($41|0)==(1);
   $or$cond7 = $or$cond5 & $42;
   if (!($or$cond7)) {
    $dst_ptr$0 = 0;
    STACKTOP = sp;return ($dst_ptr$0|0);
   }
  }
  $43 = HEAP32[$10>>2]|0;
  $dst_ptr$0 = $43;
  STACKTOP = sp;return ($dst_ptr$0|0);
 } else {
  $dst_ptr$0 = 0;
  STACKTOP = sp;return ($dst_ptr$0|0);
 }
 return (0)|0;
}
function __ZNK10__cxxabiv117__class_type_info29process_static_type_above_dstEPNS_19__dynamic_cast_infoEPKvS4_i($this,$info,$dst_ptr,$current_ptr,$path_below) {
 $this = $this|0;
 $info = $info|0;
 $dst_ptr = $dst_ptr|0;
 $current_ptr = $current_ptr|0;
 $path_below = $path_below|0;
 var $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0;
 var $27 = 0, $28 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $or$cond = 0, $or$cond1 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = (($info) + 53|0);
 HEAP8[$0>>0] = 1;
 $1 = (($info) + 4|0);
 $2 = HEAP32[$1>>2]|0;
 $3 = ($2|0)==($current_ptr|0);
 if (!($3)) {
  STACKTOP = sp;return;
 }
 $4 = (($info) + 52|0);
 HEAP8[$4>>0] = 1;
 $5 = (($info) + 16|0);
 $6 = HEAP32[$5>>2]|0;
 $7 = ($6|0)==(0|0);
 if ($7) {
  HEAP32[$5>>2] = $dst_ptr;
  $8 = (($info) + 24|0);
  HEAP32[$8>>2] = $path_below;
  $9 = (($info) + 36|0);
  HEAP32[$9>>2] = 1;
  $10 = (($info) + 48|0);
  $11 = HEAP32[$10>>2]|0;
  $12 = ($11|0)==(1);
  $13 = ($path_below|0)==(1);
  $or$cond = $12 & $13;
  if (!($or$cond)) {
   STACKTOP = sp;return;
  }
  $14 = (($info) + 54|0);
  HEAP8[$14>>0] = 1;
  STACKTOP = sp;return;
 }
 $15 = ($6|0)==($dst_ptr|0);
 if (!($15)) {
  $25 = (($info) + 36|0);
  $26 = HEAP32[$25>>2]|0;
  $27 = (($26) + 1)|0;
  HEAP32[$25>>2] = $27;
  $28 = (($info) + 54|0);
  HEAP8[$28>>0] = 1;
  STACKTOP = sp;return;
 }
 $16 = (($info) + 24|0);
 $17 = HEAP32[$16>>2]|0;
 $18 = ($17|0)==(2);
 if ($18) {
  HEAP32[$16>>2] = $path_below;
  $22 = $path_below;
 } else {
  $22 = $17;
 }
 $19 = (($info) + 48|0);
 $20 = HEAP32[$19>>2]|0;
 $21 = ($20|0)==(1);
 $23 = ($22|0)==(1);
 $or$cond1 = $21 & $23;
 if (!($or$cond1)) {
  STACKTOP = sp;return;
 }
 $24 = (($info) + 54|0);
 HEAP8[$24>>0] = 1;
 STACKTOP = sp;return;
}
function __ZNK10__cxxabiv120__si_class_type_info16search_below_dstEPNS_19__dynamic_cast_infoEPKvib($this,$info,$current_ptr,$path_below,$use_strcmp) {
 $this = $this|0;
 $info = $info|0;
 $current_ptr = $current_ptr|0;
 $path_below = $path_below|0;
 $use_strcmp = $use_strcmp|0;
 var $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0;
 var $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0;
 var $45 = 0, $46 = 0, $47 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $is_dst_type_derived_from_static_type$0$off01 = 0, $not$ = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = (($info) + 8|0);
 $1 = HEAP32[$0>>2]|0;
 $2 = ($this|0)==($1|0);
 if ($2) {
  $3 = (($info) + 4|0);
  $4 = HEAP32[$3>>2]|0;
  $5 = ($4|0)==($current_ptr|0);
  if (!($5)) {
   STACKTOP = sp;return;
  }
  $6 = (($info) + 28|0);
  $7 = HEAP32[$6>>2]|0;
  $8 = ($7|0)==(1);
  if ($8) {
   STACKTOP = sp;return;
  }
  HEAP32[$6>>2] = $path_below;
  STACKTOP = sp;return;
 }
 $9 = HEAP32[$info>>2]|0;
 $10 = ($this|0)==($9|0);
 if (!($10)) {
  $43 = (($this) + 8|0);
  $44 = HEAP32[$43>>2]|0;
  $45 = HEAP32[$44>>2]|0;
  $46 = (($45) + 24|0);
  $47 = HEAP32[$46>>2]|0;
  FUNCTION_TABLE_viiiii[$47 & 255]($44,$info,$current_ptr,$path_below,$use_strcmp);
  STACKTOP = sp;return;
 }
 $11 = (($info) + 16|0);
 $12 = HEAP32[$11>>2]|0;
 $13 = ($12|0)==($current_ptr|0);
 if (!($13)) {
  $14 = (($info) + 20|0);
  $15 = HEAP32[$14>>2]|0;
  $16 = ($15|0)==($current_ptr|0);
  if (!($16)) {
   $19 = (($info) + 32|0);
   HEAP32[$19>>2] = $path_below;
   $20 = (($info) + 44|0);
   $21 = HEAP32[$20>>2]|0;
   $22 = ($21|0)==(4);
   if ($22) {
    STACKTOP = sp;return;
   }
   $23 = (($info) + 52|0);
   HEAP8[$23>>0] = 0;
   $24 = (($info) + 53|0);
   HEAP8[$24>>0] = 0;
   $25 = (($this) + 8|0);
   $26 = HEAP32[$25>>2]|0;
   $27 = HEAP32[$26>>2]|0;
   $28 = (($27) + 20|0);
   $29 = HEAP32[$28>>2]|0;
   FUNCTION_TABLE_viiiiii[$29 & 255]($26,$info,$current_ptr,$current_ptr,1,$use_strcmp);
   $30 = HEAP8[$24>>0]|0;
   $31 = ($30<<24>>24)==(0);
   if ($31) {
    $is_dst_type_derived_from_static_type$0$off01 = 0;
    label = 13;
   } else {
    $32 = HEAP8[$23>>0]|0;
    $not$ = ($32<<24>>24)==(0);
    if ($not$) {
     $is_dst_type_derived_from_static_type$0$off01 = 1;
     label = 13;
    }
   }
   do {
    if ((label|0) == 13) {
     HEAP32[$14>>2] = $current_ptr;
     $33 = (($info) + 40|0);
     $34 = HEAP32[$33>>2]|0;
     $35 = (($34) + 1)|0;
     HEAP32[$33>>2] = $35;
     $36 = (($info) + 36|0);
     $37 = HEAP32[$36>>2]|0;
     $38 = ($37|0)==(1);
     if ($38) {
      $39 = (($info) + 24|0);
      $40 = HEAP32[$39>>2]|0;
      $41 = ($40|0)==(2);
      if ($41) {
       $42 = (($info) + 54|0);
       HEAP8[$42>>0] = 1;
       if ($is_dst_type_derived_from_static_type$0$off01) {
        break;
       }
      } else {
       label = 16;
      }
     } else {
      label = 16;
     }
     if ((label|0) == 16) {
      if ($is_dst_type_derived_from_static_type$0$off01) {
       break;
      }
     }
     HEAP32[$20>>2] = 4;
     STACKTOP = sp;return;
    }
   } while(0);
   HEAP32[$20>>2] = 3;
   STACKTOP = sp;return;
  }
 }
 $17 = ($path_below|0)==(1);
 if (!($17)) {
  STACKTOP = sp;return;
 }
 $18 = (($info) + 32|0);
 HEAP32[$18>>2] = 1;
 STACKTOP = sp;return;
}
function __ZNK10__cxxabiv117__class_type_info16search_below_dstEPNS_19__dynamic_cast_infoEPKvib($this,$info,$current_ptr,$path_below,$use_strcmp) {
 $this = $this|0;
 $info = $info|0;
 $current_ptr = $current_ptr|0;
 $path_below = $path_below|0;
 $use_strcmp = $use_strcmp|0;
 var $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0;
 var $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = (($info) + 8|0);
 $1 = HEAP32[$0>>2]|0;
 $2 = ($1|0)==($this|0);
 if ($2) {
  $3 = (($info) + 4|0);
  $4 = HEAP32[$3>>2]|0;
  $5 = ($4|0)==($current_ptr|0);
  if (!($5)) {
   STACKTOP = sp;return;
  }
  $6 = (($info) + 28|0);
  $7 = HEAP32[$6>>2]|0;
  $8 = ($7|0)==(1);
  if ($8) {
   STACKTOP = sp;return;
  }
  HEAP32[$6>>2] = $path_below;
  STACKTOP = sp;return;
 }
 $9 = HEAP32[$info>>2]|0;
 $10 = ($9|0)==($this|0);
 if (!($10)) {
  STACKTOP = sp;return;
 }
 $11 = (($info) + 16|0);
 $12 = HEAP32[$11>>2]|0;
 $13 = ($12|0)==($current_ptr|0);
 if (!($13)) {
  $14 = (($info) + 20|0);
  $15 = HEAP32[$14>>2]|0;
  $16 = ($15|0)==($current_ptr|0);
  if (!($16)) {
   $19 = (($info) + 32|0);
   HEAP32[$19>>2] = $path_below;
   HEAP32[$14>>2] = $current_ptr;
   $20 = (($info) + 40|0);
   $21 = HEAP32[$20>>2]|0;
   $22 = (($21) + 1)|0;
   HEAP32[$20>>2] = $22;
   $23 = (($info) + 36|0);
   $24 = HEAP32[$23>>2]|0;
   $25 = ($24|0)==(1);
   if ($25) {
    $26 = (($info) + 24|0);
    $27 = HEAP32[$26>>2]|0;
    $28 = ($27|0)==(2);
    if ($28) {
     $29 = (($info) + 54|0);
     HEAP8[$29>>0] = 1;
    }
   }
   $30 = (($info) + 44|0);
   HEAP32[$30>>2] = 4;
   STACKTOP = sp;return;
  }
 }
 $17 = ($path_below|0)==(1);
 if (!($17)) {
  STACKTOP = sp;return;
 }
 $18 = (($info) + 32|0);
 HEAP32[$18>>2] = 1;
 STACKTOP = sp;return;
}
function __ZNK10__cxxabiv120__si_class_type_info16search_above_dstEPNS_19__dynamic_cast_infoEPKvS4_ib($this,$info,$dst_ptr,$current_ptr,$path_below,$use_strcmp) {
 $this = $this|0;
 $info = $info|0;
 $dst_ptr = $dst_ptr|0;
 $current_ptr = $current_ptr|0;
 $path_below = $path_below|0;
 $use_strcmp = $use_strcmp|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = (($info) + 8|0);
 $1 = HEAP32[$0>>2]|0;
 $2 = ($this|0)==($1|0);
 if ($2) {
  __ZNK10__cxxabiv117__class_type_info29process_static_type_above_dstEPNS_19__dynamic_cast_infoEPKvS4_i(0,$info,$dst_ptr,$current_ptr,$path_below);
  STACKTOP = sp;return;
 } else {
  $3 = (($this) + 8|0);
  $4 = HEAP32[$3>>2]|0;
  $5 = HEAP32[$4>>2]|0;
  $6 = (($5) + 20|0);
  $7 = HEAP32[$6>>2]|0;
  FUNCTION_TABLE_viiiiii[$7 & 255]($4,$info,$dst_ptr,$current_ptr,$path_below,$use_strcmp);
  STACKTOP = sp;return;
 }
}
function __ZNK10__cxxabiv117__class_type_info16search_above_dstEPNS_19__dynamic_cast_infoEPKvS4_ib($this,$info,$dst_ptr,$current_ptr,$path_below,$use_strcmp) {
 $this = $this|0;
 $info = $info|0;
 $dst_ptr = $dst_ptr|0;
 $current_ptr = $current_ptr|0;
 $path_below = $path_below|0;
 $use_strcmp = $use_strcmp|0;
 var $0 = 0, $1 = 0, $2 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = (($info) + 8|0);
 $1 = HEAP32[$0>>2]|0;
 $2 = ($1|0)==($this|0);
 if (!($2)) {
  STACKTOP = sp;return;
 }
 __ZNK10__cxxabiv117__class_type_info29process_static_type_above_dstEPNS_19__dynamic_cast_infoEPKvS4_i(0,$info,$dst_ptr,$current_ptr,$path_below);
 STACKTOP = sp;return;
}
function ___cxa_can_catch($catchType,$excpType,$thrown) {
 $catchType = $catchType|0;
 $excpType = $excpType|0;
 $thrown = $thrown|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $temp = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $temp = sp;
 $0 = HEAP32[$thrown>>2]|0;
 HEAP32[$temp>>2] = $0;
 $1 = HEAP32[$catchType>>2]|0;
 $2 = (($1) + 16|0);
 $3 = HEAP32[$2>>2]|0;
 $4 = (FUNCTION_TABLE_iiii[$3 & 255]($catchType,$excpType,$temp)|0);
 $5 = $4&1;
 if (!($4)) {
  STACKTOP = sp;return ($5|0);
 }
 $6 = HEAP32[$temp>>2]|0;
 HEAP32[$thrown>>2] = $6;
 STACKTOP = sp;return ($5|0);
}
function ___cxa_is_pointer_type($type) {
 $type = $type|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $phitmp = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = ($type|0)==(0|0);
 if ($0) {
  $3 = 0;
 } else {
  $1 = (___dynamic_cast($type,3520,3688,0)|0);
  $phitmp = ($1|0)!=(0|0);
  $3 = $phitmp;
 }
 $2 = $3&1;
 STACKTOP = sp;return ($2|0);
}
function __ZL25default_terminate_handlerv() {
 var $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0;
 var $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $thrown_object = 0, $vararg_buffer = 0, $vararg_buffer10 = 0;
 var $vararg_buffer3 = 0, $vararg_buffer7 = 0, $vararg_ptr1 = 0, $vararg_ptr2 = 0, $vararg_ptr6 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $vararg_buffer10 = sp + 32|0;
 $vararg_buffer7 = sp + 24|0;
 $vararg_buffer3 = sp + 16|0;
 $vararg_buffer = sp;
 $thrown_object = sp + 36|0;
 $0 = (___cxa_get_globals_fast()|0);
 $1 = ($0|0)==(0|0);
 if ($1) {
  _abort_message(3064,$vararg_buffer10);
  // unreachable;
 }
 $2 = HEAP32[$0>>2]|0;
 $3 = ($2|0)==(0|0);
 if ($3) {
  _abort_message(3064,$vararg_buffer10);
  // unreachable;
 }
 $4 = (($2) + 80|0);
 $5 = (($2) + 48|0);
 $6 = $5;
 $7 = $6;
 $8 = HEAP32[$7>>2]|0;
 $9 = (($6) + 4)|0;
 $10 = $9;
 $11 = HEAP32[$10>>2]|0;
 $12 = $8 & -256;
 $13 = ($12|0)==(1126902528);
 $14 = ($11|0)==(1129074247);
 $15 = $13 & $14;
 if (!($15)) {
  $36 = HEAP32[2904>>2]|0;
  HEAP32[$vararg_buffer7>>2] = $36;
  _abort_message(3024,$vararg_buffer7);
  // unreachable;
 }
 $16 = ($8|0)==(1126902529);
 $17 = ($11|0)==(1129074247);
 $18 = $16 & $17;
 if ($18) {
  $19 = (($2) + 44|0);
  $20 = HEAP32[$19>>2]|0;
  $21 = $20;
 } else {
  $21 = $4;
 }
 HEAP32[$thrown_object>>2] = $21;
 $22 = HEAP32[$2>>2]|0;
 $23 = (($22) + 4|0);
 $24 = HEAP32[$23>>2]|0;
 $25 = HEAP32[3448>>2]|0;
 $26 = (($25) + 16|0);
 $27 = HEAP32[$26>>2]|0;
 $28 = (FUNCTION_TABLE_iiii[$27 & 255](3448,$22,$thrown_object)|0);
 if ($28) {
  $29 = HEAP32[$thrown_object>>2]|0;
  $30 = HEAP32[2904>>2]|0;
  $31 = HEAP32[$29>>2]|0;
  $32 = (($31) + 8|0);
  $33 = HEAP32[$32>>2]|0;
  $34 = (FUNCTION_TABLE_ii[$33 & 255]($29)|0);
  HEAP32[$vararg_buffer>>2] = $30;
  $vararg_ptr1 = (($vararg_buffer) + 4|0);
  HEAP32[$vararg_ptr1>>2] = $24;
  $vararg_ptr2 = (($vararg_buffer) + 8|0);
  HEAP32[$vararg_ptr2>>2] = $34;
  _abort_message(2928,$vararg_buffer);
  // unreachable;
 } else {
  $35 = HEAP32[2904>>2]|0;
  HEAP32[$vararg_buffer3>>2] = $35;
  $vararg_ptr6 = (($vararg_buffer3) + 4|0);
  HEAP32[$vararg_ptr6>>2] = $24;
  _abort_message(2976,$vararg_buffer3);
  // unreachable;
 }
}
function __ZN10__cxxabiv112_GLOBAL__N_110construct_Ev() {
 var $0 = 0, $1 = 0, $vararg_buffer = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $vararg_buffer = sp;
 $0 = (_pthread_key_create((3080|0),(207|0))|0);
 $1 = ($0|0)==(0);
 if ($1) {
  STACKTOP = sp;return;
 } else {
  _abort_message(3152,$vararg_buffer);
  // unreachable;
 }
}
function __ZN10__cxxabiv112_GLOBAL__N_19destruct_EPv($p) {
 $p = $p|0;
 var $0 = 0, $1 = 0, $2 = 0, $vararg_buffer = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abort();
 $vararg_buffer = sp;
 _free($p);
 $0 = HEAP32[3080>>2]|0;
 $1 = (_pthread_setspecific(($0|0),(0|0))|0);
 $2 = ($1|0)==(0);
 if ($2) {
  STACKTOP = sp;return;
 } else {
  _abort_message(3208,$vararg_buffer);
  // unreachable;
 }
}
function _malloc($bytes) {
 $bytes = $bytes|0;
 var $$lcssa = 0, $$lcssa110 = 0, $$lcssa112 = 0, $$lcssa115 = 0, $$lcssa116 = 0, $$lcssa117 = 0, $$lcssa118 = 0, $$lcssa120 = 0, $$lcssa123 = 0, $$lcssa125 = 0, $$lcssa127 = 0, $$lcssa130 = 0, $$lcssa132 = 0, $$lcssa134 = 0, $$lcssa137 = 0, $$pre = 0, $$pre$i = 0, $$pre$i$i = 0, $$pre$i23$i = 0, $$pre$i25 = 0;
 var $$pre$phi$i$iZ2D = 0, $$pre$phi$i24$iZ2D = 0, $$pre$phi$i26Z2D = 0, $$pre$phi$iZ2D = 0, $$pre$phi59$i$iZ2D = 0, $$pre$phiZ2D = 0, $$pre105 = 0, $$pre58$i$i = 0, $$rsize$0$i = 0, $$rsize$3$i = 0, $$rsize$3$i$lcssa = 0, $$sum = 0, $$sum$i$i = 0, $$sum$i$i$i = 0, $$sum$i12$i = 0, $$sum$i13$i = 0, $$sum$i16$i = 0, $$sum$i19$i = 0, $$sum$i2338 = 0, $$sum$i32 = 0;
 var $$sum$i39 = 0, $$sum1 = 0, $$sum1$i = 0, $$sum1$i$i = 0, $$sum1$i14$i = 0, $$sum1$i20$i = 0, $$sum1$i24 = 0, $$sum10 = 0, $$sum10$i = 0, $$sum10$i$i = 0, $$sum10$pre$i$i = 0, $$sum102$i = 0, $$sum103$i = 0, $$sum104$i = 0, $$sum105$i = 0, $$sum106$i = 0, $$sum107$i = 0, $$sum108$i = 0, $$sum109$i = 0, $$sum11$i = 0;
 var $$sum11$i$i = 0, $$sum11$i22$i = 0, $$sum110$i = 0, $$sum111$i = 0, $$sum1112 = 0, $$sum112$i = 0, $$sum113$i = 0, $$sum114$i = 0, $$sum115$i = 0, $$sum12$i = 0, $$sum12$i$i = 0, $$sum13$i = 0, $$sum13$i$i = 0, $$sum14$i$i = 0, $$sum14$pre$i = 0, $$sum15$i = 0, $$sum15$i$i = 0, $$sum16$i = 0, $$sum16$i$i = 0, $$sum17$i = 0;
 var $$sum17$i$i = 0, $$sum18$i = 0, $$sum1819$i$i = 0, $$sum2 = 0, $$sum2$i = 0, $$sum2$i$i = 0, $$sum2$i$i$i = 0, $$sum2$i15$i = 0, $$sum2$i17$i = 0, $$sum2$i21$i = 0, $$sum2$pre$i = 0, $$sum20$i$i = 0, $$sum21$i$i = 0, $$sum22$i$i = 0, $$sum23$i$i = 0, $$sum24$i$i = 0, $$sum25$i$i = 0, $$sum26$pre$i$i = 0, $$sum27$i$i = 0, $$sum28$i$i = 0;
 var $$sum29$i$i = 0, $$sum3$i = 0, $$sum3$i$i = 0, $$sum3$i27 = 0, $$sum30$i$i = 0, $$sum3132$i$i = 0, $$sum34$i$i = 0, $$sum3536$i$i = 0, $$sum3738$i$i = 0, $$sum39$i$i = 0, $$sum4 = 0, $$sum4$i = 0, $$sum4$i28 = 0, $$sum40$i$i = 0, $$sum41$i$i = 0, $$sum42$i$i = 0, $$sum5$i = 0, $$sum5$i$i = 0, $$sum56 = 0, $$sum6$i = 0;
 var $$sum67$i$i = 0, $$sum7$i = 0, $$sum8$i = 0, $$sum8$pre = 0, $$sum9 = 0, $$sum9$i = 0, $$sum9$i$i = 0, $$tsize$1$i = 0, $$v$0$i = 0, $0 = 0, $1 = 0, $10 = 0, $100 = 0, $1000 = 0, $1001 = 0, $1002 = 0, $1003 = 0, $1004 = 0, $1005 = 0, $1006 = 0;
 var $1007 = 0, $1008 = 0, $1009 = 0, $101 = 0, $1010 = 0, $1011 = 0, $1012 = 0, $1013 = 0, $1014 = 0, $1015 = 0, $1016 = 0, $1017 = 0, $1018 = 0, $1019 = 0, $102 = 0, $1020 = 0, $1021 = 0, $1022 = 0, $1023 = 0, $1024 = 0;
 var $1025 = 0, $1026 = 0, $1027 = 0, $1028 = 0, $1029 = 0, $103 = 0, $1030 = 0, $1031 = 0, $1032 = 0, $1033 = 0, $1034 = 0, $1035 = 0, $1036 = 0, $1037 = 0, $1038 = 0, $1039 = 0, $104 = 0, $1040 = 0, $1041 = 0, $1042 = 0;
 var $1043 = 0, $1044 = 0, $1045 = 0, $1046 = 0, $1047 = 0, $1048 = 0, $1049 = 0, $105 = 0, $1050 = 0, $1051 = 0, $1052 = 0, $1053 = 0, $1054 = 0, $1055 = 0, $1056 = 0, $1057 = 0, $1058 = 0, $1059 = 0, $106 = 0, $1060 = 0;
 var $1061 = 0, $1062 = 0, $1063 = 0, $1064 = 0, $1065 = 0, $1066 = 0, $1067 = 0, $1068 = 0, $1069 = 0, $107 = 0, $1070 = 0, $1071 = 0, $1072 = 0, $1073 = 0, $1074 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0;
 var $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0;
 var $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0;
 var $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0, $165 = 0, $166 = 0;
 var $167 = 0, $168 = 0, $169 = 0, $17 = 0, $170 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0, $178 = 0, $179 = 0, $18 = 0, $180 = 0, $181 = 0, $182 = 0, $183 = 0, $184 = 0;
 var $185 = 0, $186 = 0, $187 = 0, $188 = 0, $189 = 0, $19 = 0, $190 = 0, $191 = 0, $192 = 0, $193 = 0, $194 = 0, $195 = 0, $196 = 0, $197 = 0, $198 = 0, $199 = 0, $2 = 0, $20 = 0, $200 = 0, $201 = 0;
 var $202 = 0, $203 = 0, $204 = 0, $205 = 0, $206 = 0, $207 = 0, $208 = 0, $209 = 0, $21 = 0, $210 = 0, $211 = 0, $212 = 0, $213 = 0, $214 = 0, $215 = 0, $216 = 0, $217 = 0, $218 = 0, $219 = 0, $22 = 0;
 var $220 = 0, $221 = 0, $222 = 0, $223 = 0, $224 = 0, $225 = 0, $226 = 0, $227 = 0, $228 = 0, $229 = 0, $23 = 0, $230 = 0, $231 = 0, $232 = 0, $233 = 0, $234 = 0, $235 = 0, $236 = 0, $237 = 0, $238 = 0;
 var $239 = 0, $24 = 0, $240 = 0, $241 = 0, $242 = 0, $243 = 0, $244 = 0, $245 = 0, $246 = 0, $247 = 0, $248 = 0, $249 = 0, $25 = 0, $250 = 0, $251 = 0, $252 = 0, $253 = 0, $254 = 0, $255 = 0, $256 = 0;
 var $257 = 0, $258 = 0, $259 = 0, $26 = 0, $260 = 0, $261 = 0, $262 = 0, $263 = 0, $264 = 0, $265 = 0, $266 = 0, $267 = 0, $268 = 0, $269 = 0, $27 = 0, $270 = 0, $271 = 0, $272 = 0, $273 = 0, $274 = 0;
 var $275 = 0, $276 = 0, $277 = 0, $278 = 0, $279 = 0, $28 = 0, $280 = 0, $281 = 0, $282 = 0, $283 = 0, $284 = 0, $285 = 0, $286 = 0, $287 = 0, $288 = 0, $289 = 0, $29 = 0, $290 = 0, $291 = 0, $292 = 0;
 var $293 = 0, $294 = 0, $295 = 0, $296 = 0, $297 = 0, $298 = 0, $299 = 0, $3 = 0, $30 = 0, $300 = 0, $301 = 0, $302 = 0, $303 = 0, $304 = 0, $305 = 0, $306 = 0, $307 = 0, $308 = 0, $309 = 0, $31 = 0;
 var $310 = 0, $311 = 0, $312 = 0, $313 = 0, $314 = 0, $315 = 0, $316 = 0, $317 = 0, $318 = 0, $319 = 0, $32 = 0, $320 = 0, $321 = 0, $322 = 0, $323 = 0, $324 = 0, $325 = 0, $326 = 0, $327 = 0, $328 = 0;
 var $329 = 0, $33 = 0, $330 = 0, $331 = 0, $332 = 0, $333 = 0, $334 = 0, $335 = 0, $336 = 0, $337 = 0, $338 = 0, $339 = 0, $34 = 0, $340 = 0, $341 = 0, $342 = 0, $343 = 0, $344 = 0, $345 = 0, $346 = 0;
 var $347 = 0, $348 = 0, $349 = 0, $35 = 0, $350 = 0, $351 = 0, $352 = 0, $353 = 0, $354 = 0, $355 = 0, $356 = 0, $357 = 0, $358 = 0, $359 = 0, $36 = 0, $360 = 0, $361 = 0, $362 = 0, $363 = 0, $364 = 0;
 var $365 = 0, $366 = 0, $367 = 0, $368 = 0, $369 = 0, $37 = 0, $370 = 0, $371 = 0, $372 = 0, $373 = 0, $374 = 0, $375 = 0, $376 = 0, $377 = 0, $378 = 0, $379 = 0, $38 = 0, $380 = 0, $381 = 0, $382 = 0;
 var $383 = 0, $384 = 0, $385 = 0, $386 = 0, $387 = 0, $388 = 0, $389 = 0, $39 = 0, $390 = 0, $391 = 0, $392 = 0, $393 = 0, $394 = 0, $395 = 0, $396 = 0, $397 = 0, $398 = 0, $399 = 0, $4 = 0, $40 = 0;
 var $400 = 0, $401 = 0, $402 = 0, $403 = 0, $404 = 0, $405 = 0, $406 = 0, $407 = 0, $408 = 0, $409 = 0, $41 = 0, $410 = 0, $411 = 0, $412 = 0, $413 = 0, $414 = 0, $415 = 0, $416 = 0, $417 = 0, $418 = 0;
 var $419 = 0, $42 = 0, $420 = 0, $421 = 0, $422 = 0, $423 = 0, $424 = 0, $425 = 0, $426 = 0, $427 = 0, $428 = 0, $429 = 0, $43 = 0, $430 = 0, $431 = 0, $432 = 0, $433 = 0, $434 = 0, $435 = 0, $436 = 0;
 var $437 = 0, $438 = 0, $439 = 0, $44 = 0, $440 = 0, $441 = 0, $442 = 0, $443 = 0, $444 = 0, $445 = 0, $446 = 0, $447 = 0, $448 = 0, $449 = 0, $45 = 0, $450 = 0, $451 = 0, $452 = 0, $453 = 0, $454 = 0;
 var $455 = 0, $456 = 0, $457 = 0, $458 = 0, $459 = 0, $46 = 0, $460 = 0, $461 = 0, $462 = 0, $463 = 0, $464 = 0, $465 = 0, $466 = 0, $467 = 0, $468 = 0, $469 = 0, $47 = 0, $470 = 0, $471 = 0, $472 = 0;
 var $473 = 0, $474 = 0, $475 = 0, $476 = 0, $477 = 0, $478 = 0, $479 = 0, $48 = 0, $480 = 0, $481 = 0, $482 = 0, $483 = 0, $484 = 0, $485 = 0, $486 = 0, $487 = 0, $488 = 0, $489 = 0, $49 = 0, $490 = 0;
 var $491 = 0, $492 = 0, $493 = 0, $494 = 0, $495 = 0, $496 = 0, $497 = 0, $498 = 0, $499 = 0, $5 = 0, $50 = 0, $500 = 0, $501 = 0, $502 = 0, $503 = 0, $504 = 0, $505 = 0, $506 = 0, $507 = 0, $508 = 0;
 var $509 = 0, $51 = 0, $510 = 0, $511 = 0, $512 = 0, $513 = 0, $514 = 0, $515 = 0, $516 = 0, $517 = 0, $518 = 0, $519 = 0, $52 = 0, $520 = 0, $521 = 0, $522 = 0, $523 = 0, $524 = 0, $525 = 0, $526 = 0;
 var $527 = 0, $528 = 0, $529 = 0, $53 = 0, $530 = 0, $531 = 0, $532 = 0, $533 = 0, $534 = 0, $535 = 0, $536 = 0, $537 = 0, $538 = 0, $539 = 0, $54 = 0, $540 = 0, $541 = 0, $542 = 0, $543 = 0, $544 = 0;
 var $545 = 0, $546 = 0, $547 = 0, $548 = 0, $549 = 0, $55 = 0, $550 = 0, $551 = 0, $552 = 0, $553 = 0, $554 = 0, $555 = 0, $556 = 0, $557 = 0, $558 = 0, $559 = 0, $56 = 0, $560 = 0, $561 = 0, $562 = 0;
 var $563 = 0, $564 = 0, $565 = 0, $566 = 0, $567 = 0, $568 = 0, $569 = 0, $57 = 0, $570 = 0, $571 = 0, $572 = 0, $573 = 0, $574 = 0, $575 = 0, $576 = 0, $577 = 0, $578 = 0, $579 = 0, $58 = 0, $580 = 0;
 var $581 = 0, $582 = 0, $583 = 0, $584 = 0, $585 = 0, $586 = 0, $587 = 0, $588 = 0, $589 = 0, $59 = 0, $590 = 0, $591 = 0, $592 = 0, $593 = 0, $594 = 0, $595 = 0, $596 = 0, $597 = 0, $598 = 0, $599 = 0;
 var $6 = 0, $60 = 0, $600 = 0, $601 = 0, $602 = 0, $603 = 0, $604 = 0, $605 = 0, $606 = 0, $607 = 0, $608 = 0, $609 = 0, $61 = 0, $610 = 0, $611 = 0, $612 = 0, $613 = 0, $614 = 0, $615 = 0, $616 = 0;
 var $617 = 0, $618 = 0, $619 = 0, $62 = 0, $620 = 0, $621 = 0, $622 = 0, $623 = 0, $624 = 0, $625 = 0, $626 = 0, $627 = 0, $628 = 0, $629 = 0, $63 = 0, $630 = 0, $631 = 0, $632 = 0, $633 = 0, $634 = 0;
 var $635 = 0, $636 = 0, $637 = 0, $638 = 0, $639 = 0, $64 = 0, $640 = 0, $641 = 0, $642 = 0, $643 = 0, $644 = 0, $645 = 0, $646 = 0, $647 = 0, $648 = 0, $649 = 0, $65 = 0, $650 = 0, $651 = 0, $652 = 0;
 var $653 = 0, $654 = 0, $655 = 0, $656 = 0, $657 = 0, $658 = 0, $659 = 0, $66 = 0, $660 = 0, $661 = 0, $662 = 0, $663 = 0, $664 = 0, $665 = 0, $666 = 0, $667 = 0, $668 = 0, $669 = 0, $67 = 0, $670 = 0;
 var $671 = 0, $672 = 0, $673 = 0, $674 = 0, $675 = 0, $676 = 0, $677 = 0, $678 = 0, $679 = 0, $68 = 0, $680 = 0, $681 = 0, $682 = 0, $683 = 0, $684 = 0, $685 = 0, $686 = 0, $687 = 0, $688 = 0, $689 = 0;
 var $69 = 0, $690 = 0, $691 = 0, $692 = 0, $693 = 0, $694 = 0, $695 = 0, $696 = 0, $697 = 0, $698 = 0, $699 = 0, $7 = 0, $70 = 0, $700 = 0, $701 = 0, $702 = 0, $703 = 0, $704 = 0, $705 = 0, $706 = 0;
 var $707 = 0, $708 = 0, $709 = 0, $71 = 0, $710 = 0, $711 = 0, $712 = 0, $713 = 0, $714 = 0, $715 = 0, $716 = 0, $717 = 0, $718 = 0, $719 = 0, $72 = 0, $720 = 0, $721 = 0, $722 = 0, $723 = 0, $724 = 0;
 var $725 = 0, $726 = 0, $727 = 0, $728 = 0, $729 = 0, $73 = 0, $730 = 0, $731 = 0, $732 = 0, $733 = 0, $734 = 0, $735 = 0, $736 = 0, $737 = 0, $738 = 0, $739 = 0, $74 = 0, $740 = 0, $741 = 0, $742 = 0;
 var $743 = 0, $744 = 0, $745 = 0, $746 = 0, $747 = 0, $748 = 0, $749 = 0, $75 = 0, $750 = 0, $751 = 0, $752 = 0, $753 = 0, $754 = 0, $755 = 0, $756 = 0, $757 = 0, $758 = 0, $759 = 0, $76 = 0, $760 = 0;
 var $761 = 0, $762 = 0, $763 = 0, $764 = 0, $765 = 0, $766 = 0, $767 = 0, $768 = 0, $769 = 0, $77 = 0, $770 = 0, $771 = 0, $772 = 0, $773 = 0, $774 = 0, $775 = 0, $776 = 0, $777 = 0, $778 = 0, $779 = 0;
 var $78 = 0, $780 = 0, $781 = 0, $782 = 0, $783 = 0, $784 = 0, $785 = 0, $786 = 0, $787 = 0, $788 = 0, $789 = 0, $79 = 0, $790 = 0, $791 = 0, $792 = 0, $793 = 0, $794 = 0, $795 = 0, $796 = 0, $797 = 0;
 var $798 = 0, $799 = 0, $8 = 0, $80 = 0, $800 = 0, $801 = 0, $802 = 0, $803 = 0, $804 = 0, $805 = 0, $806 = 0, $807 = 0, $808 = 0, $809 = 0, $81 = 0, $810 = 0, $811 = 0, $812 = 0, $813 = 0, $814 = 0;
 var $815 = 0, $816 = 0, $817 = 0, $818 = 0, $819 = 0, $82 = 0, $820 = 0, $821 = 0, $822 = 0, $823 = 0, $824 = 0, $825 = 0, $826 = 0, $827 = 0, $828 = 0, $829 = 0, $83 = 0, $830 = 0, $831 = 0, $832 = 0;
 var $833 = 0, $834 = 0, $835 = 0, $836 = 0, $837 = 0, $838 = 0, $839 = 0, $84 = 0, $840 = 0, $841 = 0, $842 = 0, $843 = 0, $844 = 0, $845 = 0, $846 = 0, $847 = 0, $848 = 0, $849 = 0, $85 = 0, $850 = 0;
 var $851 = 0, $852 = 0, $853 = 0, $854 = 0, $855 = 0, $856 = 0, $857 = 0, $858 = 0, $859 = 0, $86 = 0, $860 = 0, $861 = 0, $862 = 0, $863 = 0, $864 = 0, $865 = 0, $866 = 0, $867 = 0, $868 = 0, $869 = 0;
 var $87 = 0, $870 = 0, $871 = 0, $872 = 0, $873 = 0, $874 = 0, $875 = 0, $876 = 0, $877 = 0, $878 = 0, $879 = 0, $88 = 0, $880 = 0, $881 = 0, $882 = 0, $883 = 0, $884 = 0, $885 = 0, $886 = 0, $887 = 0;
 var $888 = 0, $889 = 0, $89 = 0, $890 = 0, $891 = 0, $892 = 0, $893 = 0, $894 = 0, $895 = 0, $896 = 0, $897 = 0, $898 = 0, $899 = 0, $9 = 0, $90 = 0, $900 = 0, $901 = 0, $902 = 0, $903 = 0, $904 = 0;
 var $905 = 0, $906 = 0, $907 = 0, $908 = 0, $909 = 0, $91 = 0, $910 = 0, $911 = 0, $912 = 0, $913 = 0, $914 = 0, $915 = 0, $916 = 0, $917 = 0, $918 = 0, $919 = 0, $92 = 0, $920 = 0, $921 = 0, $922 = 0;
 var $923 = 0, $924 = 0, $925 = 0, $926 = 0, $927 = 0, $928 = 0, $929 = 0, $93 = 0, $930 = 0, $931 = 0, $932 = 0, $933 = 0, $934 = 0, $935 = 0, $936 = 0, $937 = 0, $938 = 0, $939 = 0, $94 = 0, $940 = 0;
 var $941 = 0, $942 = 0, $943 = 0, $944 = 0, $945 = 0, $946 = 0, $947 = 0, $948 = 0, $949 = 0, $95 = 0, $950 = 0, $951 = 0, $952 = 0, $953 = 0, $954 = 0, $955 = 0, $956 = 0, $957 = 0, $958 = 0, $959 = 0;
 var $96 = 0, $960 = 0, $961 = 0, $962 = 0, $963 = 0, $964 = 0, $965 = 0, $966 = 0, $967 = 0, $968 = 0, $969 = 0, $97 = 0, $970 = 0, $971 = 0, $972 = 0, $973 = 0, $974 = 0, $975 = 0, $976 = 0, $977 = 0;
 var $978 = 0, $979 = 0, $98 = 0, $980 = 0, $981 = 0, $982 = 0, $983 = 0, $984 = 0, $985 = 0, $986 = 0, $987 = 0, $988 = 0, $989 = 0, $99 = 0, $990 = 0, $991 = 0, $992 = 0, $993 = 0, $994 = 0, $995 = 0;
 var $996 = 0, $997 = 0, $998 = 0, $999 = 0, $F$0$i$i = 0, $F1$0$i = 0, $F4$0 = 0, $F4$0$i$i = 0, $F5$0$i = 0, $I1$0$c$i$i = 0, $I1$0$i$i = 0, $I7$0$i = 0, $I7$0$i$i = 0, $K12$029$i = 0, $K2$015$i$i = 0, $K8$053$i$i = 0, $R$0$i = 0, $R$0$i$be = 0, $R$0$i$i = 0, $R$0$i$i$be = 0;
 var $R$0$i$i$lcssa = 0, $R$0$i$i$ph = 0, $R$0$i$lcssa = 0, $R$0$i$ph = 0, $R$0$i18 = 0, $R$0$i18$be = 0, $R$0$i18$lcssa = 0, $R$0$i18$ph = 0, $R$1$i = 0, $R$1$i$i = 0, $R$1$i20 = 0, $RP$0$i = 0, $RP$0$i$be = 0, $RP$0$i$i = 0, $RP$0$i$i$be = 0, $RP$0$i$i$lcssa = 0, $RP$0$i$i$ph = 0, $RP$0$i$lcssa = 0, $RP$0$i$ph = 0, $RP$0$i17 = 0;
 var $RP$0$i17$be = 0, $RP$0$i17$lcssa = 0, $RP$0$i17$ph = 0, $T$0$lcssa$i = 0, $T$0$lcssa$i$i = 0, $T$0$lcssa$i26$i = 0, $T$014$i$i = 0, $T$014$i$i$lcssa = 0, $T$028$i = 0, $T$028$i$lcssa = 0, $T$052$i$i = 0, $T$052$i$i$lcssa = 0, $br$0$i = 0, $br$030$i = 0, $cond$i = 0, $cond$i$i = 0, $cond$i21 = 0, $exitcond$i$i = 0, $i$02$i$i = 0, $idx$0$i = 0;
 var $mem$0 = 0, $nb$0 = 0, $oldfirst$0$i$i = 0, $or$cond$i = 0, $or$cond$i$i = 0, $or$cond$i27$i = 0, $or$cond$i29 = 0, $or$cond1$i = 0, $or$cond19$i = 0, $or$cond2$i = 0, $or$cond24$i = 0, $or$cond3$i = 0, $or$cond4$i = 0, $or$cond47$i = 0, $or$cond5$i = 0, $or$cond6$i = 0, $or$cond8$i = 0, $qsize$0$i$i = 0, $rsize$0$i = 0, $rsize$0$i$lcssa = 0;
 var $rsize$0$i15 = 0, $rsize$1$i = 0, $rsize$2$i = 0, $rsize$2$i$ph = 0, $rsize$3$lcssa$i = 0, $rsize$331$i = 0, $rst$0$i = 0, $rst$1$i = 0, $sizebits$0$i = 0, $sp$0$i$i = 0, $sp$0$i$i$i = 0, $sp$0$i$i$lcssa = 0, $sp$074$i = 0, $sp$074$i$lcssa = 0, $sp$173$i = 0, $sp$173$i$lcssa = 0, $ssize$0$i = 0, $ssize$1$i = 0, $ssize$129$i = 0, $ssize$2$i = 0;
 var $t$0$i = 0, $t$0$i14 = 0, $t$1$i = 0, $t$1$i$ph = 0, $t$2$ph$i = 0, $t$2$v$3$i = 0, $t$2$v$3$i$lcssa = 0, $t$230$i = 0, $t$230$i$be = 0, $tbase$245$i = 0, $tsize$03141$i = 0, $tsize$1$i = 0, $tsize$244$i = 0, $v$0$i = 0, $v$0$i$lcssa = 0, $v$0$i16 = 0, $v$1$i = 0, $v$2$i = 0, $v$2$i$ph = 0, $v$3$lcssa$i = 0;
 var $v$332$i = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = ($bytes>>>0)<(245);
 do {
  if ($0) {
   $1 = ($bytes>>>0)<(11);
   if ($1) {
    $5 = 16;
   } else {
    $2 = (($bytes) + 11)|0;
    $3 = $2 & -8;
    $5 = $3;
   }
   $4 = $5 >>> 3;
   $6 = HEAP32[3840>>2]|0;
   $7 = $6 >>> $4;
   $8 = $7 & 3;
   $9 = ($8|0)==(0);
   if (!($9)) {
    $10 = $7 & 1;
    $11 = $10 ^ 1;
    $12 = (($11) + ($4))|0;
    $13 = $12 << 1;
    $14 = ((3840 + ($13<<2)|0) + 40|0);
    $$sum10 = (($13) + 2)|0;
    $15 = ((3840 + ($$sum10<<2)|0) + 40|0);
    $16 = HEAP32[$15>>2]|0;
    $17 = (($16) + 8|0);
    $18 = HEAP32[$17>>2]|0;
    $19 = ($14|0)==($18|0);
    do {
     if ($19) {
      $20 = 1 << $12;
      $21 = $20 ^ -1;
      $22 = $6 & $21;
      HEAP32[3840>>2] = $22;
     } else {
      $23 = HEAP32[((3840 + 16|0))>>2]|0;
      $24 = ($18>>>0)<($23>>>0);
      if ($24) {
       _abort();
       // unreachable;
      }
      $25 = (($18) + 12|0);
      $26 = HEAP32[$25>>2]|0;
      $27 = ($26|0)==($16|0);
      if ($27) {
       HEAP32[$25>>2] = $14;
       HEAP32[$15>>2] = $18;
       break;
      } else {
       _abort();
       // unreachable;
      }
     }
    } while(0);
    $28 = $12 << 3;
    $29 = $28 | 3;
    $30 = (($16) + 4|0);
    HEAP32[$30>>2] = $29;
    $$sum1112 = $28 | 4;
    $31 = (($16) + ($$sum1112)|0);
    $32 = HEAP32[$31>>2]|0;
    $33 = $32 | 1;
    HEAP32[$31>>2] = $33;
    $mem$0 = $17;
    STACKTOP = sp;return ($mem$0|0);
   }
   $34 = HEAP32[((3840 + 8|0))>>2]|0;
   $35 = ($5>>>0)>($34>>>0);
   if ($35) {
    $36 = ($7|0)==(0);
    if (!($36)) {
     $37 = $7 << $4;
     $38 = 2 << $4;
     $39 = (0 - ($38))|0;
     $40 = $38 | $39;
     $41 = $37 & $40;
     $42 = (0 - ($41))|0;
     $43 = $41 & $42;
     $44 = (($43) + -1)|0;
     $45 = $44 >>> 12;
     $46 = $45 & 16;
     $47 = $44 >>> $46;
     $48 = $47 >>> 5;
     $49 = $48 & 8;
     $50 = $49 | $46;
     $51 = $47 >>> $49;
     $52 = $51 >>> 2;
     $53 = $52 & 4;
     $54 = $50 | $53;
     $55 = $51 >>> $53;
     $56 = $55 >>> 1;
     $57 = $56 & 2;
     $58 = $54 | $57;
     $59 = $55 >>> $57;
     $60 = $59 >>> 1;
     $61 = $60 & 1;
     $62 = $58 | $61;
     $63 = $59 >>> $61;
     $64 = (($62) + ($63))|0;
     $65 = $64 << 1;
     $66 = ((3840 + ($65<<2)|0) + 40|0);
     $$sum4 = (($65) + 2)|0;
     $67 = ((3840 + ($$sum4<<2)|0) + 40|0);
     $68 = HEAP32[$67>>2]|0;
     $69 = (($68) + 8|0);
     $70 = HEAP32[$69>>2]|0;
     $71 = ($66|0)==($70|0);
     do {
      if ($71) {
       $72 = 1 << $64;
       $73 = $72 ^ -1;
       $74 = $6 & $73;
       HEAP32[3840>>2] = $74;
       $88 = $34;
      } else {
       $75 = HEAP32[((3840 + 16|0))>>2]|0;
       $76 = ($70>>>0)<($75>>>0);
       if ($76) {
        _abort();
        // unreachable;
       }
       $77 = (($70) + 12|0);
       $78 = HEAP32[$77>>2]|0;
       $79 = ($78|0)==($68|0);
       if ($79) {
        HEAP32[$77>>2] = $66;
        HEAP32[$67>>2] = $70;
        $$pre = HEAP32[((3840 + 8|0))>>2]|0;
        $88 = $$pre;
        break;
       } else {
        _abort();
        // unreachable;
       }
      }
     } while(0);
     $80 = $64 << 3;
     $81 = (($80) - ($5))|0;
     $82 = $5 | 3;
     $83 = (($68) + 4|0);
     HEAP32[$83>>2] = $82;
     $84 = (($68) + ($5)|0);
     $85 = $81 | 1;
     $$sum56 = $5 | 4;
     $86 = (($68) + ($$sum56)|0);
     HEAP32[$86>>2] = $85;
     $87 = (($68) + ($80)|0);
     HEAP32[$87>>2] = $81;
     $89 = ($88|0)==(0);
     if (!($89)) {
      $90 = HEAP32[((3840 + 20|0))>>2]|0;
      $91 = $88 >>> 3;
      $92 = $91 << 1;
      $93 = ((3840 + ($92<<2)|0) + 40|0);
      $94 = HEAP32[3840>>2]|0;
      $95 = 1 << $91;
      $96 = $94 & $95;
      $97 = ($96|0)==(0);
      if ($97) {
       $98 = $94 | $95;
       HEAP32[3840>>2] = $98;
       $$sum8$pre = (($92) + 2)|0;
       $$pre105 = ((3840 + ($$sum8$pre<<2)|0) + 40|0);
       $$pre$phiZ2D = $$pre105;$F4$0 = $93;
      } else {
       $$sum9 = (($92) + 2)|0;
       $99 = ((3840 + ($$sum9<<2)|0) + 40|0);
       $100 = HEAP32[$99>>2]|0;
       $101 = HEAP32[((3840 + 16|0))>>2]|0;
       $102 = ($100>>>0)<($101>>>0);
       if ($102) {
        _abort();
        // unreachable;
       } else {
        $$pre$phiZ2D = $99;$F4$0 = $100;
       }
      }
      HEAP32[$$pre$phiZ2D>>2] = $90;
      $103 = (($F4$0) + 12|0);
      HEAP32[$103>>2] = $90;
      $104 = (($90) + 8|0);
      HEAP32[$104>>2] = $F4$0;
      $105 = (($90) + 12|0);
      HEAP32[$105>>2] = $93;
     }
     HEAP32[((3840 + 8|0))>>2] = $81;
     HEAP32[((3840 + 20|0))>>2] = $84;
     $mem$0 = $69;
     STACKTOP = sp;return ($mem$0|0);
    }
    $106 = HEAP32[((3840 + 4|0))>>2]|0;
    $107 = ($106|0)==(0);
    if ($107) {
     $nb$0 = $5;
    } else {
     $108 = (0 - ($106))|0;
     $109 = $106 & $108;
     $110 = (($109) + -1)|0;
     $111 = $110 >>> 12;
     $112 = $111 & 16;
     $113 = $110 >>> $112;
     $114 = $113 >>> 5;
     $115 = $114 & 8;
     $116 = $115 | $112;
     $117 = $113 >>> $115;
     $118 = $117 >>> 2;
     $119 = $118 & 4;
     $120 = $116 | $119;
     $121 = $117 >>> $119;
     $122 = $121 >>> 1;
     $123 = $122 & 2;
     $124 = $120 | $123;
     $125 = $121 >>> $123;
     $126 = $125 >>> 1;
     $127 = $126 & 1;
     $128 = $124 | $127;
     $129 = $125 >>> $127;
     $130 = (($128) + ($129))|0;
     $131 = ((3840 + ($130<<2)|0) + 304|0);
     $132 = HEAP32[$131>>2]|0;
     $133 = (($132) + 4|0);
     $134 = HEAP32[$133>>2]|0;
     $135 = $134 & -8;
     $136 = (($135) - ($5))|0;
     $rsize$0$i = $136;$t$0$i = $132;$v$0$i = $132;
     while(1) {
      $137 = (($t$0$i) + 16|0);
      $138 = HEAP32[$137>>2]|0;
      $139 = ($138|0)==(0|0);
      if ($139) {
       $140 = (($t$0$i) + 20|0);
       $141 = HEAP32[$140>>2]|0;
       $142 = ($141|0)==(0|0);
       if ($142) {
        $rsize$0$i$lcssa = $rsize$0$i;$v$0$i$lcssa = $v$0$i;
        break;
       } else {
        $144 = $141;
       }
      } else {
       $144 = $138;
      }
      $143 = (($144) + 4|0);
      $145 = HEAP32[$143>>2]|0;
      $146 = $145 & -8;
      $147 = (($146) - ($5))|0;
      $148 = ($147>>>0)<($rsize$0$i>>>0);
      $$rsize$0$i = $148 ? $147 : $rsize$0$i;
      $$v$0$i = $148 ? $144 : $v$0$i;
      $rsize$0$i = $$rsize$0$i;$t$0$i = $144;$v$0$i = $$v$0$i;
     }
     $149 = HEAP32[((3840 + 16|0))>>2]|0;
     $150 = ($v$0$i$lcssa>>>0)<($149>>>0);
     if ($150) {
      _abort();
      // unreachable;
     }
     $151 = (($v$0$i$lcssa) + ($5)|0);
     $152 = ($v$0$i$lcssa>>>0)<($151>>>0);
     if (!($152)) {
      _abort();
      // unreachable;
     }
     $153 = (($v$0$i$lcssa) + 24|0);
     $154 = HEAP32[$153>>2]|0;
     $155 = (($v$0$i$lcssa) + 12|0);
     $156 = HEAP32[$155>>2]|0;
     $157 = ($156|0)==($v$0$i$lcssa|0);
     do {
      if ($157) {
       $167 = (($v$0$i$lcssa) + 20|0);
       $168 = HEAP32[$167>>2]|0;
       $169 = ($168|0)==(0|0);
       if ($169) {
        $170 = (($v$0$i$lcssa) + 16|0);
        $171 = HEAP32[$170>>2]|0;
        $172 = ($171|0)==(0|0);
        if ($172) {
         $R$1$i = 0;
         break;
        } else {
         $R$0$i$ph = $171;$RP$0$i$ph = $170;
        }
       } else {
        $R$0$i$ph = $168;$RP$0$i$ph = $167;
       }
       $R$0$i = $R$0$i$ph;$RP$0$i = $RP$0$i$ph;
       while(1) {
        $173 = (($R$0$i) + 20|0);
        $174 = HEAP32[$173>>2]|0;
        $175 = ($174|0)==(0|0);
        if ($175) {
         $176 = (($R$0$i) + 16|0);
         $177 = HEAP32[$176>>2]|0;
         $178 = ($177|0)==(0|0);
         if ($178) {
          $R$0$i$lcssa = $R$0$i;$RP$0$i$lcssa = $RP$0$i;
          break;
         } else {
          $R$0$i$be = $177;$RP$0$i$be = $176;
         }
        } else {
         $R$0$i$be = $174;$RP$0$i$be = $173;
        }
        $R$0$i = $R$0$i$be;$RP$0$i = $RP$0$i$be;
       }
       $179 = ($RP$0$i$lcssa>>>0)<($149>>>0);
       if ($179) {
        _abort();
        // unreachable;
       } else {
        HEAP32[$RP$0$i$lcssa>>2] = 0;
        $R$1$i = $R$0$i$lcssa;
        break;
       }
      } else {
       $158 = (($v$0$i$lcssa) + 8|0);
       $159 = HEAP32[$158>>2]|0;
       $160 = ($159>>>0)<($149>>>0);
       if ($160) {
        _abort();
        // unreachable;
       }
       $161 = (($159) + 12|0);
       $162 = HEAP32[$161>>2]|0;
       $163 = ($162|0)==($v$0$i$lcssa|0);
       if (!($163)) {
        _abort();
        // unreachable;
       }
       $164 = (($156) + 8|0);
       $165 = HEAP32[$164>>2]|0;
       $166 = ($165|0)==($v$0$i$lcssa|0);
       if ($166) {
        HEAP32[$161>>2] = $156;
        HEAP32[$164>>2] = $159;
        $R$1$i = $156;
        break;
       } else {
        _abort();
        // unreachable;
       }
      }
     } while(0);
     $180 = ($154|0)==(0|0);
     do {
      if (!($180)) {
       $181 = (($v$0$i$lcssa) + 28|0);
       $182 = HEAP32[$181>>2]|0;
       $183 = ((3840 + ($182<<2)|0) + 304|0);
       $184 = HEAP32[$183>>2]|0;
       $185 = ($v$0$i$lcssa|0)==($184|0);
       if ($185) {
        HEAP32[$183>>2] = $R$1$i;
        $cond$i = ($R$1$i|0)==(0|0);
        if ($cond$i) {
         $186 = 1 << $182;
         $187 = $186 ^ -1;
         $188 = HEAP32[((3840 + 4|0))>>2]|0;
         $189 = $188 & $187;
         HEAP32[((3840 + 4|0))>>2] = $189;
         break;
        }
       } else {
        $190 = HEAP32[((3840 + 16|0))>>2]|0;
        $191 = ($154>>>0)<($190>>>0);
        if ($191) {
         _abort();
         // unreachable;
        }
        $192 = (($154) + 16|0);
        $193 = HEAP32[$192>>2]|0;
        $194 = ($193|0)==($v$0$i$lcssa|0);
        if ($194) {
         HEAP32[$192>>2] = $R$1$i;
        } else {
         $195 = (($154) + 20|0);
         HEAP32[$195>>2] = $R$1$i;
        }
        $196 = ($R$1$i|0)==(0|0);
        if ($196) {
         break;
        }
       }
       $197 = HEAP32[((3840 + 16|0))>>2]|0;
       $198 = ($R$1$i>>>0)<($197>>>0);
       if ($198) {
        _abort();
        // unreachable;
       }
       $199 = (($R$1$i) + 24|0);
       HEAP32[$199>>2] = $154;
       $200 = (($v$0$i$lcssa) + 16|0);
       $201 = HEAP32[$200>>2]|0;
       $202 = ($201|0)==(0|0);
       do {
        if (!($202)) {
         $203 = ($201>>>0)<($197>>>0);
         if ($203) {
          _abort();
          // unreachable;
         } else {
          $204 = (($R$1$i) + 16|0);
          HEAP32[$204>>2] = $201;
          $205 = (($201) + 24|0);
          HEAP32[$205>>2] = $R$1$i;
          break;
         }
        }
       } while(0);
       $206 = (($v$0$i$lcssa) + 20|0);
       $207 = HEAP32[$206>>2]|0;
       $208 = ($207|0)==(0|0);
       if (!($208)) {
        $209 = HEAP32[((3840 + 16|0))>>2]|0;
        $210 = ($207>>>0)<($209>>>0);
        if ($210) {
         _abort();
         // unreachable;
        } else {
         $211 = (($R$1$i) + 20|0);
         HEAP32[$211>>2] = $207;
         $212 = (($207) + 24|0);
         HEAP32[$212>>2] = $R$1$i;
         break;
        }
       }
      }
     } while(0);
     $213 = ($rsize$0$i$lcssa>>>0)<(16);
     if ($213) {
      $214 = (($rsize$0$i$lcssa) + ($5))|0;
      $215 = $214 | 3;
      $216 = (($v$0$i$lcssa) + 4|0);
      HEAP32[$216>>2] = $215;
      $$sum4$i = (($214) + 4)|0;
      $217 = (($v$0$i$lcssa) + ($$sum4$i)|0);
      $218 = HEAP32[$217>>2]|0;
      $219 = $218 | 1;
      HEAP32[$217>>2] = $219;
     } else {
      $220 = $5 | 3;
      $221 = (($v$0$i$lcssa) + 4|0);
      HEAP32[$221>>2] = $220;
      $222 = $rsize$0$i$lcssa | 1;
      $$sum$i39 = $5 | 4;
      $223 = (($v$0$i$lcssa) + ($$sum$i39)|0);
      HEAP32[$223>>2] = $222;
      $$sum1$i = (($rsize$0$i$lcssa) + ($5))|0;
      $224 = (($v$0$i$lcssa) + ($$sum1$i)|0);
      HEAP32[$224>>2] = $rsize$0$i$lcssa;
      $225 = HEAP32[((3840 + 8|0))>>2]|0;
      $226 = ($225|0)==(0);
      if (!($226)) {
       $227 = HEAP32[((3840 + 20|0))>>2]|0;
       $228 = $225 >>> 3;
       $229 = $228 << 1;
       $230 = ((3840 + ($229<<2)|0) + 40|0);
       $231 = HEAP32[3840>>2]|0;
       $232 = 1 << $228;
       $233 = $231 & $232;
       $234 = ($233|0)==(0);
       if ($234) {
        $235 = $231 | $232;
        HEAP32[3840>>2] = $235;
        $$sum2$pre$i = (($229) + 2)|0;
        $$pre$i = ((3840 + ($$sum2$pre$i<<2)|0) + 40|0);
        $$pre$phi$iZ2D = $$pre$i;$F1$0$i = $230;
       } else {
        $$sum3$i = (($229) + 2)|0;
        $236 = ((3840 + ($$sum3$i<<2)|0) + 40|0);
        $237 = HEAP32[$236>>2]|0;
        $238 = HEAP32[((3840 + 16|0))>>2]|0;
        $239 = ($237>>>0)<($238>>>0);
        if ($239) {
         _abort();
         // unreachable;
        } else {
         $$pre$phi$iZ2D = $236;$F1$0$i = $237;
        }
       }
       HEAP32[$$pre$phi$iZ2D>>2] = $227;
       $240 = (($F1$0$i) + 12|0);
       HEAP32[$240>>2] = $227;
       $241 = (($227) + 8|0);
       HEAP32[$241>>2] = $F1$0$i;
       $242 = (($227) + 12|0);
       HEAP32[$242>>2] = $230;
      }
      HEAP32[((3840 + 8|0))>>2] = $rsize$0$i$lcssa;
      HEAP32[((3840 + 20|0))>>2] = $151;
     }
     $243 = (($v$0$i$lcssa) + 8|0);
     $mem$0 = $243;
     STACKTOP = sp;return ($mem$0|0);
    }
   } else {
    $nb$0 = $5;
   }
  } else {
   $244 = ($bytes>>>0)>(4294967231);
   if ($244) {
    $nb$0 = -1;
   } else {
    $245 = (($bytes) + 11)|0;
    $246 = $245 & -8;
    $247 = HEAP32[((3840 + 4|0))>>2]|0;
    $248 = ($247|0)==(0);
    if ($248) {
     $nb$0 = $246;
    } else {
     $249 = (0 - ($246))|0;
     $250 = $245 >>> 8;
     $251 = ($250|0)==(0);
     if ($251) {
      $idx$0$i = 0;
     } else {
      $252 = ($246>>>0)>(16777215);
      if ($252) {
       $idx$0$i = 31;
      } else {
       $253 = (($250) + 1048320)|0;
       $254 = $253 >>> 16;
       $255 = $254 & 8;
       $256 = $250 << $255;
       $257 = (($256) + 520192)|0;
       $258 = $257 >>> 16;
       $259 = $258 & 4;
       $260 = $259 | $255;
       $261 = $256 << $259;
       $262 = (($261) + 245760)|0;
       $263 = $262 >>> 16;
       $264 = $263 & 2;
       $265 = $260 | $264;
       $266 = (14 - ($265))|0;
       $267 = $261 << $264;
       $268 = $267 >>> 15;
       $269 = (($266) + ($268))|0;
       $270 = $269 << 1;
       $271 = (($269) + 7)|0;
       $272 = $246 >>> $271;
       $273 = $272 & 1;
       $274 = $273 | $270;
       $idx$0$i = $274;
      }
     }
     $275 = ((3840 + ($idx$0$i<<2)|0) + 304|0);
     $276 = HEAP32[$275>>2]|0;
     $277 = ($276|0)==(0|0);
     if ($277) {
      $rsize$2$i = $249;$t$1$i = 0;$v$2$i = 0;
     } else {
      $278 = ($idx$0$i|0)==(31);
      if ($278) {
       $282 = 0;
      } else {
       $279 = $idx$0$i >>> 1;
       $280 = (25 - ($279))|0;
       $282 = $280;
      }
      $281 = $246 << $282;
      $rsize$0$i15 = $249;$rst$0$i = 0;$sizebits$0$i = $281;$t$0$i14 = $276;$v$0$i16 = 0;
      while(1) {
       $283 = (($t$0$i14) + 4|0);
       $284 = HEAP32[$283>>2]|0;
       $285 = $284 & -8;
       $286 = (($285) - ($246))|0;
       $287 = ($286>>>0)<($rsize$0$i15>>>0);
       if ($287) {
        $288 = ($285|0)==($246|0);
        if ($288) {
         $rsize$2$i$ph = $286;$t$1$i$ph = $t$0$i14;$v$2$i$ph = $t$0$i14;
         break;
        } else {
         $rsize$1$i = $286;$v$1$i = $t$0$i14;
        }
       } else {
        $rsize$1$i = $rsize$0$i15;$v$1$i = $v$0$i16;
       }
       $289 = (($t$0$i14) + 20|0);
       $290 = HEAP32[$289>>2]|0;
       $291 = $sizebits$0$i >>> 31;
       $292 = ((($t$0$i14) + ($291<<2)|0) + 16|0);
       $293 = HEAP32[$292>>2]|0;
       $294 = ($290|0)==(0|0);
       $295 = ($290|0)==($293|0);
       $or$cond19$i = $294 | $295;
       $rst$1$i = $or$cond19$i ? $rst$0$i : $290;
       $296 = ($293|0)==(0|0);
       $297 = $sizebits$0$i << 1;
       if ($296) {
        $rsize$2$i$ph = $rsize$1$i;$t$1$i$ph = $rst$1$i;$v$2$i$ph = $v$1$i;
        break;
       } else {
        $rsize$0$i15 = $rsize$1$i;$rst$0$i = $rst$1$i;$sizebits$0$i = $297;$t$0$i14 = $293;$v$0$i16 = $v$1$i;
       }
      }
      $rsize$2$i = $rsize$2$i$ph;$t$1$i = $t$1$i$ph;$v$2$i = $v$2$i$ph;
     }
     $298 = ($t$1$i|0)==(0|0);
     $299 = ($v$2$i|0)==(0|0);
     $or$cond$i = $298 & $299;
     if ($or$cond$i) {
      $300 = 2 << $idx$0$i;
      $301 = (0 - ($300))|0;
      $302 = $300 | $301;
      $303 = $247 & $302;
      $304 = ($303|0)==(0);
      if ($304) {
       $nb$0 = $246;
       break;
      }
      $305 = (0 - ($303))|0;
      $306 = $303 & $305;
      $307 = (($306) + -1)|0;
      $308 = $307 >>> 12;
      $309 = $308 & 16;
      $310 = $307 >>> $309;
      $311 = $310 >>> 5;
      $312 = $311 & 8;
      $313 = $312 | $309;
      $314 = $310 >>> $312;
      $315 = $314 >>> 2;
      $316 = $315 & 4;
      $317 = $313 | $316;
      $318 = $314 >>> $316;
      $319 = $318 >>> 1;
      $320 = $319 & 2;
      $321 = $317 | $320;
      $322 = $318 >>> $320;
      $323 = $322 >>> 1;
      $324 = $323 & 1;
      $325 = $321 | $324;
      $326 = $322 >>> $324;
      $327 = (($325) + ($326))|0;
      $328 = ((3840 + ($327<<2)|0) + 304|0);
      $329 = HEAP32[$328>>2]|0;
      $t$2$ph$i = $329;
     } else {
      $t$2$ph$i = $t$1$i;
     }
     $330 = ($t$2$ph$i|0)==(0|0);
     if ($330) {
      $rsize$3$lcssa$i = $rsize$2$i;$v$3$lcssa$i = $v$2$i;
     } else {
      $rsize$331$i = $rsize$2$i;$t$230$i = $t$2$ph$i;$v$332$i = $v$2$i;
      while(1) {
       $331 = (($t$230$i) + 4|0);
       $332 = HEAP32[$331>>2]|0;
       $333 = $332 & -8;
       $334 = (($333) - ($246))|0;
       $335 = ($334>>>0)<($rsize$331$i>>>0);
       $$rsize$3$i = $335 ? $334 : $rsize$331$i;
       $t$2$v$3$i = $335 ? $t$230$i : $v$332$i;
       $336 = (($t$230$i) + 16|0);
       $337 = HEAP32[$336>>2]|0;
       $338 = ($337|0)==(0|0);
       if ($338) {
        $339 = (($t$230$i) + 20|0);
        $340 = HEAP32[$339>>2]|0;
        $341 = ($340|0)==(0|0);
        if ($341) {
         $$rsize$3$i$lcssa = $$rsize$3$i;$t$2$v$3$i$lcssa = $t$2$v$3$i;
         break;
        } else {
         $t$230$i$be = $340;
        }
       } else {
        $t$230$i$be = $337;
       }
       $rsize$331$i = $$rsize$3$i;$t$230$i = $t$230$i$be;$v$332$i = $t$2$v$3$i;
      }
      $rsize$3$lcssa$i = $$rsize$3$i$lcssa;$v$3$lcssa$i = $t$2$v$3$i$lcssa;
     }
     $342 = ($v$3$lcssa$i|0)==(0|0);
     if ($342) {
      $nb$0 = $246;
     } else {
      $343 = HEAP32[((3840 + 8|0))>>2]|0;
      $344 = (($343) - ($246))|0;
      $345 = ($rsize$3$lcssa$i>>>0)<($344>>>0);
      if ($345) {
       $346 = HEAP32[((3840 + 16|0))>>2]|0;
       $347 = ($v$3$lcssa$i>>>0)<($346>>>0);
       if ($347) {
        _abort();
        // unreachable;
       }
       $348 = (($v$3$lcssa$i) + ($246)|0);
       $349 = ($v$3$lcssa$i>>>0)<($348>>>0);
       if (!($349)) {
        _abort();
        // unreachable;
       }
       $350 = (($v$3$lcssa$i) + 24|0);
       $351 = HEAP32[$350>>2]|0;
       $352 = (($v$3$lcssa$i) + 12|0);
       $353 = HEAP32[$352>>2]|0;
       $354 = ($353|0)==($v$3$lcssa$i|0);
       do {
        if ($354) {
         $364 = (($v$3$lcssa$i) + 20|0);
         $365 = HEAP32[$364>>2]|0;
         $366 = ($365|0)==(0|0);
         if ($366) {
          $367 = (($v$3$lcssa$i) + 16|0);
          $368 = HEAP32[$367>>2]|0;
          $369 = ($368|0)==(0|0);
          if ($369) {
           $R$1$i20 = 0;
           break;
          } else {
           $R$0$i18$ph = $368;$RP$0$i17$ph = $367;
          }
         } else {
          $R$0$i18$ph = $365;$RP$0$i17$ph = $364;
         }
         $R$0$i18 = $R$0$i18$ph;$RP$0$i17 = $RP$0$i17$ph;
         while(1) {
          $370 = (($R$0$i18) + 20|0);
          $371 = HEAP32[$370>>2]|0;
          $372 = ($371|0)==(0|0);
          if ($372) {
           $373 = (($R$0$i18) + 16|0);
           $374 = HEAP32[$373>>2]|0;
           $375 = ($374|0)==(0|0);
           if ($375) {
            $R$0$i18$lcssa = $R$0$i18;$RP$0$i17$lcssa = $RP$0$i17;
            break;
           } else {
            $R$0$i18$be = $374;$RP$0$i17$be = $373;
           }
          } else {
           $R$0$i18$be = $371;$RP$0$i17$be = $370;
          }
          $R$0$i18 = $R$0$i18$be;$RP$0$i17 = $RP$0$i17$be;
         }
         $376 = ($RP$0$i17$lcssa>>>0)<($346>>>0);
         if ($376) {
          _abort();
          // unreachable;
         } else {
          HEAP32[$RP$0$i17$lcssa>>2] = 0;
          $R$1$i20 = $R$0$i18$lcssa;
          break;
         }
        } else {
         $355 = (($v$3$lcssa$i) + 8|0);
         $356 = HEAP32[$355>>2]|0;
         $357 = ($356>>>0)<($346>>>0);
         if ($357) {
          _abort();
          // unreachable;
         }
         $358 = (($356) + 12|0);
         $359 = HEAP32[$358>>2]|0;
         $360 = ($359|0)==($v$3$lcssa$i|0);
         if (!($360)) {
          _abort();
          // unreachable;
         }
         $361 = (($353) + 8|0);
         $362 = HEAP32[$361>>2]|0;
         $363 = ($362|0)==($v$3$lcssa$i|0);
         if ($363) {
          HEAP32[$358>>2] = $353;
          HEAP32[$361>>2] = $356;
          $R$1$i20 = $353;
          break;
         } else {
          _abort();
          // unreachable;
         }
        }
       } while(0);
       $377 = ($351|0)==(0|0);
       do {
        if (!($377)) {
         $378 = (($v$3$lcssa$i) + 28|0);
         $379 = HEAP32[$378>>2]|0;
         $380 = ((3840 + ($379<<2)|0) + 304|0);
         $381 = HEAP32[$380>>2]|0;
         $382 = ($v$3$lcssa$i|0)==($381|0);
         if ($382) {
          HEAP32[$380>>2] = $R$1$i20;
          $cond$i21 = ($R$1$i20|0)==(0|0);
          if ($cond$i21) {
           $383 = 1 << $379;
           $384 = $383 ^ -1;
           $385 = HEAP32[((3840 + 4|0))>>2]|0;
           $386 = $385 & $384;
           HEAP32[((3840 + 4|0))>>2] = $386;
           break;
          }
         } else {
          $387 = HEAP32[((3840 + 16|0))>>2]|0;
          $388 = ($351>>>0)<($387>>>0);
          if ($388) {
           _abort();
           // unreachable;
          }
          $389 = (($351) + 16|0);
          $390 = HEAP32[$389>>2]|0;
          $391 = ($390|0)==($v$3$lcssa$i|0);
          if ($391) {
           HEAP32[$389>>2] = $R$1$i20;
          } else {
           $392 = (($351) + 20|0);
           HEAP32[$392>>2] = $R$1$i20;
          }
          $393 = ($R$1$i20|0)==(0|0);
          if ($393) {
           break;
          }
         }
         $394 = HEAP32[((3840 + 16|0))>>2]|0;
         $395 = ($R$1$i20>>>0)<($394>>>0);
         if ($395) {
          _abort();
          // unreachable;
         }
         $396 = (($R$1$i20) + 24|0);
         HEAP32[$396>>2] = $351;
         $397 = (($v$3$lcssa$i) + 16|0);
         $398 = HEAP32[$397>>2]|0;
         $399 = ($398|0)==(0|0);
         do {
          if (!($399)) {
           $400 = ($398>>>0)<($394>>>0);
           if ($400) {
            _abort();
            // unreachable;
           } else {
            $401 = (($R$1$i20) + 16|0);
            HEAP32[$401>>2] = $398;
            $402 = (($398) + 24|0);
            HEAP32[$402>>2] = $R$1$i20;
            break;
           }
          }
         } while(0);
         $403 = (($v$3$lcssa$i) + 20|0);
         $404 = HEAP32[$403>>2]|0;
         $405 = ($404|0)==(0|0);
         if (!($405)) {
          $406 = HEAP32[((3840 + 16|0))>>2]|0;
          $407 = ($404>>>0)<($406>>>0);
          if ($407) {
           _abort();
           // unreachable;
          } else {
           $408 = (($R$1$i20) + 20|0);
           HEAP32[$408>>2] = $404;
           $409 = (($404) + 24|0);
           HEAP32[$409>>2] = $R$1$i20;
           break;
          }
         }
        }
       } while(0);
       $410 = ($rsize$3$lcssa$i>>>0)<(16);
       L215: do {
        if ($410) {
         $411 = (($rsize$3$lcssa$i) + ($246))|0;
         $412 = $411 | 3;
         $413 = (($v$3$lcssa$i) + 4|0);
         HEAP32[$413>>2] = $412;
         $$sum18$i = (($411) + 4)|0;
         $414 = (($v$3$lcssa$i) + ($$sum18$i)|0);
         $415 = HEAP32[$414>>2]|0;
         $416 = $415 | 1;
         HEAP32[$414>>2] = $416;
        } else {
         $417 = $246 | 3;
         $418 = (($v$3$lcssa$i) + 4|0);
         HEAP32[$418>>2] = $417;
         $419 = $rsize$3$lcssa$i | 1;
         $$sum$i2338 = $246 | 4;
         $420 = (($v$3$lcssa$i) + ($$sum$i2338)|0);
         HEAP32[$420>>2] = $419;
         $$sum1$i24 = (($rsize$3$lcssa$i) + ($246))|0;
         $421 = (($v$3$lcssa$i) + ($$sum1$i24)|0);
         HEAP32[$421>>2] = $rsize$3$lcssa$i;
         $422 = $rsize$3$lcssa$i >>> 3;
         $423 = ($rsize$3$lcssa$i>>>0)<(256);
         if ($423) {
          $424 = $422 << 1;
          $425 = ((3840 + ($424<<2)|0) + 40|0);
          $426 = HEAP32[3840>>2]|0;
          $427 = 1 << $422;
          $428 = $426 & $427;
          $429 = ($428|0)==(0);
          do {
           if ($429) {
            $430 = $426 | $427;
            HEAP32[3840>>2] = $430;
            $$sum14$pre$i = (($424) + 2)|0;
            $$pre$i25 = ((3840 + ($$sum14$pre$i<<2)|0) + 40|0);
            $$pre$phi$i26Z2D = $$pre$i25;$F5$0$i = $425;
           } else {
            $$sum17$i = (($424) + 2)|0;
            $431 = ((3840 + ($$sum17$i<<2)|0) + 40|0);
            $432 = HEAP32[$431>>2]|0;
            $433 = HEAP32[((3840 + 16|0))>>2]|0;
            $434 = ($432>>>0)<($433>>>0);
            if (!($434)) {
             $$pre$phi$i26Z2D = $431;$F5$0$i = $432;
             break;
            }
            _abort();
            // unreachable;
           }
          } while(0);
          HEAP32[$$pre$phi$i26Z2D>>2] = $348;
          $435 = (($F5$0$i) + 12|0);
          HEAP32[$435>>2] = $348;
          $$sum15$i = (($246) + 8)|0;
          $436 = (($v$3$lcssa$i) + ($$sum15$i)|0);
          HEAP32[$436>>2] = $F5$0$i;
          $$sum16$i = (($246) + 12)|0;
          $437 = (($v$3$lcssa$i) + ($$sum16$i)|0);
          HEAP32[$437>>2] = $425;
          break;
         }
         $438 = $rsize$3$lcssa$i >>> 8;
         $439 = ($438|0)==(0);
         if ($439) {
          $I7$0$i = 0;
         } else {
          $440 = ($rsize$3$lcssa$i>>>0)>(16777215);
          if ($440) {
           $I7$0$i = 31;
          } else {
           $441 = (($438) + 1048320)|0;
           $442 = $441 >>> 16;
           $443 = $442 & 8;
           $444 = $438 << $443;
           $445 = (($444) + 520192)|0;
           $446 = $445 >>> 16;
           $447 = $446 & 4;
           $448 = $447 | $443;
           $449 = $444 << $447;
           $450 = (($449) + 245760)|0;
           $451 = $450 >>> 16;
           $452 = $451 & 2;
           $453 = $448 | $452;
           $454 = (14 - ($453))|0;
           $455 = $449 << $452;
           $456 = $455 >>> 15;
           $457 = (($454) + ($456))|0;
           $458 = $457 << 1;
           $459 = (($457) + 7)|0;
           $460 = $rsize$3$lcssa$i >>> $459;
           $461 = $460 & 1;
           $462 = $461 | $458;
           $I7$0$i = $462;
          }
         }
         $463 = ((3840 + ($I7$0$i<<2)|0) + 304|0);
         $$sum2$i = (($246) + 28)|0;
         $464 = (($v$3$lcssa$i) + ($$sum2$i)|0);
         HEAP32[$464>>2] = $I7$0$i;
         $$sum3$i27 = (($246) + 16)|0;
         $465 = (($v$3$lcssa$i) + ($$sum3$i27)|0);
         $$sum4$i28 = (($246) + 20)|0;
         $466 = (($v$3$lcssa$i) + ($$sum4$i28)|0);
         HEAP32[$466>>2] = 0;
         HEAP32[$465>>2] = 0;
         $467 = HEAP32[((3840 + 4|0))>>2]|0;
         $468 = 1 << $I7$0$i;
         $469 = $467 & $468;
         $470 = ($469|0)==(0);
         if ($470) {
          $471 = $467 | $468;
          HEAP32[((3840 + 4|0))>>2] = $471;
          HEAP32[$463>>2] = $348;
          $$sum5$i = (($246) + 24)|0;
          $472 = (($v$3$lcssa$i) + ($$sum5$i)|0);
          HEAP32[$472>>2] = $463;
          $$sum6$i = (($246) + 12)|0;
          $473 = (($v$3$lcssa$i) + ($$sum6$i)|0);
          HEAP32[$473>>2] = $348;
          $$sum7$i = (($246) + 8)|0;
          $474 = (($v$3$lcssa$i) + ($$sum7$i)|0);
          HEAP32[$474>>2] = $348;
          break;
         }
         $475 = HEAP32[$463>>2]|0;
         $476 = ($I7$0$i|0)==(31);
         if ($476) {
          $484 = 0;
         } else {
          $477 = $I7$0$i >>> 1;
          $478 = (25 - ($477))|0;
          $484 = $478;
         }
         $479 = (($475) + 4|0);
         $480 = HEAP32[$479>>2]|0;
         $481 = $480 & -8;
         $482 = ($481|0)==($rsize$3$lcssa$i|0);
         do {
          if ($482) {
           $T$0$lcssa$i = $475;
          } else {
           $483 = $rsize$3$lcssa$i << $484;
           $K12$029$i = $483;$T$028$i = $475;
           while(1) {
            $491 = $K12$029$i >>> 31;
            $492 = ((($T$028$i) + ($491<<2)|0) + 16|0);
            $487 = HEAP32[$492>>2]|0;
            $493 = ($487|0)==(0|0);
            if ($493) {
             $$lcssa134 = $492;$T$028$i$lcssa = $T$028$i;
             break;
            }
            $485 = $K12$029$i << 1;
            $486 = (($487) + 4|0);
            $488 = HEAP32[$486>>2]|0;
            $489 = $488 & -8;
            $490 = ($489|0)==($rsize$3$lcssa$i|0);
            if ($490) {
             $$lcssa137 = $487;
             label = 163;
             break;
            } else {
             $K12$029$i = $485;$T$028$i = $487;
            }
           }
           if ((label|0) == 163) {
            $T$0$lcssa$i = $$lcssa137;
            break;
           }
           $494 = HEAP32[((3840 + 16|0))>>2]|0;
           $495 = ($$lcssa134>>>0)<($494>>>0);
           if ($495) {
            _abort();
            // unreachable;
           } else {
            HEAP32[$$lcssa134>>2] = $348;
            $$sum11$i = (($246) + 24)|0;
            $496 = (($v$3$lcssa$i) + ($$sum11$i)|0);
            HEAP32[$496>>2] = $T$028$i$lcssa;
            $$sum12$i = (($246) + 12)|0;
            $497 = (($v$3$lcssa$i) + ($$sum12$i)|0);
            HEAP32[$497>>2] = $348;
            $$sum13$i = (($246) + 8)|0;
            $498 = (($v$3$lcssa$i) + ($$sum13$i)|0);
            HEAP32[$498>>2] = $348;
            break L215;
           }
          }
         } while(0);
         $499 = (($T$0$lcssa$i) + 8|0);
         $500 = HEAP32[$499>>2]|0;
         $501 = HEAP32[((3840 + 16|0))>>2]|0;
         $502 = ($T$0$lcssa$i>>>0)>=($501>>>0);
         $503 = ($500>>>0)>=($501>>>0);
         $or$cond24$i = $502 & $503;
         if ($or$cond24$i) {
          $504 = (($500) + 12|0);
          HEAP32[$504>>2] = $348;
          HEAP32[$499>>2] = $348;
          $$sum8$i = (($246) + 8)|0;
          $505 = (($v$3$lcssa$i) + ($$sum8$i)|0);
          HEAP32[$505>>2] = $500;
          $$sum9$i = (($246) + 12)|0;
          $506 = (($v$3$lcssa$i) + ($$sum9$i)|0);
          HEAP32[$506>>2] = $T$0$lcssa$i;
          $$sum10$i = (($246) + 24)|0;
          $507 = (($v$3$lcssa$i) + ($$sum10$i)|0);
          HEAP32[$507>>2] = 0;
          break;
         } else {
          _abort();
          // unreachable;
         }
        }
       } while(0);
       $508 = (($v$3$lcssa$i) + 8|0);
       $mem$0 = $508;
       STACKTOP = sp;return ($mem$0|0);
      } else {
       $nb$0 = $246;
      }
     }
    }
   }
  }
 } while(0);
 $509 = HEAP32[((3840 + 8|0))>>2]|0;
 $510 = ($509>>>0)<($nb$0>>>0);
 if (!($510)) {
  $511 = (($509) - ($nb$0))|0;
  $512 = HEAP32[((3840 + 20|0))>>2]|0;
  $513 = ($511>>>0)>(15);
  if ($513) {
   $514 = (($512) + ($nb$0)|0);
   HEAP32[((3840 + 20|0))>>2] = $514;
   HEAP32[((3840 + 8|0))>>2] = $511;
   $515 = $511 | 1;
   $$sum2 = (($nb$0) + 4)|0;
   $516 = (($512) + ($$sum2)|0);
   HEAP32[$516>>2] = $515;
   $517 = (($512) + ($509)|0);
   HEAP32[$517>>2] = $511;
   $518 = $nb$0 | 3;
   $519 = (($512) + 4|0);
   HEAP32[$519>>2] = $518;
  } else {
   HEAP32[((3840 + 8|0))>>2] = 0;
   HEAP32[((3840 + 20|0))>>2] = 0;
   $520 = $509 | 3;
   $521 = (($512) + 4|0);
   HEAP32[$521>>2] = $520;
   $$sum1 = (($509) + 4)|0;
   $522 = (($512) + ($$sum1)|0);
   $523 = HEAP32[$522>>2]|0;
   $524 = $523 | 1;
   HEAP32[$522>>2] = $524;
  }
  $525 = (($512) + 8|0);
  $mem$0 = $525;
  STACKTOP = sp;return ($mem$0|0);
 }
 $526 = HEAP32[((3840 + 12|0))>>2]|0;
 $527 = ($526>>>0)>($nb$0>>>0);
 if ($527) {
  $528 = (($526) - ($nb$0))|0;
  HEAP32[((3840 + 12|0))>>2] = $528;
  $529 = HEAP32[((3840 + 24|0))>>2]|0;
  $530 = (($529) + ($nb$0)|0);
  HEAP32[((3840 + 24|0))>>2] = $530;
  $531 = $528 | 1;
  $$sum = (($nb$0) + 4)|0;
  $532 = (($529) + ($$sum)|0);
  HEAP32[$532>>2] = $531;
  $533 = $nb$0 | 3;
  $534 = (($529) + 4|0);
  HEAP32[$534>>2] = $533;
  $535 = (($529) + 8|0);
  $mem$0 = $535;
  STACKTOP = sp;return ($mem$0|0);
 }
 $536 = HEAP32[4312>>2]|0;
 $537 = ($536|0)==(0);
 do {
  if ($537) {
   $538 = (_sysconf(30)|0);
   $539 = (($538) + -1)|0;
   $540 = $539 & $538;
   $541 = ($540|0)==(0);
   if ($541) {
    HEAP32[((4312 + 8|0))>>2] = $538;
    HEAP32[((4312 + 4|0))>>2] = $538;
    HEAP32[((4312 + 12|0))>>2] = -1;
    HEAP32[((4312 + 16|0))>>2] = -1;
    HEAP32[((4312 + 20|0))>>2] = 0;
    HEAP32[((3840 + 444|0))>>2] = 0;
    $542 = (_time((0|0))|0);
    $543 = $542 & -16;
    $544 = $543 ^ 1431655768;
    HEAP32[4312>>2] = $544;
    break;
   } else {
    _abort();
    // unreachable;
   }
  }
 } while(0);
 $545 = (($nb$0) + 48)|0;
 $546 = HEAP32[((4312 + 8|0))>>2]|0;
 $547 = (($nb$0) + 47)|0;
 $548 = (($546) + ($547))|0;
 $549 = (0 - ($546))|0;
 $550 = $548 & $549;
 $551 = ($550>>>0)>($nb$0>>>0);
 if (!($551)) {
  $mem$0 = 0;
  STACKTOP = sp;return ($mem$0|0);
 }
 $552 = HEAP32[((3840 + 440|0))>>2]|0;
 $553 = ($552|0)==(0);
 if (!($553)) {
  $554 = HEAP32[((3840 + 432|0))>>2]|0;
  $555 = (($554) + ($550))|0;
  $556 = ($555>>>0)<=($554>>>0);
  $557 = ($555>>>0)>($552>>>0);
  $or$cond1$i = $556 | $557;
  if ($or$cond1$i) {
   $mem$0 = 0;
   STACKTOP = sp;return ($mem$0|0);
  }
 }
 $558 = HEAP32[((3840 + 444|0))>>2]|0;
 $559 = $558 & 4;
 $560 = ($559|0)==(0);
 L279: do {
  if ($560) {
   $561 = HEAP32[((3840 + 24|0))>>2]|0;
   $562 = ($561|0)==(0|0);
   do {
    if ($562) {
     label = 191;
    } else {
     $sp$0$i$i = ((3840 + 448|0));
     while(1) {
      $563 = HEAP32[$sp$0$i$i>>2]|0;
      $564 = ($563>>>0)>($561>>>0);
      if (!($564)) {
       $565 = (($sp$0$i$i) + 4|0);
       $566 = HEAP32[$565>>2]|0;
       $567 = (($563) + ($566)|0);
       $568 = ($567>>>0)>($561>>>0);
       if ($568) {
        $$lcssa130 = $sp$0$i$i;$$lcssa132 = $565;$sp$0$i$i$lcssa = $sp$0$i$i;
        break;
       }
      }
      $569 = (($sp$0$i$i) + 8|0);
      $570 = HEAP32[$569>>2]|0;
      $571 = ($570|0)==(0|0);
      if ($571) {
       label = 190;
       break;
      } else {
       $sp$0$i$i = $570;
      }
     }
     if ((label|0) == 190) {
      label = 191;
      break;
     }
     $572 = ($sp$0$i$i$lcssa|0)==(0|0);
     if ($572) {
      label = 191;
     } else {
      $595 = HEAP32[((3840 + 12|0))>>2]|0;
      $596 = (($548) - ($595))|0;
      $597 = $596 & $549;
      $598 = ($597>>>0)<(2147483647);
      if ($598) {
       $599 = (_sbrk(($597|0))|0);
       $600 = HEAP32[$$lcssa130>>2]|0;
       $601 = HEAP32[$$lcssa132>>2]|0;
       $602 = (($600) + ($601)|0);
       $603 = ($599|0)==($602|0);
       if ($603) {
        $br$0$i = $599;$ssize$1$i = $597;
        label = 200;
       } else {
        $br$030$i = $599;$ssize$129$i = $597;
        label = 201;
       }
      } else {
       $tsize$03141$i = 0;
      }
     }
    }
   } while(0);
   do {
    if ((label|0) == 191) {
     $573 = (_sbrk(0)|0);
     $574 = ($573|0)==((-1)|0);
     if ($574) {
      $tsize$03141$i = 0;
     } else {
      $575 = $573;
      $576 = HEAP32[((4312 + 4|0))>>2]|0;
      $577 = (($576) + -1)|0;
      $578 = $577 & $575;
      $579 = ($578|0)==(0);
      if ($579) {
       $ssize$0$i = $550;
      } else {
       $580 = (($577) + ($575))|0;
       $581 = (0 - ($576))|0;
       $582 = $580 & $581;
       $583 = (($550) - ($575))|0;
       $584 = (($583) + ($582))|0;
       $ssize$0$i = $584;
      }
      $585 = HEAP32[((3840 + 432|0))>>2]|0;
      $586 = (($585) + ($ssize$0$i))|0;
      $587 = ($ssize$0$i>>>0)>($nb$0>>>0);
      $588 = ($ssize$0$i>>>0)<(2147483647);
      $or$cond$i29 = $587 & $588;
      if ($or$cond$i29) {
       $589 = HEAP32[((3840 + 440|0))>>2]|0;
       $590 = ($589|0)==(0);
       if (!($590)) {
        $591 = ($586>>>0)<=($585>>>0);
        $592 = ($586>>>0)>($589>>>0);
        $or$cond2$i = $591 | $592;
        if ($or$cond2$i) {
         $tsize$03141$i = 0;
         break;
        }
       }
       $593 = (_sbrk(($ssize$0$i|0))|0);
       $594 = ($593|0)==($573|0);
       if ($594) {
        $br$0$i = $573;$ssize$1$i = $ssize$0$i;
        label = 200;
       } else {
        $br$030$i = $593;$ssize$129$i = $ssize$0$i;
        label = 201;
       }
      } else {
       $tsize$03141$i = 0;
      }
     }
    }
   } while(0);
   L303: do {
    if ((label|0) == 200) {
     $604 = ($br$0$i|0)==((-1)|0);
     if ($604) {
      $tsize$03141$i = $ssize$1$i;
     } else {
      $tbase$245$i = $br$0$i;$tsize$244$i = $ssize$1$i;
      label = 211;
      break L279;
     }
    }
    else if ((label|0) == 201) {
     $605 = (0 - ($ssize$129$i))|0;
     $606 = ($br$030$i|0)!=((-1)|0);
     $607 = ($ssize$129$i>>>0)<(2147483647);
     $or$cond5$i = $606 & $607;
     $608 = ($545>>>0)>($ssize$129$i>>>0);
     $or$cond4$i = $or$cond5$i & $608;
     do {
      if ($or$cond4$i) {
       $609 = HEAP32[((4312 + 8|0))>>2]|0;
       $610 = (($547) - ($ssize$129$i))|0;
       $611 = (($610) + ($609))|0;
       $612 = (0 - ($609))|0;
       $613 = $611 & $612;
       $614 = ($613>>>0)<(2147483647);
       if ($614) {
        $615 = (_sbrk(($613|0))|0);
        $616 = ($615|0)==((-1)|0);
        if ($616) {
         (_sbrk(($605|0))|0);
         $tsize$03141$i = 0;
         break L303;
        } else {
         $617 = (($613) + ($ssize$129$i))|0;
         $ssize$2$i = $617;
         break;
        }
       } else {
        $ssize$2$i = $ssize$129$i;
       }
      } else {
       $ssize$2$i = $ssize$129$i;
      }
     } while(0);
     $618 = ($br$030$i|0)==((-1)|0);
     if ($618) {
      $tsize$03141$i = 0;
     } else {
      $tbase$245$i = $br$030$i;$tsize$244$i = $ssize$2$i;
      label = 211;
      break L279;
     }
    }
   } while(0);
   $619 = HEAP32[((3840 + 444|0))>>2]|0;
   $620 = $619 | 4;
   HEAP32[((3840 + 444|0))>>2] = $620;
   $tsize$1$i = $tsize$03141$i;
   label = 208;
  } else {
   $tsize$1$i = 0;
   label = 208;
  }
 } while(0);
 if ((label|0) == 208) {
  $621 = ($550>>>0)<(2147483647);
  if ($621) {
   $622 = (_sbrk(($550|0))|0);
   $623 = (_sbrk(0)|0);
   $624 = ($622|0)!=((-1)|0);
   $625 = ($623|0)!=((-1)|0);
   $or$cond3$i = $624 & $625;
   $626 = ($622>>>0)<($623>>>0);
   $or$cond6$i = $or$cond3$i & $626;
   if ($or$cond6$i) {
    $627 = $623;
    $628 = $622;
    $629 = (($627) - ($628))|0;
    $630 = (($nb$0) + 40)|0;
    $631 = ($629>>>0)>($630>>>0);
    $$tsize$1$i = $631 ? $629 : $tsize$1$i;
    if ($631) {
     $tbase$245$i = $622;$tsize$244$i = $$tsize$1$i;
     label = 211;
    }
   }
  }
 }
 if ((label|0) == 211) {
  $632 = HEAP32[((3840 + 432|0))>>2]|0;
  $633 = (($632) + ($tsize$244$i))|0;
  HEAP32[((3840 + 432|0))>>2] = $633;
  $634 = HEAP32[((3840 + 436|0))>>2]|0;
  $635 = ($633>>>0)>($634>>>0);
  if ($635) {
   HEAP32[((3840 + 436|0))>>2] = $633;
  }
  $636 = HEAP32[((3840 + 24|0))>>2]|0;
  $637 = ($636|0)==(0|0);
  L323: do {
   if ($637) {
    $638 = HEAP32[((3840 + 16|0))>>2]|0;
    $639 = ($638|0)==(0|0);
    $640 = ($tbase$245$i>>>0)<($638>>>0);
    $or$cond8$i = $639 | $640;
    if ($or$cond8$i) {
     HEAP32[((3840 + 16|0))>>2] = $tbase$245$i;
    }
    HEAP32[((3840 + 448|0))>>2] = $tbase$245$i;
    HEAP32[((3840 + 452|0))>>2] = $tsize$244$i;
    HEAP32[((3840 + 460|0))>>2] = 0;
    $641 = HEAP32[4312>>2]|0;
    HEAP32[((3840 + 36|0))>>2] = $641;
    HEAP32[((3840 + 32|0))>>2] = -1;
    $i$02$i$i = 0;
    while(1) {
     $642 = $i$02$i$i << 1;
     $643 = ((3840 + ($642<<2)|0) + 40|0);
     $$sum$i$i = (($642) + 3)|0;
     $644 = ((3840 + ($$sum$i$i<<2)|0) + 40|0);
     HEAP32[$644>>2] = $643;
     $$sum1$i$i = (($642) + 2)|0;
     $645 = ((3840 + ($$sum1$i$i<<2)|0) + 40|0);
     HEAP32[$645>>2] = $643;
     $646 = (($i$02$i$i) + 1)|0;
     $exitcond$i$i = ($646|0)==(32);
     if ($exitcond$i$i) {
      break;
     } else {
      $i$02$i$i = $646;
     }
    }
    $647 = (($tsize$244$i) + -40)|0;
    $648 = (($tbase$245$i) + 8|0);
    $649 = $648;
    $650 = $649 & 7;
    $651 = ($650|0)==(0);
    if ($651) {
     $655 = 0;
    } else {
     $652 = (0 - ($649))|0;
     $653 = $652 & 7;
     $655 = $653;
    }
    $654 = (($tbase$245$i) + ($655)|0);
    $656 = (($647) - ($655))|0;
    HEAP32[((3840 + 24|0))>>2] = $654;
    HEAP32[((3840 + 12|0))>>2] = $656;
    $657 = $656 | 1;
    $$sum$i12$i = (($655) + 4)|0;
    $658 = (($tbase$245$i) + ($$sum$i12$i)|0);
    HEAP32[$658>>2] = $657;
    $$sum2$i$i = (($tsize$244$i) + -36)|0;
    $659 = (($tbase$245$i) + ($$sum2$i$i)|0);
    HEAP32[$659>>2] = 40;
    $660 = HEAP32[((4312 + 16|0))>>2]|0;
    HEAP32[((3840 + 28|0))>>2] = $660;
   } else {
    $sp$074$i = ((3840 + 448|0));
    while(1) {
     $661 = HEAP32[$sp$074$i>>2]|0;
     $662 = (($sp$074$i) + 4|0);
     $663 = HEAP32[$662>>2]|0;
     $664 = (($661) + ($663)|0);
     $665 = ($tbase$245$i|0)==($664|0);
     if ($665) {
      $$lcssa123 = $661;$$lcssa125 = $662;$$lcssa127 = $663;$sp$074$i$lcssa = $sp$074$i;
      label = 224;
      break;
     }
     $666 = (($sp$074$i) + 8|0);
     $667 = HEAP32[$666>>2]|0;
     $668 = ($667|0)==(0|0);
     if ($668) {
      label = 229;
      break;
     } else {
      $sp$074$i = $667;
     }
    }
    if ((label|0) == 224) {
     $669 = (($sp$074$i$lcssa) + 12|0);
     $670 = HEAP32[$669>>2]|0;
     $671 = $670 & 8;
     $672 = ($671|0)==(0);
     if ($672) {
      $673 = ($636>>>0)>=($$lcssa123>>>0);
      $674 = ($636>>>0)<($tbase$245$i>>>0);
      $or$cond47$i = $673 & $674;
      if ($or$cond47$i) {
       $675 = (($$lcssa127) + ($tsize$244$i))|0;
       HEAP32[$$lcssa125>>2] = $675;
       $676 = HEAP32[((3840 + 12|0))>>2]|0;
       $677 = (($676) + ($tsize$244$i))|0;
       $678 = (($636) + 8|0);
       $679 = $678;
       $680 = $679 & 7;
       $681 = ($680|0)==(0);
       if ($681) {
        $685 = 0;
       } else {
        $682 = (0 - ($679))|0;
        $683 = $682 & 7;
        $685 = $683;
       }
       $684 = (($636) + ($685)|0);
       $686 = (($677) - ($685))|0;
       HEAP32[((3840 + 24|0))>>2] = $684;
       HEAP32[((3840 + 12|0))>>2] = $686;
       $687 = $686 | 1;
       $$sum$i16$i = (($685) + 4)|0;
       $688 = (($636) + ($$sum$i16$i)|0);
       HEAP32[$688>>2] = $687;
       $$sum2$i17$i = (($677) + 4)|0;
       $689 = (($636) + ($$sum2$i17$i)|0);
       HEAP32[$689>>2] = 40;
       $690 = HEAP32[((4312 + 16|0))>>2]|0;
       HEAP32[((3840 + 28|0))>>2] = $690;
       break;
      }
     }
    }
    else if ((label|0) == 229) {
    }
    $691 = HEAP32[((3840 + 16|0))>>2]|0;
    $692 = ($tbase$245$i>>>0)<($691>>>0);
    if ($692) {
     HEAP32[((3840 + 16|0))>>2] = $tbase$245$i;
     $756 = $tbase$245$i;
    } else {
     $756 = $691;
    }
    $693 = (($tbase$245$i) + ($tsize$244$i)|0);
    $sp$173$i = ((3840 + 448|0));
    while(1) {
     $694 = HEAP32[$sp$173$i>>2]|0;
     $695 = ($694|0)==($693|0);
     if ($695) {
      $$lcssa120 = $sp$173$i;$sp$173$i$lcssa = $sp$173$i;
      label = 235;
      break;
     }
     $696 = (($sp$173$i) + 8|0);
     $697 = HEAP32[$696>>2]|0;
     $698 = ($697|0)==(0|0);
     if ($698) {
      label = 319;
      break;
     } else {
      $sp$173$i = $697;
     }
    }
    if ((label|0) == 235) {
     $699 = (($sp$173$i$lcssa) + 12|0);
     $700 = HEAP32[$699>>2]|0;
     $701 = $700 & 8;
     $702 = ($701|0)==(0);
     if ($702) {
      HEAP32[$$lcssa120>>2] = $tbase$245$i;
      $703 = (($sp$173$i$lcssa) + 4|0);
      $704 = HEAP32[$703>>2]|0;
      $705 = (($704) + ($tsize$244$i))|0;
      HEAP32[$703>>2] = $705;
      $706 = (($tbase$245$i) + 8|0);
      $707 = $706;
      $708 = $707 & 7;
      $709 = ($708|0)==(0);
      if ($709) {
       $713 = 0;
      } else {
       $710 = (0 - ($707))|0;
       $711 = $710 & 7;
       $713 = $711;
      }
      $712 = (($tbase$245$i) + ($713)|0);
      $$sum102$i = (($tsize$244$i) + 8)|0;
      $714 = (($tbase$245$i) + ($$sum102$i)|0);
      $715 = $714;
      $716 = $715 & 7;
      $717 = ($716|0)==(0);
      if ($717) {
       $720 = 0;
      } else {
       $718 = (0 - ($715))|0;
       $719 = $718 & 7;
       $720 = $719;
      }
      $$sum103$i = (($720) + ($tsize$244$i))|0;
      $721 = (($tbase$245$i) + ($$sum103$i)|0);
      $722 = $721;
      $723 = $712;
      $724 = (($722) - ($723))|0;
      $$sum$i19$i = (($713) + ($nb$0))|0;
      $725 = (($tbase$245$i) + ($$sum$i19$i)|0);
      $726 = (($724) - ($nb$0))|0;
      $727 = $nb$0 | 3;
      $$sum1$i20$i = (($713) + 4)|0;
      $728 = (($tbase$245$i) + ($$sum1$i20$i)|0);
      HEAP32[$728>>2] = $727;
      $729 = ($721|0)==($636|0);
      L352: do {
       if ($729) {
        $730 = HEAP32[((3840 + 12|0))>>2]|0;
        $731 = (($730) + ($726))|0;
        HEAP32[((3840 + 12|0))>>2] = $731;
        HEAP32[((3840 + 24|0))>>2] = $725;
        $732 = $731 | 1;
        $$sum42$i$i = (($$sum$i19$i) + 4)|0;
        $733 = (($tbase$245$i) + ($$sum42$i$i)|0);
        HEAP32[$733>>2] = $732;
       } else {
        $734 = HEAP32[((3840 + 20|0))>>2]|0;
        $735 = ($721|0)==($734|0);
        if ($735) {
         $736 = HEAP32[((3840 + 8|0))>>2]|0;
         $737 = (($736) + ($726))|0;
         HEAP32[((3840 + 8|0))>>2] = $737;
         HEAP32[((3840 + 20|0))>>2] = $725;
         $738 = $737 | 1;
         $$sum40$i$i = (($$sum$i19$i) + 4)|0;
         $739 = (($tbase$245$i) + ($$sum40$i$i)|0);
         HEAP32[$739>>2] = $738;
         $$sum41$i$i = (($737) + ($$sum$i19$i))|0;
         $740 = (($tbase$245$i) + ($$sum41$i$i)|0);
         HEAP32[$740>>2] = $737;
         break;
        }
        $$sum2$i21$i = (($tsize$244$i) + 4)|0;
        $$sum104$i = (($$sum2$i21$i) + ($720))|0;
        $741 = (($tbase$245$i) + ($$sum104$i)|0);
        $742 = HEAP32[$741>>2]|0;
        $743 = $742 & 3;
        $744 = ($743|0)==(1);
        if ($744) {
         $745 = $742 & -8;
         $746 = $742 >>> 3;
         $747 = ($742>>>0)<(256);
         L360: do {
          if ($747) {
           $$sum3738$i$i = $720 | 8;
           $$sum114$i = (($$sum3738$i$i) + ($tsize$244$i))|0;
           $748 = (($tbase$245$i) + ($$sum114$i)|0);
           $749 = HEAP32[$748>>2]|0;
           $$sum39$i$i = (($tsize$244$i) + 12)|0;
           $$sum115$i = (($$sum39$i$i) + ($720))|0;
           $750 = (($tbase$245$i) + ($$sum115$i)|0);
           $751 = HEAP32[$750>>2]|0;
           $752 = $746 << 1;
           $753 = ((3840 + ($752<<2)|0) + 40|0);
           $754 = ($749|0)==($753|0);
           do {
            if (!($754)) {
             $755 = ($749>>>0)<($756>>>0);
             if ($755) {
              _abort();
              // unreachable;
             }
             $757 = (($749) + 12|0);
             $758 = HEAP32[$757>>2]|0;
             $759 = ($758|0)==($721|0);
             if ($759) {
              break;
             }
             _abort();
             // unreachable;
            }
           } while(0);
           $760 = ($751|0)==($749|0);
           if ($760) {
            $761 = 1 << $746;
            $762 = $761 ^ -1;
            $763 = HEAP32[3840>>2]|0;
            $764 = $763 & $762;
            HEAP32[3840>>2] = $764;
            break;
           }
           $765 = ($751|0)==($753|0);
           do {
            if ($765) {
             $$pre58$i$i = (($751) + 8|0);
             $$pre$phi59$i$iZ2D = $$pre58$i$i;
            } else {
             $766 = ($751>>>0)<($756>>>0);
             if ($766) {
              _abort();
              // unreachable;
             }
             $767 = (($751) + 8|0);
             $768 = HEAP32[$767>>2]|0;
             $769 = ($768|0)==($721|0);
             if ($769) {
              $$pre$phi59$i$iZ2D = $767;
              break;
             }
             _abort();
             // unreachable;
            }
           } while(0);
           $770 = (($749) + 12|0);
           HEAP32[$770>>2] = $751;
           HEAP32[$$pre$phi59$i$iZ2D>>2] = $749;
          } else {
           $$sum34$i$i = $720 | 24;
           $$sum105$i = (($$sum34$i$i) + ($tsize$244$i))|0;
           $771 = (($tbase$245$i) + ($$sum105$i)|0);
           $772 = HEAP32[$771>>2]|0;
           $$sum5$i$i = (($tsize$244$i) + 12)|0;
           $$sum106$i = (($$sum5$i$i) + ($720))|0;
           $773 = (($tbase$245$i) + ($$sum106$i)|0);
           $774 = HEAP32[$773>>2]|0;
           $775 = ($774|0)==($721|0);
           do {
            if ($775) {
             $$sum67$i$i = $720 | 16;
             $$sum112$i = (($$sum2$i21$i) + ($$sum67$i$i))|0;
             $785 = (($tbase$245$i) + ($$sum112$i)|0);
             $786 = HEAP32[$785>>2]|0;
             $787 = ($786|0)==(0|0);
             if ($787) {
              $$sum113$i = (($$sum67$i$i) + ($tsize$244$i))|0;
              $788 = (($tbase$245$i) + ($$sum113$i)|0);
              $789 = HEAP32[$788>>2]|0;
              $790 = ($789|0)==(0|0);
              if ($790) {
               $R$1$i$i = 0;
               break;
              } else {
               $R$0$i$i$ph = $789;$RP$0$i$i$ph = $788;
              }
             } else {
              $R$0$i$i$ph = $786;$RP$0$i$i$ph = $785;
             }
             $R$0$i$i = $R$0$i$i$ph;$RP$0$i$i = $RP$0$i$i$ph;
             while(1) {
              $791 = (($R$0$i$i) + 20|0);
              $792 = HEAP32[$791>>2]|0;
              $793 = ($792|0)==(0|0);
              if ($793) {
               $794 = (($R$0$i$i) + 16|0);
               $795 = HEAP32[$794>>2]|0;
               $796 = ($795|0)==(0|0);
               if ($796) {
                $R$0$i$i$lcssa = $R$0$i$i;$RP$0$i$i$lcssa = $RP$0$i$i;
                break;
               } else {
                $R$0$i$i$be = $795;$RP$0$i$i$be = $794;
               }
              } else {
               $R$0$i$i$be = $792;$RP$0$i$i$be = $791;
              }
              $R$0$i$i = $R$0$i$i$be;$RP$0$i$i = $RP$0$i$i$be;
             }
             $797 = ($RP$0$i$i$lcssa>>>0)<($756>>>0);
             if ($797) {
              _abort();
              // unreachable;
             } else {
              HEAP32[$RP$0$i$i$lcssa>>2] = 0;
              $R$1$i$i = $R$0$i$i$lcssa;
              break;
             }
            } else {
             $$sum3536$i$i = $720 | 8;
             $$sum107$i = (($$sum3536$i$i) + ($tsize$244$i))|0;
             $776 = (($tbase$245$i) + ($$sum107$i)|0);
             $777 = HEAP32[$776>>2]|0;
             $778 = ($777>>>0)<($756>>>0);
             if ($778) {
              _abort();
              // unreachable;
             }
             $779 = (($777) + 12|0);
             $780 = HEAP32[$779>>2]|0;
             $781 = ($780|0)==($721|0);
             if (!($781)) {
              _abort();
              // unreachable;
             }
             $782 = (($774) + 8|0);
             $783 = HEAP32[$782>>2]|0;
             $784 = ($783|0)==($721|0);
             if ($784) {
              HEAP32[$779>>2] = $774;
              HEAP32[$782>>2] = $777;
              $R$1$i$i = $774;
              break;
             } else {
              _abort();
              // unreachable;
             }
            }
           } while(0);
           $798 = ($772|0)==(0|0);
           if ($798) {
            break;
           }
           $$sum30$i$i = (($tsize$244$i) + 28)|0;
           $$sum108$i = (($$sum30$i$i) + ($720))|0;
           $799 = (($tbase$245$i) + ($$sum108$i)|0);
           $800 = HEAP32[$799>>2]|0;
           $801 = ((3840 + ($800<<2)|0) + 304|0);
           $802 = HEAP32[$801>>2]|0;
           $803 = ($721|0)==($802|0);
           do {
            if ($803) {
             HEAP32[$801>>2] = $R$1$i$i;
             $cond$i$i = ($R$1$i$i|0)==(0|0);
             if (!($cond$i$i)) {
              break;
             }
             $804 = 1 << $800;
             $805 = $804 ^ -1;
             $806 = HEAP32[((3840 + 4|0))>>2]|0;
             $807 = $806 & $805;
             HEAP32[((3840 + 4|0))>>2] = $807;
             break L360;
            } else {
             $808 = HEAP32[((3840 + 16|0))>>2]|0;
             $809 = ($772>>>0)<($808>>>0);
             if ($809) {
              _abort();
              // unreachable;
             }
             $810 = (($772) + 16|0);
             $811 = HEAP32[$810>>2]|0;
             $812 = ($811|0)==($721|0);
             if ($812) {
              HEAP32[$810>>2] = $R$1$i$i;
             } else {
              $813 = (($772) + 20|0);
              HEAP32[$813>>2] = $R$1$i$i;
             }
             $814 = ($R$1$i$i|0)==(0|0);
             if ($814) {
              break L360;
             }
            }
           } while(0);
           $815 = HEAP32[((3840 + 16|0))>>2]|0;
           $816 = ($R$1$i$i>>>0)<($815>>>0);
           if ($816) {
            _abort();
            // unreachable;
           }
           $817 = (($R$1$i$i) + 24|0);
           HEAP32[$817>>2] = $772;
           $$sum3132$i$i = $720 | 16;
           $$sum109$i = (($$sum3132$i$i) + ($tsize$244$i))|0;
           $818 = (($tbase$245$i) + ($$sum109$i)|0);
           $819 = HEAP32[$818>>2]|0;
           $820 = ($819|0)==(0|0);
           do {
            if (!($820)) {
             $821 = ($819>>>0)<($815>>>0);
             if ($821) {
              _abort();
              // unreachable;
             } else {
              $822 = (($R$1$i$i) + 16|0);
              HEAP32[$822>>2] = $819;
              $823 = (($819) + 24|0);
              HEAP32[$823>>2] = $R$1$i$i;
              break;
             }
            }
           } while(0);
           $$sum110$i = (($$sum2$i21$i) + ($$sum3132$i$i))|0;
           $824 = (($tbase$245$i) + ($$sum110$i)|0);
           $825 = HEAP32[$824>>2]|0;
           $826 = ($825|0)==(0|0);
           if ($826) {
            break;
           }
           $827 = HEAP32[((3840 + 16|0))>>2]|0;
           $828 = ($825>>>0)<($827>>>0);
           if ($828) {
            _abort();
            // unreachable;
           } else {
            $829 = (($R$1$i$i) + 20|0);
            HEAP32[$829>>2] = $825;
            $830 = (($825) + 24|0);
            HEAP32[$830>>2] = $R$1$i$i;
            break;
           }
          }
         } while(0);
         $$sum9$i$i = $745 | $720;
         $$sum111$i = (($$sum9$i$i) + ($tsize$244$i))|0;
         $831 = (($tbase$245$i) + ($$sum111$i)|0);
         $832 = (($745) + ($726))|0;
         $oldfirst$0$i$i = $831;$qsize$0$i$i = $832;
        } else {
         $oldfirst$0$i$i = $721;$qsize$0$i$i = $726;
        }
        $833 = (($oldfirst$0$i$i) + 4|0);
        $834 = HEAP32[$833>>2]|0;
        $835 = $834 & -2;
        HEAP32[$833>>2] = $835;
        $836 = $qsize$0$i$i | 1;
        $$sum10$i$i = (($$sum$i19$i) + 4)|0;
        $837 = (($tbase$245$i) + ($$sum10$i$i)|0);
        HEAP32[$837>>2] = $836;
        $$sum11$i22$i = (($qsize$0$i$i) + ($$sum$i19$i))|0;
        $838 = (($tbase$245$i) + ($$sum11$i22$i)|0);
        HEAP32[$838>>2] = $qsize$0$i$i;
        $839 = $qsize$0$i$i >>> 3;
        $840 = ($qsize$0$i$i>>>0)<(256);
        if ($840) {
         $841 = $839 << 1;
         $842 = ((3840 + ($841<<2)|0) + 40|0);
         $843 = HEAP32[3840>>2]|0;
         $844 = 1 << $839;
         $845 = $843 & $844;
         $846 = ($845|0)==(0);
         do {
          if ($846) {
           $847 = $843 | $844;
           HEAP32[3840>>2] = $847;
           $$sum26$pre$i$i = (($841) + 2)|0;
           $$pre$i23$i = ((3840 + ($$sum26$pre$i$i<<2)|0) + 40|0);
           $$pre$phi$i24$iZ2D = $$pre$i23$i;$F4$0$i$i = $842;
          } else {
           $$sum29$i$i = (($841) + 2)|0;
           $848 = ((3840 + ($$sum29$i$i<<2)|0) + 40|0);
           $849 = HEAP32[$848>>2]|0;
           $850 = HEAP32[((3840 + 16|0))>>2]|0;
           $851 = ($849>>>0)<($850>>>0);
           if (!($851)) {
            $$pre$phi$i24$iZ2D = $848;$F4$0$i$i = $849;
            break;
           }
           _abort();
           // unreachable;
          }
         } while(0);
         HEAP32[$$pre$phi$i24$iZ2D>>2] = $725;
         $852 = (($F4$0$i$i) + 12|0);
         HEAP32[$852>>2] = $725;
         $$sum27$i$i = (($$sum$i19$i) + 8)|0;
         $853 = (($tbase$245$i) + ($$sum27$i$i)|0);
         HEAP32[$853>>2] = $F4$0$i$i;
         $$sum28$i$i = (($$sum$i19$i) + 12)|0;
         $854 = (($tbase$245$i) + ($$sum28$i$i)|0);
         HEAP32[$854>>2] = $842;
         break;
        }
        $855 = $qsize$0$i$i >>> 8;
        $856 = ($855|0)==(0);
        do {
         if ($856) {
          $I7$0$i$i = 0;
         } else {
          $857 = ($qsize$0$i$i>>>0)>(16777215);
          if ($857) {
           $I7$0$i$i = 31;
           break;
          }
          $858 = (($855) + 1048320)|0;
          $859 = $858 >>> 16;
          $860 = $859 & 8;
          $861 = $855 << $860;
          $862 = (($861) + 520192)|0;
          $863 = $862 >>> 16;
          $864 = $863 & 4;
          $865 = $864 | $860;
          $866 = $861 << $864;
          $867 = (($866) + 245760)|0;
          $868 = $867 >>> 16;
          $869 = $868 & 2;
          $870 = $865 | $869;
          $871 = (14 - ($870))|0;
          $872 = $866 << $869;
          $873 = $872 >>> 15;
          $874 = (($871) + ($873))|0;
          $875 = $874 << 1;
          $876 = (($874) + 7)|0;
          $877 = $qsize$0$i$i >>> $876;
          $878 = $877 & 1;
          $879 = $878 | $875;
          $I7$0$i$i = $879;
         }
        } while(0);
        $880 = ((3840 + ($I7$0$i$i<<2)|0) + 304|0);
        $$sum12$i$i = (($$sum$i19$i) + 28)|0;
        $881 = (($tbase$245$i) + ($$sum12$i$i)|0);
        HEAP32[$881>>2] = $I7$0$i$i;
        $$sum13$i$i = (($$sum$i19$i) + 16)|0;
        $882 = (($tbase$245$i) + ($$sum13$i$i)|0);
        $$sum14$i$i = (($$sum$i19$i) + 20)|0;
        $883 = (($tbase$245$i) + ($$sum14$i$i)|0);
        HEAP32[$883>>2] = 0;
        HEAP32[$882>>2] = 0;
        $884 = HEAP32[((3840 + 4|0))>>2]|0;
        $885 = 1 << $I7$0$i$i;
        $886 = $884 & $885;
        $887 = ($886|0)==(0);
        if ($887) {
         $888 = $884 | $885;
         HEAP32[((3840 + 4|0))>>2] = $888;
         HEAP32[$880>>2] = $725;
         $$sum15$i$i = (($$sum$i19$i) + 24)|0;
         $889 = (($tbase$245$i) + ($$sum15$i$i)|0);
         HEAP32[$889>>2] = $880;
         $$sum16$i$i = (($$sum$i19$i) + 12)|0;
         $890 = (($tbase$245$i) + ($$sum16$i$i)|0);
         HEAP32[$890>>2] = $725;
         $$sum17$i$i = (($$sum$i19$i) + 8)|0;
         $891 = (($tbase$245$i) + ($$sum17$i$i)|0);
         HEAP32[$891>>2] = $725;
         break;
        }
        $892 = HEAP32[$880>>2]|0;
        $893 = ($I7$0$i$i|0)==(31);
        if ($893) {
         $901 = 0;
        } else {
         $894 = $I7$0$i$i >>> 1;
         $895 = (25 - ($894))|0;
         $901 = $895;
        }
        $896 = (($892) + 4|0);
        $897 = HEAP32[$896>>2]|0;
        $898 = $897 & -8;
        $899 = ($898|0)==($qsize$0$i$i|0);
        do {
         if ($899) {
          $T$0$lcssa$i26$i = $892;
         } else {
          $900 = $qsize$0$i$i << $901;
          $K8$053$i$i = $900;$T$052$i$i = $892;
          while(1) {
           $908 = $K8$053$i$i >>> 31;
           $909 = ((($T$052$i$i) + ($908<<2)|0) + 16|0);
           $904 = HEAP32[$909>>2]|0;
           $910 = ($904|0)==(0|0);
           if ($910) {
            $$lcssa = $909;$T$052$i$i$lcssa = $T$052$i$i;
            break;
           }
           $902 = $K8$053$i$i << 1;
           $903 = (($904) + 4|0);
           $905 = HEAP32[$903>>2]|0;
           $906 = $905 & -8;
           $907 = ($906|0)==($qsize$0$i$i|0);
           if ($907) {
            $$lcssa110 = $904;
            label = 314;
            break;
           } else {
            $K8$053$i$i = $902;$T$052$i$i = $904;
           }
          }
          if ((label|0) == 314) {
           $T$0$lcssa$i26$i = $$lcssa110;
           break;
          }
          $911 = HEAP32[((3840 + 16|0))>>2]|0;
          $912 = ($$lcssa>>>0)<($911>>>0);
          if ($912) {
           _abort();
           // unreachable;
          } else {
           HEAP32[$$lcssa>>2] = $725;
           $$sum23$i$i = (($$sum$i19$i) + 24)|0;
           $913 = (($tbase$245$i) + ($$sum23$i$i)|0);
           HEAP32[$913>>2] = $T$052$i$i$lcssa;
           $$sum24$i$i = (($$sum$i19$i) + 12)|0;
           $914 = (($tbase$245$i) + ($$sum24$i$i)|0);
           HEAP32[$914>>2] = $725;
           $$sum25$i$i = (($$sum$i19$i) + 8)|0;
           $915 = (($tbase$245$i) + ($$sum25$i$i)|0);
           HEAP32[$915>>2] = $725;
           break L352;
          }
         }
        } while(0);
        $916 = (($T$0$lcssa$i26$i) + 8|0);
        $917 = HEAP32[$916>>2]|0;
        $918 = HEAP32[((3840 + 16|0))>>2]|0;
        $919 = ($T$0$lcssa$i26$i>>>0)>=($918>>>0);
        $920 = ($917>>>0)>=($918>>>0);
        $or$cond$i27$i = $919 & $920;
        if ($or$cond$i27$i) {
         $921 = (($917) + 12|0);
         HEAP32[$921>>2] = $725;
         HEAP32[$916>>2] = $725;
         $$sum20$i$i = (($$sum$i19$i) + 8)|0;
         $922 = (($tbase$245$i) + ($$sum20$i$i)|0);
         HEAP32[$922>>2] = $917;
         $$sum21$i$i = (($$sum$i19$i) + 12)|0;
         $923 = (($tbase$245$i) + ($$sum21$i$i)|0);
         HEAP32[$923>>2] = $T$0$lcssa$i26$i;
         $$sum22$i$i = (($$sum$i19$i) + 24)|0;
         $924 = (($tbase$245$i) + ($$sum22$i$i)|0);
         HEAP32[$924>>2] = 0;
         break;
        } else {
         _abort();
         // unreachable;
        }
       }
      } while(0);
      $$sum1819$i$i = $713 | 8;
      $925 = (($tbase$245$i) + ($$sum1819$i$i)|0);
      $mem$0 = $925;
      STACKTOP = sp;return ($mem$0|0);
     }
    }
    else if ((label|0) == 319) {
    }
    $sp$0$i$i$i = ((3840 + 448|0));
    while(1) {
     $926 = HEAP32[$sp$0$i$i$i>>2]|0;
     $927 = ($926>>>0)>($636>>>0);
     if (!($927)) {
      $928 = (($sp$0$i$i$i) + 4|0);
      $929 = HEAP32[$928>>2]|0;
      $930 = (($926) + ($929)|0);
      $931 = ($930>>>0)>($636>>>0);
      if ($931) {
       $$lcssa116 = $926;$$lcssa117 = $929;$$lcssa118 = $930;
       break;
      }
     }
     $932 = (($sp$0$i$i$i) + 8|0);
     $933 = HEAP32[$932>>2]|0;
     $sp$0$i$i$i = $933;
    }
    $$sum$i13$i = (($$lcssa117) + -47)|0;
    $$sum1$i14$i = (($$lcssa117) + -39)|0;
    $934 = (($$lcssa116) + ($$sum1$i14$i)|0);
    $935 = $934;
    $936 = $935 & 7;
    $937 = ($936|0)==(0);
    if ($937) {
     $940 = 0;
    } else {
     $938 = (0 - ($935))|0;
     $939 = $938 & 7;
     $940 = $939;
    }
    $$sum2$i15$i = (($$sum$i13$i) + ($940))|0;
    $941 = (($$lcssa116) + ($$sum2$i15$i)|0);
    $942 = (($636) + 16|0);
    $943 = ($941>>>0)<($942>>>0);
    $944 = $943 ? $636 : $941;
    $945 = (($944) + 8|0);
    $946 = (($tsize$244$i) + -40)|0;
    $947 = (($tbase$245$i) + 8|0);
    $948 = $947;
    $949 = $948 & 7;
    $950 = ($949|0)==(0);
    if ($950) {
     $954 = 0;
    } else {
     $951 = (0 - ($948))|0;
     $952 = $951 & 7;
     $954 = $952;
    }
    $953 = (($tbase$245$i) + ($954)|0);
    $955 = (($946) - ($954))|0;
    HEAP32[((3840 + 24|0))>>2] = $953;
    HEAP32[((3840 + 12|0))>>2] = $955;
    $956 = $955 | 1;
    $$sum$i$i$i = (($954) + 4)|0;
    $957 = (($tbase$245$i) + ($$sum$i$i$i)|0);
    HEAP32[$957>>2] = $956;
    $$sum2$i$i$i = (($tsize$244$i) + -36)|0;
    $958 = (($tbase$245$i) + ($$sum2$i$i$i)|0);
    HEAP32[$958>>2] = 40;
    $959 = HEAP32[((4312 + 16|0))>>2]|0;
    HEAP32[((3840 + 28|0))>>2] = $959;
    $960 = (($944) + 4|0);
    HEAP32[$960>>2] = 27;
    ;HEAP32[$945+0>>2]=HEAP32[((3840 + 448|0))+0>>2]|0;HEAP32[$945+4>>2]=HEAP32[((3840 + 448|0))+4>>2]|0;HEAP32[$945+8>>2]=HEAP32[((3840 + 448|0))+8>>2]|0;HEAP32[$945+12>>2]=HEAP32[((3840 + 448|0))+12>>2]|0;
    HEAP32[((3840 + 448|0))>>2] = $tbase$245$i;
    HEAP32[((3840 + 452|0))>>2] = $tsize$244$i;
    HEAP32[((3840 + 460|0))>>2] = 0;
    HEAP32[((3840 + 456|0))>>2] = $945;
    $961 = (($944) + 28|0);
    HEAP32[$961>>2] = 7;
    $962 = (($944) + 32|0);
    $963 = ($962>>>0)<($$lcssa118>>>0);
    if ($963) {
     $965 = $961;
     while(1) {
      $964 = (($965) + 4|0);
      HEAP32[$964>>2] = 7;
      $966 = (($965) + 8|0);
      $967 = ($966>>>0)<($$lcssa118>>>0);
      if ($967) {
       $965 = $964;
      } else {
       break;
      }
     }
    }
    $968 = ($944|0)==($636|0);
    if (!($968)) {
     $969 = $944;
     $970 = $636;
     $971 = (($969) - ($970))|0;
     $972 = (($636) + ($971)|0);
     $$sum3$i$i = (($971) + 4)|0;
     $973 = (($636) + ($$sum3$i$i)|0);
     $974 = HEAP32[$973>>2]|0;
     $975 = $974 & -2;
     HEAP32[$973>>2] = $975;
     $976 = $971 | 1;
     $977 = (($636) + 4|0);
     HEAP32[$977>>2] = $976;
     HEAP32[$972>>2] = $971;
     $978 = $971 >>> 3;
     $979 = ($971>>>0)<(256);
     if ($979) {
      $980 = $978 << 1;
      $981 = ((3840 + ($980<<2)|0) + 40|0);
      $982 = HEAP32[3840>>2]|0;
      $983 = 1 << $978;
      $984 = $982 & $983;
      $985 = ($984|0)==(0);
      do {
       if ($985) {
        $986 = $982 | $983;
        HEAP32[3840>>2] = $986;
        $$sum10$pre$i$i = (($980) + 2)|0;
        $$pre$i$i = ((3840 + ($$sum10$pre$i$i<<2)|0) + 40|0);
        $$pre$phi$i$iZ2D = $$pre$i$i;$F$0$i$i = $981;
       } else {
        $$sum11$i$i = (($980) + 2)|0;
        $987 = ((3840 + ($$sum11$i$i<<2)|0) + 40|0);
        $988 = HEAP32[$987>>2]|0;
        $989 = HEAP32[((3840 + 16|0))>>2]|0;
        $990 = ($988>>>0)<($989>>>0);
        if (!($990)) {
         $$pre$phi$i$iZ2D = $987;$F$0$i$i = $988;
         break;
        }
        _abort();
        // unreachable;
       }
      } while(0);
      HEAP32[$$pre$phi$i$iZ2D>>2] = $636;
      $991 = (($F$0$i$i) + 12|0);
      HEAP32[$991>>2] = $636;
      $992 = (($636) + 8|0);
      HEAP32[$992>>2] = $F$0$i$i;
      $993 = (($636) + 12|0);
      HEAP32[$993>>2] = $981;
      break;
     }
     $994 = $971 >>> 8;
     $995 = ($994|0)==(0);
     if ($995) {
      $I1$0$i$i = 0;
     } else {
      $996 = ($971>>>0)>(16777215);
      if ($996) {
       $I1$0$i$i = 31;
      } else {
       $997 = (($994) + 1048320)|0;
       $998 = $997 >>> 16;
       $999 = $998 & 8;
       $1000 = $994 << $999;
       $1001 = (($1000) + 520192)|0;
       $1002 = $1001 >>> 16;
       $1003 = $1002 & 4;
       $1004 = $1003 | $999;
       $1005 = $1000 << $1003;
       $1006 = (($1005) + 245760)|0;
       $1007 = $1006 >>> 16;
       $1008 = $1007 & 2;
       $1009 = $1004 | $1008;
       $1010 = (14 - ($1009))|0;
       $1011 = $1005 << $1008;
       $1012 = $1011 >>> 15;
       $1013 = (($1010) + ($1012))|0;
       $1014 = $1013 << 1;
       $1015 = (($1013) + 7)|0;
       $1016 = $971 >>> $1015;
       $1017 = $1016 & 1;
       $1018 = $1017 | $1014;
       $I1$0$i$i = $1018;
      }
     }
     $1019 = ((3840 + ($I1$0$i$i<<2)|0) + 304|0);
     $1020 = (($636) + 28|0);
     $I1$0$c$i$i = $I1$0$i$i;
     HEAP32[$1020>>2] = $I1$0$c$i$i;
     $1021 = (($636) + 20|0);
     HEAP32[$1021>>2] = 0;
     $1022 = (($636) + 16|0);
     HEAP32[$1022>>2] = 0;
     $1023 = HEAP32[((3840 + 4|0))>>2]|0;
     $1024 = 1 << $I1$0$i$i;
     $1025 = $1023 & $1024;
     $1026 = ($1025|0)==(0);
     if ($1026) {
      $1027 = $1023 | $1024;
      HEAP32[((3840 + 4|0))>>2] = $1027;
      HEAP32[$1019>>2] = $636;
      $1028 = (($636) + 24|0);
      HEAP32[$1028>>2] = $1019;
      $1029 = (($636) + 12|0);
      HEAP32[$1029>>2] = $636;
      $1030 = (($636) + 8|0);
      HEAP32[$1030>>2] = $636;
      break;
     }
     $1031 = HEAP32[$1019>>2]|0;
     $1032 = ($I1$0$i$i|0)==(31);
     if ($1032) {
      $1040 = 0;
     } else {
      $1033 = $I1$0$i$i >>> 1;
      $1034 = (25 - ($1033))|0;
      $1040 = $1034;
     }
     $1035 = (($1031) + 4|0);
     $1036 = HEAP32[$1035>>2]|0;
     $1037 = $1036 & -8;
     $1038 = ($1037|0)==($971|0);
     do {
      if ($1038) {
       $T$0$lcssa$i$i = $1031;
      } else {
       $1039 = $971 << $1040;
       $K2$015$i$i = $1039;$T$014$i$i = $1031;
       while(1) {
        $1047 = $K2$015$i$i >>> 31;
        $1048 = ((($T$014$i$i) + ($1047<<2)|0) + 16|0);
        $1043 = HEAP32[$1048>>2]|0;
        $1049 = ($1043|0)==(0|0);
        if ($1049) {
         $$lcssa112 = $1048;$T$014$i$i$lcssa = $T$014$i$i;
         break;
        }
        $1041 = $K2$015$i$i << 1;
        $1042 = (($1043) + 4|0);
        $1044 = HEAP32[$1042>>2]|0;
        $1045 = $1044 & -8;
        $1046 = ($1045|0)==($971|0);
        if ($1046) {
         $$lcssa115 = $1043;
         label = 353;
         break;
        } else {
         $K2$015$i$i = $1041;$T$014$i$i = $1043;
        }
       }
       if ((label|0) == 353) {
        $T$0$lcssa$i$i = $$lcssa115;
        break;
       }
       $1050 = HEAP32[((3840 + 16|0))>>2]|0;
       $1051 = ($$lcssa112>>>0)<($1050>>>0);
       if ($1051) {
        _abort();
        // unreachable;
       } else {
        HEAP32[$$lcssa112>>2] = $636;
        $1052 = (($636) + 24|0);
        HEAP32[$1052>>2] = $T$014$i$i$lcssa;
        $1053 = (($636) + 12|0);
        HEAP32[$1053>>2] = $636;
        $1054 = (($636) + 8|0);
        HEAP32[$1054>>2] = $636;
        break L323;
       }
      }
     } while(0);
     $1055 = (($T$0$lcssa$i$i) + 8|0);
     $1056 = HEAP32[$1055>>2]|0;
     $1057 = HEAP32[((3840 + 16|0))>>2]|0;
     $1058 = ($T$0$lcssa$i$i>>>0)>=($1057>>>0);
     $1059 = ($1056>>>0)>=($1057>>>0);
     $or$cond$i$i = $1058 & $1059;
     if ($or$cond$i$i) {
      $1060 = (($1056) + 12|0);
      HEAP32[$1060>>2] = $636;
      HEAP32[$1055>>2] = $636;
      $1061 = (($636) + 8|0);
      HEAP32[$1061>>2] = $1056;
      $1062 = (($636) + 12|0);
      HEAP32[$1062>>2] = $T$0$lcssa$i$i;
      $1063 = (($636) + 24|0);
      HEAP32[$1063>>2] = 0;
      break;
     } else {
      _abort();
      // unreachable;
     }
    }
   }
  } while(0);
  $1064 = HEAP32[((3840 + 12|0))>>2]|0;
  $1065 = ($1064>>>0)>($nb$0>>>0);
  if ($1065) {
   $1066 = (($1064) - ($nb$0))|0;
   HEAP32[((3840 + 12|0))>>2] = $1066;
   $1067 = HEAP32[((3840 + 24|0))>>2]|0;
   $1068 = (($1067) + ($nb$0)|0);
   HEAP32[((3840 + 24|0))>>2] = $1068;
   $1069 = $1066 | 1;
   $$sum$i32 = (($nb$0) + 4)|0;
   $1070 = (($1067) + ($$sum$i32)|0);
   HEAP32[$1070>>2] = $1069;
   $1071 = $nb$0 | 3;
   $1072 = (($1067) + 4|0);
   HEAP32[$1072>>2] = $1071;
   $1073 = (($1067) + 8|0);
   $mem$0 = $1073;
   STACKTOP = sp;return ($mem$0|0);
  }
 }
 $1074 = (___errno_location()|0);
 HEAP32[$1074>>2] = 12;
 $mem$0 = 0;
 STACKTOP = sp;return ($mem$0|0);
}
function _free($mem) {
 $mem = $mem|0;
 var $$lcssa = 0, $$lcssa73 = 0, $$pre = 0, $$pre$phi66Z2D = 0, $$pre$phi68Z2D = 0, $$pre$phiZ2D = 0, $$pre65 = 0, $$pre67 = 0, $$sum = 0, $$sum16$pre = 0, $$sum17 = 0, $$sum18 = 0, $$sum19 = 0, $$sum2 = 0, $$sum20 = 0, $$sum2324 = 0, $$sum25 = 0, $$sum26 = 0, $$sum28 = 0, $$sum29 = 0;
 var $$sum3 = 0, $$sum30 = 0, $$sum31 = 0, $$sum32 = 0, $$sum33 = 0, $$sum34 = 0, $$sum35 = 0, $$sum36 = 0, $$sum37 = 0, $$sum5 = 0, $$sum67 = 0, $$sum8 = 0, $$sum9 = 0, $0 = 0, $1 = 0, $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0;
 var $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0;
 var $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0;
 var $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0;
 var $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0, $165 = 0, $166 = 0, $167 = 0, $168 = 0, $169 = 0, $17 = 0, $170 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0;
 var $177 = 0, $178 = 0, $179 = 0, $18 = 0, $180 = 0, $181 = 0, $182 = 0, $183 = 0, $184 = 0, $185 = 0, $186 = 0, $187 = 0, $188 = 0, $189 = 0, $19 = 0, $190 = 0, $191 = 0, $192 = 0, $193 = 0, $194 = 0;
 var $195 = 0, $196 = 0, $197 = 0, $198 = 0, $199 = 0, $2 = 0, $20 = 0, $200 = 0, $201 = 0, $202 = 0, $203 = 0, $204 = 0, $205 = 0, $206 = 0, $207 = 0, $208 = 0, $209 = 0, $21 = 0, $210 = 0, $211 = 0;
 var $212 = 0, $213 = 0, $214 = 0, $215 = 0, $216 = 0, $217 = 0, $218 = 0, $219 = 0, $22 = 0, $220 = 0, $221 = 0, $222 = 0, $223 = 0, $224 = 0, $225 = 0, $226 = 0, $227 = 0, $228 = 0, $229 = 0, $23 = 0;
 var $230 = 0, $231 = 0, $232 = 0, $233 = 0, $234 = 0, $235 = 0, $236 = 0, $237 = 0, $238 = 0, $239 = 0, $24 = 0, $240 = 0, $241 = 0, $242 = 0, $243 = 0, $244 = 0, $245 = 0, $246 = 0, $247 = 0, $248 = 0;
 var $249 = 0, $25 = 0, $250 = 0, $251 = 0, $252 = 0, $253 = 0, $254 = 0, $255 = 0, $256 = 0, $257 = 0, $258 = 0, $259 = 0, $26 = 0, $260 = 0, $261 = 0, $262 = 0, $263 = 0, $264 = 0, $265 = 0, $266 = 0;
 var $267 = 0, $268 = 0, $269 = 0, $27 = 0, $270 = 0, $271 = 0, $272 = 0, $273 = 0, $274 = 0, $275 = 0, $276 = 0, $277 = 0, $278 = 0, $279 = 0, $28 = 0, $280 = 0, $281 = 0, $282 = 0, $283 = 0, $284 = 0;
 var $285 = 0, $286 = 0, $287 = 0, $288 = 0, $289 = 0, $29 = 0, $290 = 0, $291 = 0, $292 = 0, $293 = 0, $294 = 0, $295 = 0, $296 = 0, $297 = 0, $298 = 0, $299 = 0, $3 = 0, $30 = 0, $300 = 0, $301 = 0;
 var $302 = 0, $303 = 0, $304 = 0, $305 = 0, $306 = 0, $307 = 0, $308 = 0, $309 = 0, $31 = 0, $310 = 0, $311 = 0, $312 = 0, $313 = 0, $314 = 0, $315 = 0, $316 = 0, $317 = 0, $318 = 0, $319 = 0, $32 = 0;
 var $320 = 0, $321 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0;
 var $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0;
 var $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0;
 var $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $F16$0 = 0, $I18$0 = 0, $I18$0$c = 0, $K19$060 = 0, $R$0 = 0;
 var $R$0$be = 0, $R$0$lcssa = 0, $R$0$ph = 0, $R$1 = 0, $R7$0 = 0, $R7$0$be = 0, $R7$0$lcssa = 0, $R7$0$ph = 0, $R7$1 = 0, $RP$0 = 0, $RP$0$be = 0, $RP$0$lcssa = 0, $RP$0$ph = 0, $RP9$0 = 0, $RP9$0$be = 0, $RP9$0$lcssa = 0, $RP9$0$ph = 0, $T$0$lcssa = 0, $T$059 = 0, $T$059$lcssa = 0;
 var $cond = 0, $cond54 = 0, $or$cond = 0, $p$0 = 0, $psize$0 = 0, $psize$1 = 0, $sp$0$i = 0, $sp$0$in$i = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = ($mem|0)==(0|0);
 if ($0) {
  STACKTOP = sp;return;
 }
 $1 = (($mem) + -8|0);
 $2 = HEAP32[((3840 + 16|0))>>2]|0;
 $3 = ($1>>>0)<($2>>>0);
 if ($3) {
  _abort();
  // unreachable;
 }
 $4 = (($mem) + -4|0);
 $5 = HEAP32[$4>>2]|0;
 $6 = $5 & 3;
 $7 = ($6|0)==(1);
 if ($7) {
  _abort();
  // unreachable;
 }
 $8 = $5 & -8;
 $$sum = (($8) + -8)|0;
 $9 = (($mem) + ($$sum)|0);
 $10 = $5 & 1;
 $11 = ($10|0)==(0);
 do {
  if ($11) {
   $12 = HEAP32[$1>>2]|0;
   $13 = ($6|0)==(0);
   if ($13) {
    STACKTOP = sp;return;
   }
   $$sum2 = (-8 - ($12))|0;
   $14 = (($mem) + ($$sum2)|0);
   $15 = (($12) + ($8))|0;
   $16 = ($14>>>0)<($2>>>0);
   if ($16) {
    _abort();
    // unreachable;
   }
   $17 = HEAP32[((3840 + 20|0))>>2]|0;
   $18 = ($14|0)==($17|0);
   if ($18) {
    $$sum3 = (($8) + -4)|0;
    $103 = (($mem) + ($$sum3)|0);
    $104 = HEAP32[$103>>2]|0;
    $105 = $104 & 3;
    $106 = ($105|0)==(3);
    if (!($106)) {
     $p$0 = $14;$psize$0 = $15;
     break;
    }
    HEAP32[((3840 + 8|0))>>2] = $15;
    $107 = $104 & -2;
    HEAP32[$103>>2] = $107;
    $108 = $15 | 1;
    $$sum26 = (($$sum2) + 4)|0;
    $109 = (($mem) + ($$sum26)|0);
    HEAP32[$109>>2] = $108;
    HEAP32[$9>>2] = $15;
    STACKTOP = sp;return;
   }
   $19 = $12 >>> 3;
   $20 = ($12>>>0)<(256);
   if ($20) {
    $$sum36 = (($$sum2) + 8)|0;
    $21 = (($mem) + ($$sum36)|0);
    $22 = HEAP32[$21>>2]|0;
    $$sum37 = (($$sum2) + 12)|0;
    $23 = (($mem) + ($$sum37)|0);
    $24 = HEAP32[$23>>2]|0;
    $25 = $19 << 1;
    $26 = ((3840 + ($25<<2)|0) + 40|0);
    $27 = ($22|0)==($26|0);
    if (!($27)) {
     $28 = ($22>>>0)<($2>>>0);
     if ($28) {
      _abort();
      // unreachable;
     }
     $29 = (($22) + 12|0);
     $30 = HEAP32[$29>>2]|0;
     $31 = ($30|0)==($14|0);
     if (!($31)) {
      _abort();
      // unreachable;
     }
    }
    $32 = ($24|0)==($22|0);
    if ($32) {
     $33 = 1 << $19;
     $34 = $33 ^ -1;
     $35 = HEAP32[3840>>2]|0;
     $36 = $35 & $34;
     HEAP32[3840>>2] = $36;
     $p$0 = $14;$psize$0 = $15;
     break;
    }
    $37 = ($24|0)==($26|0);
    if ($37) {
     $$pre67 = (($24) + 8|0);
     $$pre$phi68Z2D = $$pre67;
    } else {
     $38 = ($24>>>0)<($2>>>0);
     if ($38) {
      _abort();
      // unreachable;
     }
     $39 = (($24) + 8|0);
     $40 = HEAP32[$39>>2]|0;
     $41 = ($40|0)==($14|0);
     if ($41) {
      $$pre$phi68Z2D = $39;
     } else {
      _abort();
      // unreachable;
     }
    }
    $42 = (($22) + 12|0);
    HEAP32[$42>>2] = $24;
    HEAP32[$$pre$phi68Z2D>>2] = $22;
    $p$0 = $14;$psize$0 = $15;
    break;
   }
   $$sum28 = (($$sum2) + 24)|0;
   $43 = (($mem) + ($$sum28)|0);
   $44 = HEAP32[$43>>2]|0;
   $$sum29 = (($$sum2) + 12)|0;
   $45 = (($mem) + ($$sum29)|0);
   $46 = HEAP32[$45>>2]|0;
   $47 = ($46|0)==($14|0);
   do {
    if ($47) {
     $$sum31 = (($$sum2) + 20)|0;
     $57 = (($mem) + ($$sum31)|0);
     $58 = HEAP32[$57>>2]|0;
     $59 = ($58|0)==(0|0);
     if ($59) {
      $$sum30 = (($$sum2) + 16)|0;
      $60 = (($mem) + ($$sum30)|0);
      $61 = HEAP32[$60>>2]|0;
      $62 = ($61|0)==(0|0);
      if ($62) {
       $R$1 = 0;
       break;
      } else {
       $R$0$ph = $61;$RP$0$ph = $60;
      }
     } else {
      $R$0$ph = $58;$RP$0$ph = $57;
     }
     $R$0 = $R$0$ph;$RP$0 = $RP$0$ph;
     while(1) {
      $63 = (($R$0) + 20|0);
      $64 = HEAP32[$63>>2]|0;
      $65 = ($64|0)==(0|0);
      if ($65) {
       $66 = (($R$0) + 16|0);
       $67 = HEAP32[$66>>2]|0;
       $68 = ($67|0)==(0|0);
       if ($68) {
        $R$0$lcssa = $R$0;$RP$0$lcssa = $RP$0;
        break;
       } else {
        $R$0$be = $67;$RP$0$be = $66;
       }
      } else {
       $R$0$be = $64;$RP$0$be = $63;
      }
      $R$0 = $R$0$be;$RP$0 = $RP$0$be;
     }
     $69 = ($RP$0$lcssa>>>0)<($2>>>0);
     if ($69) {
      _abort();
      // unreachable;
     } else {
      HEAP32[$RP$0$lcssa>>2] = 0;
      $R$1 = $R$0$lcssa;
      break;
     }
    } else {
     $$sum35 = (($$sum2) + 8)|0;
     $48 = (($mem) + ($$sum35)|0);
     $49 = HEAP32[$48>>2]|0;
     $50 = ($49>>>0)<($2>>>0);
     if ($50) {
      _abort();
      // unreachable;
     }
     $51 = (($49) + 12|0);
     $52 = HEAP32[$51>>2]|0;
     $53 = ($52|0)==($14|0);
     if (!($53)) {
      _abort();
      // unreachable;
     }
     $54 = (($46) + 8|0);
     $55 = HEAP32[$54>>2]|0;
     $56 = ($55|0)==($14|0);
     if ($56) {
      HEAP32[$51>>2] = $46;
      HEAP32[$54>>2] = $49;
      $R$1 = $46;
      break;
     } else {
      _abort();
      // unreachable;
     }
    }
   } while(0);
   $70 = ($44|0)==(0|0);
   if ($70) {
    $p$0 = $14;$psize$0 = $15;
   } else {
    $$sum32 = (($$sum2) + 28)|0;
    $71 = (($mem) + ($$sum32)|0);
    $72 = HEAP32[$71>>2]|0;
    $73 = ((3840 + ($72<<2)|0) + 304|0);
    $74 = HEAP32[$73>>2]|0;
    $75 = ($14|0)==($74|0);
    if ($75) {
     HEAP32[$73>>2] = $R$1;
     $cond = ($R$1|0)==(0|0);
     if ($cond) {
      $76 = 1 << $72;
      $77 = $76 ^ -1;
      $78 = HEAP32[((3840 + 4|0))>>2]|0;
      $79 = $78 & $77;
      HEAP32[((3840 + 4|0))>>2] = $79;
      $p$0 = $14;$psize$0 = $15;
      break;
     }
    } else {
     $80 = HEAP32[((3840 + 16|0))>>2]|0;
     $81 = ($44>>>0)<($80>>>0);
     if ($81) {
      _abort();
      // unreachable;
     }
     $82 = (($44) + 16|0);
     $83 = HEAP32[$82>>2]|0;
     $84 = ($83|0)==($14|0);
     if ($84) {
      HEAP32[$82>>2] = $R$1;
     } else {
      $85 = (($44) + 20|0);
      HEAP32[$85>>2] = $R$1;
     }
     $86 = ($R$1|0)==(0|0);
     if ($86) {
      $p$0 = $14;$psize$0 = $15;
      break;
     }
    }
    $87 = HEAP32[((3840 + 16|0))>>2]|0;
    $88 = ($R$1>>>0)<($87>>>0);
    if ($88) {
     _abort();
     // unreachable;
    }
    $89 = (($R$1) + 24|0);
    HEAP32[$89>>2] = $44;
    $$sum33 = (($$sum2) + 16)|0;
    $90 = (($mem) + ($$sum33)|0);
    $91 = HEAP32[$90>>2]|0;
    $92 = ($91|0)==(0|0);
    do {
     if (!($92)) {
      $93 = ($91>>>0)<($87>>>0);
      if ($93) {
       _abort();
       // unreachable;
      } else {
       $94 = (($R$1) + 16|0);
       HEAP32[$94>>2] = $91;
       $95 = (($91) + 24|0);
       HEAP32[$95>>2] = $R$1;
       break;
      }
     }
    } while(0);
    $$sum34 = (($$sum2) + 20)|0;
    $96 = (($mem) + ($$sum34)|0);
    $97 = HEAP32[$96>>2]|0;
    $98 = ($97|0)==(0|0);
    if ($98) {
     $p$0 = $14;$psize$0 = $15;
    } else {
     $99 = HEAP32[((3840 + 16|0))>>2]|0;
     $100 = ($97>>>0)<($99>>>0);
     if ($100) {
      _abort();
      // unreachable;
     } else {
      $101 = (($R$1) + 20|0);
      HEAP32[$101>>2] = $97;
      $102 = (($97) + 24|0);
      HEAP32[$102>>2] = $R$1;
      $p$0 = $14;$psize$0 = $15;
      break;
     }
    }
   }
  } else {
   $p$0 = $1;$psize$0 = $8;
  }
 } while(0);
 $110 = ($p$0>>>0)<($9>>>0);
 if (!($110)) {
  _abort();
  // unreachable;
 }
 $$sum25 = (($8) + -4)|0;
 $111 = (($mem) + ($$sum25)|0);
 $112 = HEAP32[$111>>2]|0;
 $113 = $112 & 1;
 $114 = ($113|0)==(0);
 if ($114) {
  _abort();
  // unreachable;
 }
 $115 = $112 & 2;
 $116 = ($115|0)==(0);
 if ($116) {
  $117 = HEAP32[((3840 + 24|0))>>2]|0;
  $118 = ($9|0)==($117|0);
  if ($118) {
   $119 = HEAP32[((3840 + 12|0))>>2]|0;
   $120 = (($119) + ($psize$0))|0;
   HEAP32[((3840 + 12|0))>>2] = $120;
   HEAP32[((3840 + 24|0))>>2] = $p$0;
   $121 = $120 | 1;
   $122 = (($p$0) + 4|0);
   HEAP32[$122>>2] = $121;
   $123 = HEAP32[((3840 + 20|0))>>2]|0;
   $124 = ($p$0|0)==($123|0);
   if (!($124)) {
    STACKTOP = sp;return;
   }
   HEAP32[((3840 + 20|0))>>2] = 0;
   HEAP32[((3840 + 8|0))>>2] = 0;
   STACKTOP = sp;return;
  }
  $125 = HEAP32[((3840 + 20|0))>>2]|0;
  $126 = ($9|0)==($125|0);
  if ($126) {
   $127 = HEAP32[((3840 + 8|0))>>2]|0;
   $128 = (($127) + ($psize$0))|0;
   HEAP32[((3840 + 8|0))>>2] = $128;
   HEAP32[((3840 + 20|0))>>2] = $p$0;
   $129 = $128 | 1;
   $130 = (($p$0) + 4|0);
   HEAP32[$130>>2] = $129;
   $131 = (($p$0) + ($128)|0);
   HEAP32[$131>>2] = $128;
   STACKTOP = sp;return;
  }
  $132 = $112 & -8;
  $133 = (($132) + ($psize$0))|0;
  $134 = $112 >>> 3;
  $135 = ($112>>>0)<(256);
  do {
   if ($135) {
    $136 = (($mem) + ($8)|0);
    $137 = HEAP32[$136>>2]|0;
    $$sum2324 = $8 | 4;
    $138 = (($mem) + ($$sum2324)|0);
    $139 = HEAP32[$138>>2]|0;
    $140 = $134 << 1;
    $141 = ((3840 + ($140<<2)|0) + 40|0);
    $142 = ($137|0)==($141|0);
    if (!($142)) {
     $143 = HEAP32[((3840 + 16|0))>>2]|0;
     $144 = ($137>>>0)<($143>>>0);
     if ($144) {
      _abort();
      // unreachable;
     }
     $145 = (($137) + 12|0);
     $146 = HEAP32[$145>>2]|0;
     $147 = ($146|0)==($9|0);
     if (!($147)) {
      _abort();
      // unreachable;
     }
    }
    $148 = ($139|0)==($137|0);
    if ($148) {
     $149 = 1 << $134;
     $150 = $149 ^ -1;
     $151 = HEAP32[3840>>2]|0;
     $152 = $151 & $150;
     HEAP32[3840>>2] = $152;
     break;
    }
    $153 = ($139|0)==($141|0);
    if ($153) {
     $$pre65 = (($139) + 8|0);
     $$pre$phi66Z2D = $$pre65;
    } else {
     $154 = HEAP32[((3840 + 16|0))>>2]|0;
     $155 = ($139>>>0)<($154>>>0);
     if ($155) {
      _abort();
      // unreachable;
     }
     $156 = (($139) + 8|0);
     $157 = HEAP32[$156>>2]|0;
     $158 = ($157|0)==($9|0);
     if ($158) {
      $$pre$phi66Z2D = $156;
     } else {
      _abort();
      // unreachable;
     }
    }
    $159 = (($137) + 12|0);
    HEAP32[$159>>2] = $139;
    HEAP32[$$pre$phi66Z2D>>2] = $137;
   } else {
    $$sum5 = (($8) + 16)|0;
    $160 = (($mem) + ($$sum5)|0);
    $161 = HEAP32[$160>>2]|0;
    $$sum67 = $8 | 4;
    $162 = (($mem) + ($$sum67)|0);
    $163 = HEAP32[$162>>2]|0;
    $164 = ($163|0)==($9|0);
    do {
     if ($164) {
      $$sum9 = (($8) + 12)|0;
      $175 = (($mem) + ($$sum9)|0);
      $176 = HEAP32[$175>>2]|0;
      $177 = ($176|0)==(0|0);
      if ($177) {
       $$sum8 = (($8) + 8)|0;
       $178 = (($mem) + ($$sum8)|0);
       $179 = HEAP32[$178>>2]|0;
       $180 = ($179|0)==(0|0);
       if ($180) {
        $R7$1 = 0;
        break;
       } else {
        $R7$0$ph = $179;$RP9$0$ph = $178;
       }
      } else {
       $R7$0$ph = $176;$RP9$0$ph = $175;
      }
      $R7$0 = $R7$0$ph;$RP9$0 = $RP9$0$ph;
      while(1) {
       $181 = (($R7$0) + 20|0);
       $182 = HEAP32[$181>>2]|0;
       $183 = ($182|0)==(0|0);
       if ($183) {
        $184 = (($R7$0) + 16|0);
        $185 = HEAP32[$184>>2]|0;
        $186 = ($185|0)==(0|0);
        if ($186) {
         $R7$0$lcssa = $R7$0;$RP9$0$lcssa = $RP9$0;
         break;
        } else {
         $R7$0$be = $185;$RP9$0$be = $184;
        }
       } else {
        $R7$0$be = $182;$RP9$0$be = $181;
       }
       $R7$0 = $R7$0$be;$RP9$0 = $RP9$0$be;
      }
      $187 = HEAP32[((3840 + 16|0))>>2]|0;
      $188 = ($RP9$0$lcssa>>>0)<($187>>>0);
      if ($188) {
       _abort();
       // unreachable;
      } else {
       HEAP32[$RP9$0$lcssa>>2] = 0;
       $R7$1 = $R7$0$lcssa;
       break;
      }
     } else {
      $165 = (($mem) + ($8)|0);
      $166 = HEAP32[$165>>2]|0;
      $167 = HEAP32[((3840 + 16|0))>>2]|0;
      $168 = ($166>>>0)<($167>>>0);
      if ($168) {
       _abort();
       // unreachable;
      }
      $169 = (($166) + 12|0);
      $170 = HEAP32[$169>>2]|0;
      $171 = ($170|0)==($9|0);
      if (!($171)) {
       _abort();
       // unreachable;
      }
      $172 = (($163) + 8|0);
      $173 = HEAP32[$172>>2]|0;
      $174 = ($173|0)==($9|0);
      if ($174) {
       HEAP32[$169>>2] = $163;
       HEAP32[$172>>2] = $166;
       $R7$1 = $163;
       break;
      } else {
       _abort();
       // unreachable;
      }
     }
    } while(0);
    $189 = ($161|0)==(0|0);
    if (!($189)) {
     $$sum18 = (($8) + 20)|0;
     $190 = (($mem) + ($$sum18)|0);
     $191 = HEAP32[$190>>2]|0;
     $192 = ((3840 + ($191<<2)|0) + 304|0);
     $193 = HEAP32[$192>>2]|0;
     $194 = ($9|0)==($193|0);
     if ($194) {
      HEAP32[$192>>2] = $R7$1;
      $cond54 = ($R7$1|0)==(0|0);
      if ($cond54) {
       $195 = 1 << $191;
       $196 = $195 ^ -1;
       $197 = HEAP32[((3840 + 4|0))>>2]|0;
       $198 = $197 & $196;
       HEAP32[((3840 + 4|0))>>2] = $198;
       break;
      }
     } else {
      $199 = HEAP32[((3840 + 16|0))>>2]|0;
      $200 = ($161>>>0)<($199>>>0);
      if ($200) {
       _abort();
       // unreachable;
      }
      $201 = (($161) + 16|0);
      $202 = HEAP32[$201>>2]|0;
      $203 = ($202|0)==($9|0);
      if ($203) {
       HEAP32[$201>>2] = $R7$1;
      } else {
       $204 = (($161) + 20|0);
       HEAP32[$204>>2] = $R7$1;
      }
      $205 = ($R7$1|0)==(0|0);
      if ($205) {
       break;
      }
     }
     $206 = HEAP32[((3840 + 16|0))>>2]|0;
     $207 = ($R7$1>>>0)<($206>>>0);
     if ($207) {
      _abort();
      // unreachable;
     }
     $208 = (($R7$1) + 24|0);
     HEAP32[$208>>2] = $161;
     $$sum19 = (($8) + 8)|0;
     $209 = (($mem) + ($$sum19)|0);
     $210 = HEAP32[$209>>2]|0;
     $211 = ($210|0)==(0|0);
     do {
      if (!($211)) {
       $212 = ($210>>>0)<($206>>>0);
       if ($212) {
        _abort();
        // unreachable;
       } else {
        $213 = (($R7$1) + 16|0);
        HEAP32[$213>>2] = $210;
        $214 = (($210) + 24|0);
        HEAP32[$214>>2] = $R7$1;
        break;
       }
      }
     } while(0);
     $$sum20 = (($8) + 12)|0;
     $215 = (($mem) + ($$sum20)|0);
     $216 = HEAP32[$215>>2]|0;
     $217 = ($216|0)==(0|0);
     if (!($217)) {
      $218 = HEAP32[((3840 + 16|0))>>2]|0;
      $219 = ($216>>>0)<($218>>>0);
      if ($219) {
       _abort();
       // unreachable;
      } else {
       $220 = (($R7$1) + 20|0);
       HEAP32[$220>>2] = $216;
       $221 = (($216) + 24|0);
       HEAP32[$221>>2] = $R7$1;
       break;
      }
     }
    }
   }
  } while(0);
  $222 = $133 | 1;
  $223 = (($p$0) + 4|0);
  HEAP32[$223>>2] = $222;
  $224 = (($p$0) + ($133)|0);
  HEAP32[$224>>2] = $133;
  $225 = HEAP32[((3840 + 20|0))>>2]|0;
  $226 = ($p$0|0)==($225|0);
  if ($226) {
   HEAP32[((3840 + 8|0))>>2] = $133;
   STACKTOP = sp;return;
  } else {
   $psize$1 = $133;
  }
 } else {
  $227 = $112 & -2;
  HEAP32[$111>>2] = $227;
  $228 = $psize$0 | 1;
  $229 = (($p$0) + 4|0);
  HEAP32[$229>>2] = $228;
  $230 = (($p$0) + ($psize$0)|0);
  HEAP32[$230>>2] = $psize$0;
  $psize$1 = $psize$0;
 }
 $231 = $psize$1 >>> 3;
 $232 = ($psize$1>>>0)<(256);
 if ($232) {
  $233 = $231 << 1;
  $234 = ((3840 + ($233<<2)|0) + 40|0);
  $235 = HEAP32[3840>>2]|0;
  $236 = 1 << $231;
  $237 = $235 & $236;
  $238 = ($237|0)==(0);
  if ($238) {
   $239 = $235 | $236;
   HEAP32[3840>>2] = $239;
   $$sum16$pre = (($233) + 2)|0;
   $$pre = ((3840 + ($$sum16$pre<<2)|0) + 40|0);
   $$pre$phiZ2D = $$pre;$F16$0 = $234;
  } else {
   $$sum17 = (($233) + 2)|0;
   $240 = ((3840 + ($$sum17<<2)|0) + 40|0);
   $241 = HEAP32[$240>>2]|0;
   $242 = HEAP32[((3840 + 16|0))>>2]|0;
   $243 = ($241>>>0)<($242>>>0);
   if ($243) {
    _abort();
    // unreachable;
   } else {
    $$pre$phiZ2D = $240;$F16$0 = $241;
   }
  }
  HEAP32[$$pre$phiZ2D>>2] = $p$0;
  $244 = (($F16$0) + 12|0);
  HEAP32[$244>>2] = $p$0;
  $245 = (($p$0) + 8|0);
  HEAP32[$245>>2] = $F16$0;
  $246 = (($p$0) + 12|0);
  HEAP32[$246>>2] = $234;
  STACKTOP = sp;return;
 }
 $247 = $psize$1 >>> 8;
 $248 = ($247|0)==(0);
 if ($248) {
  $I18$0 = 0;
 } else {
  $249 = ($psize$1>>>0)>(16777215);
  if ($249) {
   $I18$0 = 31;
  } else {
   $250 = (($247) + 1048320)|0;
   $251 = $250 >>> 16;
   $252 = $251 & 8;
   $253 = $247 << $252;
   $254 = (($253) + 520192)|0;
   $255 = $254 >>> 16;
   $256 = $255 & 4;
   $257 = $256 | $252;
   $258 = $253 << $256;
   $259 = (($258) + 245760)|0;
   $260 = $259 >>> 16;
   $261 = $260 & 2;
   $262 = $257 | $261;
   $263 = (14 - ($262))|0;
   $264 = $258 << $261;
   $265 = $264 >>> 15;
   $266 = (($263) + ($265))|0;
   $267 = $266 << 1;
   $268 = (($266) + 7)|0;
   $269 = $psize$1 >>> $268;
   $270 = $269 & 1;
   $271 = $270 | $267;
   $I18$0 = $271;
  }
 }
 $272 = ((3840 + ($I18$0<<2)|0) + 304|0);
 $273 = (($p$0) + 28|0);
 $I18$0$c = $I18$0;
 HEAP32[$273>>2] = $I18$0$c;
 $274 = (($p$0) + 20|0);
 HEAP32[$274>>2] = 0;
 $275 = (($p$0) + 16|0);
 HEAP32[$275>>2] = 0;
 $276 = HEAP32[((3840 + 4|0))>>2]|0;
 $277 = 1 << $I18$0;
 $278 = $276 & $277;
 $279 = ($278|0)==(0);
 L205: do {
  if ($279) {
   $280 = $276 | $277;
   HEAP32[((3840 + 4|0))>>2] = $280;
   HEAP32[$272>>2] = $p$0;
   $281 = (($p$0) + 24|0);
   HEAP32[$281>>2] = $272;
   $282 = (($p$0) + 12|0);
   HEAP32[$282>>2] = $p$0;
   $283 = (($p$0) + 8|0);
   HEAP32[$283>>2] = $p$0;
  } else {
   $284 = HEAP32[$272>>2]|0;
   $285 = ($I18$0|0)==(31);
   if ($285) {
    $293 = 0;
   } else {
    $286 = $I18$0 >>> 1;
    $287 = (25 - ($286))|0;
    $293 = $287;
   }
   $288 = (($284) + 4|0);
   $289 = HEAP32[$288>>2]|0;
   $290 = $289 & -8;
   $291 = ($290|0)==($psize$1|0);
   do {
    if ($291) {
     $T$0$lcssa = $284;
    } else {
     $292 = $psize$1 << $293;
     $K19$060 = $292;$T$059 = $284;
     while(1) {
      $300 = $K19$060 >>> 31;
      $301 = ((($T$059) + ($300<<2)|0) + 16|0);
      $296 = HEAP32[$301>>2]|0;
      $302 = ($296|0)==(0|0);
      if ($302) {
       $$lcssa = $301;$T$059$lcssa = $T$059;
       break;
      }
      $294 = $K19$060 << 1;
      $295 = (($296) + 4|0);
      $297 = HEAP32[$295>>2]|0;
      $298 = $297 & -8;
      $299 = ($298|0)==($psize$1|0);
      if ($299) {
       $$lcssa73 = $296;
       label = 137;
       break;
      } else {
       $K19$060 = $294;$T$059 = $296;
      }
     }
     if ((label|0) == 137) {
      $T$0$lcssa = $$lcssa73;
      break;
     }
     $303 = HEAP32[((3840 + 16|0))>>2]|0;
     $304 = ($$lcssa>>>0)<($303>>>0);
     if ($304) {
      _abort();
      // unreachable;
     } else {
      HEAP32[$$lcssa>>2] = $p$0;
      $305 = (($p$0) + 24|0);
      HEAP32[$305>>2] = $T$059$lcssa;
      $306 = (($p$0) + 12|0);
      HEAP32[$306>>2] = $p$0;
      $307 = (($p$0) + 8|0);
      HEAP32[$307>>2] = $p$0;
      break L205;
     }
    }
   } while(0);
   $308 = (($T$0$lcssa) + 8|0);
   $309 = HEAP32[$308>>2]|0;
   $310 = HEAP32[((3840 + 16|0))>>2]|0;
   $311 = ($T$0$lcssa>>>0)>=($310>>>0);
   $312 = ($309>>>0)>=($310>>>0);
   $or$cond = $311 & $312;
   if ($or$cond) {
    $313 = (($309) + 12|0);
    HEAP32[$313>>2] = $p$0;
    HEAP32[$308>>2] = $p$0;
    $314 = (($p$0) + 8|0);
    HEAP32[$314>>2] = $309;
    $315 = (($p$0) + 12|0);
    HEAP32[$315>>2] = $T$0$lcssa;
    $316 = (($p$0) + 24|0);
    HEAP32[$316>>2] = 0;
    break;
   } else {
    _abort();
    // unreachable;
   }
  }
 } while(0);
 $317 = HEAP32[((3840 + 32|0))>>2]|0;
 $318 = (($317) + -1)|0;
 HEAP32[((3840 + 32|0))>>2] = $318;
 $319 = ($318|0)==(0);
 if (!($319)) {
  STACKTOP = sp;return;
 }
 $sp$0$in$i = ((3840 + 456|0));
 while(1) {
  $sp$0$i = HEAP32[$sp$0$in$i>>2]|0;
  $320 = ($sp$0$i|0)==(0|0);
  $321 = (($sp$0$i) + 8|0);
  if ($320) {
   break;
  } else {
   $sp$0$in$i = $321;
  }
 }
 HEAP32[((3840 + 32|0))>>2] = -1;
 STACKTOP = sp;return;
}
function _memcmp($vl,$vr,$n) {
 $vl = $vl|0;
 $vr = $vr|0;
 $n = $n|0;
 var $$03 = 0, $$lcssa = 0, $$lcssa10 = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $l$04 = 0, $r$05 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = ($n|0)==(0);
 do {
  if ($0) {
   $11 = 0;
  } else {
   $$03 = $n;$l$04 = $vl;$r$05 = $vr;
   while(1) {
    $1 = HEAP8[$l$04>>0]|0;
    $2 = HEAP8[$r$05>>0]|0;
    $3 = ($1<<24>>24)==($2<<24>>24);
    if (!($3)) {
     $$lcssa = $1;$$lcssa10 = $2;
     label = 5;
     break;
    }
    $4 = (($$03) + -1)|0;
    $5 = (($l$04) + 1|0);
    $6 = (($r$05) + 1|0);
    $7 = ($4|0)==(0);
    if ($7) {
     label = 6;
     break;
    } else {
     $$03 = $4;$l$04 = $5;$r$05 = $6;
    }
   }
   if ((label|0) == 5) {
    $8 = $$lcssa&255;
    $9 = $$lcssa10&255;
    $10 = (($8) - ($9))|0;
    $11 = $10;
    break;
   }
   else if ((label|0) == 6) {
    $11 = 0;
    break;
   }
  }
 } while(0);
 STACKTOP = sp;return ($11|0);
}
function runPostSets() {
 
}
function _memset(ptr, value, num) {
    ptr = ptr|0; value = value|0; num = num|0;
    var stop = 0, value4 = 0, stop4 = 0, unaligned = 0;
    stop = (ptr + num)|0;
    if ((num|0) >= 20) {
      // This is unaligned, but quite large, so work hard to get to aligned settings
      value = value & 0xff;
      unaligned = ptr & 3;
      value4 = value | (value << 8) | (value << 16) | (value << 24);
      stop4 = stop & ~3;
      if (unaligned) {
        unaligned = (ptr + 4 - unaligned)|0;
        while ((ptr|0) < (unaligned|0)) { // no need to check for stop, since we have large num
          HEAP8[((ptr)>>0)]=value;
          ptr = (ptr+1)|0;
        }
      }
      while ((ptr|0) < (stop4|0)) {
        HEAP32[((ptr)>>2)]=value4;
        ptr = (ptr+4)|0;
      }
    }
    while ((ptr|0) < (stop|0)) {
      HEAP8[((ptr)>>0)]=value;
      ptr = (ptr+1)|0;
    }
    return (ptr-num)|0;
}
function _strlen(ptr) {
    ptr = ptr|0;
    var curr = 0;
    curr = ptr;
    while (((HEAP8[((curr)>>0)])|0)) {
      curr = (curr + 1)|0;
    }
    return (curr - ptr)|0;
}
function _memcpy(dest, src, num) {

    dest = dest|0; src = src|0; num = num|0;
    var ret = 0;
    if ((num|0) >= 4096) return _emscripten_memcpy_big(dest|0, src|0, num|0)|0;
    ret = dest|0;
    if ((dest&3) == (src&3)) {
      while (dest & 3) {
        if ((num|0) == 0) return ret|0;
        HEAP8[((dest)>>0)]=((HEAP8[((src)>>0)])|0);
        dest = (dest+1)|0;
        src = (src+1)|0;
        num = (num-1)|0;
      }
      while ((num|0) >= 4) {
        HEAP32[((dest)>>2)]=((HEAP32[((src)>>2)])|0);
        dest = (dest+4)|0;
        src = (src+4)|0;
        num = (num-4)|0;
      }
    }
    while ((num|0) > 0) {
      HEAP8[((dest)>>0)]=((HEAP8[((src)>>0)])|0);
      dest = (dest+1)|0;
      src = (src+1)|0;
      num = (num-1)|0;
    }
    return ret|0;
}

  
function dynCall_iiii(index,a1,a2,a3) {
  index = index|0;
  a1=a1|0; a2=a2|0; a3=a3|0;
  return FUNCTION_TABLE_iiii[index&255](a1|0,a2|0,a3|0)|0;
}


function jsCall_iiii_0(a1,a2,a3) {
  a1=a1|0; a2=a2|0; a3=a3|0;
  return jsCall(0,a1|0,a2|0,a3|0)|0;
}



function jsCall_iiii_1(a1,a2,a3) {
  a1=a1|0; a2=a2|0; a3=a3|0;
  return jsCall(1,a1|0,a2|0,a3|0)|0;
}



function jsCall_iiii_2(a1,a2,a3) {
  a1=a1|0; a2=a2|0; a3=a3|0;
  return jsCall(2,a1|0,a2|0,a3|0)|0;
}



function jsCall_iiii_3(a1,a2,a3) {
  a1=a1|0; a2=a2|0; a3=a3|0;
  return jsCall(3,a1|0,a2|0,a3|0)|0;
}



function jsCall_iiii_4(a1,a2,a3) {
  a1=a1|0; a2=a2|0; a3=a3|0;
  return jsCall(4,a1|0,a2|0,a3|0)|0;
}



function jsCall_iiii_5(a1,a2,a3) {
  a1=a1|0; a2=a2|0; a3=a3|0;
  return jsCall(5,a1|0,a2|0,a3|0)|0;
}



function jsCall_iiii_6(a1,a2,a3) {
  a1=a1|0; a2=a2|0; a3=a3|0;
  return jsCall(6,a1|0,a2|0,a3|0)|0;
}



function jsCall_iiii_7(a1,a2,a3) {
  a1=a1|0; a2=a2|0; a3=a3|0;
  return jsCall(7,a1|0,a2|0,a3|0)|0;
}



function jsCall_iiii_8(a1,a2,a3) {
  a1=a1|0; a2=a2|0; a3=a3|0;
  return jsCall(8,a1|0,a2|0,a3|0)|0;
}



function jsCall_iiii_9(a1,a2,a3) {
  a1=a1|0; a2=a2|0; a3=a3|0;
  return jsCall(9,a1|0,a2|0,a3|0)|0;
}



function dynCall_viiiii(index,a1,a2,a3,a4,a5) {
  index = index|0;
  a1=a1|0; a2=a2|0; a3=a3|0; a4=a4|0; a5=a5|0;
  FUNCTION_TABLE_viiiii[index&255](a1|0,a2|0,a3|0,a4|0,a5|0);
}


function jsCall_viiiii_0(a1,a2,a3,a4,a5) {
  a1=a1|0; a2=a2|0; a3=a3|0; a4=a4|0; a5=a5|0;
  jsCall(0,a1|0,a2|0,a3|0,a4|0,a5|0);
}



function jsCall_viiiii_1(a1,a2,a3,a4,a5) {
  a1=a1|0; a2=a2|0; a3=a3|0; a4=a4|0; a5=a5|0;
  jsCall(1,a1|0,a2|0,a3|0,a4|0,a5|0);
}



function jsCall_viiiii_2(a1,a2,a3,a4,a5) {
  a1=a1|0; a2=a2|0; a3=a3|0; a4=a4|0; a5=a5|0;
  jsCall(2,a1|0,a2|0,a3|0,a4|0,a5|0);
}



function jsCall_viiiii_3(a1,a2,a3,a4,a5) {
  a1=a1|0; a2=a2|0; a3=a3|0; a4=a4|0; a5=a5|0;
  jsCall(3,a1|0,a2|0,a3|0,a4|0,a5|0);
}



function jsCall_viiiii_4(a1,a2,a3,a4,a5) {
  a1=a1|0; a2=a2|0; a3=a3|0; a4=a4|0; a5=a5|0;
  jsCall(4,a1|0,a2|0,a3|0,a4|0,a5|0);
}



function jsCall_viiiii_5(a1,a2,a3,a4,a5) {
  a1=a1|0; a2=a2|0; a3=a3|0; a4=a4|0; a5=a5|0;
  jsCall(5,a1|0,a2|0,a3|0,a4|0,a5|0);
}



function jsCall_viiiii_6(a1,a2,a3,a4,a5) {
  a1=a1|0; a2=a2|0; a3=a3|0; a4=a4|0; a5=a5|0;
  jsCall(6,a1|0,a2|0,a3|0,a4|0,a5|0);
}



function jsCall_viiiii_7(a1,a2,a3,a4,a5) {
  a1=a1|0; a2=a2|0; a3=a3|0; a4=a4|0; a5=a5|0;
  jsCall(7,a1|0,a2|0,a3|0,a4|0,a5|0);
}



function jsCall_viiiii_8(a1,a2,a3,a4,a5) {
  a1=a1|0; a2=a2|0; a3=a3|0; a4=a4|0; a5=a5|0;
  jsCall(8,a1|0,a2|0,a3|0,a4|0,a5|0);
}



function jsCall_viiiii_9(a1,a2,a3,a4,a5) {
  a1=a1|0; a2=a2|0; a3=a3|0; a4=a4|0; a5=a5|0;
  jsCall(9,a1|0,a2|0,a3|0,a4|0,a5|0);
}



function dynCall_i(index) {
  index = index|0;
  
  return FUNCTION_TABLE_i[index&255]()|0;
}


function jsCall_i_0() {
  
  return jsCall(0)|0;
}



function jsCall_i_1() {
  
  return jsCall(1)|0;
}



function jsCall_i_2() {
  
  return jsCall(2)|0;
}



function jsCall_i_3() {
  
  return jsCall(3)|0;
}



function jsCall_i_4() {
  
  return jsCall(4)|0;
}



function jsCall_i_5() {
  
  return jsCall(5)|0;
}



function jsCall_i_6() {
  
  return jsCall(6)|0;
}



function jsCall_i_7() {
  
  return jsCall(7)|0;
}



function jsCall_i_8() {
  
  return jsCall(8)|0;
}



function jsCall_i_9() {
  
  return jsCall(9)|0;
}



function dynCall_vi(index,a1) {
  index = index|0;
  a1=a1|0;
  FUNCTION_TABLE_vi[index&255](a1|0);
}


function jsCall_vi_0(a1) {
  a1=a1|0;
  jsCall(0,a1|0);
}



function jsCall_vi_1(a1) {
  a1=a1|0;
  jsCall(1,a1|0);
}



function jsCall_vi_2(a1) {
  a1=a1|0;
  jsCall(2,a1|0);
}



function jsCall_vi_3(a1) {
  a1=a1|0;
  jsCall(3,a1|0);
}



function jsCall_vi_4(a1) {
  a1=a1|0;
  jsCall(4,a1|0);
}



function jsCall_vi_5(a1) {
  a1=a1|0;
  jsCall(5,a1|0);
}



function jsCall_vi_6(a1) {
  a1=a1|0;
  jsCall(6,a1|0);
}



function jsCall_vi_7(a1) {
  a1=a1|0;
  jsCall(7,a1|0);
}



function jsCall_vi_8(a1) {
  a1=a1|0;
  jsCall(8,a1|0);
}



function jsCall_vi_9(a1) {
  a1=a1|0;
  jsCall(9,a1|0);
}



function dynCall_vii(index,a1,a2) {
  index = index|0;
  a1=a1|0; a2=a2|0;
  FUNCTION_TABLE_vii[index&255](a1|0,a2|0);
}


function jsCall_vii_0(a1,a2) {
  a1=a1|0; a2=a2|0;
  jsCall(0,a1|0,a2|0);
}



function jsCall_vii_1(a1,a2) {
  a1=a1|0; a2=a2|0;
  jsCall(1,a1|0,a2|0);
}



function jsCall_vii_2(a1,a2) {
  a1=a1|0; a2=a2|0;
  jsCall(2,a1|0,a2|0);
}



function jsCall_vii_3(a1,a2) {
  a1=a1|0; a2=a2|0;
  jsCall(3,a1|0,a2|0);
}



function jsCall_vii_4(a1,a2) {
  a1=a1|0; a2=a2|0;
  jsCall(4,a1|0,a2|0);
}



function jsCall_vii_5(a1,a2) {
  a1=a1|0; a2=a2|0;
  jsCall(5,a1|0,a2|0);
}



function jsCall_vii_6(a1,a2) {
  a1=a1|0; a2=a2|0;
  jsCall(6,a1|0,a2|0);
}



function jsCall_vii_7(a1,a2) {
  a1=a1|0; a2=a2|0;
  jsCall(7,a1|0,a2|0);
}



function jsCall_vii_8(a1,a2) {
  a1=a1|0; a2=a2|0;
  jsCall(8,a1|0,a2|0);
}



function jsCall_vii_9(a1,a2) {
  a1=a1|0; a2=a2|0;
  jsCall(9,a1|0,a2|0);
}



function dynCall_ii(index,a1) {
  index = index|0;
  a1=a1|0;
  return FUNCTION_TABLE_ii[index&255](a1|0)|0;
}


function jsCall_ii_0(a1) {
  a1=a1|0;
  return jsCall(0,a1|0)|0;
}



function jsCall_ii_1(a1) {
  a1=a1|0;
  return jsCall(1,a1|0)|0;
}



function jsCall_ii_2(a1) {
  a1=a1|0;
  return jsCall(2,a1|0)|0;
}



function jsCall_ii_3(a1) {
  a1=a1|0;
  return jsCall(3,a1|0)|0;
}



function jsCall_ii_4(a1) {
  a1=a1|0;
  return jsCall(4,a1|0)|0;
}



function jsCall_ii_5(a1) {
  a1=a1|0;
  return jsCall(5,a1|0)|0;
}



function jsCall_ii_6(a1) {
  a1=a1|0;
  return jsCall(6,a1|0)|0;
}



function jsCall_ii_7(a1) {
  a1=a1|0;
  return jsCall(7,a1|0)|0;
}



function jsCall_ii_8(a1) {
  a1=a1|0;
  return jsCall(8,a1|0)|0;
}



function jsCall_ii_9(a1) {
  a1=a1|0;
  return jsCall(9,a1|0)|0;
}



function dynCall_viii(index,a1,a2,a3) {
  index = index|0;
  a1=a1|0; a2=a2|0; a3=a3|0;
  FUNCTION_TABLE_viii[index&255](a1|0,a2|0,a3|0);
}


function jsCall_viii_0(a1,a2,a3) {
  a1=a1|0; a2=a2|0; a3=a3|0;
  jsCall(0,a1|0,a2|0,a3|0);
}



function jsCall_viii_1(a1,a2,a3) {
  a1=a1|0; a2=a2|0; a3=a3|0;
  jsCall(1,a1|0,a2|0,a3|0);
}



function jsCall_viii_2(a1,a2,a3) {
  a1=a1|0; a2=a2|0; a3=a3|0;
  jsCall(2,a1|0,a2|0,a3|0);
}



function jsCall_viii_3(a1,a2,a3) {
  a1=a1|0; a2=a2|0; a3=a3|0;
  jsCall(3,a1|0,a2|0,a3|0);
}



function jsCall_viii_4(a1,a2,a3) {
  a1=a1|0; a2=a2|0; a3=a3|0;
  jsCall(4,a1|0,a2|0,a3|0);
}



function jsCall_viii_5(a1,a2,a3) {
  a1=a1|0; a2=a2|0; a3=a3|0;
  jsCall(5,a1|0,a2|0,a3|0);
}



function jsCall_viii_6(a1,a2,a3) {
  a1=a1|0; a2=a2|0; a3=a3|0;
  jsCall(6,a1|0,a2|0,a3|0);
}



function jsCall_viii_7(a1,a2,a3) {
  a1=a1|0; a2=a2|0; a3=a3|0;
  jsCall(7,a1|0,a2|0,a3|0);
}



function jsCall_viii_8(a1,a2,a3) {
  a1=a1|0; a2=a2|0; a3=a3|0;
  jsCall(8,a1|0,a2|0,a3|0);
}



function jsCall_viii_9(a1,a2,a3) {
  a1=a1|0; a2=a2|0; a3=a3|0;
  jsCall(9,a1|0,a2|0,a3|0);
}



function dynCall_v(index) {
  index = index|0;
  
  FUNCTION_TABLE_v[index&255]();
}


function jsCall_v_0() {
  
  jsCall(0);
}



function jsCall_v_1() {
  
  jsCall(1);
}



function jsCall_v_2() {
  
  jsCall(2);
}



function jsCall_v_3() {
  
  jsCall(3);
}



function jsCall_v_4() {
  
  jsCall(4);
}



function jsCall_v_5() {
  
  jsCall(5);
}



function jsCall_v_6() {
  
  jsCall(6);
}



function jsCall_v_7() {
  
  jsCall(7);
}



function jsCall_v_8() {
  
  jsCall(8);
}



function jsCall_v_9() {
  
  jsCall(9);
}



function dynCall_viiiiii(index,a1,a2,a3,a4,a5,a6) {
  index = index|0;
  a1=a1|0; a2=a2|0; a3=a3|0; a4=a4|0; a5=a5|0; a6=a6|0;
  FUNCTION_TABLE_viiiiii[index&255](a1|0,a2|0,a3|0,a4|0,a5|0,a6|0);
}


function jsCall_viiiiii_0(a1,a2,a3,a4,a5,a6) {
  a1=a1|0; a2=a2|0; a3=a3|0; a4=a4|0; a5=a5|0; a6=a6|0;
  jsCall(0,a1|0,a2|0,a3|0,a4|0,a5|0,a6|0);
}



function jsCall_viiiiii_1(a1,a2,a3,a4,a5,a6) {
  a1=a1|0; a2=a2|0; a3=a3|0; a4=a4|0; a5=a5|0; a6=a6|0;
  jsCall(1,a1|0,a2|0,a3|0,a4|0,a5|0,a6|0);
}



function jsCall_viiiiii_2(a1,a2,a3,a4,a5,a6) {
  a1=a1|0; a2=a2|0; a3=a3|0; a4=a4|0; a5=a5|0; a6=a6|0;
  jsCall(2,a1|0,a2|0,a3|0,a4|0,a5|0,a6|0);
}



function jsCall_viiiiii_3(a1,a2,a3,a4,a5,a6) {
  a1=a1|0; a2=a2|0; a3=a3|0; a4=a4|0; a5=a5|0; a6=a6|0;
  jsCall(3,a1|0,a2|0,a3|0,a4|0,a5|0,a6|0);
}



function jsCall_viiiiii_4(a1,a2,a3,a4,a5,a6) {
  a1=a1|0; a2=a2|0; a3=a3|0; a4=a4|0; a5=a5|0; a6=a6|0;
  jsCall(4,a1|0,a2|0,a3|0,a4|0,a5|0,a6|0);
}



function jsCall_viiiiii_5(a1,a2,a3,a4,a5,a6) {
  a1=a1|0; a2=a2|0; a3=a3|0; a4=a4|0; a5=a5|0; a6=a6|0;
  jsCall(5,a1|0,a2|0,a3|0,a4|0,a5|0,a6|0);
}



function jsCall_viiiiii_6(a1,a2,a3,a4,a5,a6) {
  a1=a1|0; a2=a2|0; a3=a3|0; a4=a4|0; a5=a5|0; a6=a6|0;
  jsCall(6,a1|0,a2|0,a3|0,a4|0,a5|0,a6|0);
}



function jsCall_viiiiii_7(a1,a2,a3,a4,a5,a6) {
  a1=a1|0; a2=a2|0; a3=a3|0; a4=a4|0; a5=a5|0; a6=a6|0;
  jsCall(7,a1|0,a2|0,a3|0,a4|0,a5|0,a6|0);
}



function jsCall_viiiiii_8(a1,a2,a3,a4,a5,a6) {
  a1=a1|0; a2=a2|0; a3=a3|0; a4=a4|0; a5=a5|0; a6=a6|0;
  jsCall(8,a1|0,a2|0,a3|0,a4|0,a5|0,a6|0);
}



function jsCall_viiiiii_9(a1,a2,a3,a4,a5,a6) {
  a1=a1|0; a2=a2|0; a3=a3|0; a4=a4|0; a5=a5|0; a6=a6|0;
  jsCall(9,a1|0,a2|0,a3|0,a4|0,a5|0,a6|0);
}



function dynCall_iii(index,a1,a2) {
  index = index|0;
  a1=a1|0; a2=a2|0;
  return FUNCTION_TABLE_iii[index&255](a1|0,a2|0)|0;
}


function jsCall_iii_0(a1,a2) {
  a1=a1|0; a2=a2|0;
  return jsCall(0,a1|0,a2|0)|0;
}



function jsCall_iii_1(a1,a2) {
  a1=a1|0; a2=a2|0;
  return jsCall(1,a1|0,a2|0)|0;
}



function jsCall_iii_2(a1,a2) {
  a1=a1|0; a2=a2|0;
  return jsCall(2,a1|0,a2|0)|0;
}



function jsCall_iii_3(a1,a2) {
  a1=a1|0; a2=a2|0;
  return jsCall(3,a1|0,a2|0)|0;
}



function jsCall_iii_4(a1,a2) {
  a1=a1|0; a2=a2|0;
  return jsCall(4,a1|0,a2|0)|0;
}



function jsCall_iii_5(a1,a2) {
  a1=a1|0; a2=a2|0;
  return jsCall(5,a1|0,a2|0)|0;
}



function jsCall_iii_6(a1,a2) {
  a1=a1|0; a2=a2|0;
  return jsCall(6,a1|0,a2|0)|0;
}



function jsCall_iii_7(a1,a2) {
  a1=a1|0; a2=a2|0;
  return jsCall(7,a1|0,a2|0)|0;
}



function jsCall_iii_8(a1,a2) {
  a1=a1|0; a2=a2|0;
  return jsCall(8,a1|0,a2|0)|0;
}



function jsCall_iii_9(a1,a2) {
  a1=a1|0; a2=a2|0;
  return jsCall(9,a1|0,a2|0)|0;
}



function dynCall_viiii(index,a1,a2,a3,a4) {
  index = index|0;
  a1=a1|0; a2=a2|0; a3=a3|0; a4=a4|0;
  FUNCTION_TABLE_viiii[index&255](a1|0,a2|0,a3|0,a4|0);
}


function jsCall_viiii_0(a1,a2,a3,a4) {
  a1=a1|0; a2=a2|0; a3=a3|0; a4=a4|0;
  jsCall(0,a1|0,a2|0,a3|0,a4|0);
}



function jsCall_viiii_1(a1,a2,a3,a4) {
  a1=a1|0; a2=a2|0; a3=a3|0; a4=a4|0;
  jsCall(1,a1|0,a2|0,a3|0,a4|0);
}



function jsCall_viiii_2(a1,a2,a3,a4) {
  a1=a1|0; a2=a2|0; a3=a3|0; a4=a4|0;
  jsCall(2,a1|0,a2|0,a3|0,a4|0);
}



function jsCall_viiii_3(a1,a2,a3,a4) {
  a1=a1|0; a2=a2|0; a3=a3|0; a4=a4|0;
  jsCall(3,a1|0,a2|0,a3|0,a4|0);
}



function jsCall_viiii_4(a1,a2,a3,a4) {
  a1=a1|0; a2=a2|0; a3=a3|0; a4=a4|0;
  jsCall(4,a1|0,a2|0,a3|0,a4|0);
}



function jsCall_viiii_5(a1,a2,a3,a4) {
  a1=a1|0; a2=a2|0; a3=a3|0; a4=a4|0;
  jsCall(5,a1|0,a2|0,a3|0,a4|0);
}



function jsCall_viiii_6(a1,a2,a3,a4) {
  a1=a1|0; a2=a2|0; a3=a3|0; a4=a4|0;
  jsCall(6,a1|0,a2|0,a3|0,a4|0);
}



function jsCall_viiii_7(a1,a2,a3,a4) {
  a1=a1|0; a2=a2|0; a3=a3|0; a4=a4|0;
  jsCall(7,a1|0,a2|0,a3|0,a4|0);
}



function jsCall_viiii_8(a1,a2,a3,a4) {
  a1=a1|0; a2=a2|0; a3=a3|0; a4=a4|0;
  jsCall(8,a1|0,a2|0,a3|0,a4|0);
}



function jsCall_viiii_9(a1,a2,a3,a4) {
  a1=a1|0; a2=a2|0; a3=a3|0; a4=a4|0;
  jsCall(9,a1|0,a2|0,a3|0,a4|0);
}


function b0(p0,p1,p2) { p0 = p0|0;p1 = p1|0;p2 = p2|0; nullFunc_iiii(0);return 0; }
function b1(p0,p1,p2,p3,p4) { p0 = p0|0;p1 = p1|0;p2 = p2|0;p3 = p3|0;p4 = p4|0; nullFunc_viiiii(1); }
function b2() { ; nullFunc_i(2);return 0; }
function b3(p0) { p0 = p0|0; nullFunc_vi(3); }
function b4(p0,p1) { p0 = p0|0;p1 = p1|0; nullFunc_vii(4); }
function b5(p0) { p0 = p0|0; nullFunc_ii(5);return 0; }
function b6(p0,p1,p2) { p0 = p0|0;p1 = p1|0;p2 = p2|0; nullFunc_viii(6); }
function ___cxa_throw__wrapper(p0,p1,p2) { p0 = p0|0;p1 = p1|0;p2 = p2|0; ___cxa_throw(p0|0,p1|0,p2|0); }
function b7() { ; nullFunc_v(7); }
function ___cxa_pure_virtual__wrapper() { ; ___cxa_pure_virtual(); }
function ___cxa_end_catch__wrapper() { ; ___cxa_end_catch(); }
function b8(p0,p1,p2,p3,p4,p5) { p0 = p0|0;p1 = p1|0;p2 = p2|0;p3 = p3|0;p4 = p4|0;p5 = p5|0; nullFunc_viiiiii(8); }
function b9(p0,p1) { p0 = p0|0;p1 = p1|0; nullFunc_iii(9);return 0; }
function b10(p0,p1,p2,p3) { p0 = p0|0;p1 = p1|0;p2 = p2|0;p3 = p3|0; nullFunc_viiii(10); }

// EMSCRIPTEN_END_FUNCS
var FUNCTION_TABLE_iiii = [b0,b0,jsCall_iiii_0,b0,jsCall_iiii_1,b0,jsCall_iiii_2,b0,jsCall_iiii_3,b0,jsCall_iiii_4,b0,jsCall_iiii_5,b0,jsCall_iiii_6,b0,jsCall_iiii_7,b0,jsCall_iiii_8,b0,jsCall_iiii_9,b0,b0,b0,b0,b0,b0,b0,b0
,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0
,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0
,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0
,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0
,b0,b0,b0,b0,b0,b0,__ZNK10__cxxabiv117__class_type_info9can_catchEPKNS_16__shim_type_infoERPv,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0
,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0
,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0
,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0];
var FUNCTION_TABLE_viiiii = [b1,b1,jsCall_viiiii_0,b1,jsCall_viiiii_1,b1,jsCall_viiiii_2,b1,jsCall_viiiii_3,b1,jsCall_viiiii_4,b1,jsCall_viiiii_5,b1,jsCall_viiiii_6,b1,jsCall_viiiii_7,b1,jsCall_viiiii_8,b1,jsCall_viiiii_9,b1,b1,b1,__ZN17HostCommunication10packetSentEi7MessageP9Componenta,b1,b1,__ZN17HostCommunication14nodesConnectedEP9ComponentaS1_a,b1
,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1
,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1
,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1
,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,__ZN12EmscriptenIO23AttachExternalInterruptEhN2IO9Interrupt4ModeEPFvPvES3_,b1,b1,b1,b1,b1,b1,b1
,b1,b1,b1,b1,b1,b1,b1,b1,__ZNK10__cxxabiv117__class_type_info16search_below_dstEPNS_19__dynamic_cast_infoEPKvib,b1,b1,b1,__ZNK10__cxxabiv120__si_class_type_info16search_below_dstEPNS_19__dynamic_cast_infoEPKvib,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1
,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1
,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1
,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1];
var FUNCTION_TABLE_i = [b2,b2,jsCall_i_0,b2,jsCall_i_1,b2,jsCall_i_2,b2,jsCall_i_3,b2,jsCall_i_4,b2,jsCall_i_5,b2,jsCall_i_6,b2,jsCall_i_7,b2,jsCall_i_8,b2,jsCall_i_9,b2,b2,b2,b2,b2,b2,b2,b2
,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2
,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2
,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2
,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2
,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2
,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,___cxa_get_globals_fast,b2,b2
,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2
,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2];
var FUNCTION_TABLE_vi = [b3,b3,jsCall_vi_0,b3,jsCall_vi_1,b3,jsCall_vi_2,b3,jsCall_vi_3,b3,jsCall_vi_4,b3,jsCall_vi_5,b3,jsCall_vi_6,b3,jsCall_vi_7,b3,jsCall_vi_8,b3,jsCall_vi_9,b3,b3,b3,b3,b3,b3,b3,b3
,b3,b3,__ZN8SubGraphD2Ev,__ZN8SubGraphD0Ev,b3,b3,__ZN23EmscriptenHostTransport7runTickEv,b3,__ZN22PureFunctionComponent2I12NumberEqualsllED2Ev,__ZN22PureFunctionComponent2I12NumberEqualsllED0Ev,b3,__ZN22PureFunctionComponent2I3MinllED2Ev,__ZN22PureFunctionComponent2I3MinllED0Ev,b3,__ZN22PureFunctionComponent2I3MaxllED2Ev,__ZN22PureFunctionComponent2I3MaxllED0Ev,b3,__ZN22PureFunctionComponent2I9BooleanOrbbED2Ev,__ZN22PureFunctionComponent2I9BooleanOrbbED0Ev,b3,__ZN22PureFunctionComponent2I10BooleanAndbbED2Ev,__ZN22PureFunctionComponent2I10BooleanAndbbED0Ev,b3,__ZN9BoolToIntD2Ev,__ZN9BoolToIntD0Ev,b3,__ZN21SingleOutputComponentD2Ev,__ZN21SingleOutputComponentD0Ev,b3,__ZN13ToggleBooleanD2Ev
,__ZN13ToggleBooleanD0Ev,b3,__ZN5TimerD2Ev,__ZN5TimerD0Ev,b3,__ZN5SplitD2Ev,__ZN5SplitD0Ev,b3,__ZN9SerialOutD2Ev,__ZN9SerialOutD0Ev,b3,__ZN8SerialInD2Ev,__ZN8SerialInD0Ev,b3,__ZN5RouteD2Ev,__ZN5RouteD0Ev,b3,__ZN17ReadCapacitivePinD2Ev,__ZN17ReadCapacitivePinD0Ev,b3,__ZN14DummyComponentD2Ev,__ZN14DummyComponentD0Ev,__ZN8PwmWriteD2Ev,__ZN8PwmWriteD0Ev,b3,__ZN10MonitorPinD2Ev,__ZN10MonitorPinD0Ev,b3,__ZN9MapLinearD2Ev,__ZN9MapLinearD0Ev
,b3,__ZN12LedMatrixMaxD2Ev,__ZN12LedMatrixMaxD0Ev,b3,__ZN13InvertBooleanD2Ev,__ZN13InvertBooleanD0Ev,b3,__ZN15HysteresisLatchD2Ev,__ZN15HysteresisLatchD0Ev,b3,__ZN4GateD2Ev,__ZN4GateD0Ev,b3,__ZN7ForwardD2Ev,__ZN7ForwardD0Ev,b3,__ZN12DigitalWriteD2Ev,__ZN12DigitalWriteD0Ev,b3,__ZN11DigitalReadD2Ev,__ZN11DigitalReadD0Ev,b3,__ZN5CountD2Ev,__ZN5CountD0Ev,b3,__ZN9ConstrainD2Ev,__ZN9ConstrainD0Ev,b3,__ZN15BreakBeforeMakeD2Ev,__ZN15BreakBeforeMakeD0Ev
,b3,__ZN10ArduinoUnoD2Ev,__ZN10ArduinoUnoD0Ev,b3,__ZN10AnalogReadD2Ev,__ZN10AnalogReadD0Ev,b3,__ZN12EmscriptenIOD2Ev,__ZN12EmscriptenIOD0Ev,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,__ZN2IOD2Ev,__ZN2IOD0Ev,b3,__ZN9ComponentD2Ev,__ZN9ComponentD0Ev,b3,__ZNSt9bad_allocD2Ev
,__ZNSt9bad_allocD0Ev,b3,__ZN10__cxxabiv116__shim_type_infoD2Ev,__ZN10__cxxabiv117__class_type_infoD0Ev,__ZNK10__cxxabiv116__shim_type_info5noop1Ev,__ZNK10__cxxabiv116__shim_type_info5noop2Ev,b3,b3,b3,b3,__ZN10__cxxabiv120__si_class_type_infoD0Ev,b3,b3,b3,__ZN10AnalogReadC2Ev,__ZN10ArduinoUnoC2Ev,__ZN22PureFunctionComponent2I10BooleanAndbbEC2Ev,__ZN22PureFunctionComponent2I9BooleanOrbbEC2Ev,__ZN15BreakBeforeMakeC2Ev,__ZN9ConstrainC2Ev,__ZN5CountC2Ev,__ZN11DigitalReadC2Ev,__ZN12DigitalWriteC2Ev,__ZN7ForwardC2Ev,__ZN4GateC2Ev,__ZN15HysteresisLatchC2Ev,__ZN13InvertBooleanC2Ev,__ZN12LedMatrixMaxC2Ev,__ZN9MapLinearC2Ev,__ZN22PureFunctionComponent2I3MaxllEC2Ev
,__ZN22PureFunctionComponent2I3MinllEC2Ev,__ZN10MonitorPinC2Ev,__ZN22PureFunctionComponent2I12NumberEqualsllEC2Ev,__ZN8PwmWriteC2Ev,__ZN17ReadCapacitivePinC2Ev,__ZN5RouteC2Ev,__ZN8SerialInC2Ev,__ZN9SerialOutC2Ev,__ZN5SplitC2Ev,__ZN8SubGraphC2Ev,__ZN5TimerC2Ev,__ZN13ToggleBooleanC2Ev,__ZN9BoolToIntC2Ev,b3,b3,_free,__ZN17EmscriptenRuntimeC2Ev,__ZN23EmscriptenHostTransportC2Ev,b3,__ZN17HostCommunicationC2Ev,__ZN17EmscriptenRuntimeD2Ev,b3,__ZN6PacketC2Ev,__ZN10MonitorPin9interruptEPv,b3,b3,b3,b3,__ZN10__cxxabiv112_GLOBAL__N_19destruct_EPv,b3
,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3
,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3];
var FUNCTION_TABLE_vii = [b4,b4,jsCall_vii_0,b4,jsCall_vii_1,b4,jsCall_vii_2,b4,jsCall_vii_3,b4,jsCall_vii_4,b4,jsCall_vii_5,b4,jsCall_vii_6,b4,jsCall_vii_7,b4,jsCall_vii_8,b4,jsCall_vii_9,b4,b4,__ZN17HostCommunication12debugChangedE10DebugLevel,b4,b4,b4,b4,__ZN17HostCommunication19networkStateChangedEN7Network5StateE
,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4
,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4
,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4
,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4
,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4
,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,__ZN7NetworkC2EP2IO,b4,b4,__ZN6PacketC2E3Msg,b4,b4,b4,_abort_message,b4,b4,b4,b4
,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4
,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4];
var FUNCTION_TABLE_ii = [b5,b5,jsCall_ii_0,b5,jsCall_ii_1,b5,jsCall_ii_2,b5,jsCall_ii_3,b5,jsCall_ii_4,b5,jsCall_ii_5,b5,jsCall_ii_6,b5,jsCall_ii_7,b5,jsCall_ii_8,b5,jsCall_ii_9,b5,b5,b5,b5,b5,b5,b5,b5
,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5
,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5
,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5
,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,__ZN12EmscriptenIO14TimerCurrentMsEv,__ZN2IO18TimerCurrentMicrosEv,b5,b5,b5,b5,b5,b5,b5,b5
,b5,__ZNKSt9bad_alloc4whatEv,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5
,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,_malloc,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5
,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5
,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5];
var FUNCTION_TABLE_viii = [b6,b6,jsCall_viii_0,b6,jsCall_viii_1,b6,jsCall_viii_2,b6,jsCall_viii_3,b6,jsCall_viii_4,b6,jsCall_viii_5,b6,jsCall_viii_6,b6,jsCall_viii_7,b6,jsCall_viii_8,b6,jsCall_viii_9,b6,__ZN17HostCommunication9emitDebugE10DebugLevel7DebugId,b6,b6,__ZN17HostCommunication15packetDeliveredEi7Message,__ZN17HostCommunication9nodeAddedEP9Componenth,b6,b6
,b6,b6,b6,b6,__ZN8SubGraph7processE6Packeta,__ZN23EmscriptenHostTransport5setupEP2IOP17HostCommunication,b6,__ZN23EmscriptenHostTransport11sendCommandEPKhh,b6,b6,__ZN22PureFunctionComponent2I12NumberEqualsllE7processE6Packeta,b6,b6,__ZN22PureFunctionComponent2I3MinllE7processE6Packeta,b6,b6,__ZN22PureFunctionComponent2I3MaxllE7processE6Packeta,b6,b6,__ZN22PureFunctionComponent2I9BooleanOrbbE7processE6Packeta,b6,b6,__ZN22PureFunctionComponent2I10BooleanAndbbE7processE6Packeta,b6,b6,__ZN9BoolToInt7processE6Packeta,b6,b6,b6,b6
,b6,__ZN13ToggleBoolean7processE6Packeta,b6,b6,__ZN5Timer7processE6Packeta,b6,b6,__ZN5Split7processE6Packeta,b6,b6,__ZN9SerialOut7processE6Packeta,b6,b6,__ZN8SerialIn7processE6Packeta,b6,b6,__ZN5Route7processE6Packeta,b6,b6,__ZN14DummyComponent7processE6Packeta,b6,b6,b6,b6,__ZN8PwmWrite7processE6Packeta,b6,b6,__ZN10MonitorPin7processE6Packeta,b6,b6
,__ZN9MapLinear7processE6Packeta,b6,b6,__ZN12LedMatrixMax7processE6Packeta,b6,b6,__ZN13InvertBoolean7processE6Packeta,b6,b6,__ZN15HysteresisLatch7processE6Packeta,b6,b6,__ZN4Gate7processE6Packeta,b6,b6,__ZN7Forward7processE6Packeta,b6,b6,__ZN12DigitalWrite7processE6Packeta,b6,b6,__ZN11DigitalRead7processE6Packeta,b6,b6,__ZN5Count7processE6Packeta,b6,b6,__ZN9Constrain7processE6Packeta,b6,b6
,__ZN15BreakBeforeMake7processE6Packeta,b6,b6,__ZN10ArduinoUno7processE6Packeta,b6,b6,__ZN10AnalogRead7processE6Packeta,b6,b6,__ZN12EmscriptenIO10setIoValueEPKhh,__ZN12EmscriptenIO11SerialBeginEhi,b6,b6,__ZN12EmscriptenIO11SerialWriteEhh,__ZN12EmscriptenIO10PinSetModeEaN2IO7PinModeE,__ZN12EmscriptenIO12PinSetPullupEaN2IO10PullupModeE,__ZN12EmscriptenIO12DigitalWriteEab,b6,b6,__ZN12EmscriptenIO8PwmWriteEal,b6,b6,b6,b6,b6,__ZN2IO10setIoValueEPKhh,b6,b6,b6,b6
,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6
,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,___cxa_throw__wrapper,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6
,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6
,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6];
var FUNCTION_TABLE_v = [b7,b7,jsCall_v_0,b7,jsCall_v_1,b7,jsCall_v_2,b7,jsCall_v_3,b7,jsCall_v_4,b7,jsCall_v_5,b7,jsCall_v_6,b7,jsCall_v_7,b7,jsCall_v_8,b7,jsCall_v_9,b7,b7,b7,b7,b7,b7,b7,b7
,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,___cxa_pure_virtual__wrapper,b7
,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7
,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7
,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,__ZL25default_terminate_handlerv,b7
,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7
,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,__ZN10__cxxabiv112_GLOBAL__N_110construct_Ev,b7,___cxa_end_catch__wrapper,b7,b7,b7
,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7
,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7];
var FUNCTION_TABLE_viiiiii = [b8,b8,jsCall_viiiiii_0,b8,jsCall_viiiiii_1,b8,jsCall_viiiiii_2,b8,jsCall_viiiiii_3,b8,jsCall_viiiiii_4,b8,jsCall_viiiiii_5,b8,jsCall_viiiiii_6,b8,jsCall_viiiiii_7,b8,jsCall_viiiiii_8,b8,jsCall_viiiiii_9,b8,b8,b8,b8,b8,b8,b8,b8
,__ZN17HostCommunication17subgraphConnectedEbhaha,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8
,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8
,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8
,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8
,b8,b8,b8,b8,b8,b8,b8,__ZNK10__cxxabiv117__class_type_info16search_above_dstEPNS_19__dynamic_cast_infoEPKvS4_ib,b8,b8,b8,__ZNK10__cxxabiv120__si_class_type_info16search_above_dstEPNS_19__dynamic_cast_infoEPKvS4_ib,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8
,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8
,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8
,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8];
var FUNCTION_TABLE_iii = [b9,b9,jsCall_iii_0,b9,jsCall_iii_1,b9,jsCall_iii_2,b9,jsCall_iii_3,b9,jsCall_iii_4,b9,jsCall_iii_5,b9,jsCall_iii_6,b9,jsCall_iii_7,b9,jsCall_iii_8,b9,jsCall_iii_9,b9,b9,b9,b9,b9,b9,b9,b9
,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9
,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9
,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9
,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,__ZN12EmscriptenIO19SerialDataAvailableEh,__ZN12EmscriptenIO10SerialReadEh,b9,b9,b9,b9,__ZN12EmscriptenIO11DigitalReadEa,__ZN12EmscriptenIO10AnalogReadEa,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9
,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9
,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9
,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9
,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9];
var FUNCTION_TABLE_viiii = [b10,b10,jsCall_viiii_0,b10,jsCall_viiii_1,b10,jsCall_viiii_2,b10,jsCall_viiii_3,b10,jsCall_viiii_4,b10,jsCall_viiii_5,b10,jsCall_viiii_6,b10,jsCall_viiii_7,b10,jsCall_viiii_8,b10,jsCall_viiii_9,b10,b10,b10,b10,b10,b10,b10,b10
,b10,__ZN17HostCommunication23portSubscriptionChangedEhab,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10
,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10
,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10
,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10
,b10,b10,b10,b10,b10,b10,b10,b10,b10,__ZNK10__cxxabiv117__class_type_info27has_unambiguous_public_baseEPNS_19__dynamic_cast_infoEPvi,b10,b10,b10,__ZNK10__cxxabiv120__si_class_type_info27has_unambiguous_public_baseEPNS_19__dynamic_cast_infoEPvi,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10
,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10
,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10
,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10];

  return { _emscripten_runtime_run: _emscripten_runtime_run, ___cxa_can_catch: ___cxa_can_catch, _emscripten_runtime_setup: _emscripten_runtime_setup, _emscripten_runtime_new: _emscripten_runtime_new, _emscripten_runtime_send: _emscripten_runtime_send, ___cxa_is_pointer_type: ___cxa_is_pointer_type, _emscripten_runtime_free: _emscripten_runtime_free, _strlen: _strlen, _memset: _memset, _malloc: _malloc, _memcpy: _memcpy, _free: _free, runPostSets: runPostSets, stackAlloc: stackAlloc, stackSave: stackSave, stackRestore: stackRestore, setThrew: setThrew, setTempRet0: setTempRet0, getTempRet0: getTempRet0, dynCall_iiii: dynCall_iiii, dynCall_viiiii: dynCall_viiiii, dynCall_i: dynCall_i, dynCall_vi: dynCall_vi, dynCall_vii: dynCall_vii, dynCall_ii: dynCall_ii, dynCall_viii: dynCall_viii, dynCall_v: dynCall_v, dynCall_viiiiii: dynCall_viiiiii, dynCall_iii: dynCall_iii, dynCall_viiii: dynCall_viiii };
})
// EMSCRIPTEN_END_ASM
(Module.asmGlobalArg, Module.asmLibraryArg, buffer);
var real__emscripten_runtime_run = asm["_emscripten_runtime_run"]; asm["_emscripten_runtime_run"] = function() {
assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
return real__emscripten_runtime_run.apply(null, arguments);
};

var real____cxa_can_catch = asm["___cxa_can_catch"]; asm["___cxa_can_catch"] = function() {
assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
return real____cxa_can_catch.apply(null, arguments);
};

var real__emscripten_runtime_setup = asm["_emscripten_runtime_setup"]; asm["_emscripten_runtime_setup"] = function() {
assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
return real__emscripten_runtime_setup.apply(null, arguments);
};

var real__emscripten_runtime_new = asm["_emscripten_runtime_new"]; asm["_emscripten_runtime_new"] = function() {
assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
return real__emscripten_runtime_new.apply(null, arguments);
};

var real__emscripten_runtime_send = asm["_emscripten_runtime_send"]; asm["_emscripten_runtime_send"] = function() {
assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
return real__emscripten_runtime_send.apply(null, arguments);
};

var real____cxa_is_pointer_type = asm["___cxa_is_pointer_type"]; asm["___cxa_is_pointer_type"] = function() {
assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
return real____cxa_is_pointer_type.apply(null, arguments);
};

var real__emscripten_runtime_free = asm["_emscripten_runtime_free"]; asm["_emscripten_runtime_free"] = function() {
assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
return real__emscripten_runtime_free.apply(null, arguments);
};

var real__strlen = asm["_strlen"]; asm["_strlen"] = function() {
assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
return real__strlen.apply(null, arguments);
};

var real_runPostSets = asm["runPostSets"]; asm["runPostSets"] = function() {
assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
return real_runPostSets.apply(null, arguments);
};
var _emscripten_runtime_run = Module["_emscripten_runtime_run"] = asm["_emscripten_runtime_run"];
var ___cxa_can_catch = Module["___cxa_can_catch"] = asm["___cxa_can_catch"];
var _emscripten_runtime_setup = Module["_emscripten_runtime_setup"] = asm["_emscripten_runtime_setup"];
var _emscripten_runtime_new = Module["_emscripten_runtime_new"] = asm["_emscripten_runtime_new"];
var _emscripten_runtime_send = Module["_emscripten_runtime_send"] = asm["_emscripten_runtime_send"];
var ___cxa_is_pointer_type = Module["___cxa_is_pointer_type"] = asm["___cxa_is_pointer_type"];
var _emscripten_runtime_free = Module["_emscripten_runtime_free"] = asm["_emscripten_runtime_free"];
var _strlen = Module["_strlen"] = asm["_strlen"];
var _memset = Module["_memset"] = asm["_memset"];
var _malloc = Module["_malloc"] = asm["_malloc"];
var _memcpy = Module["_memcpy"] = asm["_memcpy"];
var _free = Module["_free"] = asm["_free"];
var runPostSets = Module["runPostSets"] = asm["runPostSets"];
var dynCall_iiii = Module["dynCall_iiii"] = asm["dynCall_iiii"];
var dynCall_viiiii = Module["dynCall_viiiii"] = asm["dynCall_viiiii"];
var dynCall_i = Module["dynCall_i"] = asm["dynCall_i"];
var dynCall_vi = Module["dynCall_vi"] = asm["dynCall_vi"];
var dynCall_vii = Module["dynCall_vii"] = asm["dynCall_vii"];
var dynCall_ii = Module["dynCall_ii"] = asm["dynCall_ii"];
var dynCall_viii = Module["dynCall_viii"] = asm["dynCall_viii"];
var dynCall_v = Module["dynCall_v"] = asm["dynCall_v"];
var dynCall_viiiiii = Module["dynCall_viiiiii"] = asm["dynCall_viiiiii"];
var dynCall_iii = Module["dynCall_iii"] = asm["dynCall_iii"];
var dynCall_viiii = Module["dynCall_viiii"] = asm["dynCall_viiii"];

Runtime.stackAlloc = asm['stackAlloc'];
Runtime.stackSave = asm['stackSave'];
Runtime.stackRestore = asm['stackRestore'];
Runtime.setTempRet0 = asm['setTempRet0'];
Runtime.getTempRet0 = asm['getTempRet0'];


// Warning: printing of i64 values may be slightly rounded! No deep i64 math used, so precise i64 code not included
var i64Math = null;

// === Auto-generated postamble setup entry stuff ===

if (memoryInitializer) {
  if (typeof Module['locateFile'] === 'function') {
    memoryInitializer = Module['locateFile'](memoryInitializer);
  } else if (Module['memoryInitializerPrefixURL']) {
    memoryInitializer = Module['memoryInitializerPrefixURL'] + memoryInitializer;
  }
  if (ENVIRONMENT_IS_NODE || ENVIRONMENT_IS_SHELL) {
    var data = Module['readBinary'](memoryInitializer);
    HEAPU8.set(data, STATIC_BASE);
  } else {
    addRunDependency('memory initializer');
    function applyMemoryInitializer(data) {
      if (data.byteLength) data = new Uint8Array(data);
      for (var i = 0; i < data.length; i++) {
        assert(HEAPU8[STATIC_BASE + i] === 0, "area for memory initializer should not have been touched before it's loaded");
      }
      HEAPU8.set(data, STATIC_BASE);
      removeRunDependency('memory initializer');
    }
    var request = Module['memoryInitializerRequest'];
    if (request) {
      // a network request has already been created, just use that
      if (request.response) {
        setTimeout(function() {
          applyMemoryInitializer(request.response);
        }, 0); // it's already here; but, apply it asynchronously
      } else {
        request.addEventListener('load', function() { // wait for it
          if (request.status !== 200 && request.status !== 0) {
            console.warn('a problem seems to have happened with Module.memoryInitializerRequest, status: ' + request.status);
          }
          if (!request.response || typeof request.response !== 'object' || !request.response.byteLength) {
            console.warn('a problem seems to have happened with Module.memoryInitializerRequest response (expected ArrayBuffer): ' + request.response);
          }
          applyMemoryInitializer(request.response);
        });
      }
    } else {
      // fetch it from the network ourselves
      Browser.asyncLoad(memoryInitializer, applyMemoryInitializer, function() {
        throw 'could not load memory initializer ' + memoryInitializer;
      });
    }
  }
}

function ExitStatus(status) {
  this.name = "ExitStatus";
  this.message = "Program terminated with exit(" + status + ")";
  this.status = status;
};
ExitStatus.prototype = new Error();
ExitStatus.prototype.constructor = ExitStatus;

var initialStackTop;
var preloadStartTime = null;
var calledMain = false;

dependenciesFulfilled = function runCaller() {
  // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)
  if (!Module['calledRun']) run();
  if (!Module['calledRun']) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled
}

Module['callMain'] = Module.callMain = function callMain(args) {
  assert(runDependencies == 0, 'cannot call main when async dependencies remain! (listen on __ATMAIN__)');
  assert(__ATPRERUN__.length == 0, 'cannot call main when preRun functions remain to be called');

  args = args || [];

  ensureInitRuntime();

  var argc = args.length+1;
  function pad() {
    for (var i = 0; i < 4-1; i++) {
      argv.push(0);
    }
  }
  var argv = [allocate(intArrayFromString(Module['thisProgram']), 'i8', ALLOC_NORMAL) ];
  pad();
  for (var i = 0; i < argc-1; i = i + 1) {
    argv.push(allocate(intArrayFromString(args[i]), 'i8', ALLOC_NORMAL));
    pad();
  }
  argv.push(0);
  argv = allocate(argv, 'i32', ALLOC_NORMAL);

  initialStackTop = STACKTOP;

  try {

    var ret = Module['_main'](argc, argv, 0);


    // if we're not running an evented main loop, it's time to exit
    exit(ret);
  }
  catch(e) {
    if (e instanceof ExitStatus) {
      // exit() throws this once it's done to make sure execution
      // has been stopped completely
      return;
    } else if (e == 'SimulateInfiniteLoop') {
      // running an evented main loop, don't immediately exit
      Module['noExitRuntime'] = true;
      return;
    } else {
      if (e && typeof e === 'object' && e.stack) Module.printErr('exception thrown: ' + [e, e.stack]);
      throw e;
    }
  } finally {
    calledMain = true;
  }
}




function run(args) {
  args = args || Module['arguments'];

  if (preloadStartTime === null) preloadStartTime = Date.now();

  if (runDependencies > 0) {
    Module.printErr('run() called, but dependencies remain, so not running');
    return;
  }

  preRun();

  if (runDependencies > 0) return; // a preRun added a dependency, run will be called later
  if (Module['calledRun']) return; // run may have just been called through dependencies being fulfilled just in this very frame

  function doRun() {
    if (Module['calledRun']) return; // run may have just been called while the async setStatus time below was happening
    Module['calledRun'] = true;

    if (ABORT) return; 

    ensureInitRuntime();

    preMain();

    if (ENVIRONMENT_IS_WEB && preloadStartTime !== null) {
      Module.printErr('pre-main prep time: ' + (Date.now() - preloadStartTime) + ' ms');
    }

    if (Module['onRuntimeInitialized']) Module['onRuntimeInitialized']();

    if (Module['_main'] && shouldRunNow) Module['callMain'](args);

    postRun();
  }

  if (Module['setStatus']) {
    Module['setStatus']('Running...');
    setTimeout(function() {
      setTimeout(function() {
        Module['setStatus']('');
      }, 1);
      doRun();
    }, 1);
  } else {
    doRun();
  }
}
Module['run'] = Module.run = run;

function exit(status) {
  if (Module['noExitRuntime']) {
    Module.printErr('exit(' + status + ') called, but noExitRuntime, so not exiting (you can use emscripten_force_exit, if you want to force a true shutdown)');
    return;
  }

  ABORT = true;
  EXITSTATUS = status;
  STACKTOP = initialStackTop;

  // exit the runtime
  exitRuntime();

  if (Module['onExit']) Module['onExit'](status);

  if (ENVIRONMENT_IS_NODE) {
    // Work around a node.js bug where stdout buffer is not flushed at process exit:
    // Instead of process.exit() directly, wait for stdout flush event.
    // See https://github.com/joyent/node/issues/1669 and https://github.com/kripken/emscripten/issues/2582
    // Workaround is based on https://github.com/RReverser/acorn/commit/50ab143cecc9ed71a2d66f78b4aec3bb2e9844f6
    process['stdout']['once']('drain', function () {
      process['exit'](status);
    });
    console.log(' '); // Make sure to print something to force the drain event to occur, in case the stdout buffer was empty.
    // Work around another node bug where sometimes 'drain' is never fired - make another effort
    // to emit the exit status, after a significant delay (if node hasn't fired drain by then, give up)
    setTimeout(function() {
      process['exit'](status);
    }, 500);
  } else
  if (ENVIRONMENT_IS_SHELL && typeof quit === 'function') {
    quit(status);
  }
  // if we reach here, we must throw an exception to halt the current execution
  throw new ExitStatus(status);
}
Module['exit'] = Module.exit = exit;

var abortDecorators = [];

function abort(what) {
  if (what !== undefined) {
    Module.print(what);
    Module.printErr(what);
    what = JSON.stringify(what)
  } else {
    what = '';
  }

  ABORT = true;
  EXITSTATUS = 1;

  var extra = '';

  var output = 'abort(' + what + ') at ' + stackTrace() + extra;
  abortDecorators.forEach(function(decorator) {
    output = decorator(output, what);
  });
  throw output;
}
Module['abort'] = Module.abort = abort;

// {{PRE_RUN_ADDITIONS}}

if (Module['preInit']) {
  if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];
  while (Module['preInit'].length > 0) {
    Module['preInit'].pop()();
  }
}

// shouldRunNow refers to calling main(), not run().
var shouldRunNow = true;
if (Module['noInitialRun']) {
  shouldRunNow = false;
}


run();

// {{POST_RUN_ADDITIONS}}






// {{MODULE_ADDITIONS}}




});
require.register("microflo-microflo-emscripten/index.js", function(exports, require, module){

module.exports = {
  runtime: require('./microflo-runtime.js'),
  library: require('./componentlib-map.json')
}

});
require.register("microflo-microflo-emscripten/componentlib-map.json", function(exports, require, module){
module.exports = JSON.parse('{"components":{"AnalogRead":{"name":"AnalogRead","description":"Read analog value from pin. Value=[0-1023]","inports":null,"outports":null,"filename":"/home/jon/contrib/code/microflo/node_modules/microflo-core/components/AnalogRead.hpp","id":1,"inPorts":{"trigger":{"type":"all","description":"","id":0},"pin":{"type":"all","description":"","id":1}},"outPorts":{"out":{"type":"all","description":"","id":0}}},"ArduinoUno":{"name":"ArduinoUno","description":"Convenient definition of pins available on Arduino Uno","inports":null,"outports":null,"filename":"/home/jon/contrib/code/microflo/node_modules/microflo-core/components/ArduinoUno.hpp","id":2,"inPorts":{},"outPorts":{"pin0":{"type":"all","description":"","id":0},"pin1":{"type":"all","description":"","id":1},"pin2":{"type":"all","description":"","id":2},"pin3":{"type":"all","description":"","id":3},"pin4":{"type":"all","description":"","id":4},"pin5":{"type":"all","description":"","id":5},"pin6":{"type":"all","description":"","id":6},"pin7":{"type":"all","description":"","id":7},"pin8":{"type":"all","description":"","id":8},"pin9":{"type":"all","description":"","id":9},"pin10":{"type":"all","description":"","id":10},"pin11":{"type":"all","description":"","id":11},"pin12":{"type":"all","description":"","id":12},"pin13":{"type":"all","description":"","id":13},"pina0":{"type":"all","description":"","id":14},"pina1":{"type":"all","description":"","id":15},"pina2":{"type":"all","description":"","id":16},"pina3":{"type":"all","description":"","id":17},"pina4":{"type":"all","description":"","id":18},"pina5":{"type":"all","description":"","id":19}}},"BooleanAnd":{"name":"BooleanAnd","description":"Emits true if @a AND @b is true, else false","inports":null,"outports":null,"type":"pure2","filename":"/home/jon/contrib/code/microflo/node_modules/microflo-core/components/BooleanAnd.hpp","id":3,"inPorts":{"a":{"ctype":"bool","type":"all","description":"","id":0,"name":"a"},"b":{"ctype":"bool","type":"all","description":"","id":1}},"outPorts":{"out":{"type":"all","description":"","id":0}}},"BooleanOr":{"name":"BooleanOr","description":"Emits true if either @a OR @b is true, else false","inports":null,"outports":null,"type":"pure2","filename":"/home/jon/contrib/code/microflo/node_modules/microflo-core/components/BooleanOr.hpp","id":4,"inPorts":{"a":{"ctype":"bool","type":"all","description":"","id":0,"name":"a"},"b":{"ctype":"bool","type":"all","description":"","id":1}},"outPorts":{"out":{"type":"all","description":"","id":0}}},"BreakBeforeMake":{"name":"BreakBeforeMake","description":"Break-before-make switch logic. Monitor ports must be connected to form a feedback loop from what outputs are connected to","inports":null,"outports":null,"filename":"/home/jon/contrib/code/microflo/node_modules/microflo-core/components/BreakBeforeMake.hpp","id":5,"inPorts":{"in":{"type":"all","description":"","id":0},"monitor1":{"type":"all","description":"","id":1},"monitor2":{"type":"all","description":"","id":2}},"outPorts":{"out1":{"type":"all","description":"","id":0},"out2":{"type":"all","description":"","id":1}}},"Constrain":{"name":"Constrain","description":"Constraina a number within a the range [@lower,@upper]","inports":null,"outports":null,"filename":"/home/jon/contrib/code/microflo/node_modules/microflo-core/components/Constrain.hpp","id":6,"inPorts":{"in":{"type":"all","description":"","id":0},"lower":{"type":"all","description":"","id":1},"upper":{"type":"all","description":"","id":2}},"outPorts":{"out":{"type":"all","description":"","id":0}}},"Count":{"name":"Count","description":"Count upwards from 0, with step 1","inports":null,"outports":null,"filename":"/home/jon/contrib/code/microflo/node_modules/microflo-core/components/Count.hpp","id":7,"inPorts":{"in":{"type":"all","description":"","id":0},"reset":{"type":"all","description":"","id":1}},"outPorts":{"out":{"type":"all","description":"","id":0}}},"DigitalRead":{"name":"DigitalRead","description":"Read a boolean value from pin. Value is read on @trigger","inports":null,"outports":null,"filename":"/home/jon/contrib/code/microflo/node_modules/microflo-core/components/DigitalRead.hpp","id":8,"inPorts":{"trigger":{"type":"all","description":"","id":0},"pin":{"type":"all","description":"","id":1},"pullup":{"type":"all","description":"","id":2}},"outPorts":{"out":{"type":"all","description":"","id":0}}},"DigitalWrite":{"name":"DigitalWrite","description":"Write a boolean value to pin","inports":null,"outports":null,"filename":"/home/jon/contrib/code/microflo/node_modules/microflo-core/components/DigitalWrite.hpp","id":9,"inPorts":{"in":{"type":"all","description":"","id":0},"pin":{"type":"all","description":"","id":1}},"outPorts":{"out":{"type":"all","description":"","id":0}}},"Forward":{"name":"Forward","description":"Forward a packet from input to output","inports":null,"outports":null,"filename":"/home/jon/contrib/code/microflo/node_modules/microflo-core/components/Forward.hpp","id":10,"inPorts":{"in":{"type":"all","description":"","id":0}},"outPorts":{"out":{"type":"all","description":"","id":0}}},"Gate":{"name":"Gate","description":"Pass packets from @in to @out only if @enable is true","inports":null,"outports":null,"filename":"/home/jon/contrib/code/microflo/node_modules/microflo-core/components/Gate.hpp","id":11,"inPorts":{"in":{"type":"all","description":"","id":0},"enable":{"type":"all","description":"","id":1}},"outPorts":{"out":{"type":"all","description":"","id":0}}},"HysteresisLatch":{"name":"HysteresisLatch","description":"Emit true if @in < @highthreshold, false if @in < @lowthreshold, else keep previous state","inports":null,"outports":null,"filename":"/home/jon/contrib/code/microflo/node_modules/microflo-core/components/HysteresisLatch.hpp","id":12,"inPorts":{"in":{"type":"all","description":"","id":0},"lowthreshold":{"type":"all","description":"","id":1},"highthreshold":{"type":"all","description":"","id":2}},"outPorts":{"out":{"type":"all","description":"","id":0}}},"InvertBoolean":{"name":"InvertBoolean","description":"Invert incoming boolean value. Logical equivalent: NOT","inports":null,"outports":null,"filename":"/home/jon/contrib/code/microflo/node_modules/microflo-core/components/InvertBoolean.hpp","id":13,"inPorts":{"in":{"type":"all","description":"","id":0}},"outPorts":{"out":{"type":"all","description":"","id":0}}},"LedMatrixMax":{"name":"LedMatrixMax","description":"Set characters on MAX7219 display","inports":null,"outports":null,"filename":"/home/jon/contrib/code/microflo/node_modules/microflo-core/components/LedMatrixMax.hpp","id":14,"inPorts":{"in":{"type":"all","description":"","id":0},"pincs":{"type":"all","description":"","id":1},"pindin":{"type":"all","description":"","id":2},"pinclk":{"type":"all","description":"","id":3}},"outPorts":{"out":{"type":"all","description":"","id":0}}},"MapLinear":{"name":"MapLinear","description":"Map the integer @in from range [@inmin,@inmax] to [@outmin,@outmax]","inports":null,"outports":null,"filename":"/home/jon/contrib/code/microflo/node_modules/microflo-core/components/MapLinear.hpp","id":15,"inPorts":{"in":{"type":"all","description":"","id":0},"inmin":{"type":"all","description":"","id":1},"inmax":{"type":"all","description":"","id":2},"outmin":{"type":"all","description":"","id":3},"outmax":{"type":"all","description":"","id":4}},"outPorts":{"out":{"type":"all","description":"","id":0}}},"Max":{"name":"Max","description":"Emits maximum value of @in and @threshold","inports":null,"outports":null,"type":"pure2","filename":"/home/jon/contrib/code/microflo/node_modules/microflo-core/components/Max.hpp","id":16,"inPorts":{"in":{"ctype":"long","type":"all","description":"","id":0,"name":"in"},"threshold":{"ctype":"long","type":"all","description":"","id":1}},"outPorts":{"out":{"type":"all","description":"","id":0}}},"Min":{"name":"Min","description":"Emits minimum value of @in and @threshold","inports":null,"outports":null,"type":"pure2","filename":"/home/jon/contrib/code/microflo/node_modules/microflo-core/components/Min.hpp","id":17,"inPorts":{"in":{"ctype":"long","type":"all","description":"","id":0,"name":"in"},"threshold":{"ctype":"long","type":"all","description":"","id":1}},"outPorts":{"out":{"type":"all","description":"","id":0}}},"MonitorPin":{"name":"MonitorPin","description":"Emit a boolean value each time a pin changes state. Note: only pin 2/3 on Arduino Uno/Nano supported.","inports":null,"outports":null,"filename":"/home/jon/contrib/code/microflo/node_modules/microflo-core/components/MonitorPin.hpp","id":18,"inPorts":{"pin":{"type":"all","description":"","id":0}},"outPorts":{"out":{"type":"all","description":"","id":0}}},"NumberEquals":{"name":"NumberEquals","description":"Emits true if @a EQUALS @b is true, else false","inports":null,"outports":null,"type":"pure2","filename":"/home/jon/contrib/code/microflo/node_modules/microflo-core/components/NumberEquals.hpp","id":19,"inPorts":{"a":{"ctype":"long","type":"all","description":"","id":0,"name":"a"},"b":{"ctype":"long","type":"all","description":"","id":1}},"outPorts":{"out":{"type":"all","description":"","id":0}}},"PwmWrite":{"name":"PwmWrite","description":"Set duty cycle [0-100%] of PWM pin","inports":null,"outports":null,"filename":"/home/jon/contrib/code/microflo/node_modules/microflo-core/components/PwmWrite.hpp","id":20,"inPorts":{"dutycycle":{"type":"all","description":"","id":0},"pin":{"type":"all","description":"","id":1}},"outPorts":{"out":{"type":"all","description":"","id":0}}},"ReadCapacitivePin":{"name":"ReadCapacitivePin","description":"Emits true if measured capacitance (in iterations) on @pin exceeds @threshold","inports":null,"outports":null,"filename":"/home/jon/contrib/code/microflo/node_modules/microflo-core/components/ReadCapacitivePin.hpp","id":21,"inPorts":{"trigger":{"type":"all","description":"","id":0},"pin":{"type":"all","description":"","id":1},"threshold":{"type":"all","description":"","id":2}},"outPorts":{"out":{"type":"all","description":"","id":0}}},"Route":{"name":"Route","description":"Pass packets to @out from input port number @port","inports":null,"outports":null,"filename":"/home/jon/contrib/code/microflo/node_modules/microflo-core/components/Route.hpp","id":22,"inPorts":{"port":{"type":"all","description":"","id":0},"in1":{"type":"all","description":"","id":1},"in2":{"type":"all","description":"","id":2},"in3":{"type":"all","description":"","id":3},"in4":{"type":"all","description":"","id":4},"in5":{"type":"all","description":"","id":5},"in6":{"type":"all","description":"","id":6},"in7":{"type":"all","description":"","id":7},"in8":{"type":"all","description":"","id":8},"in9":{"type":"all","description":"","id":9}},"outPorts":{"out":{"type":"all","description":"","id":0}}},"SerialIn":{"name":"SerialIn","description":"Emit packets read from serial port (0). Warning: may interfere with MicroFlo UI usage","inports":null,"outports":null,"filename":"/home/jon/contrib/code/microflo/node_modules/microflo-core/components/SerialIn.hpp","id":23,"inPorts":{"in":{"type":"all","description":"","id":0}},"outPorts":{"out":{"type":"all","description":"","id":0}}},"SerialOut":{"name":"SerialOut","description":"Write input packets to serial port (0). Warning: may interfere with MicroFlo UI usage","inports":null,"outports":null,"filename":"/home/jon/contrib/code/microflo/node_modules/microflo-core/components/SerialOut.hpp","id":24,"inPorts":{"in":{"type":"all","description":"","id":0}},"outPorts":{"out":{"type":"all","description":"","id":0}}},"Split":{"name":"Split","description":"Emit incoming packets on all output ports","inports":null,"outports":null,"filename":"/home/jon/contrib/code/microflo/node_modules/microflo-core/components/Split.hpp","id":25,"inPorts":{"in":{"type":"all","description":"","id":0}},"outPorts":{"out1":{"type":"all","description":"","id":0},"out2":{"type":"all","description":"","id":1},"out3":{"type":"all","description":"","id":2},"out4":{"type":"all","description":"","id":3},"out5":{"type":"all","description":"","id":4},"out6":{"type":"all","description":"","id":5},"out7":{"type":"all","description":"","id":6},"out8":{"type":"all","description":"","id":7},"out9":{"type":"all","description":"","id":8}}},"SubGraph":{"name":"SubGraph","description":"Not for normal use. Used internally for handling subgraphs","inports":null,"outports":null,"filename":"/home/jon/contrib/code/microflo/node_modules/microflo-core/components/SubGraph.hpp","id":26,"inPorts":{},"outPorts":{}},"Timer":{"name":"Timer","description":"Emit a packet every @interval milliseconds","inports":null,"outports":null,"filename":"/home/jon/contrib/code/microflo/node_modules/microflo-core/components/Timer.hpp","id":27,"inPorts":{"interval":{"type":"all","description":"","id":0},"reset":{"type":"all","description":"","id":1}},"outPorts":{"out":{"type":"all","description":"","id":0}}},"ToggleBoolean":{"name":"ToggleBoolean","description":"Invert output packet everytime an input packet arrives. Output defaults to false","inports":null,"outports":null,"filename":"/home/jon/contrib/code/microflo/node_modules/microflo-core/components/ToggleBoolean.hpp","id":28,"inPorts":{"in":{"type":"all","description":"","id":0},"reset":{"type":"all","description":"","id":1}},"outPorts":{"out":{"type":"all","description":"","id":0}}},"BoolToInt":{"name":"BoolToInt","description":"Convert boolean input to integer. true->1, false->0","inports":null,"outports":null,"filename":"/home/jon/contrib/code/microflo/node_modules/microflo-core/components/BoolToInt.hpp","id":29,"inPorts":{"in":{"type":"all","description":"","id":0}},"outPorts":{"out":{"type":"all","description":"","id":0}}}}}');
});
require.register("component-emitter/index.js", function(exports, require, module){

/**
 * Expose `Emitter`.
 */

if (typeof module !== 'undefined') {
  module.exports = Emitter;
}

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks['$' + event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

});
require.register("flowbased-fbp-protocol-client/index.js", function(exports, require, module){
exports.transports = {
  'websocket': require('./src/websocket'),
  'iframe': require('./src/iframe'),
  'webrtc': require('./src/webrtc')
};

try {
  exports.transports.microflo = require('./src/microflo');
} catch (e) {
  console.log('MicroFlo transport unavailable: ' + e.message);
}

exports.getTransport = function (transport) {
  return exports.transports[transport];
};

});
require.register("flowbased-fbp-protocol-client/component.json", function(exports, require, module){
module.exports = JSON.parse('{"name":"fbp-protocol-client","description":"Client library for the FBP protocol","author":"Henri Bergius <henri.bergius@iki.fi>","repo":"flowbased/fbp-protocol-client","version":"0.1.2","keywords":[],"dependencies":{"noflo/noflo":"*","microflo/microflo":"*","microflo/microflo-emscripten":"*","component/emitter":"*"},"remotes":["https://raw.githubusercontent.com"],"scripts":["helpers/platform.js","helpers/connection.js","src/base.js","src/iframe.js","src/websocket.js","src/microflo.js","src/webrtc.js","index.js"],"json":["component.json"]}');
});
require.register("flowbased-fbp-protocol-client/helpers/platform.js", function(exports, require, module){
var EventEmitter, NodeWebSocketClient, e, error1, isBrowser,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

isBrowser = function() {
  return !(typeof process !== 'undefined' && process.execPath && process.execPath.indexOf('node') !== -1);
};

try {
  EventEmitter = require('emitter');
} catch (error1) {
  e = error1;
  EventEmitter = require('events').EventEmitter;
}

if (!isBrowser()) {
  NodeWebSocketClient = (function(superClass) {
    extend(NodeWebSocketClient, superClass);

    function NodeWebSocketClient(address, protocol) {
      var WebSocketClient;
      WebSocketClient = require('websocket').client;
      this.client = new WebSocketClient;
      this.connection = null;
      this.client.on('connectionFailed', (function(_this) {
        return function(error) {
          return _this.emit('error', error);
        };
      })(this));
      this.client.on('connect', (function(_this) {
        return function(connection) {
          if (_this.connection) {
            console.log('WARNING: multiple connections for one NodeWebSocketClient');
          }
          _this.connection = connection;
          connection.on('error', function(error) {
            _this.connection = null;
            return _this.emit('error', error);
          });
          connection.on('close', function() {
            _this.connection = null;
            return _this.emit('close');
          });
          connection.on('message', function(message) {
            message.data = message.utf8Data;
            return _this.emit('message', message);
          });
          return _this.emit('open');
        };
      })(this));
      this.client.connect(address, protocol);
    }

    NodeWebSocketClient.prototype.addEventListener = function(event, listener, capture, wantsUntrusted) {
      return this.on(event, listener);
    };

    NodeWebSocketClient.prototype.close = function() {
      return this.connection.close();
    };

    NodeWebSocketClient.prototype.send = function(msg) {
      return this.connection.sendUTF(msg);
    };

    return NodeWebSocketClient;

  })(EventEmitter);
}

module.exports = {
  isBrowser: isBrowser,
  EventEmitter: EventEmitter,
  WebSocket: isBrowser() ? window.WebSocket : NodeWebSocketClient
};

});
require.register("flowbased-fbp-protocol-client/helpers/connection.js", function(exports, require, module){
exports.sendGraph = function(graph, runtime, callback, main) {
  var edge, graphId, i, iip, j, k, len, len1, len2, node, priv, pub, ref, ref1, ref2, ref3, ref4, ref5, ref6;
  if ((ref = graph.properties.environment) != null ? ref.type : void 0) {
    if ((ref1 = graph.properties.environment.type) !== 'all' && ref1 !== runtime.definition.type) {
      return callback(new Error("Graph type " + graph.properties.environment.type + " doesn't match runtime type " + runtime.definition.type));
    }
  }
  if (!runtime.canDo('protocol:graph')) {
    return callback(new Error('Runtime doesn\'t support graph protocol'));
  }
  graphId = graph.name || graph.properties.id;
  runtime.sendGraph('clear', {
    id: graphId,
    name: graph.name,
    main: main,
    library: graph.properties.project,
    icon: graph.properties.icon || '',
    description: graph.properties.description || ''
  });
  ref2 = graph.nodes;
  for (i = 0, len = ref2.length; i < len; i++) {
    node = ref2[i];
    runtime.sendGraph('addnode', {
      id: node.id,
      component: node.component,
      metadata: node.metadata,
      graph: graphId
    });
  }
  ref3 = graph.edges;
  for (j = 0, len1 = ref3.length; j < len1; j++) {
    edge = ref3[j];
    runtime.sendGraph('addedge', {
      src: {
        node: edge.from.node,
        port: edge.from.port
      },
      tgt: {
        node: edge.to.node,
        port: edge.to.port
      },
      metadata: edge.metadata,
      graph: graphId
    });
  }
  ref4 = graph.initializers;
  for (k = 0, len2 = ref4.length; k < len2; k++) {
    iip = ref4[k];
    runtime.sendGraph('addinitial', {
      src: {
        data: iip.from.data
      },
      tgt: {
        node: iip.to.node,
        port: iip.to.port
      },
      metadata: iip.metadata,
      graph: graphId
    });
  }
  if (graph.inports) {
    ref5 = graph.inports;
    for (pub in ref5) {
      priv = ref5[pub];
      runtime.sendGraph('addinport', {
        "public": pub,
        node: priv.process,
        port: priv.port,
        graph: graphId
      });
    }
  }
  if (graph.outports) {
    ref6 = graph.outports;
    for (pub in ref6) {
      priv = ref6[pub];
      runtime.sendGraph('addoutport', {
        "public": pub,
        node: priv.process,
        port: priv.port,
        graph: graphId
      });
    }
  }
  return callback();
};

});
require.register("flowbased-fbp-protocol-client/src/base.js", function(exports, require, module){
var BaseRuntime, platform,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

platform = require('../helpers/platform');

BaseRuntime = (function(superClass) {
  extend(BaseRuntime, superClass);

  function BaseRuntime(definition) {
    this.definition = definition;
    if (!this.definition.capabilities) {
      this.definition.capabilities = [];
    }
    this.graph = null;
  }

  BaseRuntime.prototype.setMain = function(graph) {
    this.graph = graph;
  };

  BaseRuntime.prototype.getType = function() {
    return this.definition.protocol;
  };

  BaseRuntime.prototype.getAddress = function() {
    return this.definition.address;
  };

  BaseRuntime.prototype.canDo = function(capability) {
    return this.definition.capabilities.indexOf(capability) !== -1;
  };

  BaseRuntime.prototype.isConnected = function() {
    return false;
  };

  BaseRuntime.prototype.connect = function() {};

  BaseRuntime.prototype.disconnect = function() {};

  BaseRuntime.prototype.reconnect = function() {
    this.disconnect();
    return this.connect();
  };

  BaseRuntime.prototype.start = function() {
    if (!this.graph) {
      throw new Error('No graph defined for execution');
    }
    return this.sendNetwork('start', {
      graph: this.graph.name || this.graph.properties.id
    });
  };

  BaseRuntime.prototype.stop = function() {
    if (!this.graph) {
      throw new Error('No graph defined for execution');
    }
    return this.sendNetwork('stop', {
      graph: this.graph.name || this.graph.properties.id
    });
  };

  BaseRuntime.prototype.setParentElement = function(parent) {};

  BaseRuntime.prototype.getElement = function() {};

  BaseRuntime.prototype.recvRuntime = function(command, payload) {
    var key, val;
    if (command === 'runtime') {
      for (key in payload) {
        val = payload[key];
        this.definition[key] = val;
      }
      this.emit('capabilities', payload.capabilities || []);
    }
    return this.emit('runtime', {
      command: command,
      payload: payload
    });
  };

  BaseRuntime.prototype.recvComponent = function(command, payload) {
    switch (command) {
      case 'error':
        return this.emit('network', {
          command: command,
          payload: payload
        });
      default:
        return this.emit('component', {
          command: command,
          payload: payload
        });
    }
  };

  BaseRuntime.prototype.recvGraph = function(command, payload) {
    return this.emit('graph', {
      command: command,
      payload: payload
    });
  };

  BaseRuntime.prototype.recvNetwork = function(command, payload) {
    switch (command) {
      case 'started':
        return this.emit('execution', {
          running: (payload != null) && (payload.running != null) ? payload.running : true,
          started: (payload != null) && payload.started ? payload.started : true
        });
      case 'stopped':
        return this.emit('execution', {
          running: (payload != null) && (payload.running != null) ? payload.running : false,
          started: (payload != null) && payload.started ? payload.started : false
        });
      case 'status':
        return this.emit('execution', {
          running: payload.running,
          started: payload.started
        });
      case 'icon':
        return this.emit('icon', payload);
      default:
        return this.emit('network', {
          command: command,
          payload: payload
        });
    }
  };

  BaseRuntime.prototype.sendRuntime = function(command, payload) {
    if (payload == null) {
      payload = {};
    }
    payload.secret = this.definition.secret;
    return this.send('runtime', command, payload);
  };

  BaseRuntime.prototype.sendGraph = function(command, payload) {
    if (payload == null) {
      payload = {};
    }
    payload.secret = this.definition.secret;
    return this.send('graph', command, payload);
  };

  BaseRuntime.prototype.sendNetwork = function(command, payload) {
    if (payload == null) {
      payload = {};
    }
    payload.secret = this.definition.secret;
    return this.send('network', command, payload);
  };

  BaseRuntime.prototype.sendComponent = function(command, payload) {
    if (payload == null) {
      payload = {};
    }
    payload.secret = this.definition.secret;
    return this.send('component', command, payload);
  };

  BaseRuntime.prototype.send = function(protocol, command, payload) {};

  return BaseRuntime;

})(platform.EventEmitter);

module.exports = BaseRuntime;

});
require.register("flowbased-fbp-protocol-client/src/iframe.js", function(exports, require, module){
var Base, IframeRuntime,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Base = require('./base');

IframeRuntime = (function(superClass) {
  extend(IframeRuntime, superClass);

  function IframeRuntime(definition) {
    this.onMessage = bind(this.onMessage, this);
    this.onLoaded = bind(this.onLoaded, this);
    this.updateIframe = bind(this.updateIframe, this);
    this.origin = window.location.origin;
    this.connecting = false;
    this.connected = false;
    this.buffer = [];
    this.iframe = null;
    IframeRuntime.__super__.constructor.call(this, definition);
  }

  IframeRuntime.prototype.getElement = function() {
    return this.iframe;
  };

  IframeRuntime.prototype.isConnected = function() {
    return this.connected;
  };

  IframeRuntime.prototype.setMain = function(graph) {
    if (this.graph) {
      this.graph.removeListener('changeProperties', this.updateIframe);
    }
    graph.on('changeProperties', this.updateIframe);
    return IframeRuntime.__super__.setMain.call(this, graph);
  };

  IframeRuntime.prototype.setParentElement = function(parent) {
    this.iframe = document.createElement('iframe');
    this.iframe.setAttribute('sandbox', 'allow-scripts allow-same-origin');
    return parent.appendChild(this.iframe);
  };

  IframeRuntime.prototype.connect = function() {
    if (!this.iframe) {
      throw new Error('Unable to connect without a parent element');
    }
    this.iframe.addEventListener('load', this.onLoaded, false);
    this.connecting = true;
    this.emit('status', {
      online: false,
      label: 'connecting'
    });
    this.iframe.setAttribute('src', this.getAddress());
    this.iframe.id = 'preview-iframe';
    return window.addEventListener('message', this.onMessage, false);
  };

  IframeRuntime.prototype.updateIframe = function() {
    var env;
    if (!this.iframe || !this.graph) {
      return;
    }
    env = this.graph.properties.environment;
    if (!env || !env.content) {
      return;
    }
    return this.send('iframe', 'setcontent', env.content);
  };

  IframeRuntime.prototype.disconnect = function() {
    this.iframe.removeEventListener('load', this.onLoaded, false);
    this.connected = false;
    window.removeEventListener('message', this.onMessage, false);
    this.emit('status', {
      online: false,
      label: 'disconnected'
    });
    return this.emit('disconnected');
  };

  IframeRuntime.prototype.onLoaded = function() {
    this.connecting = false;
    this.connected = true;
    this.sendRuntime('getruntime', {});
    this.emit('status', {
      online: true,
      label: 'connected'
    });
    this.emit('connected');
    this.updateIframe();
    return this.flush();
  };

  IframeRuntime.prototype.send = function(protocol, command, payload) {
    var e, error, w;
    if (this.connecting) {
      this.buffer.push({
        protocol: protocol,
        command: command,
        payload: payload
      });
      return;
    }
    w = this.iframe.contentWindow;
    if (!w) {
      return;
    }
    try {
      if (w.location.href === 'about:blank') {
        return;
      }
      if (w.location.href.indexOf('chrome-extension://') !== -1) {
        throw new Error('Use * for IFRAME communications in a Chrome app');
      }
    } catch (error) {
      e = error;
      w.postMessage(JSON.stringify({
        protocol: protocol,
        command: command,
        payload: payload
      }), '*');
      return;
    }
    return w.postMessage(JSON.stringify({
      protocol: protocol,
      command: command,
      payload: payload
    }), w.location.href);
  };

  IframeRuntime.prototype.onMessage = function(message) {
    var data;
    if (typeof message.data === 'string') {
      data = JSON.parse(message.data);
    } else {
      data = message.data;
    }
    switch (data.protocol) {
      case 'runtime':
        return this.recvRuntime(data.command, data.payload);
      case 'graph':
        return this.recvGraph(data.command, data.payload);
      case 'network':
        return this.recvNetwork(data.command, data.payload);
      case 'component':
        return this.recvComponent(data.command, data.payload);
    }
  };

  IframeRuntime.prototype.flush = function() {
    var i, item, len, ref;
    ref = this.buffer;
    for (i = 0, len = ref.length; i < len; i++) {
      item = ref[i];
      this.send(item.protocol, item.command, item.payload);
    }
    return this.buffer = [];
  };

  return IframeRuntime;

})(Base);

module.exports = IframeRuntime;

});
require.register("flowbased-fbp-protocol-client/src/websocket.js", function(exports, require, module){
var Base, WebSocketRuntime, platform,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Base = require('./base');

platform = require('../helpers/platform');

WebSocketRuntime = (function(superClass) {
  extend(WebSocketRuntime, superClass);

  function WebSocketRuntime(definition) {
    this.handleMessage = bind(this.handleMessage, this);
    this.handleError = bind(this.handleError, this);
    this.connecting = false;
    this.connection = null;
    this.protocol = 'noflo';
    this.buffer = [];
    this.container = null;
    WebSocketRuntime.__super__.constructor.call(this, definition);
  }

  WebSocketRuntime.prototype.getElement = function() {
    var messageConsole, previewImage;
    if (this.container) {
      return this.container;
    }
    this.container = document.createElement('div');
    this.container.classList.add('preview-container');
    messageConsole = document.createElement('pre');
    previewImage = document.createElement('img');
    this.container.appendChild(previewImage);
    this.container.appendChild(messageConsole);
    this.on('network', function(message) {
      var encoded, hasQuery, p, separator;
      if (message.command !== 'output') {
        return;
      }
      p = message.payload;
      if ((p.type != null) && p.type === 'previewurl') {
        hasQuery = p.url.indexOf('?' !== -1);
        separator = hasQuery ? '&' : '?';
        previewImage.src = p.url + separator + 'timestamp=' + new Date().getTime();
      }
      if (p.message != null) {
        encoded = p.message.replace(/[\u00A0-\u99999<>\&]/gim, function(i) {
          return "&#" + (i.charCodeAt(0)) + ";";
        });
        messageConsole.innerHTML += encoded + "\n";
        return messageConsole.scrollTop = messageConsole.scrollHeight;
      }
    });
    this.on('disconnected', function() {
      return messageConsole.innerHTML = '';
    });
    return this.container;
  };

  WebSocketRuntime.prototype.isConnected = function() {
    return this.connection !== null;
  };

  WebSocketRuntime.prototype.connect = function() {
    if (this.connection || this.connecting) {
      return;
    }
    if (this.protocol) {
      this.connection = new platform.WebSocket(this.getAddress(), this.protocol);
    } else {
      this.connection = new platform.WebSocket(this.getAddress());
    }
    this.connection.addEventListener('open', (function(_this) {
      return function() {
        _this.connecting = false;
        _this.sendRuntime('getruntime', {});
        _this.emit('status', {
          online: true,
          label: 'connected'
        });
        _this.emit('connected');
        return _this.flush();
      };
    })(this), false);
    this.connection.addEventListener('message', this.handleMessage, false);
    this.connection.addEventListener('error', this.handleError, false);
    this.connection.addEventListener('close', (function(_this) {
      return function() {
        _this.connection = null;
        _this.emit('status', {
          online: false,
          label: 'disconnected'
        });
        return _this.emit('disconnected');
      };
    })(this), false);
    return this.connecting = true;
  };

  WebSocketRuntime.prototype.disconnect = function() {
    if (!this.connection) {
      return;
    }
    this.connecting = false;
    return this.connection.close();
  };

  WebSocketRuntime.prototype.send = function(protocol, command, payload) {
    if (this.connecting) {
      this.buffer.push({
        protocol: protocol,
        command: command,
        payload: payload
      });
      return;
    }
    if (!this.connection) {
      return;
    }
    return this.connection.send(JSON.stringify({
      protocol: protocol,
      command: command,
      payload: payload
    }));
  };

  WebSocketRuntime.prototype.handleError = function(error) {
    if (this.protocol === 'noflo') {
      delete this.protocol;
      this.connecting = false;
      this.connection = null;
      setTimeout((function(_this) {
        return function() {
          return _this.connect();
        };
      })(this), 1);
      return;
    }
    this.emit('error', error);
    this.connection = null;
    return this.connecting = false;
  };

  WebSocketRuntime.prototype.handleMessage = function(message) {
    var msg;
    msg = JSON.parse(message.data);
    switch (msg.protocol) {
      case 'runtime':
        return this.recvRuntime(msg.command, msg.payload);
      case 'graph':
        return this.recvGraph(msg.command, msg.payload);
      case 'network':
        return this.recvNetwork(msg.command, msg.payload);
      case 'component':
        return this.recvComponent(msg.command, msg.payload);
    }
  };

  WebSocketRuntime.prototype.flush = function() {
    var item, j, len, ref;
    ref = this.buffer;
    for (j = 0, len = ref.length; j < len; j++) {
      item = ref[j];
      this.send(item.protocol, item.command, item.payload);
    }
    return this.buffer = [];
  };

  return WebSocketRuntime;

})(Base);

module.exports = WebSocketRuntime;

});
require.register("flowbased-fbp-protocol-client/src/microflo.js", function(exports, require, module){
var Base, MicroFloRuntime, microflo, parseAddress, parseQueryString,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Base = require('./base');

microflo = require('microflo');

parseQueryString = function(queryString) {
  var params, queries;
  queries = queryString.split("&");
  params = {};
  queries.forEach(function(query, i) {
    var kv;
    kv = query.split('=');
    return params[kv[0]] = kv[1];
  });
  return params;
};

parseAddress = function(address) {
  var d, end, info, k, params, query, queryStart, start, v;
  info = {
    type: null,
    device: null,
    baudrate: "9600"
  };
  if (address.indexOf('serial://') === 0) {
    info.type = 'serial';
  }
  if (address.indexOf('simulator://') === 0) {
    info.type = 'simulator';
  }
  if (info.type) {
    start = address.indexOf('://') + '://'.length;
    end = address.indexOf('?');
    if (end < 0) {
      end = address.length;
    }
    d = address.substring(start, end);
    if (d) {
      info.device = d;
    }
  }
  queryStart = address.indexOf('?');
  if (queryStart !== -1) {
    query = address.substring(queryStart + 1);
    params = parseQueryString(query);
    for (k in params) {
      v = params[k];
      info[k] = v;
    }
  }
  return info;
};

MicroFloRuntime = (function(superClass) {
  extend(MicroFloRuntime, superClass);

  function MicroFloRuntime(definition) {
    this.onMessage = bind(this.onMessage, this);
    this.updatecontainer = bind(this.updatecontainer, this);
    this.connecting = false;
    this.buffer = [];
    this.container = null;
    this.runtime = null;
    this.on('connected', this.updatecontainer);
    MicroFloRuntime.__super__.constructor.call(this, definition);
  }

  MicroFloRuntime.prototype.isConnected = function() {
    return this.runtime !== null;
  };

  MicroFloRuntime.prototype.getElement = function() {
    return this.container;
  };

  MicroFloRuntime.prototype.setParentElement = function(parent) {
    this.container = document.createElement('container');
    return parent.appendChild(this.container);
  };

  MicroFloRuntime.prototype.setMain = function(graph) {
    if (this.graph) {
      this.graph.removeListener('changeProperties', this.updatecontainer);
    }
    graph.on('changeProperties', this.updatecontainer);
    return MicroFloRuntime.__super__.setMain.call(this, graph);
  };

  MicroFloRuntime.prototype.openComm = function() {
    var getRuntime, info;
    getRuntime = null;
    info = parseAddress(this.getAddress());
    if (info.type === 'serial') {
      getRuntime = (function(_this) {
        return function(callback) {
          return microflo.serial.openTransport(info.device, parseInt(info.baudrate), function(err, transport) {
            var dev, filename, fs;
            if (err) {
              return callback(err);
            }
            dev = new microflo.runtime.Runtime(transport);
            if (((typeof process !== "undefined" && process !== null ? process.env : void 0) != null) && process.env['MICROFLO_COMPONENT_MAP']) {
              fs = require('fs');
              filename = process.env['MICROFLO_COMPONENT_MAP'];
              dev.library.definition = JSON.parse(fs.readFileSync(filename));
            }
            return callback(null, dev);
          });
        };
      })(this);
    } else if (info.type === 'simulator') {
      getRuntime = (function(_this) {
        return function(callback) {
          var build, sim;
          build = require('microflo-emscripten');
          sim = new microflo.simulator.RuntimeSimulator(build.runtime);
          sim.library.definition = build.library;
          sim.start();
          return callback(null, sim);
        };
      })(this);
    }
    return getRuntime((function(_this) {
      return function(err, runtime) {
        if (err) {
          return _this.emit('error', err);
        }
        runtime.on('message', function(response) {
          return _this.onMessage({
            data: response
          });
        });
        return runtime.device.open(function() {
          _this.connecting = false;
          if (err) {
            console.log('MicroFlo error:', err);
            _this.emit('error', err);
            return;
          }
          _this.runtime = runtime;
          _this.sendRuntime('getruntime', {});
          _this.emit('status', {
            online: true,
            label: 'connected'
          });
          _this.emit('connected');
          return _this.flush();
        });
      };
    })(this));
  };

  MicroFloRuntime.prototype.connect = function() {
    var f, ref, transport;
    if (this.connecting) {
      return;
    }
    this.connecting = true;
    transport = typeof runtime !== "undefined" && runtime !== null ? runtime.transport : void 0;
    if ((ref = this.runtime) != null) {
      ref.stop();
    }
    this.runtime = null;
    if (transport) {
      return transport.close((function(_this) {
        return function() {
          return _this.openComm();
        };
      })(this));
    } else {
      f = (function(_this) {
        return function() {
          return _this.openComm();
        };
      })(this);
      return setTimeout(f, 0);
    }
  };

  MicroFloRuntime.prototype.disconnect = function() {
    var onClosed;
    onClosed = (function(_this) {
      return function(success) {
        _this.runtime = null;
        _this.emit('status', {
          online: false,
          label: 'disconnected'
        });
        return _this.emit('disconnected');
      };
    })(this);
    if (this.runtime) {
      return this.runtime.transport.close(onClosed);
    } else {
      return onClosed(false);
    }
  };

  MicroFloRuntime.prototype.updatecontainer = function() {
    if (!this.container) {
      return;
    }
    return this.container.id = 'preview-container';
  };

  MicroFloRuntime.prototype.send = function(protocol, command, payload) {
    var e, error, msg;
    msg = {
      protocol: protocol,
      command: command,
      payload: payload
    };
    if (this.connecting) {
      this.buffer.push(msg);
      return;
    }
    try {
      return this.runtime.handleMessage(msg);
    } catch (error) {
      e = error;
      console.log(e.stack);
      return console.log(e);
    }
  };

  MicroFloRuntime.prototype.onMessage = function(message) {
    switch (message.data.protocol) {
      case 'runtime':
        return this.recvRuntime(message.data.command, message.data.payload);
      case 'graph':
        return this.recvGraph(message.data.command, message.data.payload);
      case 'network':
        return this.recvNetwork(message.data.command, message.data.payload);
      case 'component':
        return this.recvComponent(message.data.command, message.data.payload);
    }
  };

  MicroFloRuntime.prototype.flush = function() {
    var item, j, len, ref;
    ref = this.buffer;
    for (j = 0, len = ref.length; j < len; j++) {
      item = ref[j];
      this.send(item.protocol, item.command, item.payload);
    }
    return this.buffer = [];
  };

  return MicroFloRuntime;

})(Base);

module.exports = MicroFloRuntime;

MicroFloRuntime.parseAddress = parseAddress;

});
require.register("flowbased-fbp-protocol-client/src/webrtc.js", function(exports, require, module){
var Base, WebRTCRuntime,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Base = require('./base');

WebRTCRuntime = (function(superClass) {
  extend(WebRTCRuntime, superClass);

  function WebRTCRuntime(definition) {
    this.handleMessage = bind(this.handleMessage, this);
    this.handleError = bind(this.handleError, this);
    this.peer = null;
    this.connecting = false;
    this.connection = null;
    this.protocol = 'webrtc';
    this.buffer = [];
    this.debug = false;
    WebRTCRuntime.__super__.constructor.call(this, definition);
  }

  WebRTCRuntime.prototype.getElement = function() {
    var console;
    return null;
    console = document.createElement('pre');
    this.on('network', function(message) {
      var encoded;
      if (message.command !== 'output') {
        return;
      }
      if (!message.payload.message) {
        message.payload.message = '';
      }
      encoded = message.payload.message.replace(/[\u00A0-\u99999<>\&]/gim, function(i) {
        return "&#" + (i.charCodeAt(0)) + ";";
      });
      console.innerHTML += encoded + "\n";
      return console.scrollTop = console.scrollHeight;
    });
    return this.on('disconnected', function() {
      return console.innerHTML = '';
    });
  };

  WebRTCRuntime.prototype.isConnected = function() {
    return this.connection !== null;
  };

  WebRTCRuntime.prototype.connect = function() {
    var address, id, options, signaller;
    if (this.connection || this.connecting) {
      return;
    }
    address = this.getAddress();
    if (address.indexOf('#') !== -1) {
      signaller = address.split('#')[0];
      id = address.split('#')[1];
    } else {
      signaller = 'https://api.flowhub.io';
      id = address;
    }
    options = {
      room: id,
      debug: true,
      channels: {
        chat: true
      },
      signaller: signaller,
      capture: false,
      constraints: false,
      expectedLocalStreams: 0
    };
    this.peer = RTC(options);
    this.peer.on('channel:opened:chat', (function(_this) {
      return function(id, dc) {
        _this.connection = dc;
        _this.connection.onmessage = function(data) {
          if (_this.debug) {
            console.log('message', data.data);
          }
          return _this.handleMessage(data.data);
        };
        _this.connecting = false;
        _this.sendRuntime('getruntime', {});
        _this.emit('status', {
          online: true,
          label: 'connected'
        });
        _this.emit('connected');
        return _this.flush();
      };
    })(this));
    this.peer.on('channel:closed:chat', (function(_this) {
      return function(id, dc) {
        dc.onmessage = null;
        _this.connection = null;
        _this.emit('status', {
          online: false,
          label: 'disconnected'
        });
        return _this.emit('disconnected');
      };
    })(this));
    return this.connecting = true;
  };

  WebRTCRuntime.prototype.disconnect = function() {
    if (!this.connection) {
      return;
    }
    this.connecting = false;
    return this.connection.close();
  };

  WebRTCRuntime.prototype.send = function(protocol, command, payload) {
    var m;
    m = {
      protocol: protocol,
      command: command,
      payload: payload
    };
    if (this.connecting) {
      this.buffer.push(m);
      return;
    }
    if (!this.connection) {
      return;
    }
    if (this.debug) {
      console.log('send', m);
    }
    return this.connection.send(JSON.stringify(m));
  };

  WebRTCRuntime.prototype.handleError = function(error) {
    this.connection = null;
    return this.connecting = false;
  };

  WebRTCRuntime.prototype.handleMessage = function(message) {
    var msg;
    msg = JSON.parse(message);
    switch (msg.protocol) {
      case 'runtime':
        return this.recvRuntime(msg.command, msg.payload);
      case 'graph':
        return this.recvGraph(msg.command, msg.payload);
      case 'network':
        return this.recvNetwork(msg.command, msg.payload);
      case 'component':
        return this.recvComponent(msg.command, msg.payload);
    }
  };

  WebRTCRuntime.prototype.flush = function() {
    var item, j, len, ref;
    ref = this.buffer;
    for (j = 0, len = ref.length; j < len; j++) {
      item = ref[j];
      this.send(item.protocol, item.command, item.payload);
    }
    return this.buffer = [];
  };

  return WebRTCRuntime;

})(Base);

module.exports = WebRTCRuntime;

});
require.register("flowbased-fbp/lib/fbp.js", function(exports, require, module){
module.exports = (function() {
  /*
   * Generated by PEG.js 0.8.0.
   *
   * http://pegjs.majda.cz/
   */

  function peg$subclass(child, parent) {
    function ctor() { this.constructor = child; }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
  }

  function SyntaxError(message, expected, found, offset, line, column) {
    this.message  = message;
    this.expected = expected;
    this.found    = found;
    this.offset   = offset;
    this.line     = line;
    this.column   = column;

    this.name     = "SyntaxError";
  }

  peg$subclass(SyntaxError, Error);

  function parse(input) {
    var options = arguments.length > 1 ? arguments[1] : {},

        peg$FAILED = {},

        peg$startRuleFunctions = { start: peg$parsestart },
        peg$startRuleFunction  = peg$parsestart,

        peg$c0 = [],
        peg$c1 = function() { return parser.getResult();  },
        peg$c2 = peg$FAILED,
        peg$c3 = "EXPORT=",
        peg$c4 = { type: "literal", value: "EXPORT=", description: "\"EXPORT=\"" },
        peg$c5 = /^[A-Za-z.0-9_]/,
        peg$c6 = { type: "class", value: "[A-Za-z.0-9_]", description: "[A-Za-z.0-9_]" },
        peg$c7 = ":",
        peg$c8 = { type: "literal", value: ":", description: "\":\"" },
        peg$c9 = /^[A-Z0-9_]/,
        peg$c10 = { type: "class", value: "[A-Z0-9_]", description: "[A-Z0-9_]" },
        peg$c11 = null,
        peg$c12 = function(priv, pub) {return parser.registerExports(priv.join(""),pub.join(""))},
        peg$c13 = "INPORT=",
        peg$c14 = { type: "literal", value: "INPORT=", description: "\"INPORT=\"" },
        peg$c15 = /^[A-Za-z0-9_]/,
        peg$c16 = { type: "class", value: "[A-Za-z0-9_]", description: "[A-Za-z0-9_]" },
        peg$c17 = ".",
        peg$c18 = { type: "literal", value: ".", description: "\".\"" },
        peg$c19 = function(node, port, pub) {return parser.registerInports(node.join(""),port.join(""),pub.join(""))},
        peg$c20 = "OUTPORT=",
        peg$c21 = { type: "literal", value: "OUTPORT=", description: "\"OUTPORT=\"" },
        peg$c22 = function(node, port, pub) {return parser.registerOutports(node.join(""),port.join(""),pub.join(""))},
        peg$c23 = /^[\n\r\u2028\u2029]/,
        peg$c24 = { type: "class", value: "[\\n\\r\\u2028\\u2029]", description: "[\\n\\r\\u2028\\u2029]" },
        peg$c25 = function(edges) {return parser.registerEdges(edges);},
        peg$c26 = ",",
        peg$c27 = { type: "literal", value: ",", description: "\",\"" },
        peg$c28 = "#",
        peg$c29 = { type: "literal", value: "#", description: "\"#\"" },
        peg$c30 = "->",
        peg$c31 = { type: "literal", value: "->", description: "\"->\"" },
        peg$c32 = function(x, y) { return [x,y]; },
        peg$c33 = function(x, proc, y) { return [{"tgt":{process:proc, port:x}},{"src":{process:proc, port:y}}]; },
        peg$c34 = function(proc, port) { return {"src":{process:proc, port:port}} },
        peg$c35 = function(proc, port) { return {"src":{process:proc, port:port.port, index: port.index}} },
        peg$c36 = "'",
        peg$c37 = { type: "literal", value: "'", description: "\"'\"" },
        peg$c38 = function(iip) { return {"data":iip.join("")} },
        peg$c39 = function(port, proc) { return {"tgt":{process:proc, port:port}} },
        peg$c40 = function(port, proc) { return {"tgt":{process:proc, port:port.port, index: port.index}} },
        peg$c41 = /^[a-zA-Z0-9_\-]/,
        peg$c42 = { type: "class", value: "[a-zA-Z0-9_\\-]", description: "[a-zA-Z0-9_\\-]" },
        peg$c43 = function(node, comp) { if(comp){parser.addNode(node.join(""),comp);}; return node.join("")},
        peg$c44 = "(",
        peg$c45 = { type: "literal", value: "(", description: "\"(\"" },
        peg$c46 = /^[a-zA-Z\/\-0-9_]/,
        peg$c47 = { type: "class", value: "[a-zA-Z\\/\\-0-9_]", description: "[a-zA-Z\\/\\-0-9_]" },
        peg$c48 = ")",
        peg$c49 = { type: "literal", value: ")", description: "\")\"" },
        peg$c50 = function(comp, meta) { var o = {}; comp ? o.comp = comp.join("") : o.comp = ''; meta ? o.meta = meta.join("").split(',') : null; return o; },
        peg$c51 = /^[a-zA-Z\/=_,0-9]/,
        peg$c52 = { type: "class", value: "[a-zA-Z\\/=_,0-9]", description: "[a-zA-Z\\/=_,0-9]" },
        peg$c53 = function(meta) {return meta},
        peg$c54 = /^[A-Z.0-9_]/,
        peg$c55 = { type: "class", value: "[A-Z.0-9_]", description: "[A-Z.0-9_]" },
        peg$c56 = function(portname) {return portname.join("").toLowerCase()},
        peg$c57 = "[",
        peg$c58 = { type: "literal", value: "[", description: "\"[\"" },
        peg$c59 = /^[0-9]/,
        peg$c60 = { type: "class", value: "[0-9]", description: "[0-9]" },
        peg$c61 = "]",
        peg$c62 = { type: "literal", value: "]", description: "\"]\"" },
        peg$c63 = function(portname, portindex) {return { port: portname.join("").toLowerCase(), index: parseInt(portindex.join('')) }},
        peg$c64 = /^[^\n\r\u2028\u2029]/,
        peg$c65 = { type: "class", value: "[^\\n\\r\\u2028\\u2029]", description: "[^\\n\\r\\u2028\\u2029]" },
        peg$c66 = /^[\\]/,
        peg$c67 = { type: "class", value: "[\\\\]", description: "[\\\\]" },
        peg$c68 = /^[']/,
        peg$c69 = { type: "class", value: "[']", description: "[']" },
        peg$c70 = function() { return "'"; },
        peg$c71 = /^[^']/,
        peg$c72 = { type: "class", value: "[^']", description: "[^']" },
        peg$c73 = " ",
        peg$c74 = { type: "literal", value: " ", description: "\" \"" },

        peg$currPos          = 0,
        peg$reportedPos      = 0,
        peg$cachedPos        = 0,
        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },
        peg$maxFailPos       = 0,
        peg$maxFailExpected  = [],
        peg$silentFails      = 0,

        peg$result;

    if ("startRule" in options) {
      if (!(options.startRule in peg$startRuleFunctions)) {
        throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
      }

      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
    }

    function text() {
      return input.substring(peg$reportedPos, peg$currPos);
    }

    function offset() {
      return peg$reportedPos;
    }

    function line() {
      return peg$computePosDetails(peg$reportedPos).line;
    }

    function column() {
      return peg$computePosDetails(peg$reportedPos).column;
    }

    function expected(description) {
      throw peg$buildException(
        null,
        [{ type: "other", description: description }],
        peg$reportedPos
      );
    }

    function error(message) {
      throw peg$buildException(message, null, peg$reportedPos);
    }

    function peg$computePosDetails(pos) {
      function advance(details, startPos, endPos) {
        var p, ch;

        for (p = startPos; p < endPos; p++) {
          ch = input.charAt(p);
          if (ch === "\n") {
            if (!details.seenCR) { details.line++; }
            details.column = 1;
            details.seenCR = false;
          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
            details.line++;
            details.column = 1;
            details.seenCR = true;
          } else {
            details.column++;
            details.seenCR = false;
          }
        }
      }

      if (peg$cachedPos !== pos) {
        if (peg$cachedPos > pos) {
          peg$cachedPos = 0;
          peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };
        }
        advance(peg$cachedPosDetails, peg$cachedPos, pos);
        peg$cachedPos = pos;
      }

      return peg$cachedPosDetails;
    }

    function peg$fail(expected) {
      if (peg$currPos < peg$maxFailPos) { return; }

      if (peg$currPos > peg$maxFailPos) {
        peg$maxFailPos = peg$currPos;
        peg$maxFailExpected = [];
      }

      peg$maxFailExpected.push(expected);
    }

    function peg$buildException(message, expected, pos) {
      function cleanupExpected(expected) {
        var i = 1;

        expected.sort(function(a, b) {
          if (a.description < b.description) {
            return -1;
          } else if (a.description > b.description) {
            return 1;
          } else {
            return 0;
          }
        });

        while (i < expected.length) {
          if (expected[i - 1] === expected[i]) {
            expected.splice(i, 1);
          } else {
            i++;
          }
        }
      }

      function buildMessage(expected, found) {
        function stringEscape(s) {
          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }

          return s
            .replace(/\\/g,   '\\\\')
            .replace(/"/g,    '\\"')
            .replace(/\x08/g, '\\b')
            .replace(/\t/g,   '\\t')
            .replace(/\n/g,   '\\n')
            .replace(/\f/g,   '\\f')
            .replace(/\r/g,   '\\r')
            .replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) { return '\\x0' + hex(ch); })
            .replace(/[\x10-\x1F\x80-\xFF]/g,    function(ch) { return '\\x'  + hex(ch); })
            .replace(/[\u0180-\u0FFF]/g,         function(ch) { return '\\u0' + hex(ch); })
            .replace(/[\u1080-\uFFFF]/g,         function(ch) { return '\\u'  + hex(ch); });
        }

        var expectedDescs = new Array(expected.length),
            expectedDesc, foundDesc, i;

        for (i = 0; i < expected.length; i++) {
          expectedDescs[i] = expected[i].description;
        }

        expectedDesc = expected.length > 1
          ? expectedDescs.slice(0, -1).join(", ")
              + " or "
              + expectedDescs[expected.length - 1]
          : expectedDescs[0];

        foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";

        return "Expected " + expectedDesc + " but " + foundDesc + " found.";
      }

      var posDetails = peg$computePosDetails(pos),
          found      = pos < input.length ? input.charAt(pos) : null;

      if (expected !== null) {
        cleanupExpected(expected);
      }

      return new SyntaxError(
        message !== null ? message : buildMessage(expected, found),
        expected,
        found,
        pos,
        posDetails.line,
        posDetails.column
      );
    }

    function peg$parsestart() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parseline();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parseline();
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c1();
      }
      s0 = s1;

      return s0;
    }

    function peg$parseline() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;

      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        if (input.substr(peg$currPos, 7) === peg$c3) {
          s2 = peg$c3;
          peg$currPos += 7;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c4); }
        }
        if (s2 !== peg$FAILED) {
          s3 = [];
          if (peg$c5.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c6); }
          }
          if (s4 !== peg$FAILED) {
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              if (peg$c5.test(input.charAt(peg$currPos))) {
                s4 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c6); }
              }
            }
          } else {
            s3 = peg$c2;
          }
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 58) {
              s4 = peg$c7;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c8); }
            }
            if (s4 !== peg$FAILED) {
              s5 = [];
              if (peg$c9.test(input.charAt(peg$currPos))) {
                s6 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c10); }
              }
              if (s6 !== peg$FAILED) {
                while (s6 !== peg$FAILED) {
                  s5.push(s6);
                  if (peg$c9.test(input.charAt(peg$currPos))) {
                    s6 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s6 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c10); }
                  }
                }
              } else {
                s5 = peg$c2;
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parse_();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parseLineTerminator();
                  if (s7 === peg$FAILED) {
                    s7 = peg$c11;
                  }
                  if (s7 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c12(s3, s5);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parse_();
        if (s1 !== peg$FAILED) {
          if (input.substr(peg$currPos, 7) === peg$c13) {
            s2 = peg$c13;
            peg$currPos += 7;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c14); }
          }
          if (s2 !== peg$FAILED) {
            s3 = [];
            if (peg$c15.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c16); }
            }
            if (s4 !== peg$FAILED) {
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                if (peg$c15.test(input.charAt(peg$currPos))) {
                  s4 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c16); }
                }
              }
            } else {
              s3 = peg$c2;
            }
            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 46) {
                s4 = peg$c17;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c18); }
              }
              if (s4 !== peg$FAILED) {
                s5 = [];
                if (peg$c9.test(input.charAt(peg$currPos))) {
                  s6 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c10); }
                }
                if (s6 !== peg$FAILED) {
                  while (s6 !== peg$FAILED) {
                    s5.push(s6);
                    if (peg$c9.test(input.charAt(peg$currPos))) {
                      s6 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s6 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c10); }
                    }
                  }
                } else {
                  s5 = peg$c2;
                }
                if (s5 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 58) {
                    s6 = peg$c7;
                    peg$currPos++;
                  } else {
                    s6 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c8); }
                  }
                  if (s6 !== peg$FAILED) {
                    s7 = [];
                    if (peg$c9.test(input.charAt(peg$currPos))) {
                      s8 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s8 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c10); }
                    }
                    if (s8 !== peg$FAILED) {
                      while (s8 !== peg$FAILED) {
                        s7.push(s8);
                        if (peg$c9.test(input.charAt(peg$currPos))) {
                          s8 = input.charAt(peg$currPos);
                          peg$currPos++;
                        } else {
                          s8 = peg$FAILED;
                          if (peg$silentFails === 0) { peg$fail(peg$c10); }
                        }
                      }
                    } else {
                      s7 = peg$c2;
                    }
                    if (s7 !== peg$FAILED) {
                      s8 = peg$parse_();
                      if (s8 !== peg$FAILED) {
                        s9 = peg$parseLineTerminator();
                        if (s9 === peg$FAILED) {
                          s9 = peg$c11;
                        }
                        if (s9 !== peg$FAILED) {
                          peg$reportedPos = s0;
                          s1 = peg$c19(s3, s5, s7);
                          s0 = s1;
                        } else {
                          peg$currPos = s0;
                          s0 = peg$c2;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parse_();
          if (s1 !== peg$FAILED) {
            if (input.substr(peg$currPos, 8) === peg$c20) {
              s2 = peg$c20;
              peg$currPos += 8;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c21); }
            }
            if (s2 !== peg$FAILED) {
              s3 = [];
              if (peg$c15.test(input.charAt(peg$currPos))) {
                s4 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c16); }
              }
              if (s4 !== peg$FAILED) {
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  if (peg$c15.test(input.charAt(peg$currPos))) {
                    s4 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c16); }
                  }
                }
              } else {
                s3 = peg$c2;
              }
              if (s3 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 46) {
                  s4 = peg$c17;
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c18); }
                }
                if (s4 !== peg$FAILED) {
                  s5 = [];
                  if (peg$c9.test(input.charAt(peg$currPos))) {
                    s6 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s6 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c10); }
                  }
                  if (s6 !== peg$FAILED) {
                    while (s6 !== peg$FAILED) {
                      s5.push(s6);
                      if (peg$c9.test(input.charAt(peg$currPos))) {
                        s6 = input.charAt(peg$currPos);
                        peg$currPos++;
                      } else {
                        s6 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c10); }
                      }
                    }
                  } else {
                    s5 = peg$c2;
                  }
                  if (s5 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 58) {
                      s6 = peg$c7;
                      peg$currPos++;
                    } else {
                      s6 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c8); }
                    }
                    if (s6 !== peg$FAILED) {
                      s7 = [];
                      if (peg$c9.test(input.charAt(peg$currPos))) {
                        s8 = input.charAt(peg$currPos);
                        peg$currPos++;
                      } else {
                        s8 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c10); }
                      }
                      if (s8 !== peg$FAILED) {
                        while (s8 !== peg$FAILED) {
                          s7.push(s8);
                          if (peg$c9.test(input.charAt(peg$currPos))) {
                            s8 = input.charAt(peg$currPos);
                            peg$currPos++;
                          } else {
                            s8 = peg$FAILED;
                            if (peg$silentFails === 0) { peg$fail(peg$c10); }
                          }
                        }
                      } else {
                        s7 = peg$c2;
                      }
                      if (s7 !== peg$FAILED) {
                        s8 = peg$parse_();
                        if (s8 !== peg$FAILED) {
                          s9 = peg$parseLineTerminator();
                          if (s9 === peg$FAILED) {
                            s9 = peg$c11;
                          }
                          if (s9 !== peg$FAILED) {
                            peg$reportedPos = s0;
                            s1 = peg$c22(s3, s5, s7);
                            s0 = s1;
                          } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$c2;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsecomment();
            if (s1 !== peg$FAILED) {
              if (peg$c23.test(input.charAt(peg$currPos))) {
                s2 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c24); }
              }
              if (s2 === peg$FAILED) {
                s2 = peg$c11;
              }
              if (s2 !== peg$FAILED) {
                s1 = [s1, s2];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parse_();
              if (s1 !== peg$FAILED) {
                if (peg$c23.test(input.charAt(peg$currPos))) {
                  s2 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c24); }
                }
                if (s2 !== peg$FAILED) {
                  s1 = [s1, s2];
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parse_();
                if (s1 !== peg$FAILED) {
                  s2 = peg$parseconnection();
                  if (s2 !== peg$FAILED) {
                    s3 = peg$parse_();
                    if (s3 !== peg$FAILED) {
                      s4 = peg$parseLineTerminator();
                      if (s4 === peg$FAILED) {
                        s4 = peg$c11;
                      }
                      if (s4 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c25(s2);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              }
            }
          }
        }
      }

      return s0;
    }

    function peg$parseLineTerminator() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 44) {
          s2 = peg$c26;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c27); }
        }
        if (s2 === peg$FAILED) {
          s2 = peg$c11;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parsecomment();
          if (s3 === peg$FAILED) {
            s3 = peg$c11;
          }
          if (s3 !== peg$FAILED) {
            if (peg$c23.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c24); }
            }
            if (s4 === peg$FAILED) {
              s4 = peg$c11;
            }
            if (s4 !== peg$FAILED) {
              s1 = [s1, s2, s3, s4];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      return s0;
    }

    function peg$parsecomment() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 35) {
          s2 = peg$c28;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c29); }
        }
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$parseanychar();
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parseanychar();
          }
          if (s3 !== peg$FAILED) {
            s1 = [s1, s2, s3];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      return s0;
    }

    function peg$parseconnection() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$parsebridge();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c30) {
            s3 = peg$c30;
            peg$currPos += 2;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c31); }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseconnection();
              if (s5 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c32(s1, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$parsebridge();
      }

      return s0;
    }

    function peg$parsebridge() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$parseport();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parsenode();
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseport();
              if (s5 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c33(s1, s3, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$parseiip();
        if (s0 === peg$FAILED) {
          s0 = peg$parserightlet();
          if (s0 === peg$FAILED) {
            s0 = peg$parseleftlet();
          }
        }
      }

      return s0;
    }

    function peg$parseleftlet() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parsenode();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseport();
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c34(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parsenode();
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseportWithIndex();
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c35(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      }

      return s0;
    }

    function peg$parseiip() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 39) {
        s1 = peg$c36;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c37); }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parseiipchar();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parseiipchar();
        }
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 39) {
            s3 = peg$c36;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c37); }
          }
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c38(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      return s0;
    }

    function peg$parserightlet() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parseport();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parsenode();
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c39(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseportWithIndex();
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();
          if (s2 !== peg$FAILED) {
            s3 = peg$parsenode();
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c40(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      }

      return s0;
    }

    function peg$parsenode() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      if (peg$c41.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c42); }
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          if (peg$c41.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c42); }
          }
        }
      } else {
        s1 = peg$c2;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsecomponent();
        if (s2 === peg$FAILED) {
          s2 = peg$c11;
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c43(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      return s0;
    }

    function peg$parsecomponent() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 40) {
        s1 = peg$c44;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c45); }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        if (peg$c46.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c47); }
        }
        if (s3 !== peg$FAILED) {
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            if (peg$c46.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c47); }
            }
          }
        } else {
          s2 = peg$c2;
        }
        if (s2 === peg$FAILED) {
          s2 = peg$c11;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parsecompMeta();
          if (s3 === peg$FAILED) {
            s3 = peg$c11;
          }
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 41) {
              s4 = peg$c48;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c49); }
            }
            if (s4 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c50(s2, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      return s0;
    }

    function peg$parsecompMeta() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 58) {
        s1 = peg$c7;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c8); }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        if (peg$c51.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c52); }
        }
        if (s3 !== peg$FAILED) {
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            if (peg$c51.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c52); }
            }
          }
        } else {
          s2 = peg$c2;
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c53(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      return s0;
    }

    function peg$parseport() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      if (peg$c54.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c55); }
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          if (peg$c54.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c55); }
          }
        }
      } else {
        s1 = peg$c2;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c56(s1);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      return s0;
    }

    function peg$parseportWithIndex() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = [];
      if (peg$c54.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c55); }
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          if (peg$c54.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c55); }
          }
        }
      } else {
        s1 = peg$c2;
      }
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 91) {
          s2 = peg$c57;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c58); }
        }
        if (s2 !== peg$FAILED) {
          s3 = [];
          if (peg$c59.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c60); }
          }
          if (s4 !== peg$FAILED) {
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              if (peg$c59.test(input.charAt(peg$currPos))) {
                s4 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c60); }
              }
            }
          } else {
            s3 = peg$c2;
          }
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 93) {
              s4 = peg$c61;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c62); }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parse__();
              if (s5 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c63(s1, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      return s0;
    }

    function peg$parseanychar() {
      var s0;

      if (peg$c64.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c65); }
      }

      return s0;
    }

    function peg$parseiipchar() {
      var s0, s1, s2;

      s0 = peg$currPos;
      if (peg$c66.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c67); }
      }
      if (s1 !== peg$FAILED) {
        if (peg$c68.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c69); }
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c70();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }
      if (s0 === peg$FAILED) {
        if (peg$c71.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c72); }
        }
      }

      return s0;
    }

    function peg$parse_() {
      var s0, s1;

      s0 = [];
      if (input.charCodeAt(peg$currPos) === 32) {
        s1 = peg$c73;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c74); }
      }
      while (s1 !== peg$FAILED) {
        s0.push(s1);
        if (input.charCodeAt(peg$currPos) === 32) {
          s1 = peg$c73;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c74); }
        }
      }
      if (s0 === peg$FAILED) {
        s0 = peg$c11;
      }

      return s0;
    }

    function peg$parse__() {
      var s0, s1;

      s0 = [];
      if (input.charCodeAt(peg$currPos) === 32) {
        s1 = peg$c73;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c74); }
      }
      if (s1 !== peg$FAILED) {
        while (s1 !== peg$FAILED) {
          s0.push(s1);
          if (input.charCodeAt(peg$currPos) === 32) {
            s1 = peg$c73;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c74); }
          }
        }
      } else {
        s0 = peg$c2;
      }

      return s0;
    }


      var parser, edges, nodes; 

      parser = this;
      delete parser.exports;
      delete parser.inports;
      delete parser.outports;

      edges = parser.edges = [];

      nodes = {};

      parser.addNode = function (nodeName, comp) {
        if (!nodes[nodeName]) {
          nodes[nodeName] = {}
        }
        if (!!comp.comp) {
          nodes[nodeName].component = comp.comp;
        }
        if (!!comp.meta) {
          var metadata = {};
          for (var i = 0; i < comp.meta.length; i++) {
            var item = comp.meta[i].split('=');
            if (item.length === 1) {
              item = ['routes', item[0]];
            }
            var key = item[0];
            var value = item[1];
            if (key==='x' || key==='y') {
              value = parseFloat(value);
            }
            metadata[key] = value;
          }
          nodes[nodeName].metadata=metadata;
        }
       
      }

      parser.getResult = function () {
        return {processes:nodes, connections:parser.processEdges(), exports:parser.exports, inports: parser.inports, outports: parser.outports};
      }  

      var flatten = function (array, isShallow) {
        var index = -1,
          length = array ? array.length : 0,
          result = [];

        while (++index < length) {
          var value = array[index];

          if (value instanceof Array) {
            Array.prototype.push.apply(result, isShallow ? value : flatten(value));
          }
          else {
            result.push(value);
          }
        }
        return result;
      }
      
      parser.registerExports = function (priv, pub) {
        if (!parser.exports) {
          parser.exports = [];
        }
        parser.exports.push({private:priv.toLowerCase(), public:pub.toLowerCase()})
      }
      parser.registerInports = function (node, port, pub) {
        if (!parser.inports) {
          parser.inports = {};
        }
        parser.inports[pub.toLowerCase()] = {process:node, port:port.toLowerCase()}
      }
      parser.registerOutports = function (node, port, pub) {
        if (!parser.outports) {
          parser.outports = {};
        }
        parser.outports[pub.toLowerCase()] = {process:node, port:port.toLowerCase()}
      }

      parser.registerEdges = function (edges) {

        edges.forEach(function (o, i) {
          parser.edges.push(o);
        });
      }  

      parser.processEdges = function () {   
        var flats, grouped;
        flats = flatten(parser.edges);
        grouped = [];
        var current = {};
        flats.forEach(function (o, i) {
          if (i % 2 !== 0) { 
            var pair = grouped[grouped.length - 1];
            pair.tgt = o.tgt;
            return;
          }
          grouped.push(o);
        });
        return grouped;
      }


    peg$result = peg$startRuleFunction();

    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
      return peg$result;
    } else {
      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
        peg$fail({ type: "end", description: "end of input" });
      }

      throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);
    }
  }

  return {
    SyntaxError: SyntaxError,
    parse:       parse
  };
})();
});
require.register("jonnor-js-yaml/dist/js-yaml.js", function(exports, require, module){
/* js-yaml 3.3.1 https://github.com/nodeca/js-yaml */(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.jsyaml = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';


var loader = require('./js-yaml/loader');
var dumper = require('./js-yaml/dumper');


function deprecated(name) {
  return function () {
    throw new Error('Function ' + name + ' is deprecated and cannot be used.');
  };
}


module.exports.Type                = require('./js-yaml/type');
module.exports.Schema              = require('./js-yaml/schema');
module.exports.FAILSAFE_SCHEMA     = require('./js-yaml/schema/failsafe');
module.exports.JSON_SCHEMA         = require('./js-yaml/schema/json');
module.exports.CORE_SCHEMA         = require('./js-yaml/schema/core');
module.exports.DEFAULT_SAFE_SCHEMA = require('./js-yaml/schema/default_safe');
module.exports.DEFAULT_FULL_SCHEMA = require('./js-yaml/schema/default_full');
module.exports.load                = loader.load;
module.exports.loadAll             = loader.loadAll;
module.exports.safeLoad            = loader.safeLoad;
module.exports.safeLoadAll         = loader.safeLoadAll;
module.exports.dump                = dumper.dump;
module.exports.safeDump            = dumper.safeDump;
module.exports.YAMLException       = require('./js-yaml/exception');

// Deprecared schema names from JS-YAML 2.0.x
module.exports.MINIMAL_SCHEMA = require('./js-yaml/schema/failsafe');
module.exports.SAFE_SCHEMA    = require('./js-yaml/schema/default_safe');
module.exports.DEFAULT_SCHEMA = require('./js-yaml/schema/default_full');

// Deprecated functions from JS-YAML 1.x.x
module.exports.scan           = deprecated('scan');
module.exports.parse          = deprecated('parse');
module.exports.compose        = deprecated('compose');
module.exports.addConstructor = deprecated('addConstructor');

},{"./js-yaml/dumper":3,"./js-yaml/exception":4,"./js-yaml/loader":5,"./js-yaml/schema":7,"./js-yaml/schema/core":8,"./js-yaml/schema/default_full":9,"./js-yaml/schema/default_safe":10,"./js-yaml/schema/failsafe":11,"./js-yaml/schema/json":12,"./js-yaml/type":13}],2:[function(require,module,exports){
'use strict';


function isNothing(subject) {
  return (typeof subject === 'undefined') || (null === subject);
}


function isObject(subject) {
  return (typeof subject === 'object') && (null !== subject);
}


function toArray(sequence) {
  if (Array.isArray(sequence)) {
    return sequence;
  } else if (isNothing(sequence)) {
    return [];
  }
  return [ sequence ];
}


function extend(target, source) {
  var index, length, key, sourceKeys;

  if (source) {
    sourceKeys = Object.keys(source);

    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
      key = sourceKeys[index];
      target[key] = source[key];
    }
  }

  return target;
}


function repeat(string, count) {
  var result = '', cycle;

  for (cycle = 0; cycle < count; cycle += 1) {
    result += string;
  }

  return result;
}


function isNegativeZero(number) {
  return (0 === number) && (Number.NEGATIVE_INFINITY === 1 / number);
}


module.exports.isNothing      = isNothing;
module.exports.isObject       = isObject;
module.exports.toArray        = toArray;
module.exports.repeat         = repeat;
module.exports.isNegativeZero = isNegativeZero;
module.exports.extend         = extend;

},{}],3:[function(require,module,exports){
'use strict';

/*eslint-disable no-use-before-define*/

var common              = require('./common');
var YAMLException       = require('./exception');
var DEFAULT_FULL_SCHEMA = require('./schema/default_full');
var DEFAULT_SAFE_SCHEMA = require('./schema/default_safe');

var _toString       = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;

var CHAR_TAB                  = 0x09; /* Tab */
var CHAR_LINE_FEED            = 0x0A; /* LF */
var CHAR_CARRIAGE_RETURN      = 0x0D; /* CR */
var CHAR_SPACE                = 0x20; /* Space */
var CHAR_EXCLAMATION          = 0x21; /* ! */
var CHAR_DOUBLE_QUOTE         = 0x22; /* " */
var CHAR_SHARP                = 0x23; /* # */
var CHAR_PERCENT              = 0x25; /* % */
var CHAR_AMPERSAND            = 0x26; /* & */
var CHAR_SINGLE_QUOTE         = 0x27; /* ' */
var CHAR_ASTERISK             = 0x2A; /* * */
var CHAR_COMMA                = 0x2C; /* , */
var CHAR_MINUS                = 0x2D; /* - */
var CHAR_COLON                = 0x3A; /* : */
var CHAR_GREATER_THAN         = 0x3E; /* > */
var CHAR_QUESTION             = 0x3F; /* ? */
var CHAR_COMMERCIAL_AT        = 0x40; /* @ */
var CHAR_LEFT_SQUARE_BRACKET  = 0x5B; /* [ */
var CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */
var CHAR_GRAVE_ACCENT         = 0x60; /* ` */
var CHAR_LEFT_CURLY_BRACKET   = 0x7B; /* { */
var CHAR_VERTICAL_LINE        = 0x7C; /* | */
var CHAR_RIGHT_CURLY_BRACKET  = 0x7D; /* } */

var ESCAPE_SEQUENCES = {};

ESCAPE_SEQUENCES[0x00]   = '\\0';
ESCAPE_SEQUENCES[0x07]   = '\\a';
ESCAPE_SEQUENCES[0x08]   = '\\b';
ESCAPE_SEQUENCES[0x09]   = '\\t';
ESCAPE_SEQUENCES[0x0A]   = '\\n';
ESCAPE_SEQUENCES[0x0B]   = '\\v';
ESCAPE_SEQUENCES[0x0C]   = '\\f';
ESCAPE_SEQUENCES[0x0D]   = '\\r';
ESCAPE_SEQUENCES[0x1B]   = '\\e';
ESCAPE_SEQUENCES[0x22]   = '\\"';
ESCAPE_SEQUENCES[0x5C]   = '\\\\';
ESCAPE_SEQUENCES[0x85]   = '\\N';
ESCAPE_SEQUENCES[0xA0]   = '\\_';
ESCAPE_SEQUENCES[0x2028] = '\\L';
ESCAPE_SEQUENCES[0x2029] = '\\P';

var DEPRECATED_BOOLEANS_SYNTAX = [
  'y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON',
  'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'
];

function compileStyleMap(schema, map) {
  var result, keys, index, length, tag, style, type;

  if (null === map) {
    return {};
  }

  result = {};
  keys = Object.keys(map);

  for (index = 0, length = keys.length; index < length; index += 1) {
    tag = keys[index];
    style = String(map[tag]);

    if ('!!' === tag.slice(0, 2)) {
      tag = 'tag:yaml.org,2002:' + tag.slice(2);
    }

    type = schema.compiledTypeMap[tag];

    if (type && _hasOwnProperty.call(type.styleAliases, style)) {
      style = type.styleAliases[style];
    }

    result[tag] = style;
  }

  return result;
}

function encodeHex(character) {
  var string, handle, length;

  string = character.toString(16).toUpperCase();

  if (character <= 0xFF) {
    handle = 'x';
    length = 2;
  } else if (character <= 0xFFFF) {
    handle = 'u';
    length = 4;
  } else if (character <= 0xFFFFFFFF) {
    handle = 'U';
    length = 8;
  } else {
    throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');
  }

  return '\\' + handle + common.repeat('0', length - string.length) + string;
}

function State(options) {
  this.schema      = options['schema'] || DEFAULT_FULL_SCHEMA;
  this.indent      = Math.max(1, (options['indent'] || 2));
  this.skipInvalid = options['skipInvalid'] || false;
  this.flowLevel   = (common.isNothing(options['flowLevel']) ? -1 : options['flowLevel']);
  this.styleMap    = compileStyleMap(this.schema, options['styles'] || null);
  this.sortKeys    = options['sortKeys'] || false;

  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;

  this.tag = null;
  this.result = '';

  this.duplicates = [];
  this.usedDuplicates = null;
}

function indentString(string, spaces) {
  var ind = common.repeat(' ', spaces),
      position = 0,
      next = -1,
      result = '',
      line,
      length = string.length;

  while (position < length) {
    next = string.indexOf('\n', position);
    if (next === -1) {
      line = string.slice(position);
      position = length;
    } else {
      line = string.slice(position, next + 1);
      position = next + 1;
    }
    if (line.length && line !== '\n') {
      result += ind;
    }
    result += line;
  }

  return result;
}

function generateNextLine(state, level) {
  return '\n' + common.repeat(' ', state.indent * level);
}

function testImplicitResolving(state, str) {
  var index, length, type;

  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
    type = state.implicitTypes[index];

    if (type.resolve(str)) {
      return true;
    }
  }

  return false;
}

function StringBuilder(source) {
  this.source = source;
  this.result = '';
  this.checkpoint = 0;
}

StringBuilder.prototype.takeUpTo = function (position) {
  var er;

  if (position < this.checkpoint) {
    er = new Error('position should be > checkpoint');
    er.position = position;
    er.checkpoint = this.checkpoint;
    throw er;
  }

  this.result += this.source.slice(this.checkpoint, position);
  this.checkpoint = position;
  return this;
};

StringBuilder.prototype.escapeChar = function () {
  var character, esc;

  character = this.source.charCodeAt(this.checkpoint);
  esc = ESCAPE_SEQUENCES[character] || encodeHex(character);
  this.result += esc;
  this.checkpoint += 1;

  return this;
};

StringBuilder.prototype.finish = function () {
  if (this.source.length > this.checkpoint) {
    this.takeUpTo(this.source.length);
  }
};

function writeScalar(state, object, level) {
  var simple, first, spaceWrap, folded, literal, single, double,
      sawLineFeed, linePosition, longestLine, indent, max, character,
      position, escapeSeq, hexEsc, previous, lineLength, modifier,
      trailingLineBreaks, result;

  if (0 === object.length) {
    state.dump = "''";
    return;
  }

  if (-1 !== DEPRECATED_BOOLEANS_SYNTAX.indexOf(object)) {
    state.dump = "'" + object + "'";
    return;
  }

  simple = true;
  first = object.length ? object.charCodeAt(0) : 0;
  spaceWrap = (CHAR_SPACE === first ||
               CHAR_SPACE === object.charCodeAt(object.length - 1));

  // Simplified check for restricted first characters
  // http://www.yaml.org/spec/1.2/spec.html#ns-plain-first%28c%29
  if (CHAR_MINUS         === first ||
      CHAR_QUESTION      === first ||
      CHAR_COMMERCIAL_AT === first ||
      CHAR_GRAVE_ACCENT  === first) {
    simple = false;
  }

  // can only use > and | if not wrapped in spaces.
  if (spaceWrap) {
    simple = false;
    folded = false;
    literal = false;
  } else {
    folded = true;
    literal = true;
  }

  single = true;
  double = new StringBuilder(object);

  sawLineFeed = false;
  linePosition = 0;
  longestLine = 0;

  indent = state.indent * level;
  max = 80;
  if (indent < 40) {
    max -= indent;
  } else {
    max = 40;
  }

  for (position = 0; position < object.length; position++) {
    character = object.charCodeAt(position);
    if (simple) {
      // Characters that can never appear in the simple scalar
      if (!simpleChar(character)) {
        simple = false;
      } else {
        // Still simple.  If we make it all the way through like
        // this, then we can just dump the string as-is.
        continue;
      }
    }

    if (single && character === CHAR_SINGLE_QUOTE) {
      single = false;
    }

    escapeSeq = ESCAPE_SEQUENCES[character];
    hexEsc = needsHexEscape(character);

    if (!escapeSeq && !hexEsc) {
      continue;
    }

    if (character !== CHAR_LINE_FEED &&
        character !== CHAR_DOUBLE_QUOTE &&
        character !== CHAR_SINGLE_QUOTE) {
      folded = false;
      literal = false;
    } else if (character === CHAR_LINE_FEED) {
      sawLineFeed = true;
      single = false;
      if (position > 0) {
        previous = object.charCodeAt(position - 1);
        if (previous === CHAR_SPACE) {
          literal = false;
          folded = false;
        }
      }
      if (folded) {
        lineLength = position - linePosition;
        linePosition = position;
        if (lineLength > longestLine) {
          longestLine = lineLength;
        }
      }
    }

    if (character !== CHAR_DOUBLE_QUOTE) {
      single = false;
    }

    double.takeUpTo(position);
    double.escapeChar();
  }

  if (simple && testImplicitResolving(state, object)) {
    simple = false;
  }

  modifier = '';
  if (folded || literal) {
    trailingLineBreaks = 0;
    if (object.charCodeAt(object.length - 1) === CHAR_LINE_FEED) {
      trailingLineBreaks += 1;
      if (object.charCodeAt(object.length - 2) === CHAR_LINE_FEED) {
        trailingLineBreaks += 1;
      }
    }

    if (trailingLineBreaks === 0) {
      modifier = '-';
    } else if (trailingLineBreaks === 2) {
      modifier = '+';
    }
  }

  if (literal && longestLine < max) {
    folded = false;
  }

  // If it's literally one line, then don't bother with the literal.
  // We may still want to do a fold, though, if it's a super long line.
  if (!sawLineFeed) {
    literal = false;
  }

  if (simple) {
    state.dump = object;
  } else if (single) {
    state.dump = '\'' + object + '\'';
  } else if (folded) {
    result = fold(object, max);
    state.dump = '>' + modifier + '\n' + indentString(result, indent);
  } else if (literal) {
    if (!modifier) {
      object = object.replace(/\n$/, '');
    }
    state.dump = '|' + modifier + '\n' + indentString(object, indent);
  } else if (double) {
    double.finish();
    state.dump = '"' + double.result + '"';
  } else {
    throw new Error('Failed to dump scalar value');
  }

  return;
}

// The `trailing` var is a regexp match of any trailing `\n` characters.
//
// There are three cases we care about:
//
// 1. One trailing `\n` on the string.  Just use `|` or `>`.
//    This is the assumed default. (trailing = null)
// 2. No trailing `\n` on the string.  Use `|-` or `>-` to "chomp" the end.
// 3. More than one trailing `\n` on the string.  Use `|+` or `>+`.
//
// In the case of `>+`, these line breaks are *not* doubled (like the line
// breaks within the string), so it's important to only end with the exact
// same number as we started.
function fold(object, max) {
  var result = '',
      position = 0,
      length = object.length,
      trailing = /\n+$/.exec(object),
      newLine;

  if (trailing) {
    length = trailing.index + 1;
  }

  while (position < length) {
    newLine = object.indexOf('\n', position);
    if (newLine > length || newLine === -1) {
      if (result) {
        result += '\n\n';
      }
      result += foldLine(object.slice(position, length), max);
      position = length;
    } else {
      if (result) {
        result += '\n\n';
      }
      result += foldLine(object.slice(position, newLine), max);
      position = newLine + 1;
    }
  }
  if (trailing && trailing[0] !== '\n') {
    result += trailing[0];
  }

  return result;
}

function foldLine(line, max) {
  if (line === '') {
    return line;
  }

  var foldRe = /[^\s] [^\s]/g,
      result = '',
      prevMatch = 0,
      foldStart = 0,
      match = foldRe.exec(line),
      index,
      foldEnd,
      folded;

  while (match) {
    index = match.index;

    // when we cross the max len, if the previous match would've
    // been ok, use that one, and carry on.  If there was no previous
    // match on this fold section, then just have a long line.
    if (index - foldStart > max) {
      if (prevMatch !== foldStart) {
        foldEnd = prevMatch;
      } else {
        foldEnd = index;
      }

      if (result) {
        result += '\n';
      }
      folded = line.slice(foldStart, foldEnd);
      result += folded;
      foldStart = foldEnd + 1;
    }
    prevMatch = index + 1;
    match = foldRe.exec(line);
  }

  if (result) {
    result += '\n';
  }

  // if we end up with one last word at the end, then the last bit might
  // be slightly bigger than we wanted, because we exited out of the loop.
  if (foldStart !== prevMatch && line.length - foldStart > max) {
    result += line.slice(foldStart, prevMatch) + '\n' +
              line.slice(prevMatch + 1);
  } else {
    result += line.slice(foldStart);
  }

  return result;
}

// Returns true if character can be found in a simple scalar
function simpleChar(character) {
  return CHAR_TAB                  !== character &&
         CHAR_LINE_FEED            !== character &&
         CHAR_CARRIAGE_RETURN      !== character &&
         CHAR_COMMA                !== character &&
         CHAR_LEFT_SQUARE_BRACKET  !== character &&
         CHAR_RIGHT_SQUARE_BRACKET !== character &&
         CHAR_LEFT_CURLY_BRACKET   !== character &&
         CHAR_RIGHT_CURLY_BRACKET  !== character &&
         CHAR_SHARP                !== character &&
         CHAR_AMPERSAND            !== character &&
         CHAR_ASTERISK             !== character &&
         CHAR_EXCLAMATION          !== character &&
         CHAR_VERTICAL_LINE        !== character &&
         CHAR_GREATER_THAN         !== character &&
         CHAR_SINGLE_QUOTE         !== character &&
         CHAR_DOUBLE_QUOTE         !== character &&
         CHAR_PERCENT              !== character &&
         CHAR_COLON                !== character &&
         !ESCAPE_SEQUENCES[character]            &&
         !needsHexEscape(character);
}

// Returns true if the character code needs to be escaped.
function needsHexEscape(character) {
  return !((0x00020 <= character && character <= 0x00007E) ||
           (0x00085 === character)                         ||
           (0x000A0 <= character && character <= 0x00D7FF) ||
           (0x0E000 <= character && character <= 0x00FFFD) ||
           (0x10000 <= character && character <= 0x10FFFF));
}

function writeFlowSequence(state, level, object) {
  var _result = '',
      _tag    = state.tag,
      index,
      length;

  for (index = 0, length = object.length; index < length; index += 1) {
    // Write only valid elements.
    if (writeNode(state, level, object[index], false, false)) {
      if (0 !== index) {
        _result += ', ';
      }
      _result += state.dump;
    }
  }

  state.tag = _tag;
  state.dump = '[' + _result + ']';
}

function writeBlockSequence(state, level, object, compact) {
  var _result = '',
      _tag    = state.tag,
      index,
      length;

  for (index = 0, length = object.length; index < length; index += 1) {
    // Write only valid elements.
    if (writeNode(state, level + 1, object[index], true, true)) {
      if (!compact || 0 !== index) {
        _result += generateNextLine(state, level);
      }
      _result += '- ' + state.dump;
    }
  }

  state.tag = _tag;
  state.dump = _result || '[]'; // Empty sequence if no valid values.
}

function writeFlowMapping(state, level, object) {
  var _result       = '',
      _tag          = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      pairBuffer;

  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = '';

    if (0 !== index) {
      pairBuffer += ', ';
    }

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (!writeNode(state, level, objectKey, false, false)) {
      continue; // Skip this pair because of invalid key;
    }

    if (state.dump.length > 1024) {
      pairBuffer += '? ';
    }

    pairBuffer += state.dump + ': ';

    if (!writeNode(state, level, objectValue, false, false)) {
      continue; // Skip this pair because of invalid value.
    }

    pairBuffer += state.dump;

    // Both key and value are valid.
    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = '{' + _result + '}';
}

function writeBlockMapping(state, level, object, compact) {
  var _result       = '',
      _tag          = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      explicitPair,
      pairBuffer;

  // Allow sorting keys so that the output file is deterministic
  if (state.sortKeys === true) {
    // Default sorting
    objectKeyList.sort();
  } else if (typeof state.sortKeys === 'function') {
    // Custom sort function
    objectKeyList.sort(state.sortKeys);
  } else if (state.sortKeys) {
    // Something is wrong
    throw new YAMLException('sortKeys must be a boolean or a function');
  }

  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = '';

    if (!compact || 0 !== index) {
      pairBuffer += generateNextLine(state, level);
    }

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (!writeNode(state, level + 1, objectKey, true, true)) {
      continue; // Skip this pair because of invalid key.
    }

    explicitPair = (null !== state.tag && '?' !== state.tag) ||
                   (state.dump && state.dump.length > 1024);

    if (explicitPair) {
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += '?';
      } else {
        pairBuffer += '? ';
      }
    }

    pairBuffer += state.dump;

    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }

    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue; // Skip this pair because of invalid value.
    }

    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += ':';
    } else {
      pairBuffer += ': ';
    }

    pairBuffer += state.dump;

    // Both key and value are valid.
    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = _result || '{}'; // Empty mapping if no valid pairs.
}

function detectType(state, object, explicit) {
  var _result, typeList, index, length, type, style;

  typeList = explicit ? state.explicitTypes : state.implicitTypes;

  for (index = 0, length = typeList.length; index < length; index += 1) {
    type = typeList[index];

    if ((type.instanceOf  || type.predicate) &&
        (!type.instanceOf || (('object' === typeof object) && (object instanceof type.instanceOf))) &&
        (!type.predicate  || type.predicate(object))) {

      state.tag = explicit ? type.tag : '?';

      if (type.represent) {
        style = state.styleMap[type.tag] || type.defaultStyle;

        if ('[object Function]' === _toString.call(type.represent)) {
          _result = type.represent(object, style);
        } else if (_hasOwnProperty.call(type.represent, style)) {
          _result = type.represent[style](object, style);
        } else {
          throw new YAMLException('!<' + type.tag + '> tag resolver accepts not "' + style + '" style');
        }

        state.dump = _result;
      }

      return true;
    }
  }

  return false;
}

// Serializes `object` and writes it to global `result`.
// Returns true on success, or false on invalid object.
//
function writeNode(state, level, object, block, compact) {
  state.tag = null;
  state.dump = object;

  if (!detectType(state, object, false)) {
    detectType(state, object, true);
  }

  var type = _toString.call(state.dump);

  if (block) {
    block = (0 > state.flowLevel || state.flowLevel > level);
  }

  if ((null !== state.tag && '?' !== state.tag) || (2 !== state.indent && level > 0)) {
    compact = false;
  }

  var objectOrArray = '[object Object]' === type || '[object Array]' === type,
      duplicateIndex,
      duplicate;

  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object);
    duplicate = duplicateIndex !== -1;
  }

  if (duplicate && state.usedDuplicates[duplicateIndex]) {
    state.dump = '*ref_' + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }
    if ('[object Object]' === type) {
      if (block && (0 !== Object.keys(state.dump).length)) {
        writeBlockMapping(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + (0 === level ? '\n' : '') + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
        }
      }
    } else if ('[object Array]' === type) {
      if (block && (0 !== state.dump.length)) {
        writeBlockSequence(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + (0 === level ? '\n' : '') + state.dump;
        }
      } else {
        writeFlowSequence(state, level, state.dump);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
        }
      }
    } else if ('[object String]' === type) {
      if ('?' !== state.tag) {
        writeScalar(state, state.dump, level);
      }
    } else {
      if (state.skipInvalid) {
        return false;
      }
      throw new YAMLException('unacceptable kind of an object to dump ' + type);
    }

    if (null !== state.tag && '?' !== state.tag) {
      state.dump = '!<' + state.tag + '> ' + state.dump;
    }
  }

  return true;
}

function getDuplicateReferences(object, state) {
  var objects = [],
      duplicatesIndexes = [],
      index,
      length;

  inspectNode(object, objects, duplicatesIndexes);

  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index]]);
  }
  state.usedDuplicates = new Array(length);
}

function inspectNode(object, objects, duplicatesIndexes) {
  var type = _toString.call(object),
      objectKeyList,
      index,
      length;

  if (null !== object && 'object' === typeof object) {
    index = objects.indexOf(object);
    if (-1 !== index) {
      if (-1 === duplicatesIndexes.indexOf(index)) {
        duplicatesIndexes.push(index);
      }
    } else {
      objects.push(object);

      if (Array.isArray(object)) {
        for (index = 0, length = object.length; index < length; index += 1) {
          inspectNode(object[index], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object);

        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
        }
      }
    }
  }
}

function dump(input, options) {
  options = options || {};

  var state = new State(options);

  getDuplicateReferences(input, state);

  if (writeNode(state, 0, input, true, true)) {
    return state.dump + '\n';
  }
  return '';
}

function safeDump(input, options) {
  return dump(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
}

module.exports.dump     = dump;
module.exports.safeDump = safeDump;

},{"./common":2,"./exception":4,"./schema/default_full":9,"./schema/default_safe":10}],4:[function(require,module,exports){
'use strict';


function YAMLException(reason, mark) {
  this.name    = 'YAMLException';
  this.reason  = reason;
  this.mark    = mark;
  this.message = this.toString(false);
}


YAMLException.prototype.toString = function toString(compact) {
  var result;

  result = 'JS-YAML: ' + (this.reason || '(unknown reason)');

  if (!compact && this.mark) {
    result += ' ' + this.mark.toString();
  }

  return result;
};


module.exports = YAMLException;

},{}],5:[function(require,module,exports){
'use strict';

/*eslint-disable max-len,no-use-before-define*/

var common              = require('./common');
var YAMLException       = require('./exception');
var Mark                = require('./mark');
var DEFAULT_SAFE_SCHEMA = require('./schema/default_safe');
var DEFAULT_FULL_SCHEMA = require('./schema/default_full');


var _hasOwnProperty = Object.prototype.hasOwnProperty;


var CONTEXT_FLOW_IN   = 1;
var CONTEXT_FLOW_OUT  = 2;
var CONTEXT_BLOCK_IN  = 3;
var CONTEXT_BLOCK_OUT = 4;


var CHOMPING_CLIP  = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP  = 3;


var PATTERN_NON_PRINTABLE         = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS       = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE            = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI               = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;


function is_EOL(c) {
  return (c === 0x0A/* LF */) || (c === 0x0D/* CR */);
}

function is_WHITE_SPACE(c) {
  return (c === 0x09/* Tab */) || (c === 0x20/* Space */);
}

function is_WS_OR_EOL(c) {
  return (c === 0x09/* Tab */) ||
         (c === 0x20/* Space */) ||
         (c === 0x0A/* LF */) ||
         (c === 0x0D/* CR */);
}

function is_FLOW_INDICATOR(c) {
  return 0x2C/* , */ === c ||
         0x5B/* [ */ === c ||
         0x5D/* ] */ === c ||
         0x7B/* { */ === c ||
         0x7D/* } */ === c;
}

function fromHexCode(c) {
  var lc;

  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
    return c - 0x30;
  }

  /*eslint-disable no-bitwise*/
  lc = c | 0x20;

  if ((0x61/* a */ <= lc) && (lc <= 0x66/* f */)) {
    return lc - 0x61 + 10;
  }

  return -1;
}

function escapedHexLen(c) {
  if (c === 0x78/* x */) { return 2; }
  if (c === 0x75/* u */) { return 4; }
  if (c === 0x55/* U */) { return 8; }
  return 0;
}

function fromDecimalCode(c) {
  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
    return c - 0x30;
  }

  return -1;
}

function simpleEscapeSequence(c) {
  return (c === 0x30/* 0 */) ? '\x00' :
        (c === 0x61/* a */) ? '\x07' :
        (c === 0x62/* b */) ? '\x08' :
        (c === 0x74/* t */) ? '\x09' :
        (c === 0x09/* Tab */) ? '\x09' :
        (c === 0x6E/* n */) ? '\x0A' :
        (c === 0x76/* v */) ? '\x0B' :
        (c === 0x66/* f */) ? '\x0C' :
        (c === 0x72/* r */) ? '\x0D' :
        (c === 0x65/* e */) ? '\x1B' :
        (c === 0x20/* Space */) ? ' ' :
        (c === 0x22/* " */) ? '\x22' :
        (c === 0x2F/* / */) ? '/' :
        (c === 0x5C/* \ */) ? '\x5C' :
        (c === 0x4E/* N */) ? '\x85' :
        (c === 0x5F/* _ */) ? '\xA0' :
        (c === 0x4C/* L */) ? '\u2028' :
        (c === 0x50/* P */) ? '\u2029' : '';
}

function charFromCodepoint(c) {
  if (c <= 0xFFFF) {
    return String.fromCharCode(c);
  }
  // Encode UTF-16 surrogate pair
  // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF
  return String.fromCharCode(((c - 0x010000) >> 10) + 0xD800,
                             ((c - 0x010000) & 0x03FF) + 0xDC00);
}

var simpleEscapeCheck = new Array(256); // integer, for fast access
var simpleEscapeMap = new Array(256);
for (var i = 0; i < 256; i++) {
  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
  simpleEscapeMap[i] = simpleEscapeSequence(i);
}


function State(input, options) {
  this.input = input;

  this.filename  = options['filename']  || null;
  this.schema    = options['schema']    || DEFAULT_FULL_SCHEMA;
  this.onWarning = options['onWarning'] || null;
  this.legacy    = options['legacy']    || false;

  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap       = this.schema.compiledTypeMap;

  this.length     = input.length;
  this.position   = 0;
  this.line       = 0;
  this.lineStart  = 0;
  this.lineIndent = 0;

  this.documents = [];

  /*
  this.version;
  this.checkLineBreaks;
  this.tagMap;
  this.anchorMap;
  this.tag;
  this.anchor;
  this.kind;
  this.result;*/

}


function generateError(state, message) {
  return new YAMLException(
    message,
    new Mark(state.filename, state.input, state.position, state.line, (state.position - state.lineStart)));
}

function throwError(state, message) {
  throw generateError(state, message);
}

function throwWarning(state, message) {
  var error = generateError(state, message);

  if (state.onWarning) {
    state.onWarning.call(null, error);
  } else {
    throw error;
  }
}


var directiveHandlers = {

  YAML: function handleYamlDirective(state, name, args) {

      var match, major, minor;

      if (null !== state.version) {
        throwError(state, 'duplication of %YAML directive');
      }

      if (1 !== args.length) {
        throwError(state, 'YAML directive accepts exactly one argument');
      }

      match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);

      if (null === match) {
        throwError(state, 'ill-formed argument of the YAML directive');
      }

      major = parseInt(match[1], 10);
      minor = parseInt(match[2], 10);

      if (1 !== major) {
        throwError(state, 'unacceptable YAML version of the document');
      }

      state.version = args[0];
      state.checkLineBreaks = (minor < 2);

      if (1 !== minor && 2 !== minor) {
        throwWarning(state, 'unsupported YAML version of the document');
      }
    },

  TAG: function handleTagDirective(state, name, args) {

      var handle, prefix;

      if (2 !== args.length) {
        throwError(state, 'TAG directive accepts exactly two arguments');
      }

      handle = args[0];
      prefix = args[1];

      if (!PATTERN_TAG_HANDLE.test(handle)) {
        throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');
      }

      if (_hasOwnProperty.call(state.tagMap, handle)) {
        throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
      }

      if (!PATTERN_TAG_URI.test(prefix)) {
        throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');
      }

      state.tagMap[handle] = prefix;
    }
};


function captureSegment(state, start, end, checkJson) {
  var _position, _length, _character, _result;

  if (start < end) {
    _result = state.input.slice(start, end);

    if (checkJson) {
      for (_position = 0, _length = _result.length;
           _position < _length;
           _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(0x09 === _character ||
              0x20 <= _character && _character <= 0x10FFFF)) {
          throwError(state, 'expected valid JSON character');
        }
      }
    }

    state.result += _result;
  }
}

function mergeMappings(state, destination, source) {
  var sourceKeys, key, index, quantity;

  if (!common.isObject(source)) {
    throwError(state, 'cannot merge mappings; the provided source object is unacceptable');
  }

  sourceKeys = Object.keys(source);

  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
    key = sourceKeys[index];

    if (!_hasOwnProperty.call(destination, key)) {
      destination[key] = source[key];
    }
  }
}

function storeMappingPair(state, _result, keyTag, keyNode, valueNode) {
  var index, quantity;

  keyNode = String(keyNode);

  if (null === _result) {
    _result = {};
  }

  if ('tag:yaml.org,2002:merge' === keyTag) {
    if (Array.isArray(valueNode)) {
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
        mergeMappings(state, _result, valueNode[index]);
      }
    } else {
      mergeMappings(state, _result, valueNode);
    }
  } else {
    _result[keyNode] = valueNode;
  }

  return _result;
}

function readLineBreak(state) {
  var ch;

  ch = state.input.charCodeAt(state.position);

  if (0x0A/* LF */ === ch) {
    state.position++;
  } else if (0x0D/* CR */ === ch) {
    state.position++;
    if (0x0A/* LF */ === state.input.charCodeAt(state.position)) {
      state.position++;
    }
  } else {
    throwError(state, 'a line break is expected');
  }

  state.line += 1;
  state.lineStart = state.position;
}

function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0,
      ch = state.input.charCodeAt(state.position);

  while (0 !== ch) {
    while (is_WHITE_SPACE(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    if (allowComments && 0x23/* # */ === ch) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 0x0A/* LF */ && ch !== 0x0D/* CR */ && 0 !== ch);
    }

    if (is_EOL(ch)) {
      readLineBreak(state);

      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;

      while (0x20/* Space */ === ch) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }

  if (-1 !== checkIndent && 0 !== lineBreaks && state.lineIndent < checkIndent) {
    throwWarning(state, 'deficient indentation');
  }

  return lineBreaks;
}

function testDocumentSeparator(state) {
  var _position = state.position,
      ch;

  ch = state.input.charCodeAt(_position);

  // Condition state.position === state.lineStart is tested
  // in parent on each call, for efficiency. No needs to test here again.
  if ((0x2D/* - */ === ch || 0x2E/* . */ === ch) &&
      state.input.charCodeAt(_position + 1) === ch &&
      state.input.charCodeAt(_position + 2) === ch) {

    _position += 3;

    ch = state.input.charCodeAt(_position);

    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }

  return false;
}

function writeFoldedLines(state, count) {
  if (1 === count) {
    state.result += ' ';
  } else if (count > 1) {
    state.result += common.repeat('\n', count - 1);
  }
}


function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding,
      following,
      captureStart,
      captureEnd,
      hasPendingContent,
      _line,
      _lineStart,
      _lineIndent,
      _kind = state.kind,
      _result = state.result,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (is_WS_OR_EOL(ch)             ||
      is_FLOW_INDICATOR(ch)        ||
      0x23/* # */           === ch ||
      0x26/* & */           === ch ||
      0x2A/* * */           === ch ||
      0x21/* ! */           === ch ||
      0x7C/* | */           === ch ||
      0x3E/* > */           === ch ||
      0x27/* ' */           === ch ||
      0x22/* " */           === ch ||
      0x25/* % */           === ch ||
      0x40/* @ */           === ch ||
      0x60/* ` */           === ch) {
    return false;
  }

  if (0x3F/* ? */ === ch || 0x2D/* - */ === ch) {
    following = state.input.charCodeAt(state.position + 1);

    if (is_WS_OR_EOL(following) ||
        withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }

  state.kind = 'scalar';
  state.result = '';
  captureStart = captureEnd = state.position;
  hasPendingContent = false;

  while (0 !== ch) {
    if (0x3A/* : */ === ch) {
      following = state.input.charCodeAt(state.position + 1);

      if (is_WS_OR_EOL(following) ||
          withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }

    } else if (0x23/* # */ === ch) {
      preceding = state.input.charCodeAt(state.position - 1);

      if (is_WS_OR_EOL(preceding)) {
        break;
      }

    } else if ((state.position === state.lineStart && testDocumentSeparator(state)) ||
               withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;

    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);

      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }

    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }

    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }

    ch = state.input.charCodeAt(++state.position);
  }

  captureSegment(state, captureStart, captureEnd, false);

  if (state.result) {
    return true;
  }

  state.kind = _kind;
  state.result = _result;
  return false;
}

function readSingleQuotedScalar(state, nodeIndent) {
  var ch,
      captureStart, captureEnd;

  ch = state.input.charCodeAt(state.position);

  if (0x27/* ' */ !== ch) {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;

  while (0 !== (ch = state.input.charCodeAt(state.position))) {
    if (0x27/* ' */ === ch) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);

      if (0x27/* ' */ === ch) {
        captureStart = captureEnd = state.position;
        state.position++;
      } else {
        return true;
      }

    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;

    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, 'unexpected end of the document within a single quoted scalar');

    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  throwError(state, 'unexpected end of the stream within a single quoted scalar');
}

function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart,
      captureEnd,
      hexLength,
      hexResult,
      tmp, tmpEsc,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (0x22/* " */ !== ch) {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;

  while (0 !== (ch = state.input.charCodeAt(state.position))) {
    if (0x22/* " */ === ch) {
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;

    } else if (0x5C/* \ */ === ch) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);

      if (is_EOL(ch)) {
        skipSeparationSpace(state, false, nodeIndent);

        // TODO: rework to inline fn with no type cast?
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state.result += simpleEscapeMap[ch];
        state.position++;

      } else if ((tmp = escapedHexLen(ch)) > 0) {
        hexLength = tmp;
        hexResult = 0;

        for (; hexLength > 0; hexLength--) {
          ch = state.input.charCodeAt(++state.position);

          if ((tmp = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp;

          } else {
            throwError(state, 'expected hexadecimal character');
          }
        }

        state.result += charFromCodepoint(hexResult);

        state.position++;

      } else {
        throwError(state, 'unknown escape sequence');
      }

      captureStart = captureEnd = state.position;

    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;

    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, 'unexpected end of the document within a double quoted scalar');

    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  throwError(state, 'unexpected end of the stream within a double quoted scalar');
}

function readFlowCollection(state, nodeIndent) {
  var readNext = true,
      _line,
      _tag     = state.tag,
      _result,
      _anchor  = state.anchor,
      following,
      terminator,
      isPair,
      isExplicitPair,
      isMapping,
      keyNode,
      keyTag,
      valueNode,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x5B/* [ */) {
    terminator = 0x5D;/* ] */
    isMapping = false;
    _result = [];
  } else if (ch === 0x7B/* { */) {
    terminator = 0x7D;/* } */
    isMapping = true;
    _result = {};
  } else {
    return false;
  }

  if (null !== state.anchor) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(++state.position);

  while (0 !== ch) {
    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? 'mapping' : 'sequence';
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, 'missed comma between flow collection entries');
    }

    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;

    if (0x3F/* ? */ === ch) {
      following = state.input.charCodeAt(state.position + 1);

      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      }
    }

    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if ((isExplicitPair || state.line === _line) && 0x3A/* : */ === ch) {
      isPair = true;
      ch = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }

    if (isMapping) {
      storeMappingPair(state, _result, keyTag, keyNode, valueNode);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, keyTag, keyNode, valueNode));
    } else {
      _result.push(keyNode);
    }

    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if (0x2C/* , */ === ch) {
      readNext = true;
      ch = state.input.charCodeAt(++state.position);
    } else {
      readNext = false;
    }
  }

  throwError(state, 'unexpected end of the stream within a flow collection');
}

function readBlockScalar(state, nodeIndent) {
  var captureStart,
      folding,
      chomping       = CHOMPING_CLIP,
      detectedIndent = false,
      textIndent     = nodeIndent,
      emptyLines     = 0,
      atMoreIndented = false,
      tmp,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x7C/* | */) {
    folding = false;
  } else if (ch === 0x3E/* > */) {
    folding = true;
  } else {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';

  while (0 !== ch) {
    ch = state.input.charCodeAt(++state.position);

    if (0x2B/* + */ === ch || 0x2D/* - */ === ch) {
      if (CHOMPING_CLIP === chomping) {
        chomping = (0x2B/* + */ === ch) ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state, 'repeat of a chomping mode identifier');
      }

    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, 'repeat of an indentation width identifier');
      }

    } else {
      break;
    }
  }

  if (is_WHITE_SPACE(ch)) {
    do { ch = state.input.charCodeAt(++state.position); }
    while (is_WHITE_SPACE(ch));

    if (0x23/* # */ === ch) {
      do { ch = state.input.charCodeAt(++state.position); }
      while (!is_EOL(ch) && (0 !== ch));
    }
  }

  while (0 !== ch) {
    readLineBreak(state);
    state.lineIndent = 0;

    ch = state.input.charCodeAt(state.position);

    while ((!detectedIndent || state.lineIndent < textIndent) &&
           (0x20/* Space */ === ch)) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }

    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }

    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }

    // End of the scalar.
    if (state.lineIndent < textIndent) {

      // Perform the chomping.
      if (chomping === CHOMPING_KEEP) {
        state.result += common.repeat('\n', emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (detectedIndent) { // i.e. only if the scalar is not empty.
          state.result += '\n';
        }
      }

      // Break this `while` cycle and go to the funciton's epilogue.
      break;
    }

    // Folded style: use fancy rules to handle line breaks.
    if (folding) {

      // Lines starting with white space characters (more-indented lines) are not folded.
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        state.result += common.repeat('\n', emptyLines + 1);

      // End of more-indented block.
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common.repeat('\n', emptyLines + 1);

      // Just one line break - perceive as the same line.
      } else if (0 === emptyLines) {
        if (detectedIndent) { // i.e. only if we have already read some scalar content.
          state.result += ' ';
        }

      // Several line breaks - perceive as different lines.
      } else {
        state.result += common.repeat('\n', emptyLines);
      }

    // Literal style: just add exact number of line breaks between content lines.
    } else if (detectedIndent) {
      // If current line isn't the first one - count line break from the last content line.
      state.result += common.repeat('\n', emptyLines + 1);
    } else {
      // In case of the first content line - count only empty lines.
    }

    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;

    while (!is_EOL(ch) && (0 !== ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    captureSegment(state, captureStart, state.position, false);
  }

  return true;
}

function readBlockSequence(state, nodeIndent) {
  var _line,
      _tag      = state.tag,
      _anchor   = state.anchor,
      _result   = [],
      following,
      detected  = false,
      ch;

  if (null !== state.anchor) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (0 !== ch) {

    if (0x2D/* - */ !== ch) {
      break;
    }

    following = state.input.charCodeAt(state.position + 1);

    if (!is_WS_OR_EOL(following)) {
      break;
    }

    detected = true;
    state.position++;

    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }

    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);

    ch = state.input.charCodeAt(state.position);

    if ((state.line === _line || state.lineIndent > nodeIndent) && (0 !== ch)) {
      throwError(state, 'bad indentation of a sequence entry');
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }

  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'sequence';
    state.result = _result;
    return true;
  }
  return false;
}

function readBlockMapping(state, nodeIndent, flowIndent) {
  var following,
      allowCompact,
      _line,
      _tag          = state.tag,
      _anchor       = state.anchor,
      _result       = {},
      keyTag        = null,
      keyNode       = null,
      valueNode     = null,
      atExplicitKey = false,
      detected      = false,
      ch;

  if (null !== state.anchor) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (0 !== ch) {
    following = state.input.charCodeAt(state.position + 1);
    _line = state.line; // Save the current line.

    //
    // Explicit notation case. There are two separate blocks:
    // first for the key (denoted by "?") and second for the value (denoted by ":")
    //
    if ((0x3F/* ? */ === ch || 0x3A/* : */  === ch) && is_WS_OR_EOL(following)) {

      if (0x3F/* ? */ === ch) {
        if (atExplicitKey) {
          storeMappingPair(state, _result, keyTag, keyNode, null);
          keyTag = keyNode = valueNode = null;
        }

        detected = true;
        atExplicitKey = true;
        allowCompact = true;

      } else if (atExplicitKey) {
        // i.e. 0x3A/* : */ === character after the explicit key.
        atExplicitKey = false;
        allowCompact = true;

      } else {
        throwError(state, 'incomplete explicit mapping pair; a key node is missed');
      }

      state.position += 1;
      ch = following;

    //
    // Implicit notation case. Flow-style node as the key first, then ":", and the value.
    //
    } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {

      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);

        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }

        if (0x3A/* : */ === ch) {
          ch = state.input.charCodeAt(++state.position);

          if (!is_WS_OR_EOL(ch)) {
            throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');
          }

          if (atExplicitKey) {
            storeMappingPair(state, _result, keyTag, keyNode, null);
            keyTag = keyNode = valueNode = null;
          }

          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;

        } else if (detected) {
          throwError(state, 'can not read an implicit mapping pair; a colon is missed');

        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true; // Keep the result of `composeNode`.
        }

      } else if (detected) {
        throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');

      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true; // Keep the result of `composeNode`.
      }

    } else {
      break; // Reading is done. Go to the epilogue.
    }

    //
    // Common reading code for both explicit and implicit notations.
    //
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }

      if (!atExplicitKey) {
        storeMappingPair(state, _result, keyTag, keyNode, valueNode);
        keyTag = keyNode = valueNode = null;
      }

      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }

    if (state.lineIndent > nodeIndent && (0 !== ch)) {
      throwError(state, 'bad indentation of a mapping entry');
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }

  //
  // Epilogue.
  //

  // Special case: last mapping's node contains only the key in explicit notation.
  if (atExplicitKey) {
    storeMappingPair(state, _result, keyTag, keyNode, null);
  }

  // Expose the resulting mapping.
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'mapping';
    state.result = _result;
  }

  return detected;
}

function readTagProperty(state) {
  var _position,
      isVerbatim = false,
      isNamed    = false,
      tagHandle,
      tagName,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (0x21/* ! */ !== ch) {
    return false;
  }

  if (null !== state.tag) {
    throwError(state, 'duplication of a tag property');
  }

  ch = state.input.charCodeAt(++state.position);

  if (0x3C/* < */ === ch) {
    isVerbatim = true;
    ch = state.input.charCodeAt(++state.position);

  } else if (0x21/* ! */ === ch) {
    isNamed = true;
    tagHandle = '!!';
    ch = state.input.charCodeAt(++state.position);

  } else {
    tagHandle = '!';
  }

  _position = state.position;

  if (isVerbatim) {
    do { ch = state.input.charCodeAt(++state.position); }
    while (0 !== ch && 0x3E/* > */ !== ch);

    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, 'unexpected end of the stream within a verbatim tag');
    }
  } else {
    while (0 !== ch && !is_WS_OR_EOL(ch)) {

      if (0x21/* ! */ === ch) {
        if (!isNamed) {
          tagHandle = state.input.slice(_position - 1, state.position + 1);

          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state, 'named tag handle cannot contain such characters');
          }

          isNamed = true;
          _position = state.position + 1;
        } else {
          throwError(state, 'tag suffix cannot contain exclamation marks');
        }
      }

      ch = state.input.charCodeAt(++state.position);
    }

    tagName = state.input.slice(_position, state.position);

    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, 'tag suffix cannot contain flow indicator characters');
    }
  }

  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, 'tag name cannot contain such characters: ' + tagName);
  }

  if (isVerbatim) {
    state.tag = tagName;

  } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;

  } else if ('!' === tagHandle) {
    state.tag = '!' + tagName;

  } else if ('!!' === tagHandle) {
    state.tag = 'tag:yaml.org,2002:' + tagName;

  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }

  return true;
}

function readAnchorProperty(state) {
  var _position,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (0x26/* & */ !== ch) {
    return false;
  }

  if (null !== state.anchor) {
    throwError(state, 'duplication of an anchor property');
  }

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (0 !== ch && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    throwError(state, 'name of an anchor node must contain at least one character');
  }

  state.anchor = state.input.slice(_position, state.position);
  return true;
}

function readAlias(state) {
  var _position, alias,
      len = state.length,
      input = state.input,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (0x2A/* * */ !== ch) {
    return false;
  }

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (0 !== ch && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    throwError(state, 'name of an alias node must contain at least one character');
  }

  alias = state.input.slice(_position, state.position);

  if (!state.anchorMap.hasOwnProperty(alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }

  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}

function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles,
      allowBlockScalars,
      allowBlockCollections,
      indentStatus = 1, // 1: this>parent, 0: this=parent, -1: this<parent
      atNewLine  = false,
      hasContent = false,
      typeIndex,
      typeQuantity,
      type,
      flowIndent,
      blockIndent,
      _result;

  state.tag    = null;
  state.anchor = null;
  state.kind   = null;
  state.result = null;

  allowBlockStyles = allowBlockScalars = allowBlockCollections =
    CONTEXT_BLOCK_OUT === nodeContext ||
    CONTEXT_BLOCK_IN  === nodeContext;

  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;

      if (state.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }

  if (1 === indentStatus) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;

        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }

  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }

  if (1 === indentStatus || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }

    blockIndent = state.position - state.lineStart;

    if (1 === indentStatus) {
      if (allowBlockCollections &&
          (readBlockSequence(state, blockIndent) ||
           readBlockMapping(state, blockIndent, flowIndent)) ||
          readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if ((allowBlockScalars && readBlockScalar(state, flowIndent)) ||
            readSingleQuotedScalar(state, flowIndent) ||
            readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;

        } else if (readAlias(state)) {
          hasContent = true;

          if (null !== state.tag || null !== state.anchor) {
            throwError(state, 'alias node should not have any properties');
          }

        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;

          if (null === state.tag) {
            state.tag = '?';
          }
        }

        if (null !== state.anchor) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (0 === indentStatus) {
      // Special case: block sequences are allowed to have same indentation level as the parent.
      // http://www.yaml.org/spec/1.2/spec.html#id2799784
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }

  if (null !== state.tag && '!' !== state.tag) {
    if ('?' === state.tag) {
      for (typeIndex = 0, typeQuantity = state.implicitTypes.length;
           typeIndex < typeQuantity;
           typeIndex += 1) {
        type = state.implicitTypes[typeIndex];

        // Implicit resolving is not allowed for non-scalar types, and '?'
        // non-specific tag is only assigned to plain scalars. So, it isn't
        // needed to check for 'kind' conformity.

        if (type.resolve(state.result)) { // `state.result` updated in resolver if matched
          state.result = type.construct(state.result);
          state.tag = type.tag;
          if (null !== state.anchor) {
            state.anchorMap[state.anchor] = state.result;
          }
          break;
        }
      }
    } else if (_hasOwnProperty.call(state.typeMap, state.tag)) {
      type = state.typeMap[state.tag];

      if (null !== state.result && type.kind !== state.kind) {
        throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
      }

      if (!type.resolve(state.result)) { // `state.result` updated in resolver if matched
        throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');
      } else {
        state.result = type.construct(state.result);
        if (null !== state.anchor) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else {
      throwWarning(state, 'unknown tag !<' + state.tag + '>');
    }
  }

  return null !== state.tag || null !== state.anchor || hasContent;
}

function readDocument(state) {
  var documentStart = state.position,
      _position,
      directiveName,
      directiveArgs,
      hasDirectives = false,
      ch;

  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = {};
  state.anchorMap = {};

  while (0 !== (ch = state.input.charCodeAt(state.position))) {
    skipSeparationSpace(state, true, -1);

    ch = state.input.charCodeAt(state.position);

    if (state.lineIndent > 0 || 0x25/* % */ !== ch) {
      break;
    }

    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;

    while (0 !== ch && !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];

    if (directiveName.length < 1) {
      throwError(state, 'directive name must not be less than one character in length');
    }

    while (0 !== ch) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      if (0x23/* # */ === ch) {
        do { ch = state.input.charCodeAt(++state.position); }
        while (0 !== ch && !is_EOL(ch));
        break;
      }

      if (is_EOL(ch)) {
        break;
      }

      _position = state.position;

      while (0 !== ch && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      directiveArgs.push(state.input.slice(_position, state.position));
    }

    if (0 !== ch) {
      readLineBreak(state);
    }

    if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }

  skipSeparationSpace(state, true, -1);

  if (0 === state.lineIndent &&
      0x2D/* - */ === state.input.charCodeAt(state.position) &&
      0x2D/* - */ === state.input.charCodeAt(state.position + 1) &&
      0x2D/* - */ === state.input.charCodeAt(state.position + 2)) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);

  } else if (hasDirectives) {
    throwError(state, 'directives end mark is expected');
  }

  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);

  if (state.checkLineBreaks &&
      PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, 'non-ASCII line breaks are interpreted as content');
  }

  state.documents.push(state.result);

  if (state.position === state.lineStart && testDocumentSeparator(state)) {

    if (0x2E/* . */ === state.input.charCodeAt(state.position)) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    }
    return;
  }

  if (state.position < (state.length - 1)) {
    throwError(state, 'end of the stream or a document separator is expected');
  } else {
    return;
  }
}


function loadDocuments(input, options) {
  input = String(input);
  options = options || {};

  if (input.length !== 0) {

    // Add tailing `\n` if not exists
    if (0x0A/* LF */ !== input.charCodeAt(input.length - 1) &&
        0x0D/* CR */ !== input.charCodeAt(input.length - 1)) {
      input += '\n';
    }

    // Strip BOM
    if (input.charCodeAt(0) === 0xFEFF) {
      input = input.slice(1);
    }
  }

  var state = new State(input, options);

  if (PATTERN_NON_PRINTABLE.test(state.input)) {
    throwError(state, 'the stream contains non-printable characters');
  }

  // Use 0 as string terminator. That significantly simplifies bounds check.
  state.input += '\0';

  while (0x20/* Space */ === state.input.charCodeAt(state.position)) {
    state.lineIndent += 1;
    state.position += 1;
  }

  while (state.position < (state.length - 1)) {
    readDocument(state);
  }

  return state.documents;
}


function loadAll(input, iterator, options) {
  var documents = loadDocuments(input, options), index, length;

  for (index = 0, length = documents.length; index < length; index += 1) {
    iterator(documents[index]);
  }
}


function load(input, options) {
  var documents = loadDocuments(input, options), index, length;

  if (0 === documents.length) {
    /*eslint-disable no-undefined*/
    return undefined;
  } else if (1 === documents.length) {
    return documents[0];
  }
  throw new YAMLException('expected a single document in the stream, but found more');
}


function safeLoadAll(input, output, options) {
  loadAll(input, output, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
}


function safeLoad(input, options) {
  return load(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
}


module.exports.loadAll     = loadAll;
module.exports.load        = load;
module.exports.safeLoadAll = safeLoadAll;
module.exports.safeLoad    = safeLoad;

},{"./common":2,"./exception":4,"./mark":6,"./schema/default_full":9,"./schema/default_safe":10}],6:[function(require,module,exports){
'use strict';


var common = require('./common');


function Mark(name, buffer, position, line, column) {
  this.name     = name;
  this.buffer   = buffer;
  this.position = position;
  this.line     = line;
  this.column   = column;
}


Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {
  var head, start, tail, end, snippet;

  if (!this.buffer) {
    return null;
  }

  indent = indent || 4;
  maxLength = maxLength || 75;

  head = '';
  start = this.position;

  while (start > 0 && -1 === '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(start - 1))) {
    start -= 1;
    if (this.position - start > (maxLength / 2 - 1)) {
      head = ' ... ';
      start += 5;
      break;
    }
  }

  tail = '';
  end = this.position;

  while (end < this.buffer.length && -1 === '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(end))) {
    end += 1;
    if (end - this.position > (maxLength / 2 - 1)) {
      tail = ' ... ';
      end -= 5;
      break;
    }
  }

  snippet = this.buffer.slice(start, end);

  return common.repeat(' ', indent) + head + snippet + tail + '\n' +
         common.repeat(' ', indent + this.position - start + head.length) + '^';
};


Mark.prototype.toString = function toString(compact) {
  var snippet, where = '';

  if (this.name) {
    where += 'in "' + this.name + '" ';
  }

  where += 'at line ' + (this.line + 1) + ', column ' + (this.column + 1);

  if (!compact) {
    snippet = this.getSnippet();

    if (snippet) {
      where += ':\n' + snippet;
    }
  }

  return where;
};


module.exports = Mark;

},{"./common":2}],7:[function(require,module,exports){
'use strict';

/*eslint-disable max-len*/

var common        = require('./common');
var YAMLException = require('./exception');
var Type          = require('./type');


function compileList(schema, name, result) {
  var exclude = [];

  schema.include.forEach(function (includedSchema) {
    result = compileList(includedSchema, name, result);
  });

  schema[name].forEach(function (currentType) {
    result.forEach(function (previousType, previousIndex) {
      if (previousType.tag === currentType.tag) {
        exclude.push(previousIndex);
      }
    });

    result.push(currentType);
  });

  return result.filter(function (type, index) {
    return -1 === exclude.indexOf(index);
  });
}


function compileMap(/* lists... */) {
  var result = {}, index, length;

  function collectType(type) {
    result[type.tag] = type;
  }

  for (index = 0, length = arguments.length; index < length; index += 1) {
    arguments[index].forEach(collectType);
  }

  return result;
}


function Schema(definition) {
  this.include  = definition.include  || [];
  this.implicit = definition.implicit || [];
  this.explicit = definition.explicit || [];

  this.implicit.forEach(function (type) {
    if (type.loadKind && 'scalar' !== type.loadKind) {
      throw new YAMLException('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');
    }
  });

  this.compiledImplicit = compileList(this, 'implicit', []);
  this.compiledExplicit = compileList(this, 'explicit', []);
  this.compiledTypeMap  = compileMap(this.compiledImplicit, this.compiledExplicit);
}


Schema.DEFAULT = null;


Schema.create = function createSchema() {
  var schemas, types;

  switch (arguments.length) {
  case 1:
    schemas = Schema.DEFAULT;
    types = arguments[0];
    break;

  case 2:
    schemas = arguments[0];
    types = arguments[1];
    break;

  default:
    throw new YAMLException('Wrong number of arguments for Schema.create function');
  }

  schemas = common.toArray(schemas);
  types = common.toArray(types);

  if (!schemas.every(function (schema) { return schema instanceof Schema; })) {
    throw new YAMLException('Specified list of super schemas (or a single Schema object) contains a non-Schema object.');
  }

  if (!types.every(function (type) { return type instanceof Type; })) {
    throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');
  }

  return new Schema({
    include: schemas,
    explicit: types
  });
};


module.exports = Schema;

},{"./common":2,"./exception":4,"./type":13}],8:[function(require,module,exports){
// Standard YAML's Core schema.
// http://www.yaml.org/spec/1.2/spec.html#id2804923
//
// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
// So, Core schema has no distinctions from JSON schema is JS-YAML.


'use strict';


var Schema = require('../schema');


module.exports = new Schema({
  include: [
    require('./json')
  ]
});

},{"../schema":7,"./json":12}],9:[function(require,module,exports){
// JS-YAML's default schema for `load` function.
// It is not described in the YAML specification.
//
// This schema is based on JS-YAML's default safe schema and includes
// JavaScript-specific types: !!js/undefined, !!js/regexp and !!js/function.
//
// Also this schema is used as default base schema at `Schema.create` function.


'use strict';


var Schema = require('../schema');


module.exports = Schema.DEFAULT = new Schema({
  include: [
    require('./default_safe')
  ],
  explicit: [
    require('../type/js/undefined'),
    require('../type/js/regexp'),
    require('../type/js/function')
  ]
});

},{"../schema":7,"../type/js/function":18,"../type/js/regexp":19,"../type/js/undefined":20,"./default_safe":10}],10:[function(require,module,exports){
// JS-YAML's default schema for `safeLoad` function.
// It is not described in the YAML specification.
//
// This schema is based on standard YAML's Core schema and includes most of
// extra types described at YAML tag repository. (http://yaml.org/type/)


'use strict';


var Schema = require('../schema');


module.exports = new Schema({
  include: [
    require('./core')
  ],
  implicit: [
    require('../type/timestamp'),
    require('../type/merge')
  ],
  explicit: [
    require('../type/binary'),
    require('../type/omap'),
    require('../type/pairs'),
    require('../type/set')
  ]
});

},{"../schema":7,"../type/binary":14,"../type/merge":22,"../type/omap":24,"../type/pairs":25,"../type/set":27,"../type/timestamp":29,"./core":8}],11:[function(require,module,exports){
// Standard YAML's Failsafe schema.
// http://www.yaml.org/spec/1.2/spec.html#id2802346


'use strict';


var Schema = require('../schema');


module.exports = new Schema({
  explicit: [
    require('../type/str'),
    require('../type/seq'),
    require('../type/map')
  ]
});

},{"../schema":7,"../type/map":21,"../type/seq":26,"../type/str":28}],12:[function(require,module,exports){
// Standard YAML's JSON schema.
// http://www.yaml.org/spec/1.2/spec.html#id2803231
//
// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
// So, this schema is not such strict as defined in the YAML specification.
// It allows numbers in binary notaion, use `Null` and `NULL` as `null`, etc.


'use strict';


var Schema = require('../schema');


module.exports = new Schema({
  include: [
    require('./failsafe')
  ],
  implicit: [
    require('../type/null'),
    require('../type/bool'),
    require('../type/int'),
    require('../type/float')
  ]
});

},{"../schema":7,"../type/bool":15,"../type/float":16,"../type/int":17,"../type/null":23,"./failsafe":11}],13:[function(require,module,exports){
'use strict';

var YAMLException = require('./exception');

var TYPE_CONSTRUCTOR_OPTIONS = [
  'kind',
  'resolve',
  'construct',
  'instanceOf',
  'predicate',
  'represent',
  'defaultStyle',
  'styleAliases'
];

var YAML_NODE_KINDS = [
  'scalar',
  'sequence',
  'mapping'
];

function compileStyleAliases(map) {
  var result = {};

  if (null !== map) {
    Object.keys(map).forEach(function (style) {
      map[style].forEach(function (alias) {
        result[String(alias)] = style;
      });
    });
  }

  return result;
}

function Type(tag, options) {
  options = options || {};

  Object.keys(options).forEach(function (name) {
    if (-1 === TYPE_CONSTRUCTOR_OPTIONS.indexOf(name)) {
      throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }
  });

  // TODO: Add tag format check.
  this.tag          = tag;
  this.kind         = options['kind']         || null;
  this.resolve      = options['resolve']      || function () { return true; };
  this.construct    = options['construct']    || function (data) { return data; };
  this.instanceOf   = options['instanceOf']   || null;
  this.predicate    = options['predicate']    || null;
  this.represent    = options['represent']    || null;
  this.defaultStyle = options['defaultStyle'] || null;
  this.styleAliases = compileStyleAliases(options['styleAliases'] || null);

  if (-1 === YAML_NODE_KINDS.indexOf(this.kind)) {
    throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}

module.exports = Type;

},{"./exception":4}],14:[function(require,module,exports){
'use strict';

/*eslint-disable no-bitwise*/

// A trick for browserified version.
// Since we make browserifier to ignore `buffer` module, NodeBuffer will be undefined
var NodeBuffer = require('buffer').Buffer;
var Type       = require('../type');


// [ 64, 65, 66 ] -> [ padding, CR, LF ]
var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r';


function resolveYamlBinary(data) {
  if (null === data) {
    return false;
  }

  var code, idx, bitlen = 0, len = 0, max = data.length, map = BASE64_MAP;

  // Convert one by one.
  for (idx = 0; idx < max; idx++) {
    code = map.indexOf(data.charAt(idx));

    // Skip CR/LF
    if (code > 64) { continue; }

    // Fail on illegal characters
    if (code < 0) { return false; }

    bitlen += 6;
  }

  // If there are any bits left, source was corrupted
  return (bitlen % 8) === 0;
}

function constructYamlBinary(data) {
  var code, idx, tailbits,
      input = data.replace(/[\r\n=]/g, ''), // remove CR/LF & padding to simplify scan
      max = input.length,
      map = BASE64_MAP,
      bits = 0,
      result = [];

  // Collect by 6*4 bits (3 bytes)

  for (idx = 0; idx < max; idx++) {
    if ((idx % 4 === 0) && idx) {
      result.push((bits >> 16) & 0xFF);
      result.push((bits >> 8) & 0xFF);
      result.push(bits & 0xFF);
    }

    bits = (bits << 6) | map.indexOf(input.charAt(idx));
  }

  // Dump tail

  tailbits = (max % 4) * 6;

  if (tailbits === 0) {
    result.push((bits >> 16) & 0xFF);
    result.push((bits >> 8) & 0xFF);
    result.push(bits & 0xFF);
  } else if (tailbits === 18) {
    result.push((bits >> 10) & 0xFF);
    result.push((bits >> 2) & 0xFF);
  } else if (tailbits === 12) {
    result.push((bits >> 4) & 0xFF);
  }

  // Wrap into Buffer for NodeJS and leave Array for browser
  if (NodeBuffer) {
    return new NodeBuffer(result);
  }

  return result;
}

function representYamlBinary(object /*, style*/) {
  var result = '', bits = 0, idx, tail,
      max = object.length,
      map = BASE64_MAP;

  // Convert every three bytes to 4 ASCII characters.

  for (idx = 0; idx < max; idx++) {
    if ((idx % 3 === 0) && idx) {
      result += map[(bits >> 18) & 0x3F];
      result += map[(bits >> 12) & 0x3F];
      result += map[(bits >> 6) & 0x3F];
      result += map[bits & 0x3F];
    }

    bits = (bits << 8) + object[idx];
  }

  // Dump tail

  tail = max % 3;

  if (tail === 0) {
    result += map[(bits >> 18) & 0x3F];
    result += map[(bits >> 12) & 0x3F];
    result += map[(bits >> 6) & 0x3F];
    result += map[bits & 0x3F];
  } else if (tail === 2) {
    result += map[(bits >> 10) & 0x3F];
    result += map[(bits >> 4) & 0x3F];
    result += map[(bits << 2) & 0x3F];
    result += map[64];
  } else if (tail === 1) {
    result += map[(bits >> 2) & 0x3F];
    result += map[(bits << 4) & 0x3F];
    result += map[64];
    result += map[64];
  }

  return result;
}

function isBinary(object) {
  return NodeBuffer && NodeBuffer.isBuffer(object);
}

module.exports = new Type('tag:yaml.org,2002:binary', {
  kind: 'scalar',
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});

},{"../type":13,"buffer":30}],15:[function(require,module,exports){
'use strict';

var Type = require('../type');

function resolveYamlBoolean(data) {
  if (null === data) {
    return false;
  }

  var max = data.length;

  return (max === 4 && (data === 'true' || data === 'True' || data === 'TRUE')) ||
         (max === 5 && (data === 'false' || data === 'False' || data === 'FALSE'));
}

function constructYamlBoolean(data) {
  return data === 'true' ||
         data === 'True' ||
         data === 'TRUE';
}

function isBoolean(object) {
  return '[object Boolean]' === Object.prototype.toString.call(object);
}

module.exports = new Type('tag:yaml.org,2002:bool', {
  kind: 'scalar',
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function (object) { return object ? 'true' : 'false'; },
    uppercase: function (object) { return object ? 'TRUE' : 'FALSE'; },
    camelcase: function (object) { return object ? 'True' : 'False'; }
  },
  defaultStyle: 'lowercase'
});

},{"../type":13}],16:[function(require,module,exports){
'use strict';

var common = require('../common');
var Type   = require('../type');

var YAML_FLOAT_PATTERN = new RegExp(
  '^(?:[-+]?(?:[0-9][0-9_]*)\\.[0-9_]*(?:[eE][-+][0-9]+)?' +
  '|\\.[0-9_]+(?:[eE][-+][0-9]+)?' +
  '|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*' +
  '|[-+]?\\.(?:inf|Inf|INF)' +
  '|\\.(?:nan|NaN|NAN))$');

function resolveYamlFloat(data) {
  if (null === data) {
    return false;
  }

  var value, sign, base, digits;

  if (!YAML_FLOAT_PATTERN.test(data)) {
    return false;
  }
  return true;
}

function constructYamlFloat(data) {
  var value, sign, base, digits;

  value  = data.replace(/_/g, '').toLowerCase();
  sign   = '-' === value[0] ? -1 : 1;
  digits = [];

  if (0 <= '+-'.indexOf(value[0])) {
    value = value.slice(1);
  }

  if ('.inf' === value) {
    return (1 === sign) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;

  } else if ('.nan' === value) {
    return NaN;

  } else if (0 <= value.indexOf(':')) {
    value.split(':').forEach(function (v) {
      digits.unshift(parseFloat(v, 10));
    });

    value = 0.0;
    base = 1;

    digits.forEach(function (d) {
      value += d * base;
      base *= 60;
    });

    return sign * value;

  }
  return sign * parseFloat(value, 10);
}

function representYamlFloat(object, style) {
  if (isNaN(object)) {
    switch (style) {
    case 'lowercase':
      return '.nan';
    case 'uppercase':
      return '.NAN';
    case 'camelcase':
      return '.NaN';
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
    case 'lowercase':
      return '.inf';
    case 'uppercase':
      return '.INF';
    case 'camelcase':
      return '.Inf';
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
    case 'lowercase':
      return '-.inf';
    case 'uppercase':
      return '-.INF';
    case 'camelcase':
      return '-.Inf';
    }
  } else if (common.isNegativeZero(object)) {
    return '-0.0';
  }
  return object.toString(10);
}

function isFloat(object) {
  return ('[object Number]' === Object.prototype.toString.call(object)) &&
         (0 !== object % 1 || common.isNegativeZero(object));
}

module.exports = new Type('tag:yaml.org,2002:float', {
  kind: 'scalar',
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: 'lowercase'
});

},{"../common":2,"../type":13}],17:[function(require,module,exports){
'use strict';

var common = require('../common');
var Type   = require('../type');

function isHexCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) ||
         ((0x41/* A */ <= c) && (c <= 0x46/* F */)) ||
         ((0x61/* a */ <= c) && (c <= 0x66/* f */));
}

function isOctCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x37/* 7 */));
}

function isDecCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */));
}

function resolveYamlInteger(data) {
  if (null === data) {
    return false;
  }

  var max = data.length,
      index = 0,
      hasDigits = false,
      ch;

  if (!max) { return false; }

  ch = data[index];

  // sign
  if (ch === '-' || ch === '+') {
    ch = data[++index];
  }

  if (ch === '0') {
    // 0
    if (index + 1 === max) { return true; }
    ch = data[++index];

    // base 2, base 8, base 16

    if (ch === 'b') {
      // base 2
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') { continue; }
        if (ch !== '0' && ch !== '1') {
          return false;
        }
        hasDigits = true;
      }
      return hasDigits;
    }


    if (ch === 'x') {
      // base 16
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') { continue; }
        if (!isHexCode(data.charCodeAt(index))) {
          return false;
        }
        hasDigits = true;
      }
      return hasDigits;
    }

    // base 8
    for (; index < max; index++) {
      ch = data[index];
      if (ch === '_') { continue; }
      if (!isOctCode(data.charCodeAt(index))) {
        return false;
      }
      hasDigits = true;
    }
    return hasDigits;
  }

  // base 10 (except 0) or base 60

  for (; index < max; index++) {
    ch = data[index];
    if (ch === '_') { continue; }
    if (ch === ':') { break; }
    if (!isDecCode(data.charCodeAt(index))) {
      return false;
    }
    hasDigits = true;
  }

  if (!hasDigits) { return false; }

  // if !base60 - done;
  if (ch !== ':') { return true; }

  // base60 almost not used, no needs to optimize
  return /^(:[0-5]?[0-9])+$/.test(data.slice(index));
}

function constructYamlInteger(data) {
  var value = data, sign = 1, ch, base, digits = [];

  if (value.indexOf('_') !== -1) {
    value = value.replace(/_/g, '');
  }

  ch = value[0];

  if (ch === '-' || ch === '+') {
    if (ch === '-') { sign = -1; }
    value = value.slice(1);
    ch = value[0];
  }

  if ('0' === value) {
    return 0;
  }

  if (ch === '0') {
    if (value[1] === 'b') {
      return sign * parseInt(value.slice(2), 2);
    }
    if (value[1] === 'x') {
      return sign * parseInt(value, 16);
    }
    return sign * parseInt(value, 8);

  }

  if (value.indexOf(':') !== -1) {
    value.split(':').forEach(function (v) {
      digits.unshift(parseInt(v, 10));
    });

    value = 0;
    base = 1;

    digits.forEach(function (d) {
      value += (d * base);
      base *= 60;
    });

    return sign * value;

  }

  return sign * parseInt(value, 10);
}

function isInteger(object) {
  return ('[object Number]' === Object.prototype.toString.call(object)) &&
         (0 === object % 1 && !common.isNegativeZero(object));
}

module.exports = new Type('tag:yaml.org,2002:int', {
  kind: 'scalar',
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary:      function (object) { return '0b' + object.toString(2); },
    octal:       function (object) { return '0'  + object.toString(8); },
    decimal:     function (object) { return        object.toString(10); },
    hexadecimal: function (object) { return '0x' + object.toString(16).toUpperCase(); }
  },
  defaultStyle: 'decimal',
  styleAliases: {
    binary:      [ 2,  'bin' ],
    octal:       [ 8,  'oct' ],
    decimal:     [ 10, 'dec' ],
    hexadecimal: [ 16, 'hex' ]
  }
});

},{"../common":2,"../type":13}],18:[function(require,module,exports){
'use strict';

var esprima;

// Browserified version does not have esprima
//
// 1. For node.js just require module as deps
// 2. For browser try to require mudule via external AMD system.
//    If not found - try to fallback to window.esprima. If not
//    found too - then fail to parse.
//
try {
  esprima = require('esprima');
} catch (_) {
  /*global window */
  if (typeof window !== 'undefined') { esprima = window.esprima; }
}

var Type = require('../../type');

function resolveJavascriptFunction(data) {
  if (null === data) {
    return false;
  }

  try {
    var source = '(' + data + ')',
        ast    = esprima.parse(source, { range: true }),
        params = [],
        body;

    if ('Program'             !== ast.type         ||
        1                     !== ast.body.length  ||
        'ExpressionStatement' !== ast.body[0].type ||
        'FunctionExpression'  !== ast.body[0].expression.type) {
      return false;
    }

    return true;
  } catch (err) {
    return false;
  }
}

function constructJavascriptFunction(data) {
  /*jslint evil:true*/

  var source = '(' + data + ')',
      ast    = esprima.parse(source, { range: true }),
      params = [],
      body;

  if ('Program'             !== ast.type         ||
      1                     !== ast.body.length  ||
      'ExpressionStatement' !== ast.body[0].type ||
      'FunctionExpression'  !== ast.body[0].expression.type) {
    throw new Error('Failed to resolve function');
  }

  ast.body[0].expression.params.forEach(function (param) {
    params.push(param.name);
  });

  body = ast.body[0].expression.body.range;

  // Esprima's ranges include the first '{' and the last '}' characters on
  // function expressions. So cut them out.
  /*eslint-disable no-new-func*/
  return new Function(params, source.slice(body[0] + 1, body[1] - 1));
}

function representJavascriptFunction(object /*, style*/) {
  return object.toString();
}

function isFunction(object) {
  return '[object Function]' === Object.prototype.toString.call(object);
}

module.exports = new Type('tag:yaml.org,2002:js/function', {
  kind: 'scalar',
  resolve: resolveJavascriptFunction,
  construct: constructJavascriptFunction,
  predicate: isFunction,
  represent: representJavascriptFunction
});

},{"../../type":13,"esprima":"esprima"}],19:[function(require,module,exports){
'use strict';

var Type = require('../../type');

function resolveJavascriptRegExp(data) {
  if (null === data) {
    return false;
  }

  if (0 === data.length) {
    return false;
  }

  var regexp = data,
      tail   = /\/([gim]*)$/.exec(data),
      modifiers = '';

  // if regexp starts with '/' it can have modifiers and must be properly closed
  // `/foo/gim` - modifiers tail can be maximum 3 chars
  if ('/' === regexp[0]) {
    if (tail) {
      modifiers = tail[1];
    }

    if (modifiers.length > 3) { return false; }
    // if expression starts with /, is should be properly terminated
    if (regexp[regexp.length - modifiers.length - 1] !== '/') { return false; }

    regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
  }

  try {
    var dummy = new RegExp(regexp, modifiers);
    return true;
  } catch (error) {
    return false;
  }
}

function constructJavascriptRegExp(data) {
  var regexp = data,
      tail   = /\/([gim]*)$/.exec(data),
      modifiers = '';

  // `/foo/gim` - tail can be maximum 4 chars
  if ('/' === regexp[0]) {
    if (tail) {
      modifiers = tail[1];
    }
    regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
  }

  return new RegExp(regexp, modifiers);
}

function representJavascriptRegExp(object /*, style*/) {
  var result = '/' + object.source + '/';

  if (object.global) {
    result += 'g';
  }

  if (object.multiline) {
    result += 'm';
  }

  if (object.ignoreCase) {
    result += 'i';
  }

  return result;
}

function isRegExp(object) {
  return '[object RegExp]' === Object.prototype.toString.call(object);
}

module.exports = new Type('tag:yaml.org,2002:js/regexp', {
  kind: 'scalar',
  resolve: resolveJavascriptRegExp,
  construct: constructJavascriptRegExp,
  predicate: isRegExp,
  represent: representJavascriptRegExp
});

},{"../../type":13}],20:[function(require,module,exports){
'use strict';

var Type = require('../../type');

function resolveJavascriptUndefined() {
  return true;
}

function constructJavascriptUndefined() {
  /*eslint-disable no-undefined*/
  return undefined;
}

function representJavascriptUndefined() {
  return '';
}

function isUndefined(object) {
  return 'undefined' === typeof object;
}

module.exports = new Type('tag:yaml.org,2002:js/undefined', {
  kind: 'scalar',
  resolve: resolveJavascriptUndefined,
  construct: constructJavascriptUndefined,
  predicate: isUndefined,
  represent: representJavascriptUndefined
});

},{"../../type":13}],21:[function(require,module,exports){
'use strict';

var Type = require('../type');

module.exports = new Type('tag:yaml.org,2002:map', {
  kind: 'mapping',
  construct: function (data) { return null !== data ? data : {}; }
});

},{"../type":13}],22:[function(require,module,exports){
'use strict';

var Type = require('../type');

function resolveYamlMerge(data) {
  return '<<' === data || null === data;
}

module.exports = new Type('tag:yaml.org,2002:merge', {
  kind: 'scalar',
  resolve: resolveYamlMerge
});

},{"../type":13}],23:[function(require,module,exports){
'use strict';

var Type = require('../type');

function resolveYamlNull(data) {
  if (null === data) {
    return true;
  }

  var max = data.length;

  return (max === 1 && data === '~') ||
         (max === 4 && (data === 'null' || data === 'Null' || data === 'NULL'));
}

function constructYamlNull() {
  return null;
}

function isNull(object) {
  return null === object;
}

module.exports = new Type('tag:yaml.org,2002:null', {
  kind: 'scalar',
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function () { return '~';    },
    lowercase: function () { return 'null'; },
    uppercase: function () { return 'NULL'; },
    camelcase: function () { return 'Null'; }
  },
  defaultStyle: 'lowercase'
});

},{"../type":13}],24:[function(require,module,exports){
'use strict';

var Type = require('../type');

var _hasOwnProperty = Object.prototype.hasOwnProperty;
var _toString       = Object.prototype.toString;

function resolveYamlOmap(data) {
  if (null === data) {
    return true;
  }

  var objectKeys = [], index, length, pair, pairKey, pairHasKey,
      object = data;

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    pairHasKey = false;

    if ('[object Object]' !== _toString.call(pair)) {
      return false;
    }

    for (pairKey in pair) {
      if (_hasOwnProperty.call(pair, pairKey)) {
        if (!pairHasKey) {
          pairHasKey = true;
        } else {
          return false;
        }
      }
    }

    if (!pairHasKey) {
      return false;
    }

    if (-1 === objectKeys.indexOf(pairKey)) {
      objectKeys.push(pairKey);
    } else {
      return false;
    }
  }

  return true;
}

function constructYamlOmap(data) {
  return null !== data ? data : [];
}

module.exports = new Type('tag:yaml.org,2002:omap', {
  kind: 'sequence',
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});

},{"../type":13}],25:[function(require,module,exports){
'use strict';

var Type = require('../type');

var _toString = Object.prototype.toString;

function resolveYamlPairs(data) {
  if (null === data) {
    return true;
  }

  var index, length, pair, keys, result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];

    if ('[object Object]' !== _toString.call(pair)) {
      return false;
    }

    keys = Object.keys(pair);

    if (1 !== keys.length) {
      return false;
    }

    result[index] = [ keys[0], pair[keys[0]] ];
  }

  return true;
}

function constructYamlPairs(data) {
  if (null === data) {
    return [];
  }

  var index, length, pair, keys, result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];

    keys = Object.keys(pair);

    result[index] = [ keys[0], pair[keys[0]] ];
  }

  return result;
}

module.exports = new Type('tag:yaml.org,2002:pairs', {
  kind: 'sequence',
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});

},{"../type":13}],26:[function(require,module,exports){
'use strict';

var Type = require('../type');

module.exports = new Type('tag:yaml.org,2002:seq', {
  kind: 'sequence',
  construct: function (data) { return null !== data ? data : []; }
});

},{"../type":13}],27:[function(require,module,exports){
'use strict';

var Type = require('../type');

var _hasOwnProperty = Object.prototype.hasOwnProperty;

function resolveYamlSet(data) {
  if (null === data) {
    return true;
  }

  var key, object = data;

  for (key in object) {
    if (_hasOwnProperty.call(object, key)) {
      if (null !== object[key]) {
        return false;
      }
    }
  }

  return true;
}

function constructYamlSet(data) {
  return null !== data ? data : {};
}

module.exports = new Type('tag:yaml.org,2002:set', {
  kind: 'mapping',
  resolve: resolveYamlSet,
  construct: constructYamlSet
});

},{"../type":13}],28:[function(require,module,exports){
'use strict';

var Type = require('../type');

module.exports = new Type('tag:yaml.org,2002:str', {
  kind: 'scalar',
  construct: function (data) { return null !== data ? data : ''; }
});

},{"../type":13}],29:[function(require,module,exports){
'use strict';

var Type = require('../type');

var YAML_TIMESTAMP_REGEXP = new RegExp(
  '^([0-9][0-9][0-9][0-9])'          + // [1] year
  '-([0-9][0-9]?)'                   + // [2] month
  '-([0-9][0-9]?)'                   + // [3] day
  '(?:(?:[Tt]|[ \\t]+)'              + // ...
  '([0-9][0-9]?)'                    + // [4] hour
  ':([0-9][0-9])'                    + // [5] minute
  ':([0-9][0-9])'                    + // [6] second
  '(?:\\.([0-9]*))?'                 + // [7] fraction
  '(?:[ \\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour
  '(?::([0-9][0-9]))?))?)?$');         // [11] tz_minute

function resolveYamlTimestamp(data) {
  if (null === data) {
    return false;
  }

  var match, year, month, day, hour, minute, second, fraction = 0,
      delta = null, tz_hour, tz_minute, date;

  match = YAML_TIMESTAMP_REGEXP.exec(data);

  if (null === match) {
    return false;
  }

  return true;
}

function constructYamlTimestamp(data) {
  var match, year, month, day, hour, minute, second, fraction = 0,
      delta = null, tz_hour, tz_minute, date;

  match = YAML_TIMESTAMP_REGEXP.exec(data);

  if (null === match) {
    throw new Error('Date resolve error');
  }

  // match: [1] year [2] month [3] day

  year = +(match[1]);
  month = +(match[2]) - 1; // JS month starts with 0
  day = +(match[3]);

  if (!match[4]) { // no hour
    return new Date(Date.UTC(year, month, day));
  }

  // match: [4] hour [5] minute [6] second [7] fraction

  hour = +(match[4]);
  minute = +(match[5]);
  second = +(match[6]);

  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) { // milli-seconds
      fraction += '0';
    }
    fraction = +fraction;
  }

  // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute

  if (match[9]) {
    tz_hour = +(match[10]);
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds
    if ('-' === match[9]) {
      delta = -delta;
    }
  }

  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));

  if (delta) {
    date.setTime(date.getTime() - delta);
  }

  return date;
}

function representYamlTimestamp(object /*, style*/) {
  return object.toISOString();
}

module.exports = new Type('tag:yaml.org,2002:timestamp', {
  kind: 'scalar',
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});

},{"../type":13}],30:[function(require,module,exports){

},{}],"/":[function(require,module,exports){
'use strict';


var yaml = require('./lib/js-yaml.js');


module.exports = yaml;

},{"./lib/js-yaml.js":1}]},{},[])("/")
});
});
require.register("jonnor-js-yaml/component.json", function(exports, require, module){
module.exports = JSON.parse('{"name":"js-yaml","description":"YAML parser","author":"","repo":"jonnor/js-yaml","version":"3.3.1","main":"dist/js-yaml.js","keywords":[],"dependencies":{},"remotes":["https://raw.githubusercontent.com"],"scripts":["dist/js-yaml.js"],"json":["component.json"]}');
});
require.register("jonnor-chai/chai.js", function(exports, require, module){
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.chai = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
module.exports = require('./lib/chai');

},{"./lib/chai":2}],2:[function(require,module,exports){
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

var used = []
  , exports = module.exports = {};

/*!
 * Chai version
 */

exports.version = '3.2.0';

/*!
 * Assertion Error
 */

exports.AssertionError = require('assertion-error');

/*!
 * Utils for plugins (not exported)
 */

var util = require('./chai/utils');

/**
 * # .use(function)
 *
 * Provides a way to extend the internals of Chai
 *
 * @param {Function}
 * @returns {this} for chaining
 * @api public
 */

exports.use = function (fn) {
  if (!~used.indexOf(fn)) {
    fn(this, util);
    used.push(fn);
  }

  return this;
};

/*!
 * Utility Functions
 */

exports.util = util;

/*!
 * Configuration
 */

var config = require('./chai/config');
exports.config = config;

/*!
 * Primary `Assertion` prototype
 */

var assertion = require('./chai/assertion');
exports.use(assertion);

/*!
 * Core Assertions
 */

var core = require('./chai/core/assertions');
exports.use(core);

/*!
 * Expect interface
 */

var expect = require('./chai/interface/expect');
exports.use(expect);

/*!
 * Should interface
 */

var should = require('./chai/interface/should');
exports.use(should);

/*!
 * Assert interface
 */

var assert = require('./chai/interface/assert');
exports.use(assert);

},{"./chai/assertion":3,"./chai/config":4,"./chai/core/assertions":5,"./chai/interface/assert":6,"./chai/interface/expect":7,"./chai/interface/should":8,"./chai/utils":21,"assertion-error":29}],3:[function(require,module,exports){
/*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

var config = require('./config');

module.exports = function (_chai, util) {
  /*!
   * Module dependencies.
   */

  var AssertionError = _chai.AssertionError
    , flag = util.flag;

  /*!
   * Module export.
   */

  _chai.Assertion = Assertion;

  /*!
   * Assertion Constructor
   *
   * Creates object for chaining.
   *
   * @api private
   */

  function Assertion (obj, msg, stack) {
    flag(this, 'ssfi', stack || arguments.callee);
    flag(this, 'object', obj);
    flag(this, 'message', msg);
  }

  Object.defineProperty(Assertion, 'includeStack', {
    get: function() {
      console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');
      return config.includeStack;
    },
    set: function(value) {
      console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');
      config.includeStack = value;
    }
  });

  Object.defineProperty(Assertion, 'showDiff', {
    get: function() {
      console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');
      return config.showDiff;
    },
    set: function(value) {
      console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');
      config.showDiff = value;
    }
  });

  Assertion.addProperty = function (name, fn) {
    util.addProperty(this.prototype, name, fn);
  };

  Assertion.addMethod = function (name, fn) {
    util.addMethod(this.prototype, name, fn);
  };

  Assertion.addChainableMethod = function (name, fn, chainingBehavior) {
    util.addChainableMethod(this.prototype, name, fn, chainingBehavior);
  };

  Assertion.overwriteProperty = function (name, fn) {
    util.overwriteProperty(this.prototype, name, fn);
  };

  Assertion.overwriteMethod = function (name, fn) {
    util.overwriteMethod(this.prototype, name, fn);
  };

  Assertion.overwriteChainableMethod = function (name, fn, chainingBehavior) {
    util.overwriteChainableMethod(this.prototype, name, fn, chainingBehavior);
  };

  /**
   * ### .assert(expression, message, negateMessage, expected, actual, showDiff)
   *
   * Executes an expression and check expectations. Throws AssertionError for reporting if test doesn't pass.
   *
   * @name assert
   * @param {Philosophical} expression to be tested
   * @param {String or Function} message or function that returns message to display if expression fails
   * @param {String or Function} negatedMessage or function that returns negatedMessage to display if negated expression fails
   * @param {Mixed} expected value (remember to check for negation)
   * @param {Mixed} actual (optional) will default to `this.obj`
   * @param {Boolean} showDiff (optional) when set to `true`, assert will display a diff in addition to the message if expression fails
   * @api private
   */

  Assertion.prototype.assert = function (expr, msg, negateMsg, expected, _actual, showDiff) {
    var ok = util.test(this, arguments);
    if (true !== showDiff) showDiff = false;
    if (true !== config.showDiff) showDiff = false;

    if (!ok) {
      var msg = util.getMessage(this, arguments)
        , actual = util.getActual(this, arguments);
      throw new AssertionError(msg, {
          actual: actual
        , expected: expected
        , showDiff: showDiff
      }, (config.includeStack) ? this.assert : flag(this, 'ssfi'));
    }
  };

  /*!
   * ### ._obj
   *
   * Quick reference to stored `actual` value for plugin developers.
   *
   * @api private
   */

  Object.defineProperty(Assertion.prototype, '_obj',
    { get: function () {
        return flag(this, 'object');
      }
    , set: function (val) {
        flag(this, 'object', val);
      }
  });
};

},{"./config":4}],4:[function(require,module,exports){
module.exports = {

  /**
   * ### config.includeStack
   *
   * User configurable property, influences whether stack trace
   * is included in Assertion error message. Default of false
   * suppresses stack trace in the error message.
   *
   *     chai.config.includeStack = true;  // enable stack on error
   *
   * @param {Boolean}
   * @api public
   */

   includeStack: false,

  /**
   * ### config.showDiff
   *
   * User configurable property, influences whether or not
   * the `showDiff` flag should be included in the thrown
   * AssertionErrors. `false` will always be `false`; `true`
   * will be true when the assertion has requested a diff
   * be shown.
   *
   * @param {Boolean}
   * @api public
   */

  showDiff: true,

  /**
   * ### config.truncateThreshold
   *
   * User configurable property, sets length threshold for actual and
   * expected values in assertion errors. If this threshold is exceeded, for
   * example for large data structures, the value is replaced with something
   * like `[ Array(3) ]` or `{ Object (prop1, prop2) }`.
   *
   * Set it to zero if you want to disable truncating altogether.
   *
   * This is especially userful when doing assertions on arrays: having this
   * set to a reasonable large value makes the failure messages readily
   * inspectable.
   *
   *     chai.config.truncateThreshold = 0;  // disable truncating
   *
   * @param {Number}
   * @api public
   */

  truncateThreshold: 40

};

},{}],5:[function(require,module,exports){
/*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

module.exports = function (chai, _) {
  var Assertion = chai.Assertion
    , toString = Object.prototype.toString
    , flag = _.flag;

  /**
   * ### Language Chains
   *
   * The following are provided as chainable getters to
   * improve the readability of your assertions. They
   * do not provide testing capabilities unless they
   * have been overwritten by a plugin.
   *
   * **Chains**
   *
   * - to
   * - be
   * - been
   * - is
   * - that
   * - which
   * - and
   * - has
   * - have
   * - with
   * - at
   * - of
   * - same
   *
   * @name language chains
   * @api public
   */

  [ 'to', 'be', 'been'
  , 'is', 'and', 'has', 'have'
  , 'with', 'that', 'which', 'at'
  , 'of', 'same' ].forEach(function (chain) {
    Assertion.addProperty(chain, function () {
      return this;
    });
  });

  /**
   * ### .not
   *
   * Negates any of assertions following in the chain.
   *
   *     expect(foo).to.not.equal('bar');
   *     expect(goodFn).to.not.throw(Error);
   *     expect({ foo: 'baz' }).to.have.property('foo')
   *       .and.not.equal('bar');
   *
   * @name not
   * @api public
   */

  Assertion.addProperty('not', function () {
    flag(this, 'negate', true);
  });

  /**
   * ### .deep
   *
   * Sets the `deep` flag, later used by the `equal` and
   * `property` assertions.
   *
   *     expect(foo).to.deep.equal({ bar: 'baz' });
   *     expect({ foo: { bar: { baz: 'quux' } } })
   *       .to.have.deep.property('foo.bar.baz', 'quux');
   *
   * `.deep.property` special characters can be escaped
   * by adding two slashes before the `.` or `[]`.
   *
   *     var deepCss = { '.link': { '[target]': 42 }};
   *     expect(deepCss).to.have.deep.property('\\.link.\\[target\\]', 42);
   *
   * @name deep
   * @api public
   */

  Assertion.addProperty('deep', function () {
    flag(this, 'deep', true);
  });

  /**
   * ### .any
   *
   * Sets the `any` flag, (opposite of the `all` flag)
   * later used in the `keys` assertion.
   *
   *     expect(foo).to.have.any.keys('bar', 'baz');
   *
   * @name any
   * @api public
   */

  Assertion.addProperty('any', function () {
    flag(this, 'any', true);
    flag(this, 'all', false)
  });


  /**
   * ### .all
   *
   * Sets the `all` flag (opposite of the `any` flag)
   * later used by the `keys` assertion.
   *
   *     expect(foo).to.have.all.keys('bar', 'baz');
   *
   * @name all
   * @api public
   */

  Assertion.addProperty('all', function () {
    flag(this, 'all', true);
    flag(this, 'any', false);
  });

  /**
   * ### .a(type)
   *
   * The `a` and `an` assertions are aliases that can be
   * used either as language chains or to assert a value's
   * type.
   *
   *     // typeof
   *     expect('test').to.be.a('string');
   *     expect({ foo: 'bar' }).to.be.an('object');
   *     expect(null).to.be.a('null');
   *     expect(undefined).to.be.an('undefined');
   *     expect(new Promise).to.be.a('promise');
   *     expect(new Float32Array()).to.be.a('float32array');
   *     expect(Symbol()).to.be.a('symbol');
   *
   *     // es6 overrides
   *     expect({[Symbol.toStringTag]:()=>'foo'}).to.be.a('foo');
   *
   *     // language chain
   *     expect(foo).to.be.an.instanceof(Foo);
   *
   * @name a
   * @alias an
   * @param {String} type
   * @param {String} message _optional_
   * @api public
   */

  function an (type, msg) {
    if (msg) flag(this, 'message', msg);
    type = type.toLowerCase();
    var obj = flag(this, 'object')
      , article = ~[ 'a', 'e', 'i', 'o', 'u' ].indexOf(type.charAt(0)) ? 'an ' : 'a ';

    this.assert(
        type === _.type(obj)
      , 'expected #{this} to be ' + article + type
      , 'expected #{this} not to be ' + article + type
    );
  }

  Assertion.addChainableMethod('an', an);
  Assertion.addChainableMethod('a', an);

  /**
   * ### .include(value)
   *
   * The `include` and `contain` assertions can be used as either property
   * based language chains or as methods to assert the inclusion of an object
   * in an array or a substring in a string. When used as language chains,
   * they toggle the `contains` flag for the `keys` assertion.
   *
   *     expect([1,2,3]).to.include(2);
   *     expect('foobar').to.contain('foo');
   *     expect({ foo: 'bar', hello: 'universe' }).to.include.keys('foo');
   *
   * @name include
   * @alias contain
   * @alias includes
   * @alias contains
   * @param {Object|String|Number} obj
   * @param {String} message _optional_
   * @api public
   */

  function includeChainingBehavior () {
    flag(this, 'contains', true);
  }

  function include (val, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    var expected = false;
    if (_.type(obj) === 'array' && _.type(val) === 'object') {
      for (var i in obj) {
        if (_.eql(obj[i], val)) {
          expected = true;
          break;
        }
      }
    } else if (_.type(val) === 'object') {
      if (!flag(this, 'negate')) {
        for (var k in val) new Assertion(obj).property(k, val[k]);
        return;
      }
      var subset = {};
      for (var k in val) subset[k] = obj[k];
      expected = _.eql(subset, val);
    } else {
      expected = obj && ~obj.indexOf(val);
    }
    this.assert(
        expected
      , 'expected #{this} to include ' + _.inspect(val)
      , 'expected #{this} to not include ' + _.inspect(val));
  }

  Assertion.addChainableMethod('include', include, includeChainingBehavior);
  Assertion.addChainableMethod('contain', include, includeChainingBehavior);
  Assertion.addChainableMethod('contains', include, includeChainingBehavior);
  Assertion.addChainableMethod('includes', include, includeChainingBehavior);

  /**
   * ### .ok
   *
   * Asserts that the target is truthy.
   *
   *     expect('everthing').to.be.ok;
   *     expect(1).to.be.ok;
   *     expect(false).to.not.be.ok;
   *     expect(undefined).to.not.be.ok;
   *     expect(null).to.not.be.ok;
   *
   * @name ok
   * @api public
   */

  Assertion.addProperty('ok', function () {
    this.assert(
        flag(this, 'object')
      , 'expected #{this} to be truthy'
      , 'expected #{this} to be falsy');
  });

  /**
   * ### .true
   *
   * Asserts that the target is `true`.
   *
   *     expect(true).to.be.true;
   *     expect(1).to.not.be.true;
   *
   * @name true
   * @api public
   */

  Assertion.addProperty('true', function () {
    this.assert(
        true === flag(this, 'object')
      , 'expected #{this} to be true'
      , 'expected #{this} to be false'
      , this.negate ? false : true
    );
  });

  /**
   * ### .false
   *
   * Asserts that the target is `false`.
   *
   *     expect(false).to.be.false;
   *     expect(0).to.not.be.false;
   *
   * @name false
   * @api public
   */

  Assertion.addProperty('false', function () {
    this.assert(
        false === flag(this, 'object')
      , 'expected #{this} to be false'
      , 'expected #{this} to be true'
      , this.negate ? true : false
    );
  });

  /**
   * ### .null
   *
   * Asserts that the target is `null`.
   *
   *     expect(null).to.be.null;
   *     expect(undefined).to.not.be.null;
   *
   * @name null
   * @api public
   */

  Assertion.addProperty('null', function () {
    this.assert(
        null === flag(this, 'object')
      , 'expected #{this} to be null'
      , 'expected #{this} not to be null'
    );
  });

  /**
   * ### .undefined
   *
   * Asserts that the target is `undefined`.
   *
   *     expect(undefined).to.be.undefined;
   *     expect(null).to.not.be.undefined;
   *
   * @name undefined
   * @api public
   */

  Assertion.addProperty('undefined', function () {
    this.assert(
        undefined === flag(this, 'object')
      , 'expected #{this} to be undefined'
      , 'expected #{this} not to be undefined'
    );
  });

  /**
   * ### .NaN
   * Asserts that the target is `NaN`.
   *
   *     expect('foo').to.be.NaN;
   *     expect(4).not.to.be.NaN;
   *
   * @name NaN
   * @api public
   */

  Assertion.addProperty('NaN', function () {
    this.assert(
        isNaN(flag(this, 'object'))
        , 'expected #{this} to be NaN'
        , 'expected #{this} not to be NaN'
    );
  });

  /**
   * ### .exist
   *
   * Asserts that the target is neither `null` nor `undefined`.
   *
   *     var foo = 'hi'
   *       , bar = null
   *       , baz;
   *
   *     expect(foo).to.exist;
   *     expect(bar).to.not.exist;
   *     expect(baz).to.not.exist;
   *
   * @name exist
   * @api public
   */

  Assertion.addProperty('exist', function () {
    this.assert(
        null != flag(this, 'object')
      , 'expected #{this} to exist'
      , 'expected #{this} to not exist'
    );
  });


  /**
   * ### .empty
   *
   * Asserts that the target's length is `0`. For arrays and strings, it checks
   * the `length` property. For objects, it gets the count of
   * enumerable keys.
   *
   *     expect([]).to.be.empty;
   *     expect('').to.be.empty;
   *     expect({}).to.be.empty;
   *
   * @name empty
   * @api public
   */

  Assertion.addProperty('empty', function () {
    var obj = flag(this, 'object')
      , expected = obj;

    if (Array.isArray(obj) || 'string' === typeof object) {
      expected = obj.length;
    } else if (typeof obj === 'object') {
      expected = Object.keys(obj).length;
    }

    this.assert(
        !expected
      , 'expected #{this} to be empty'
      , 'expected #{this} not to be empty'
    );
  });

  /**
   * ### .arguments
   *
   * Asserts that the target is an arguments object.
   *
   *     function test () {
   *       expect(arguments).to.be.arguments;
   *     }
   *
   * @name arguments
   * @alias Arguments
   * @api public
   */

  function checkArguments () {
    var obj = flag(this, 'object')
      , type = Object.prototype.toString.call(obj);
    this.assert(
        '[object Arguments]' === type
      , 'expected #{this} to be arguments but got ' + type
      , 'expected #{this} to not be arguments'
    );
  }

  Assertion.addProperty('arguments', checkArguments);
  Assertion.addProperty('Arguments', checkArguments);

  /**
   * ### .equal(value)
   *
   * Asserts that the target is strictly equal (`===`) to `value`.
   * Alternately, if the `deep` flag is set, asserts that
   * the target is deeply equal to `value`.
   *
   *     expect('hello').to.equal('hello');
   *     expect(42).to.equal(42);
   *     expect(1).to.not.equal(true);
   *     expect({ foo: 'bar' }).to.not.equal({ foo: 'bar' });
   *     expect({ foo: 'bar' }).to.deep.equal({ foo: 'bar' });
   *
   * @name equal
   * @alias equals
   * @alias eq
   * @alias deep.equal
   * @param {Mixed} value
   * @param {String} message _optional_
   * @api public
   */

  function assertEqual (val, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    if (flag(this, 'deep')) {
      return this.eql(val);
    } else {
      this.assert(
          val === obj
        , 'expected #{this} to equal #{exp}'
        , 'expected #{this} to not equal #{exp}'
        , val
        , this._obj
        , true
      );
    }
  }

  Assertion.addMethod('equal', assertEqual);
  Assertion.addMethod('equals', assertEqual);
  Assertion.addMethod('eq', assertEqual);

  /**
   * ### .eql(value)
   *
   * Asserts that the target is deeply equal to `value`.
   *
   *     expect({ foo: 'bar' }).to.eql({ foo: 'bar' });
   *     expect([ 1, 2, 3 ]).to.eql([ 1, 2, 3 ]);
   *
   * @name eql
   * @alias eqls
   * @param {Mixed} value
   * @param {String} message _optional_
   * @api public
   */

  function assertEql(obj, msg) {
    if (msg) flag(this, 'message', msg);
    this.assert(
        _.eql(obj, flag(this, 'object'))
      , 'expected #{this} to deeply equal #{exp}'
      , 'expected #{this} to not deeply equal #{exp}'
      , obj
      , this._obj
      , true
    );
  }

  Assertion.addMethod('eql', assertEql);
  Assertion.addMethod('eqls', assertEql);

  /**
   * ### .above(value)
   *
   * Asserts that the target is greater than `value`.
   *
   *     expect(10).to.be.above(5);
   *
   * Can also be used in conjunction with `length` to
   * assert a minimum length. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.above(2);
   *     expect([ 1, 2, 3 ]).to.have.length.above(2);
   *
   * @name above
   * @alias gt
   * @alias greaterThan
   * @param {Number} value
   * @param {String} message _optional_
   * @api public
   */

  function assertAbove (n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    if (flag(this, 'doLength')) {
      new Assertion(obj, msg).to.have.property('length');
      var len = obj.length;
      this.assert(
          len > n
        , 'expected #{this} to have a length above #{exp} but got #{act}'
        , 'expected #{this} to not have a length above #{exp}'
        , n
        , len
      );
    } else {
      this.assert(
          obj > n
        , 'expected #{this} to be above ' + n
        , 'expected #{this} to be at most ' + n
      );
    }
  }

  Assertion.addMethod('above', assertAbove);
  Assertion.addMethod('gt', assertAbove);
  Assertion.addMethod('greaterThan', assertAbove);

  /**
   * ### .least(value)
   *
   * Asserts that the target is greater than or equal to `value`.
   *
   *     expect(10).to.be.at.least(10);
   *
   * Can also be used in conjunction with `length` to
   * assert a minimum length. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.of.at.least(2);
   *     expect([ 1, 2, 3 ]).to.have.length.of.at.least(3);
   *
   * @name least
   * @alias gte
   * @param {Number} value
   * @param {String} message _optional_
   * @api public
   */

  function assertLeast (n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    if (flag(this, 'doLength')) {
      new Assertion(obj, msg).to.have.property('length');
      var len = obj.length;
      this.assert(
          len >= n
        , 'expected #{this} to have a length at least #{exp} but got #{act}'
        , 'expected #{this} to have a length below #{exp}'
        , n
        , len
      );
    } else {
      this.assert(
          obj >= n
        , 'expected #{this} to be at least ' + n
        , 'expected #{this} to be below ' + n
      );
    }
  }

  Assertion.addMethod('least', assertLeast);
  Assertion.addMethod('gte', assertLeast);

  /**
   * ### .below(value)
   *
   * Asserts that the target is less than `value`.
   *
   *     expect(5).to.be.below(10);
   *
   * Can also be used in conjunction with `length` to
   * assert a maximum length. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.below(4);
   *     expect([ 1, 2, 3 ]).to.have.length.below(4);
   *
   * @name below
   * @alias lt
   * @alias lessThan
   * @param {Number} value
   * @param {String} message _optional_
   * @api public
   */

  function assertBelow (n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    if (flag(this, 'doLength')) {
      new Assertion(obj, msg).to.have.property('length');
      var len = obj.length;
      this.assert(
          len < n
        , 'expected #{this} to have a length below #{exp} but got #{act}'
        , 'expected #{this} to not have a length below #{exp}'
        , n
        , len
      );
    } else {
      this.assert(
          obj < n
        , 'expected #{this} to be below ' + n
        , 'expected #{this} to be at least ' + n
      );
    }
  }

  Assertion.addMethod('below', assertBelow);
  Assertion.addMethod('lt', assertBelow);
  Assertion.addMethod('lessThan', assertBelow);

  /**
   * ### .most(value)
   *
   * Asserts that the target is less than or equal to `value`.
   *
   *     expect(5).to.be.at.most(5);
   *
   * Can also be used in conjunction with `length` to
   * assert a maximum length. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.of.at.most(4);
   *     expect([ 1, 2, 3 ]).to.have.length.of.at.most(3);
   *
   * @name most
   * @alias lte
   * @param {Number} value
   * @param {String} message _optional_
   * @api public
   */

  function assertMost (n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    if (flag(this, 'doLength')) {
      new Assertion(obj, msg).to.have.property('length');
      var len = obj.length;
      this.assert(
          len <= n
        , 'expected #{this} to have a length at most #{exp} but got #{act}'
        , 'expected #{this} to have a length above #{exp}'
        , n
        , len
      );
    } else {
      this.assert(
          obj <= n
        , 'expected #{this} to be at most ' + n
        , 'expected #{this} to be above ' + n
      );
    }
  }

  Assertion.addMethod('most', assertMost);
  Assertion.addMethod('lte', assertMost);

  /**
   * ### .within(start, finish)
   *
   * Asserts that the target is within a range.
   *
   *     expect(7).to.be.within(5,10);
   *
   * Can also be used in conjunction with `length` to
   * assert a length range. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.within(2,4);
   *     expect([ 1, 2, 3 ]).to.have.length.within(2,4);
   *
   * @name within
   * @param {Number} start lowerbound inclusive
   * @param {Number} finish upperbound inclusive
   * @param {String} message _optional_
   * @api public
   */

  Assertion.addMethod('within', function (start, finish, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object')
      , range = start + '..' + finish;
    if (flag(this, 'doLength')) {
      new Assertion(obj, msg).to.have.property('length');
      var len = obj.length;
      this.assert(
          len >= start && len <= finish
        , 'expected #{this} to have a length within ' + range
        , 'expected #{this} to not have a length within ' + range
      );
    } else {
      this.assert(
          obj >= start && obj <= finish
        , 'expected #{this} to be within ' + range
        , 'expected #{this} to not be within ' + range
      );
    }
  });

  /**
   * ### .instanceof(constructor)
   *
   * Asserts that the target is an instance of `constructor`.
   *
   *     var Tea = function (name) { this.name = name; }
   *       , Chai = new Tea('chai');
   *
   *     expect(Chai).to.be.an.instanceof(Tea);
   *     expect([ 1, 2, 3 ]).to.be.instanceof(Array);
   *
   * @name instanceof
   * @param {Constructor} constructor
   * @param {String} message _optional_
   * @alias instanceOf
   * @api public
   */

  function assertInstanceOf (constructor, msg) {
    if (msg) flag(this, 'message', msg);
    var name = _.getName(constructor);
    this.assert(
        flag(this, 'object') instanceof constructor
      , 'expected #{this} to be an instance of ' + name
      , 'expected #{this} to not be an instance of ' + name
    );
  };

  Assertion.addMethod('instanceof', assertInstanceOf);
  Assertion.addMethod('instanceOf', assertInstanceOf);

  /**
   * ### .property(name, [value])
   *
   * Asserts that the target has a property `name`, optionally asserting that
   * the value of that property is strictly equal to  `value`.
   * If the `deep` flag is set, you can use dot- and bracket-notation for deep
   * references into objects and arrays.
   *
   *     // simple referencing
   *     var obj = { foo: 'bar' };
   *     expect(obj).to.have.property('foo');
   *     expect(obj).to.have.property('foo', 'bar');
   *
   *     // deep referencing
   *     var deepObj = {
   *         green: { tea: 'matcha' }
   *       , teas: [ 'chai', 'matcha', { tea: 'konacha' } ]
   *     };
   *
   *     expect(deepObj).to.have.deep.property('green.tea', 'matcha');
   *     expect(deepObj).to.have.deep.property('teas[1]', 'matcha');
   *     expect(deepObj).to.have.deep.property('teas[2].tea', 'konacha');
   *
   * You can also use an array as the starting point of a `deep.property`
   * assertion, or traverse nested arrays.
   *
   *     var arr = [
   *         [ 'chai', 'matcha', 'konacha' ]
   *       , [ { tea: 'chai' }
   *         , { tea: 'matcha' }
   *         , { tea: 'konacha' } ]
   *     ];
   *
   *     expect(arr).to.have.deep.property('[0][1]', 'matcha');
   *     expect(arr).to.have.deep.property('[1][2].tea', 'konacha');
   *
   * Furthermore, `property` changes the subject of the assertion
   * to be the value of that property from the original object. This
   * permits for further chainable assertions on that property.
   *
   *     expect(obj).to.have.property('foo')
   *       .that.is.a('string');
   *     expect(deepObj).to.have.property('green')
   *       .that.is.an('object')
   *       .that.deep.equals({ tea: 'matcha' });
   *     expect(deepObj).to.have.property('teas')
   *       .that.is.an('array')
   *       .with.deep.property('[2]')
   *         .that.deep.equals({ tea: 'konacha' });
   *
   * Note that dots and bracket in `name` must be backslash-escaped when
   * the `deep` flag is set, while they must NOT be escaped when the `deep`
   * flag is not set.
   *
   *     // simple referencing
   *     var css = { '.link[target]': 42 };
   *     expect(css).to.have.property('.link[target]', 42);
   *
   *     // deep referencing
   *     var deepCss = { '.link': { '[target]': 42 }};
   *     expect(deepCss).to.have.deep.property('\\.link.\\[target\\]', 42);
   *
   * @name property
   * @alias deep.property
   * @param {String} name
   * @param {Mixed} value (optional)
   * @param {String} message _optional_
   * @returns value of property for chaining
   * @api public
   */

  Assertion.addMethod('property', function (name, val, msg) {
    if (msg) flag(this, 'message', msg);

    var isDeep = !!flag(this, 'deep')
      , descriptor = isDeep ? 'deep property ' : 'property '
      , negate = flag(this, 'negate')
      , obj = flag(this, 'object')
      , pathInfo = isDeep ? _.getPathInfo(name, obj) : null
      , hasProperty = isDeep
        ? pathInfo.exists
        : _.hasProperty(name, obj)
      , value = isDeep
        ? pathInfo.value
        : obj[name];

    if (negate && arguments.length > 1) {
      if (undefined === value) {
        msg = (msg != null) ? msg + ': ' : '';
        throw new Error(msg + _.inspect(obj) + ' has no ' + descriptor + _.inspect(name));
      }
    } else {
      this.assert(
          hasProperty
        , 'expected #{this} to have a ' + descriptor + _.inspect(name)
        , 'expected #{this} to not have ' + descriptor + _.inspect(name));
    }

    if (arguments.length > 1) {
      this.assert(
          val === value
        , 'expected #{this} to have a ' + descriptor + _.inspect(name) + ' of #{exp}, but got #{act}'
        , 'expected #{this} to not have a ' + descriptor + _.inspect(name) + ' of #{act}'
        , val
        , value
      );
    }

    flag(this, 'object', value);
  });


  /**
   * ### .ownProperty(name)
   *
   * Asserts that the target has an own property `name`.
   *
   *     expect('test').to.have.ownProperty('length');
   *
   * @name ownProperty
   * @alias haveOwnProperty
   * @param {String} name
   * @param {String} message _optional_
   * @api public
   */

  function assertOwnProperty (name, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    this.assert(
        obj.hasOwnProperty(name)
      , 'expected #{this} to have own property ' + _.inspect(name)
      , 'expected #{this} to not have own property ' + _.inspect(name)
    );
  }

  Assertion.addMethod('ownProperty', assertOwnProperty);
  Assertion.addMethod('haveOwnProperty', assertOwnProperty);

  /**
   * ### .ownPropertyDescriptor(name[, descriptor[, message]])
   *
   * Asserts that the target has an own property descriptor `name`, that optionally matches `descriptor`.
   *
   *     expect('test').to.have.ownPropertyDescriptor('length');
   *     expect('test').to.have.ownPropertyDescriptor('length', { enumerable: false, configurable: false, writable: false, value: 4 });
   *     expect('test').not.to.have.ownPropertyDescriptor('length', { enumerable: false, configurable: false, writable: false, value: 3 });
   *     expect('test').ownPropertyDescriptor('length').to.have.property('enumerable', false);
   *     expect('test').ownPropertyDescriptor('length').to.have.keys('value');
   *
   * @name ownPropertyDescriptor
   * @alias haveOwnPropertyDescriptor
   * @param {String} name
   * @param {Object} descriptor _optional_
   * @param {String} message _optional_
   * @api public
   */

  function assertOwnPropertyDescriptor (name, descriptor, msg) {
    if (typeof descriptor === 'string') {
      msg = descriptor;
      descriptor = null;
    }
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    var actualDescriptor = Object.getOwnPropertyDescriptor(Object(obj), name);
    if (actualDescriptor && descriptor) {
      this.assert(
          _.eql(descriptor, actualDescriptor)
        , 'expected the own property descriptor for ' + _.inspect(name) + ' on #{this} to match ' + _.inspect(descriptor) + ', got ' + _.inspect(actualDescriptor)
        , 'expected the own property descriptor for ' + _.inspect(name) + ' on #{this} to not match ' + _.inspect(descriptor)
        , descriptor
        , actualDescriptor
        , true
      );
    } else {
      this.assert(
          actualDescriptor
        , 'expected #{this} to have an own property descriptor for ' + _.inspect(name)
        , 'expected #{this} to not have an own property descriptor for ' + _.inspect(name)
      );
    }
    flag(this, 'object', actualDescriptor);
  }

  Assertion.addMethod('ownPropertyDescriptor', assertOwnPropertyDescriptor);
  Assertion.addMethod('haveOwnPropertyDescriptor', assertOwnPropertyDescriptor);

  /**
   * ### .length
   *
   * Sets the `doLength` flag later used as a chain precursor to a value
   * comparison for the `length` property.
   *
   *     expect('foo').to.have.length.above(2);
   *     expect([ 1, 2, 3 ]).to.have.length.above(2);
   *     expect('foo').to.have.length.below(4);
   *     expect([ 1, 2, 3 ]).to.have.length.below(4);
   *     expect('foo').to.have.length.within(2,4);
   *     expect([ 1, 2, 3 ]).to.have.length.within(2,4);
   *
   * *Deprecation notice:* Using `length` as an assertion will be deprecated
   * in version 2.4.0 and removed in 3.0.0. Code using the old style of
   * asserting for `length` property value using `length(value)` should be
   * switched to use `lengthOf(value)` instead.
   *
   * @name length
   * @api public
   */

  /**
   * ### .lengthOf(value[, message])
   *
   * Asserts that the target's `length` property has
   * the expected value.
   *
   *     expect([ 1, 2, 3]).to.have.lengthOf(3);
   *     expect('foobar').to.have.lengthOf(6);
   *
   * @name lengthOf
   * @param {Number} length
   * @param {String} message _optional_
   * @api public
   */

  function assertLengthChain () {
    flag(this, 'doLength', true);
  }

  function assertLength (n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    new Assertion(obj, msg).to.have.property('length');
    var len = obj.length;

    this.assert(
        len == n
      , 'expected #{this} to have a length of #{exp} but got #{act}'
      , 'expected #{this} to not have a length of #{act}'
      , n
      , len
    );
  }

  Assertion.addChainableMethod('length', assertLength, assertLengthChain);
  Assertion.addMethod('lengthOf', assertLength);

  /**
   * ### .match(regexp)
   *
   * Asserts that the target matches a regular expression.
   *
   *     expect('foobar').to.match(/^foo/);
   *
   * @name match
   * @alias matches
   * @param {RegExp} RegularExpression
   * @param {String} message _optional_
   * @api public
   */
  function assertMatch(re, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    this.assert(
        re.exec(obj)
      , 'expected #{this} to match ' + re
      , 'expected #{this} not to match ' + re
    );
  }

  Assertion.addMethod('match', assertMatch);
  Assertion.addMethod('matches', assertMatch);

  /**
   * ### .string(string)
   *
   * Asserts that the string target contains another string.
   *
   *     expect('foobar').to.have.string('bar');
   *
   * @name string
   * @param {String} string
   * @param {String} message _optional_
   * @api public
   */

  Assertion.addMethod('string', function (str, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    new Assertion(obj, msg).is.a('string');

    this.assert(
        ~obj.indexOf(str)
      , 'expected #{this} to contain ' + _.inspect(str)
      , 'expected #{this} to not contain ' + _.inspect(str)
    );
  });


  /**
   * ### .keys(key1, [key2], [...])
   *
   * Asserts that the target contains any or all of the passed-in keys.
   * Use in combination with `any`, `all`, `contains`, or `have` will affect
   * what will pass.
   *
   * When used in conjunction with `any`, at least one key that is passed
   * in must exist in the target object. This is regardless whether or not
   * the `have` or `contain` qualifiers are used. Note, either `any` or `all`
   * should be used in the assertion. If neither are used, the assertion is
   * defaulted to `all`.
   *
   * When both `all` and `contain` are used, the target object must have at
   * least all of the passed-in keys but may have more keys not listed.
   *
   * When both `all` and `have` are used, the target object must both contain
   * all of the passed-in keys AND the number of keys in the target object must
   * match the number of keys passed in (in other words, a target object must
   * have all and only all of the passed-in keys).
   *
   *     expect({ foo: 1, bar: 2 }).to.have.any.keys('foo', 'baz');
   *     expect({ foo: 1, bar: 2 }).to.have.any.keys('foo');
   *     expect({ foo: 1, bar: 2 }).to.contain.any.keys('bar', 'baz');
   *     expect({ foo: 1, bar: 2 }).to.contain.any.keys(['foo']);
   *     expect({ foo: 1, bar: 2 }).to.contain.any.keys({'foo': 6});
   *     expect({ foo: 1, bar: 2 }).to.have.all.keys(['bar', 'foo']);
   *     expect({ foo: 1, bar: 2 }).to.have.all.keys({'bar': 6, 'foo': 7});
   *     expect({ foo: 1, bar: 2, baz: 3 }).to.contain.all.keys(['bar', 'foo']);
   *     expect({ foo: 1, bar: 2, baz: 3 }).to.contain.all.keys({'bar': 6});
   *
   *
   * @name keys
   * @alias key
   * @param {String...|Array|Object} keys
   * @api public
   */

  function assertKeys (keys) {
    var obj = flag(this, 'object')
      , str
      , ok = true
      , mixedArgsMsg = 'keys must be given single argument of Array|Object|String, or multiple String arguments';

    switch (_.type(keys)) {
      case "array":
        if (arguments.length > 1) throw (new Error(mixedArgsMsg));
        break;
      case "object":
        if (arguments.length > 1) throw (new Error(mixedArgsMsg));
        keys = Object.keys(keys);
        break;
      default:
        keys = Array.prototype.slice.call(arguments);
    }

    if (!keys.length) throw new Error('keys required');

    var actual = Object.keys(obj)
      , expected = keys
      , len = keys.length
      , any = flag(this, 'any')
      , all = flag(this, 'all');

    if (!any && !all) {
      all = true;
    }

    // Has any
    if (any) {
      var intersection = expected.filter(function(key) {
        return ~actual.indexOf(key);
      });
      ok = intersection.length > 0;
    }

    // Has all
    if (all) {
      ok = keys.every(function(key){
        return ~actual.indexOf(key);
      });
      if (!flag(this, 'negate') && !flag(this, 'contains')) {
        ok = ok && keys.length == actual.length;
      }
    }

    // Key string
    if (len > 1) {
      keys = keys.map(function(key){
        return _.inspect(key);
      });
      var last = keys.pop();
      if (all) {
        str = keys.join(', ') + ', and ' + last;
      }
      if (any) {
        str = keys.join(', ') + ', or ' + last;
      }
    } else {
      str = _.inspect(keys[0]);
    }

    // Form
    str = (len > 1 ? 'keys ' : 'key ') + str;

    // Have / include
    str = (flag(this, 'contains') ? 'contain ' : 'have ') + str;

    // Assertion
    this.assert(
        ok
      , 'expected #{this} to ' + str
      , 'expected #{this} to not ' + str
      , expected.slice(0).sort()
      , actual.sort()
      , true
    );
  }

  Assertion.addMethod('keys', assertKeys);
  Assertion.addMethod('key', assertKeys);

  /**
   * ### .throw(constructor)
   *
   * Asserts that the function target will throw a specific error, or specific type of error
   * (as determined using `instanceof`), optionally with a RegExp or string inclusion test
   * for the error's message.
   *
   *     var err = new ReferenceError('This is a bad function.');
   *     var fn = function () { throw err; }
   *     expect(fn).to.throw(ReferenceError);
   *     expect(fn).to.throw(Error);
   *     expect(fn).to.throw(/bad function/);
   *     expect(fn).to.not.throw('good function');
   *     expect(fn).to.throw(ReferenceError, /bad function/);
   *     expect(fn).to.throw(err);
   *     expect(fn).to.not.throw(new RangeError('Out of range.'));
   *
   * Please note that when a throw expectation is negated, it will check each
   * parameter independently, starting with error constructor type. The appropriate way
   * to check for the existence of a type of error but for a message that does not match
   * is to use `and`.
   *
   *     expect(fn).to.throw(ReferenceError)
   *        .and.not.throw(/good function/);
   *
   * @name throw
   * @alias throws
   * @alias Throw
   * @param {ErrorConstructor} constructor
   * @param {String|RegExp} expected error message
   * @param {String} message _optional_
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @returns error for chaining (null if no error)
   * @api public
   */

  function assertThrows (constructor, errMsg, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    new Assertion(obj, msg).is.a('function');

    var thrown = false
      , desiredError = null
      , name = null
      , thrownError = null;

    if (arguments.length === 0) {
      errMsg = null;
      constructor = null;
    } else if (constructor && (constructor instanceof RegExp || 'string' === typeof constructor)) {
      errMsg = constructor;
      constructor = null;
    } else if (constructor && constructor instanceof Error) {
      desiredError = constructor;
      constructor = null;
      errMsg = null;
    } else if (typeof constructor === 'function') {
      name = constructor.prototype.name || constructor.name;
      if (name === 'Error' && constructor !== Error) {
        name = (new constructor()).name;
      }
    } else {
      constructor = null;
    }

    try {
      obj();
    } catch (err) {
      // first, check desired error
      if (desiredError) {
        this.assert(
            err === desiredError
          , 'expected #{this} to throw #{exp} but #{act} was thrown'
          , 'expected #{this} to not throw #{exp}'
          , (desiredError instanceof Error ? desiredError.toString() : desiredError)
          , (err instanceof Error ? err.toString() : err)
        );

        flag(this, 'object', err);
        return this;
      }

      // next, check constructor
      if (constructor) {
        this.assert(
            err instanceof constructor
          , 'expected #{this} to throw #{exp} but #{act} was thrown'
          , 'expected #{this} to not throw #{exp} but #{act} was thrown'
          , name
          , (err instanceof Error ? err.toString() : err)
        );

        if (!errMsg) {
          flag(this, 'object', err);
          return this;
        }
      }

      // next, check message
      var message = 'error' === _.type(err) && "message" in err
        ? err.message
        : '' + err;

      if ((message != null) && errMsg && errMsg instanceof RegExp) {
        this.assert(
            errMsg.exec(message)
          , 'expected #{this} to throw error matching #{exp} but got #{act}'
          , 'expected #{this} to throw error not matching #{exp}'
          , errMsg
          , message
        );

        flag(this, 'object', err);
        return this;
      } else if ((message != null) && errMsg && 'string' === typeof errMsg) {
        this.assert(
            ~message.indexOf(errMsg)
          , 'expected #{this} to throw error including #{exp} but got #{act}'
          , 'expected #{this} to throw error not including #{act}'
          , errMsg
          , message
        );

        flag(this, 'object', err);
        return this;
      } else {
        thrown = true;
        thrownError = err;
      }
    }

    var actuallyGot = ''
      , expectedThrown = name !== null
        ? name
        : desiredError
          ? '#{exp}' //_.inspect(desiredError)
          : 'an error';

    if (thrown) {
      actuallyGot = ' but #{act} was thrown'
    }

    this.assert(
        thrown === true
      , 'expected #{this} to throw ' + expectedThrown + actuallyGot
      , 'expected #{this} to not throw ' + expectedThrown + actuallyGot
      , (desiredError instanceof Error ? desiredError.toString() : desiredError)
      , (thrownError instanceof Error ? thrownError.toString() : thrownError)
    );

    flag(this, 'object', thrownError);
  };

  Assertion.addMethod('throw', assertThrows);
  Assertion.addMethod('throws', assertThrows);
  Assertion.addMethod('Throw', assertThrows);

  /**
   * ### .respondTo(method)
   *
   * Asserts that the object or class target will respond to a method.
   *
   *     Klass.prototype.bar = function(){};
   *     expect(Klass).to.respondTo('bar');
   *     expect(obj).to.respondTo('bar');
   *
   * To check if a constructor will respond to a static function,
   * set the `itself` flag.
   *
   *     Klass.baz = function(){};
   *     expect(Klass).itself.to.respondTo('baz');
   *
   * @name respondTo
   * @alias respondsTo
   * @param {String} method
   * @param {String} message _optional_
   * @api public
   */

  function respondTo (method, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object')
      , itself = flag(this, 'itself')
      , context = ('function' === _.type(obj) && !itself)
        ? obj.prototype[method]
        : obj[method];

    this.assert(
        'function' === typeof context
      , 'expected #{this} to respond to ' + _.inspect(method)
      , 'expected #{this} to not respond to ' + _.inspect(method)
    );
  }

  Assertion.addMethod('respondTo', respondTo);
  Assertion.addMethod('respondsTo', respondTo);

  /**
   * ### .itself
   *
   * Sets the `itself` flag, later used by the `respondTo` assertion.
   *
   *     function Foo() {}
   *     Foo.bar = function() {}
   *     Foo.prototype.baz = function() {}
   *
   *     expect(Foo).itself.to.respondTo('bar');
   *     expect(Foo).itself.not.to.respondTo('baz');
   *
   * @name itself
   * @api public
   */

  Assertion.addProperty('itself', function () {
    flag(this, 'itself', true);
  });

  /**
   * ### .satisfy(method)
   *
   * Asserts that the target passes a given truth test.
   *
   *     expect(1).to.satisfy(function(num) { return num > 0; });
   *
   * @name satisfy
   * @alias satisfies
   * @param {Function} matcher
   * @param {String} message _optional_
   * @api public
   */

  function satisfy (matcher, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    var result = matcher(obj);
    this.assert(
        result
      , 'expected #{this} to satisfy ' + _.objDisplay(matcher)
      , 'expected #{this} to not satisfy' + _.objDisplay(matcher)
      , this.negate ? false : true
      , result
    );
  }
  
  Assertion.addMethod('satisfy', satisfy);
  Assertion.addMethod('satisfies', satisfy);

  /**
   * ### .closeTo(expected, delta)
   *
   * Asserts that the target is equal `expected`, to within a +/- `delta` range.
   *
   *     expect(1.5).to.be.closeTo(1, 0.5);
   *
   * @name closeTo
   * @param {Number} expected
   * @param {Number} delta
   * @param {String} message _optional_
   * @api public
   */

  Assertion.addMethod('closeTo', function (expected, delta, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');

    new Assertion(obj, msg).is.a('number');
    if (_.type(expected) !== 'number' || _.type(delta) !== 'number') {
      throw new Error('the arguments to closeTo must be numbers');
    }

    this.assert(
        Math.abs(obj - expected) <= delta
      , 'expected #{this} to be close to ' + expected + ' +/- ' + delta
      , 'expected #{this} not to be close to ' + expected + ' +/- ' + delta
    );
  });

  function isSubsetOf(subset, superset, cmp) {
    return subset.every(function(elem) {
      if (!cmp) return superset.indexOf(elem) !== -1;

      return superset.some(function(elem2) {
        return cmp(elem, elem2);
      });
    })
  }

  /**
   * ### .members(set)
   *
   * Asserts that the target is a superset of `set`,
   * or that the target and `set` have the same strictly-equal (===) members.
   * Alternately, if the `deep` flag is set, set members are compared for deep
   * equality.
   *
   *     expect([1, 2, 3]).to.include.members([3, 2]);
   *     expect([1, 2, 3]).to.not.include.members([3, 2, 8]);
   *
   *     expect([4, 2]).to.have.members([2, 4]);
   *     expect([5, 2]).to.not.have.members([5, 2, 1]);
   *
   *     expect([{ id: 1 }]).to.deep.include.members([{ id: 1 }]);
   *
   * @name members
   * @param {Array} set
   * @param {String} message _optional_
   * @api public
   */

  Assertion.addMethod('members', function (subset, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');

    new Assertion(obj).to.be.an('array');
    new Assertion(subset).to.be.an('array');

    var cmp = flag(this, 'deep') ? _.eql : undefined;

    if (flag(this, 'contains')) {
      return this.assert(
          isSubsetOf(subset, obj, cmp)
        , 'expected #{this} to be a superset of #{act}'
        , 'expected #{this} to not be a superset of #{act}'
        , obj
        , subset
      );
    }

    this.assert(
        isSubsetOf(obj, subset, cmp) && isSubsetOf(subset, obj, cmp)
        , 'expected #{this} to have the same members as #{act}'
        , 'expected #{this} to not have the same members as #{act}'
        , obj
        , subset
    );
  });

  /**
   * ### .change(function)
   *
   * Asserts that a function changes an object property
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val += 3 };
   *     var noChangeFn = function() { return 'foo' + 'bar'; }
   *     expect(fn).to.change(obj, 'val');
   *     expect(noChangFn).to.not.change(obj, 'val')
   *
   * @name change
   * @alias changes
   * @alias Change
   * @param {String} object
   * @param {String} property name
   * @param {String} message _optional_
   * @api public
   */

  function assertChanges (object, prop, msg) {
    if (msg) flag(this, 'message', msg);
    var fn = flag(this, 'object');
    new Assertion(object, msg).to.have.property(prop);
    new Assertion(fn).is.a('function');

    var initial = object[prop];
    fn();

    this.assert(
      initial !== object[prop]
      , 'expected .' + prop + ' to change'
      , 'expected .' + prop + ' to not change'
    );
  }

  Assertion.addChainableMethod('change', assertChanges);
  Assertion.addChainableMethod('changes', assertChanges);

  /**
   * ### .increase(function)
   *
   * Asserts that a function increases an object property
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 15 };
   *     expect(fn).to.increase(obj, 'val');
   *
   * @name increase
   * @alias increases
   * @alias Increase
   * @param {String} object
   * @param {String} property name
   * @param {String} message _optional_
   * @api public
   */

  function assertIncreases (object, prop, msg) {
    if (msg) flag(this, 'message', msg);
    var fn = flag(this, 'object');
    new Assertion(object, msg).to.have.property(prop);
    new Assertion(fn).is.a('function');

    var initial = object[prop];
    fn();

    this.assert(
      object[prop] - initial > 0
      , 'expected .' + prop + ' to increase'
      , 'expected .' + prop + ' to not increase'
    );
  }

  Assertion.addChainableMethod('increase', assertIncreases);
  Assertion.addChainableMethod('increases', assertIncreases);

  /**
   * ### .decrease(function)
   *
   * Asserts that a function decreases an object property
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 5 };
   *     expect(fn).to.decrease(obj, 'val');
   *
   * @name decrease
   * @alias decreases
   * @alias Decrease
   * @param {String} object
   * @param {String} property name
   * @param {String} message _optional_
   * @api public
   */

  function assertDecreases (object, prop, msg) {
    if (msg) flag(this, 'message', msg);
    var fn = flag(this, 'object');
    new Assertion(object, msg).to.have.property(prop);
    new Assertion(fn).is.a('function');

    var initial = object[prop];
    fn();

    this.assert(
      object[prop] - initial < 0
      , 'expected .' + prop + ' to decrease'
      , 'expected .' + prop + ' to not decrease'
    );
  }

  Assertion.addChainableMethod('decrease', assertDecreases);
  Assertion.addChainableMethod('decreases', assertDecreases);

  /**
   * ### .extensible
   *
   * Asserts that the target is extensible (can have new properties added to 
   * it).
   *
   *     var nonExtensibleObject = Object.preventExtensions({});
   *     var sealedObject = Object.seal({});
   *     var frozenObject = Object.freeze({});
   *
   *     expect({}).to.be.extensible;
   *     expect(nonExtensibleObject).to.not.be.extensible;
   *     expect(sealedObject).to.not.be.extensible;
   *     expect(frozenObject).to.not.be.extensible;
   *
   * @name extensible
   * @api public
   */

  Assertion.addProperty('extensible', function() {
    var obj = flag(this, 'object');

    this.assert(
      Object.isExtensible(obj)
      , 'expected #{this} to be extensible'
      , 'expected #{this} to not be extensible'
    );
  });

  /**
   * ### .sealed
   *
   * Asserts that the target is sealed (cannot have new properties added to it
   * and its existing properties cannot be removed).
   *
   *     var sealedObject = Object.seal({});
   *     var frozenObject = Object.freeze({});
   *
   *     expect(sealedObject).to.be.sealed;
   *     expect(frozenObject).to.be.sealed;
   *     expect({}).to.not.be.sealed;
   *
   * @name sealed
   * @api public
   */

  Assertion.addProperty('sealed', function() {
    var obj = flag(this, 'object');

    this.assert(
      Object.isSealed(obj)
      , 'expected #{this} to be sealed'
      , 'expected #{this} to not be sealed'
    );
  });

  /**
   * ### .frozen
   *
   * Asserts that the target is frozen (cannot have new properties added to it
   * and its existing properties cannot be modified).
   *
   *     var frozenObject = Object.freeze({});
   *
   *     expect(frozenObject).to.be.frozen;
   *     expect({}).to.not.be.frozen;
   *
   * @name frozen
   * @api public
   */

  Assertion.addProperty('frozen', function() {
    var obj = flag(this, 'object');

    this.assert(
      Object.isFrozen(obj)
      , 'expected #{this} to be frozen'
      , 'expected #{this} to not be frozen'
    );
  });

};

},{}],6:[function(require,module,exports){
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */


module.exports = function (chai, util) {

  /*!
   * Chai dependencies.
   */

  var Assertion = chai.Assertion
    , flag = util.flag;

  /*!
   * Module export.
   */

  /**
   * ### assert(expression, message)
   *
   * Write your own test expressions.
   *
   *     assert('foo' !== 'bar', 'foo is not bar');
   *     assert(Array.isArray([]), 'empty arrays are arrays');
   *
   * @param {Mixed} expression to test for truthiness
   * @param {String} message to display on error
   * @name assert
   * @api public
   */

  var assert = chai.assert = function (express, errmsg) {
    var test = new Assertion(null, null, chai.assert);
    test.assert(
        express
      , errmsg
      , '[ negation message unavailable ]'
    );
  };

  /**
   * ### .fail(actual, expected, [message], [operator])
   *
   * Throw a failure. Node.js `assert` module-compatible.
   *
   * @name fail
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @param {String} operator
   * @api public
   */

  assert.fail = function (actual, expected, message, operator) {
    message = message || 'assert.fail()';
    throw new chai.AssertionError(message, {
        actual: actual
      , expected: expected
      , operator: operator
    }, assert.fail);
  };

  /**
   * ### .isOk(object, [message])
   *
   * Asserts that `object` is truthy.
   *
   *     assert.isOk('everything', 'everything is ok');
   *     assert.isOk(false, 'this will fail');
   *
   * @name isOk
   * @alias ok
   * @param {Mixed} object to test
   * @param {String} message
   * @api public
   */

  assert.isOk = function (val, msg) {
    new Assertion(val, msg).is.ok;
  };

  /**
   * ### .isNotOk(object, [message])
   *
   * Asserts that `object` is falsy.
   *
   *     assert.isNotOk('everything', 'this will fail');
   *     assert.isNotOk(false, 'this will pass');
   *
   * @name isNotOk
   * @alias notOk
   * @param {Mixed} object to test
   * @param {String} message
   * @api public
   */

  assert.isNotOk = function (val, msg) {
    new Assertion(val, msg).is.not.ok;
  };

  /**
   * ### .equal(actual, expected, [message])
   *
   * Asserts non-strict equality (`==`) of `actual` and `expected`.
   *
   *     assert.equal(3, '3', '== coerces values to strings');
   *
   * @name equal
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */

  assert.equal = function (act, exp, msg) {
    var test = new Assertion(act, msg, assert.equal);

    test.assert(
        exp == flag(test, 'object')
      , 'expected #{this} to equal #{exp}'
      , 'expected #{this} to not equal #{act}'
      , exp
      , act
    );
  };

  /**
   * ### .notEqual(actual, expected, [message])
   *
   * Asserts non-strict inequality (`!=`) of `actual` and `expected`.
   *
   *     assert.notEqual(3, 4, 'these numbers are not equal');
   *
   * @name notEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */

  assert.notEqual = function (act, exp, msg) {
    var test = new Assertion(act, msg, assert.notEqual);

    test.assert(
        exp != flag(test, 'object')
      , 'expected #{this} to not equal #{exp}'
      , 'expected #{this} to equal #{act}'
      , exp
      , act
    );
  };

  /**
   * ### .strictEqual(actual, expected, [message])
   *
   * Asserts strict equality (`===`) of `actual` and `expected`.
   *
   *     assert.strictEqual(true, true, 'these booleans are strictly equal');
   *
   * @name strictEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */

  assert.strictEqual = function (act, exp, msg) {
    new Assertion(act, msg).to.equal(exp);
  };

  /**
   * ### .notStrictEqual(actual, expected, [message])
   *
   * Asserts strict inequality (`!==`) of `actual` and `expected`.
   *
   *     assert.notStrictEqual(3, '3', 'no coercion for strict equality');
   *
   * @name notStrictEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */

  assert.notStrictEqual = function (act, exp, msg) {
    new Assertion(act, msg).to.not.equal(exp);
  };

  /**
   * ### .deepEqual(actual, expected, [message])
   *
   * Asserts that `actual` is deeply equal to `expected`.
   *
   *     assert.deepEqual({ tea: 'green' }, { tea: 'green' });
   *
   * @name deepEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */

  assert.deepEqual = function (act, exp, msg) {
    new Assertion(act, msg).to.eql(exp);
  };

  /**
   * ### .notDeepEqual(actual, expected, [message])
   *
   * Assert that `actual` is not deeply equal to `expected`.
   *
   *     assert.notDeepEqual({ tea: 'green' }, { tea: 'jasmine' });
   *
   * @name notDeepEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */

  assert.notDeepEqual = function (act, exp, msg) {
    new Assertion(act, msg).to.not.eql(exp);
  };

  /**
   * ### .isTrue(value, [message])
   *
   * Asserts that `value` is true.
   *
   *     var teaServed = true;
   *     assert.isTrue(teaServed, 'the tea has been served');
   *
   * @name isTrue
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isAbove = function (val, abv, msg) {
    new Assertion(val, msg).to.be.above(abv);
  };

   /**
   * ### .isAbove(valueToCheck, valueToBeAbove, [message])
   *
   * Asserts `valueToCheck` is strictly greater than (>) `valueToBeAbove`
   *
   *     assert.isAbove(5, 2, '5 is strictly greater than 2');
   *
   * @name isAbove
   * @param {Mixed} valueToCheck
   * @param {Mixed} valueToBeAbove
   * @param {String} message
   * @api public
   */

  assert.isBelow = function (val, blw, msg) {
    new Assertion(val, msg).to.be.below(blw);
  };

   /**
   * ### .isBelow(valueToCheck, valueToBeBelow, [message])
   *
   * Asserts `valueToCheck` is strictly less than (<) `valueToBeBelow`
   *
   *     assert.isBelow(3, 6, '3 is strictly less than 6');
   *
   * @name isBelow
   * @param {Mixed} valueToCheck
   * @param {Mixed} valueToBeBelow
   * @param {String} message
   * @api public
   */

  assert.isTrue = function (val, msg) {
    new Assertion(val, msg).is['true'];
  };

  /**
   * ### .isFalse(value, [message])
   *
   * Asserts that `value` is false.
   *
   *     var teaServed = false;
   *     assert.isFalse(teaServed, 'no tea yet? hmm...');
   *
   * @name isFalse
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isFalse = function (val, msg) {
    new Assertion(val, msg).is['false'];
  };

  /**
   * ### .isNull(value, [message])
   *
   * Asserts that `value` is null.
   *
   *     assert.isNull(err, 'there was no error');
   *
   * @name isNull
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNull = function (val, msg) {
    new Assertion(val, msg).to.equal(null);
  };

  /**
   * ### .isNotNull(value, [message])
   *
   * Asserts that `value` is not null.
   *
   *     var tea = 'tasty chai';
   *     assert.isNotNull(tea, 'great, time for tea!');
   *
   * @name isNotNull
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotNull = function (val, msg) {
    new Assertion(val, msg).to.not.equal(null);
  };

  /**
   * ### .isNaN
   * Asserts that value is NaN
   *
   *    assert.isNaN('foo', 'foo is NaN');
   *
   * @name isNaN
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNaN = function (val, msg) {
    new Assertion(val, msg).to.be.NaN;
  };

  /**
   * ### .isNotNaN
   * Asserts that value is not NaN
   *
   *    assert.isNotNaN(4, '4 is not NaN');
   *
   * @name isNotNaN
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */
  assert.isNotNaN = function (val, msg) {
    new Assertion(val, msg).not.to.be.NaN;
  };

  /**
   * ### .isUndefined(value, [message])
   *
   * Asserts that `value` is `undefined`.
   *
   *     var tea;
   *     assert.isUndefined(tea, 'no tea defined');
   *
   * @name isUndefined
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isUndefined = function (val, msg) {
    new Assertion(val, msg).to.equal(undefined);
  };

  /**
   * ### .isDefined(value, [message])
   *
   * Asserts that `value` is not `undefined`.
   *
   *     var tea = 'cup of chai';
   *     assert.isDefined(tea, 'tea has been defined');
   *
   * @name isDefined
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isDefined = function (val, msg) {
    new Assertion(val, msg).to.not.equal(undefined);
  };

  /**
   * ### .isFunction(value, [message])
   *
   * Asserts that `value` is a function.
   *
   *     function serveTea() { return 'cup of tea'; };
   *     assert.isFunction(serveTea, 'great, we can have tea now');
   *
   * @name isFunction
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isFunction = function (val, msg) {
    new Assertion(val, msg).to.be.a('function');
  };

  /**
   * ### .isNotFunction(value, [message])
   *
   * Asserts that `value` is _not_ a function.
   *
   *     var serveTea = [ 'heat', 'pour', 'sip' ];
   *     assert.isNotFunction(serveTea, 'great, we have listed the steps');
   *
   * @name isNotFunction
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotFunction = function (val, msg) {
    new Assertion(val, msg).to.not.be.a('function');
  };

  /**
   * ### .isObject(value, [message])
   *
   * Asserts that `value` is an object (as revealed by
   * `Object.prototype.toString`).
   *
   *     var selection = { name: 'Chai', serve: 'with spices' };
   *     assert.isObject(selection, 'tea selection is an object');
   *
   * @name isObject
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isObject = function (val, msg) {
    new Assertion(val, msg).to.be.a('object');
  };

  /**
   * ### .isNotObject(value, [message])
   *
   * Asserts that `value` is _not_ an object.
   *
   *     var selection = 'chai'
   *     assert.isNotObject(selection, 'tea selection is not an object');
   *     assert.isNotObject(null, 'null is not an object');
   *
   * @name isNotObject
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotObject = function (val, msg) {
    new Assertion(val, msg).to.not.be.a('object');
  };

  /**
   * ### .isArray(value, [message])
   *
   * Asserts that `value` is an array.
   *
   *     var menu = [ 'green', 'chai', 'oolong' ];
   *     assert.isArray(menu, 'what kind of tea do we want?');
   *
   * @name isArray
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isArray = function (val, msg) {
    new Assertion(val, msg).to.be.an('array');
  };

  /**
   * ### .isNotArray(value, [message])
   *
   * Asserts that `value` is _not_ an array.
   *
   *     var menu = 'green|chai|oolong';
   *     assert.isNotArray(menu, 'what kind of tea do we want?');
   *
   * @name isNotArray
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotArray = function (val, msg) {
    new Assertion(val, msg).to.not.be.an('array');
  };

  /**
   * ### .isString(value, [message])
   *
   * Asserts that `value` is a string.
   *
   *     var teaOrder = 'chai';
   *     assert.isString(teaOrder, 'order placed');
   *
   * @name isString
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isString = function (val, msg) {
    new Assertion(val, msg).to.be.a('string');
  };

  /**
   * ### .isNotString(value, [message])
   *
   * Asserts that `value` is _not_ a string.
   *
   *     var teaOrder = 4;
   *     assert.isNotString(teaOrder, 'order placed');
   *
   * @name isNotString
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotString = function (val, msg) {
    new Assertion(val, msg).to.not.be.a('string');
  };

  /**
   * ### .isNumber(value, [message])
   *
   * Asserts that `value` is a number.
   *
   *     var cups = 2;
   *     assert.isNumber(cups, 'how many cups');
   *
   * @name isNumber
   * @param {Number} value
   * @param {String} message
   * @api public
   */

  assert.isNumber = function (val, msg) {
    new Assertion(val, msg).to.be.a('number');
  };

  /**
   * ### .isNotNumber(value, [message])
   *
   * Asserts that `value` is _not_ a number.
   *
   *     var cups = '2 cups please';
   *     assert.isNotNumber(cups, 'how many cups');
   *
   * @name isNotNumber
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotNumber = function (val, msg) {
    new Assertion(val, msg).to.not.be.a('number');
  };

  /**
   * ### .isBoolean(value, [message])
   *
   * Asserts that `value` is a boolean.
   *
   *     var teaReady = true
   *       , teaServed = false;
   *
   *     assert.isBoolean(teaReady, 'is the tea ready');
   *     assert.isBoolean(teaServed, 'has tea been served');
   *
   * @name isBoolean
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isBoolean = function (val, msg) {
    new Assertion(val, msg).to.be.a('boolean');
  };

  /**
   * ### .isNotBoolean(value, [message])
   *
   * Asserts that `value` is _not_ a boolean.
   *
   *     var teaReady = 'yep'
   *       , teaServed = 'nope';
   *
   *     assert.isNotBoolean(teaReady, 'is the tea ready');
   *     assert.isNotBoolean(teaServed, 'has tea been served');
   *
   * @name isNotBoolean
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotBoolean = function (val, msg) {
    new Assertion(val, msg).to.not.be.a('boolean');
  };

  /**
   * ### .typeOf(value, name, [message])
   *
   * Asserts that `value`'s type is `name`, as determined by
   * `Object.prototype.toString`.
   *
   *     assert.typeOf({ tea: 'chai' }, 'object', 'we have an object');
   *     assert.typeOf(['chai', 'jasmine'], 'array', 'we have an array');
   *     assert.typeOf('tea', 'string', 'we have a string');
   *     assert.typeOf(/tea/, 'regexp', 'we have a regular expression');
   *     assert.typeOf(null, 'null', 'we have a null');
   *     assert.typeOf(undefined, 'undefined', 'we have an undefined');
   *
   * @name typeOf
   * @param {Mixed} value
   * @param {String} name
   * @param {String} message
   * @api public
   */

  assert.typeOf = function (val, type, msg) {
    new Assertion(val, msg).to.be.a(type);
  };

  /**
   * ### .notTypeOf(value, name, [message])
   *
   * Asserts that `value`'s type is _not_ `name`, as determined by
   * `Object.prototype.toString`.
   *
   *     assert.notTypeOf('tea', 'number', 'strings are not numbers');
   *
   * @name notTypeOf
   * @param {Mixed} value
   * @param {String} typeof name
   * @param {String} message
   * @api public
   */

  assert.notTypeOf = function (val, type, msg) {
    new Assertion(val, msg).to.not.be.a(type);
  };

  /**
   * ### .instanceOf(object, constructor, [message])
   *
   * Asserts that `value` is an instance of `constructor`.
   *
   *     var Tea = function (name) { this.name = name; }
   *       , chai = new Tea('chai');
   *
   *     assert.instanceOf(chai, Tea, 'chai is an instance of tea');
   *
   * @name instanceOf
   * @param {Object} object
   * @param {Constructor} constructor
   * @param {String} message
   * @api public
   */

  assert.instanceOf = function (val, type, msg) {
    new Assertion(val, msg).to.be.instanceOf(type);
  };

  /**
   * ### .notInstanceOf(object, constructor, [message])
   *
   * Asserts `value` is not an instance of `constructor`.
   *
   *     var Tea = function (name) { this.name = name; }
   *       , chai = new String('chai');
   *
   *     assert.notInstanceOf(chai, Tea, 'chai is not an instance of tea');
   *
   * @name notInstanceOf
   * @param {Object} object
   * @param {Constructor} constructor
   * @param {String} message
   * @api public
   */

  assert.notInstanceOf = function (val, type, msg) {
    new Assertion(val, msg).to.not.be.instanceOf(type);
  };

  /**
   * ### .include(haystack, needle, [message])
   *
   * Asserts that `haystack` includes `needle`. Works
   * for strings and arrays.
   *
   *     assert.include('foobar', 'bar', 'foobar contains string "bar"');
   *     assert.include([ 1, 2, 3 ], 3, 'array contains value');
   *
   * @name include
   * @param {Array|String} haystack
   * @param {Mixed} needle
   * @param {String} message
   * @api public
   */

  assert.include = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.include).include(inc);
  };

  /**
   * ### .notInclude(haystack, needle, [message])
   *
   * Asserts that `haystack` does not include `needle`. Works
   * for strings and arrays.
   *
   *     assert.notInclude('foobar', 'baz', 'string not include substring');
   *     assert.notInclude([ 1, 2, 3 ], 4, 'array not include contain value');
   *
   * @name notInclude
   * @param {Array|String} haystack
   * @param {Mixed} needle
   * @param {String} message
   * @api public
   */

  assert.notInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.notInclude).not.include(inc);
  };

  /**
   * ### .match(value, regexp, [message])
   *
   * Asserts that `value` matches the regular expression `regexp`.
   *
   *     assert.match('foobar', /^foo/, 'regexp matches');
   *
   * @name match
   * @param {Mixed} value
   * @param {RegExp} regexp
   * @param {String} message
   * @api public
   */

  assert.match = function (exp, re, msg) {
    new Assertion(exp, msg).to.match(re);
  };

  /**
   * ### .notMatch(value, regexp, [message])
   *
   * Asserts that `value` does not match the regular expression `regexp`.
   *
   *     assert.notMatch('foobar', /^foo/, 'regexp does not match');
   *
   * @name notMatch
   * @param {Mixed} value
   * @param {RegExp} regexp
   * @param {String} message
   * @api public
   */

  assert.notMatch = function (exp, re, msg) {
    new Assertion(exp, msg).to.not.match(re);
  };

  /**
   * ### .property(object, property, [message])
   *
   * Asserts that `object` has a property named by `property`.
   *
   *     assert.property({ tea: { green: 'matcha' }}, 'tea');
   *
   * @name property
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @api public
   */

  assert.property = function (obj, prop, msg) {
    new Assertion(obj, msg).to.have.property(prop);
  };

  /**
   * ### .notProperty(object, property, [message])
   *
   * Asserts that `object` does _not_ have a property named by `property`.
   *
   *     assert.notProperty({ tea: { green: 'matcha' }}, 'coffee');
   *
   * @name notProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @api public
   */

  assert.notProperty = function (obj, prop, msg) {
    new Assertion(obj, msg).to.not.have.property(prop);
  };

  /**
   * ### .deepProperty(object, property, [message])
   *
   * Asserts that `object` has a property named by `property`, which can be a
   * string using dot- and bracket-notation for deep reference.
   *
   *     assert.deepProperty({ tea: { green: 'matcha' }}, 'tea.green');
   *
   * @name deepProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @api public
   */

  assert.deepProperty = function (obj, prop, msg) {
    new Assertion(obj, msg).to.have.deep.property(prop);
  };

  /**
   * ### .notDeepProperty(object, property, [message])
   *
   * Asserts that `object` does _not_ have a property named by `property`, which
   * can be a string using dot- and bracket-notation for deep reference.
   *
   *     assert.notDeepProperty({ tea: { green: 'matcha' }}, 'tea.oolong');
   *
   * @name notDeepProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @api public
   */

  assert.notDeepProperty = function (obj, prop, msg) {
    new Assertion(obj, msg).to.not.have.deep.property(prop);
  };

  /**
   * ### .propertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property` with value given
   * by `value`.
   *
   *     assert.propertyVal({ tea: 'is good' }, 'tea', 'is good');
   *
   * @name propertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.propertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg).to.have.property(prop, val);
  };

  /**
   * ### .propertyNotVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property`, but with a value
   * different from that given by `value`.
   *
   *     assert.propertyNotVal({ tea: 'is good' }, 'tea', 'is bad');
   *
   * @name propertyNotVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.propertyNotVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg).to.not.have.property(prop, val);
  };

  /**
   * ### .deepPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property` with value given
   * by `value`. `property` can use dot- and bracket-notation for deep
   * reference.
   *
   *     assert.deepPropertyVal({ tea: { green: 'matcha' }}, 'tea.green', 'matcha');
   *
   * @name deepPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.deepPropertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg).to.have.deep.property(prop, val);
  };

  /**
   * ### .deepPropertyNotVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property`, but with a value
   * different from that given by `value`. `property` can use dot- and
   * bracket-notation for deep reference.
   *
   *     assert.deepPropertyNotVal({ tea: { green: 'matcha' }}, 'tea.green', 'konacha');
   *
   * @name deepPropertyNotVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.deepPropertyNotVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg).to.not.have.deep.property(prop, val);
  };

  /**
   * ### .lengthOf(object, length, [message])
   *
   * Asserts that `object` has a `length` property with the expected value.
   *
   *     assert.lengthOf([1,2,3], 3, 'array has length of 3');
   *     assert.lengthOf('foobar', 5, 'string has length of 6');
   *
   * @name lengthOf
   * @param {Mixed} object
   * @param {Number} length
   * @param {String} message
   * @api public
   */

  assert.lengthOf = function (exp, len, msg) {
    new Assertion(exp, msg).to.have.length(len);
  };

  /**
   * ### .throws(function, [constructor/string/regexp], [string/regexp], [message])
   *
   * Asserts that `function` will throw an error that is an instance of
   * `constructor`, or alternately that it will throw an error with message
   * matching `regexp`.
   *
   *     assert.throws(fn, 'function throws a reference error');
   *     assert.throws(fn, /function throws a reference error/);
   *     assert.throws(fn, ReferenceError);
   *     assert.throws(fn, ReferenceError, 'function throws a reference error');
   *     assert.throws(fn, ReferenceError, /function throws a reference error/);
   *
   * @name throws
   * @alias throw
   * @alias Throw
   * @param {Function} function
   * @param {ErrorConstructor} constructor
   * @param {RegExp} regexp
   * @param {String} message
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @api public
   */

  assert.throws = function (fn, errt, errs, msg) {
    if ('string' === typeof errt || errt instanceof RegExp) {
      errs = errt;
      errt = null;
    }

    var assertErr = new Assertion(fn, msg).to.throw(errt, errs);
    return flag(assertErr, 'object');
  };

  /**
   * ### .doesNotThrow(function, [constructor/regexp], [message])
   *
   * Asserts that `function` will _not_ throw an error that is an instance of
   * `constructor`, or alternately that it will not throw an error with message
   * matching `regexp`.
   *
   *     assert.doesNotThrow(fn, Error, 'function does not throw');
   *
   * @name doesNotThrow
   * @param {Function} function
   * @param {ErrorConstructor} constructor
   * @param {RegExp} regexp
   * @param {String} message
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @api public
   */

  assert.doesNotThrow = function (fn, type, msg) {
    if ('string' === typeof type) {
      msg = type;
      type = null;
    }

    new Assertion(fn, msg).to.not.Throw(type);
  };

  /**
   * ### .operator(val1, operator, val2, [message])
   *
   * Compares two values using `operator`.
   *
   *     assert.operator(1, '<', 2, 'everything is ok');
   *     assert.operator(1, '>', 2, 'this will fail');
   *
   * @name operator
   * @param {Mixed} val1
   * @param {String} operator
   * @param {Mixed} val2
   * @param {String} message
   * @api public
   */

  assert.operator = function (val, operator, val2, msg) {
    var ok;
    switch(operator) {
      case '==':
        ok = val == val2;
        break;
      case '===':
        ok = val === val2;
        break;
      case '>':
        ok = val > val2;
        break;
      case '>=':
        ok = val >= val2;
        break;
      case '<':
        ok = val < val2;
        break;
      case '<=':
        ok = val <= val2;
        break;
      case '!=':
        ok = val != val2;
        break;
      case '!==':
        ok = val !== val2;
        break;
      default:
        throw new Error('Invalid operator "' + operator + '"');
    }
    var test = new Assertion(ok, msg);
    test.assert(
        true === flag(test, 'object')
      , 'expected ' + util.inspect(val) + ' to be ' + operator + ' ' + util.inspect(val2)
      , 'expected ' + util.inspect(val) + ' to not be ' + operator + ' ' + util.inspect(val2) );
  };

  /**
   * ### .closeTo(actual, expected, delta, [message])
   *
   * Asserts that the target is equal `expected`, to within a +/- `delta` range.
   *
   *     assert.closeTo(1.5, 1, 0.5, 'numbers are close');
   *
   * @name closeTo
   * @param {Number} actual
   * @param {Number} expected
   * @param {Number} delta
   * @param {String} message
   * @api public
   */

  assert.closeTo = function (act, exp, delta, msg) {
    new Assertion(act, msg).to.be.closeTo(exp, delta);
  };

  /**
   * ### .sameMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` have the same members.
   * Order is not taken into account.
   *
   *     assert.sameMembers([ 1, 2, 3 ], [ 2, 1, 3 ], 'same members');
   *
   * @name sameMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @api public
   */

  assert.sameMembers = function (set1, set2, msg) {
    new Assertion(set1, msg).to.have.same.members(set2);
  }

  /**
   * ### .sameDeepMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` have the same members - using a deep equality checking.
   * Order is not taken into account.
   *
   *     assert.sameDeepMembers([ {b: 3}, {a: 2}, {c: 5} ], [ {c: 5}, {b: 3}, {a: 2} ], 'same deep members');
   *
   * @name sameDeepMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @api public
   */

  assert.sameDeepMembers = function (set1, set2, msg) {
    new Assertion(set1, msg).to.have.same.deep.members(set2);
  }

  /**
   * ### .includeMembers(superset, subset, [message])
   *
   * Asserts that `subset` is included in `superset`.
   * Order is not taken into account.
   *
   *     assert.includeMembers([ 1, 2, 3 ], [ 2, 1 ], 'include members');
   *
   * @name includeMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @api public
   */

  assert.includeMembers = function (superset, subset, msg) {
    new Assertion(superset, msg).to.include.members(subset);
  }

   /**
   * ### .changes(function, object, property)
   *
   * Asserts that a function changes the value of a property
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 22 };
   *     assert.changes(fn, obj, 'val');
   *
   * @name changes
   * @param {Function} modifier function
   * @param {Object} object
   * @param {String} property name
   * @param {String} message _optional_
   * @api public
   */

  assert.changes = function (fn, obj, prop) {
    new Assertion(fn).to.change(obj, prop);
  }

   /**
   * ### .doesNotChange(function, object, property)
   *
   * Asserts that a function does not changes the value of a property
   *
   *     var obj = { val: 10 };
   *     var fn = function() { console.log('foo'); };
   *     assert.doesNotChange(fn, obj, 'val');
   *
   * @name doesNotChange
   * @param {Function} modifier function
   * @param {Object} object
   * @param {String} property name
   * @param {String} message _optional_
   * @api public
   */

  assert.doesNotChange = function (fn, obj, prop) {
    new Assertion(fn).to.not.change(obj, prop);
  }

   /**
   * ### .increases(function, object, property)
   *
   * Asserts that a function increases an object property
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 13 };
   *     assert.increases(fn, obj, 'val');
   *
   * @name increases
   * @param {Function} modifier function
   * @param {Object} object
   * @param {String} property name
   * @param {String} message _optional_
   * @api public
   */

  assert.increases = function (fn, obj, prop) {
    new Assertion(fn).to.increase(obj, prop);
  }

   /**
   * ### .doesNotIncrease(function, object, property)
   *
   * Asserts that a function does not increase object property
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 8 };
   *     assert.doesNotIncrease(fn, obj, 'val');
   *
   * @name doesNotIncrease
   * @param {Function} modifier function
   * @param {Object} object
   * @param {String} property name
   * @param {String} message _optional_
   * @api public
   */

  assert.doesNotIncrease = function (fn, obj, prop) {
    new Assertion(fn).to.not.increase(obj, prop);
  }

   /**
   * ### .decreases(function, object, property)
   *
   * Asserts that a function decreases an object property
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 5 };
   *     assert.decreases(fn, obj, 'val');
   *
   * @name decreases
   * @param {Function} modifier function
   * @param {Object} object
   * @param {String} property name
   * @param {String} message _optional_
   * @api public
   */

  assert.decreases = function (fn, obj, prop) {
    new Assertion(fn).to.decrease(obj, prop);
  }

   /**
   * ### .doesNotDecrease(function, object, property)
   *
   * Asserts that a function does not decreases an object property
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 15 };
   *     assert.doesNotDecrease(fn, obj, 'val');
   *
   * @name doesNotDecrease
   * @param {Function} modifier function
   * @param {Object} object
   * @param {String} property name
   * @param {String} message _optional_
   * @api public
   */

  assert.doesNotDecrease = function (fn, obj, prop) {
    new Assertion(fn).to.not.decrease(obj, prop);
  }

  /*!
   * ### .ifError(object)
   *
   * Asserts if value is not a false value, and throws if it is a true value.
   * This is added to allow for chai to be a drop-in replacement for Node's
   * assert class.
   *
   *     var err = new Error('I am a custom error');
   *     assert.ifError(err); // Rethrows err!
   *
   * @name ifError
   * @param {Object} object
   * @api public
   */

  assert.ifError = function (val) {
    if (val) {
      throw(val);
    }
  };

  /**
   * ### .isExtensible(object)
   *
   * Asserts that `object` is extensible (can have new properties added to it).
   *
   *     assert.isExtensible({});
   *
   * @name isExtensible
   * @alias extensible
   * @param {Object} object
   * @param {String} message _optional_
   * @api public
   */

  assert.isExtensible = function (obj, msg) {
    new Assertion(obj, msg).to.be.extensible;
  };

  /**
   * ### .isNotExtensible(object)
   *
   * Asserts that `object` is _not_ extensible.
   *
   *     var nonExtensibleObject = Object.preventExtensions({});
   *     var sealedObject = Object.seal({});
   *     var frozenObject = Object.freese({});
   *
   *     assert.isNotExtensible(nonExtensibleObject);
   *     assert.isNotExtensible(sealedObject);
   *     assert.isNotExtensible(frozenObject);
   *
   * @name isNotExtensible
   * @alias notExtensible
   * @param {Object} object
   * @param {String} message _optional_
   * @api public
   */

  assert.isNotExtensible = function (obj, msg) {
    new Assertion(obj, msg).to.not.be.extensible;
  };

  /**
   * ### .isSealed(object)
   *
   * Asserts that `object` is sealed (cannot have new properties added to it
   * and its existing properties cannot be removed).
   *
   *     var sealedObject = Object.seal({});
   *     var frozenObject = Object.seal({});
   *
   *     assert.isSealed(sealedObject);
   *     assert.isSealed(frozenObject);
   *
   * @name isSealed
   * @alias sealed
   * @param {Object} object
   * @param {String} message _optional_
   * @api public
   */

  assert.isSealed = function (obj, msg) {
    new Assertion(obj, msg).to.be.sealed;
  };

  /**
   * ### .isNotSealed(object)
   *
   * Asserts that `object` is _not_ sealed.
   *
   *     assert.isNotSealed({});
   *
   * @name isNotSealed
   * @alias notSealed
   * @param {Object} object
   * @param {String} message _optional_
   * @api public
   */

  assert.isNotSealed = function (obj, msg) {
    new Assertion(obj, msg).to.not.be.sealed;
  };

  /**
   * ### .isFrozen(object)
   *
   * Asserts that `object` is frozen (cannot have new properties added to it
   * and its existing properties cannot be modified).
   *
   *     var frozenObject = Object.freeze({});
   *     assert.frozen(frozenObject);
   *
   * @name isFrozen
   * @alias frozen
   * @param {Object} object
   * @param {String} message _optional_
   * @api public
   */

  assert.isFrozen = function (obj, msg) {
    new Assertion(obj, msg).to.be.frozen;
  };

  /**
   * ### .isNotFrozen(object)
   *
   * Asserts that `object` is _not_ frozen.
   *
   *     assert.isNotFrozen({});
   *
   * @name isNotFrozen
   * @alias notFrozen
   * @param {Object} object
   * @param {String} message _optional_
   * @api public
   */

  assert.isNotFrozen = function (obj, msg) {
    new Assertion(obj, msg).to.not.be.frozen;
  };

  /*!
   * Aliases.
   */

  (function alias(name, as){
    assert[as] = assert[name];
    return alias;
  })
  ('isOk', 'ok')
  ('isNotOk', 'notOk')
  ('throws', 'throw')
  ('throws', 'Throw')
  ('isExtensible', 'extensible')
  ('isNotExtensible', 'notExtensible')
  ('isSealed', 'sealed')
  ('isNotSealed', 'notSealed')
  ('isFrozen', 'frozen')
  ('isNotFrozen', 'notFrozen');
};

},{}],7:[function(require,module,exports){
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

module.exports = function (chai, util) {
  chai.expect = function (val, message) {
    return new chai.Assertion(val, message);
  };

  /**
   * ### .fail(actual, expected, [message], [operator])
   *
   * Throw a failure.
   *
   * @name fail
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @param {String} operator
   * @api public
   */

  chai.expect.fail = function (actual, expected, message, operator) {
    message = message || 'expect.fail()';
    throw new chai.AssertionError(message, {
        actual: actual
      , expected: expected
      , operator: operator
    }, chai.expect.fail);
  };
};

},{}],8:[function(require,module,exports){
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

module.exports = function (chai, util) {
  var Assertion = chai.Assertion;

  function loadShould () {
    // explicitly define this method as function as to have it's name to include as `ssfi`
    function shouldGetter() {
      if (this instanceof String || this instanceof Number || this instanceof Boolean ) {
        return new Assertion(this.valueOf(), null, shouldGetter);
      }
      return new Assertion(this, null, shouldGetter);
    }
    function shouldSetter(value) {
      // See https://github.com/chaijs/chai/issues/86: this makes
      // `whatever.should = someValue` actually set `someValue`, which is
      // especially useful for `global.should = require('chai').should()`.
      //
      // Note that we have to use [[DefineProperty]] instead of [[Put]]
      // since otherwise we would trigger this very setter!
      Object.defineProperty(this, 'should', {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    }
    // modify Object.prototype to have `should`
    Object.defineProperty(Object.prototype, 'should', {
      set: shouldSetter
      , get: shouldGetter
      , configurable: true
    });

    var should = {};

    /**
     * ### .fail(actual, expected, [message], [operator])
     *
     * Throw a failure.
     *
     * @name fail
     * @param {Mixed} actual
     * @param {Mixed} expected
     * @param {String} message
     * @param {String} operator
     * @api public
     */

    should.fail = function (actual, expected, message, operator) {
      message = message || 'should.fail()';
      throw new chai.AssertionError(message, {
          actual: actual
        , expected: expected
        , operator: operator
      }, should.fail);
    };

    should.equal = function (val1, val2, msg) {
      new Assertion(val1, msg).to.equal(val2);
    };

    should.Throw = function (fn, errt, errs, msg) {
      new Assertion(fn, msg).to.Throw(errt, errs);
    };

    should.exist = function (val, msg) {
      new Assertion(val, msg).to.exist;
    }

    // negation
    should.not = {}

    should.not.equal = function (val1, val2, msg) {
      new Assertion(val1, msg).to.not.equal(val2);
    };

    should.not.Throw = function (fn, errt, errs, msg) {
      new Assertion(fn, msg).to.not.Throw(errt, errs);
    };

    should.not.exist = function (val, msg) {
      new Assertion(val, msg).to.not.exist;
    }

    should['throw'] = should['Throw'];
    should.not['throw'] = should.not['Throw'];

    return should;
  };

  chai.should = loadShould;
  chai.Should = loadShould;
};

},{}],9:[function(require,module,exports){
/*!
 * Chai - addChainingMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependencies
 */

var transferFlags = require('./transferFlags');
var flag = require('./flag');
var config = require('../config');

/*!
 * Module variables
 */

// Check whether `__proto__` is supported
var hasProtoSupport = '__proto__' in Object;

// Without `__proto__` support, this module will need to add properties to a function.
// However, some Function.prototype methods cannot be overwritten,
// and there seems no easy cross-platform way to detect them (@see chaijs/chai/issues/69).
var excludeNames = /^(?:length|name|arguments|caller)$/;

// Cache `Function` properties
var call  = Function.prototype.call,
    apply = Function.prototype.apply;

/**
 * ### addChainableMethod (ctx, name, method, chainingBehavior)
 *
 * Adds a method to an object, such that the method can also be chained.
 *
 *     utils.addChainableMethod(chai.Assertion.prototype, 'foo', function (str) {
 *       var obj = utils.flag(this, 'object');
 *       new chai.Assertion(obj).to.be.equal(str);
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.addChainableMethod('foo', fn, chainingBehavior);
 *
 * The result can then be used as both a method assertion, executing both `method` and
 * `chainingBehavior`, or as a language chain, which only executes `chainingBehavior`.
 *
 *     expect(fooStr).to.be.foo('bar');
 *     expect(fooStr).to.be.foo.equal('foo');
 *
 * @param {Object} ctx object to which the method is added
 * @param {String} name of method to add
 * @param {Function} method function to be used for `name`, when called
 * @param {Function} chainingBehavior function to be called every time the property is accessed
 * @name addChainableMethod
 * @api public
 */

module.exports = function (ctx, name, method, chainingBehavior) {
  if (typeof chainingBehavior !== 'function') {
    chainingBehavior = function () { };
  }

  var chainableBehavior = {
      method: method
    , chainingBehavior: chainingBehavior
  };

  // save the methods so we can overwrite them later, if we need to.
  if (!ctx.__methods) {
    ctx.__methods = {};
  }
  ctx.__methods[name] = chainableBehavior;

  Object.defineProperty(ctx, name,
    { get: function () {
        chainableBehavior.chainingBehavior.call(this);

        var assert = function assert() {
          var old_ssfi = flag(this, 'ssfi');
          if (old_ssfi && config.includeStack === false)
            flag(this, 'ssfi', assert);
          var result = chainableBehavior.method.apply(this, arguments);
          return result === undefined ? this : result;
        };

        // Use `__proto__` if available
        if (hasProtoSupport) {
          // Inherit all properties from the object by replacing the `Function` prototype
          var prototype = assert.__proto__ = Object.create(this);
          // Restore the `call` and `apply` methods from `Function`
          prototype.call = call;
          prototype.apply = apply;
        }
        // Otherwise, redefine all properties (slow!)
        else {
          var asserterNames = Object.getOwnPropertyNames(ctx);
          asserterNames.forEach(function (asserterName) {
            if (!excludeNames.test(asserterName)) {
              var pd = Object.getOwnPropertyDescriptor(ctx, asserterName);
              Object.defineProperty(assert, asserterName, pd);
            }
          });
        }

        transferFlags(this, assert);
        return assert;
      }
    , configurable: true
  });
};

},{"../config":4,"./flag":12,"./transferFlags":28}],10:[function(require,module,exports){
/*!
 * Chai - addMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

var config = require('../config');

/**
 * ### .addMethod (ctx, name, method)
 *
 * Adds a method to the prototype of an object.
 *
 *     utils.addMethod(chai.Assertion.prototype, 'foo', function (str) {
 *       var obj = utils.flag(this, 'object');
 *       new chai.Assertion(obj).to.be.equal(str);
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.addMethod('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(fooStr).to.be.foo('bar');
 *
 * @param {Object} ctx object to which the method is added
 * @param {String} name of method to add
 * @param {Function} method function to be used for name
 * @name addMethod
 * @api public
 */
var flag = require('./flag');

module.exports = function (ctx, name, method) {
  ctx[name] = function () {
    var old_ssfi = flag(this, 'ssfi');
    if (old_ssfi && config.includeStack === false)
      flag(this, 'ssfi', ctx[name]);
    var result = method.apply(this, arguments);
    return result === undefined ? this : result;
  };
};

},{"../config":4,"./flag":12}],11:[function(require,module,exports){
/*!
 * Chai - addProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### addProperty (ctx, name, getter)
 *
 * Adds a property to the prototype of an object.
 *
 *     utils.addProperty(chai.Assertion.prototype, 'foo', function () {
 *       var obj = utils.flag(this, 'object');
 *       new chai.Assertion(obj).to.be.instanceof(Foo);
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.addProperty('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.be.foo;
 *
 * @param {Object} ctx object to which the property is added
 * @param {String} name of property to add
 * @param {Function} getter function to be used for name
 * @name addProperty
 * @api public
 */

module.exports = function (ctx, name, getter) {
  Object.defineProperty(ctx, name,
    { get: function () {
        var result = getter.call(this);
        return result === undefined ? this : result;
      }
    , configurable: true
  });
};

},{}],12:[function(require,module,exports){
/*!
 * Chai - flag utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### flag(object, key, [value])
 *
 * Get or set a flag value on an object. If a
 * value is provided it will be set, else it will
 * return the currently set value or `undefined` if
 * the value is not set.
 *
 *     utils.flag(this, 'foo', 'bar'); // setter
 *     utils.flag(this, 'foo'); // getter, returns `bar`
 *
 * @param {Object} object constructed Assertion
 * @param {String} key
 * @param {Mixed} value (optional)
 * @name flag
 * @api private
 */

module.exports = function (obj, key, value) {
  var flags = obj.__flags || (obj.__flags = Object.create(null));
  if (arguments.length === 3) {
    flags[key] = value;
  } else {
    return flags[key];
  }
};

},{}],13:[function(require,module,exports){
/*!
 * Chai - getActual utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * # getActual(object, [actual])
 *
 * Returns the `actual` value for an Assertion
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 */

module.exports = function (obj, args) {
  return args.length > 4 ? args[4] : obj._obj;
};

},{}],14:[function(require,module,exports){
/*!
 * Chai - getEnumerableProperties utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .getEnumerableProperties(object)
 *
 * This allows the retrieval of enumerable property names of an object,
 * inherited or not.
 *
 * @param {Object} object
 * @returns {Array}
 * @name getEnumerableProperties
 * @api public
 */

module.exports = function getEnumerableProperties(object) {
  var result = [];
  for (var name in object) {
    result.push(name);
  }
  return result;
};

},{}],15:[function(require,module,exports){
/*!
 * Chai - message composition utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependancies
 */

var flag = require('./flag')
  , getActual = require('./getActual')
  , inspect = require('./inspect')
  , objDisplay = require('./objDisplay');

/**
 * ### .getMessage(object, message, negateMessage)
 *
 * Construct the error message based on flags
 * and template tags. Template tags will return
 * a stringified inspection of the object referenced.
 *
 * Message template tags:
 * - `#{this}` current asserted object
 * - `#{act}` actual value
 * - `#{exp}` expected value
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 * @name getMessage
 * @api public
 */

module.exports = function (obj, args) {
  var negate = flag(obj, 'negate')
    , val = flag(obj, 'object')
    , expected = args[3]
    , actual = getActual(obj, args)
    , msg = negate ? args[2] : args[1]
    , flagMsg = flag(obj, 'message');

  if(typeof msg === "function") msg = msg();
  msg = msg || '';
  msg = msg
    .replace(/#{this}/g, objDisplay(val))
    .replace(/#{act}/g, objDisplay(actual))
    .replace(/#{exp}/g, objDisplay(expected));

  return flagMsg ? flagMsg + ': ' + msg : msg;
};

},{"./flag":12,"./getActual":13,"./inspect":22,"./objDisplay":23}],16:[function(require,module,exports){
/*!
 * Chai - getName utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * # getName(func)
 *
 * Gets the name of a function, in a cross-browser way.
 *
 * @param {Function} a function (usually a constructor)
 */

module.exports = function (func) {
  if (func.name) return func.name;

  var match = /^\s?function ([^(]*)\(/.exec(func);
  return match && match[1] ? match[1] : "";
};

},{}],17:[function(require,module,exports){
/*!
 * Chai - getPathInfo utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

var hasProperty = require('./hasProperty');

/**
 * ### .getPathInfo(path, object)
 *
 * This allows the retrieval of property info in an
 * object given a string path.
 *
 * The path info consists of an object with the
 * following properties:
 *
 * * parent - The parent object of the property referenced by `path`
 * * name - The name of the final property, a number if it was an array indexer
 * * value - The value of the property, if it exists, otherwise `undefined`
 * * exists - Whether the property exists or not
 *
 * @param {String} path
 * @param {Object} object
 * @returns {Object} info
 * @name getPathInfo
 * @api public
 */

module.exports = function getPathInfo(path, obj) {
  var parsed = parsePath(path),
      last = parsed[parsed.length - 1];

  var info = {
    parent: parsed.length > 1 ? _getPathValue(parsed, obj, parsed.length - 1) : obj,
    name: last.p || last.i,
    value: _getPathValue(parsed, obj)
  };
  info.exists = hasProperty(info.name, info.parent);

  return info;
};


/*!
 * ## parsePath(path)
 *
 * Helper function used to parse string object
 * paths. Use in conjunction with `_getPathValue`.
 *
 *      var parsed = parsePath('myobject.property.subprop');
 *
 * ### Paths:
 *
 * * Can be as near infinitely deep and nested
 * * Arrays are also valid using the formal `myobject.document[3].property`.
 * * Literal dots and brackets (not delimiter) must be backslash-escaped.
 *
 * @param {String} path
 * @returns {Object} parsed
 * @api private
 */

function parsePath (path) {
  var str = path.replace(/([^\\])\[/g, '$1.[')
    , parts = str.match(/(\\\.|[^.]+?)+/g);
  return parts.map(function (value) {
    var re = /^\[(\d+)\]$/
      , mArr = re.exec(value);
    if (mArr) return { i: parseFloat(mArr[1]) };
    else return { p: value.replace(/\\([.\[\]])/g, '$1') };
  });
}


/*!
 * ## _getPathValue(parsed, obj)
 *
 * Helper companion function for `.parsePath` that returns
 * the value located at the parsed address.
 *
 *      var value = getPathValue(parsed, obj);
 *
 * @param {Object} parsed definition from `parsePath`.
 * @param {Object} object to search against
 * @param {Number} object to search against
 * @returns {Object|Undefined} value
 * @api private
 */

function _getPathValue (parsed, obj, index) {
  var tmp = obj
    , res;

  index = (index === undefined ? parsed.length : index);

  for (var i = 0, l = index; i < l; i++) {
    var part = parsed[i];
    if (tmp) {
      if ('undefined' !== typeof part.p)
        tmp = tmp[part.p];
      else if ('undefined' !== typeof part.i)
        tmp = tmp[part.i];
      if (i == (l - 1)) res = tmp;
    } else {
      res = undefined;
    }
  }
  return res;
}

},{"./hasProperty":20}],18:[function(require,module,exports){
/*!
 * Chai - getPathValue utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * @see https://github.com/logicalparadox/filtr
 * MIT Licensed
 */

var getPathInfo = require('./getPathInfo');

/**
 * ### .getPathValue(path, object)
 *
 * This allows the retrieval of values in an
 * object given a string path.
 *
 *     var obj = {
 *         prop1: {
 *             arr: ['a', 'b', 'c']
 *           , str: 'Hello'
 *         }
 *       , prop2: {
 *             arr: [ { nested: 'Universe' } ]
 *           , str: 'Hello again!'
 *         }
 *     }
 *
 * The following would be the results.
 *
 *     getPathValue('prop1.str', obj); // Hello
 *     getPathValue('prop1.att[2]', obj); // b
 *     getPathValue('prop2.arr[0].nested', obj); // Universe
 *
 * @param {String} path
 * @param {Object} object
 * @returns {Object} value or `undefined`
 * @name getPathValue
 * @api public
 */
module.exports = function(path, obj) {
  var info = getPathInfo(path, obj);
  return info.value;
}; 

},{"./getPathInfo":17}],19:[function(require,module,exports){
/*!
 * Chai - getProperties utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .getProperties(object)
 *
 * This allows the retrieval of property names of an object, enumerable or not,
 * inherited or not.
 *
 * @param {Object} object
 * @returns {Array}
 * @name getProperties
 * @api public
 */

module.exports = function getProperties(object) {
  var result = Object.getOwnPropertyNames(object);

  function addProperty(property) {
    if (result.indexOf(property) === -1) {
      result.push(property);
    }
  }

  var proto = Object.getPrototypeOf(object);
  while (proto !== null) {
    Object.getOwnPropertyNames(proto).forEach(addProperty);
    proto = Object.getPrototypeOf(proto);
  }

  return result;
};

},{}],20:[function(require,module,exports){
/*!
 * Chai - hasProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

var type = require('type-detect');

/**
 * ### .hasProperty(object, name)
 *
 * This allows checking whether an object has
 * named property or numeric array index.
 *
 * Basically does the same thing as the `in`
 * operator but works properly with natives
 * and null/undefined values.
 *
 *     var obj = {
 *         arr: ['a', 'b', 'c']
 *       , str: 'Hello'
 *     }
 *
 * The following would be the results.
 *
 *     hasProperty('str', obj);  // true
 *     hasProperty('constructor', obj);  // true
 *     hasProperty('bar', obj);  // false
 *     
 *     hasProperty('length', obj.str); // true
 *     hasProperty(1, obj.str);  // true
 *     hasProperty(5, obj.str);  // false
 *
 *     hasProperty('length', obj.arr);  // true
 *     hasProperty(2, obj.arr);  // true
 *     hasProperty(3, obj.arr);  // false
 *
 * @param {Objuect} object
 * @param {String|Number} name
 * @returns {Boolean} whether it exists
 * @name getPathInfo
 * @api public
 */

var literals = {
    'number': Number
  , 'string': String
};

module.exports = function hasProperty(name, obj) {
  var ot = type(obj);

  // Bad Object, obviously no props at all
  if(ot === 'null' || ot === 'undefined')
    return false;

  // The `in` operator does not work with certain literals
  // box these before the check
  if(literals[ot] && typeof obj !== 'object')
    obj = new literals[ot](obj);

  return name in obj;
};

},{"type-detect":34}],21:[function(require,module,exports){
/*!
 * chai
 * Copyright(c) 2011 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Main exports
 */

var exports = module.exports = {};

/*!
 * test utility
 */

exports.test = require('./test');

/*!
 * type utility
 */

exports.type = require('type-detect');

/*!
 * message utility
 */

exports.getMessage = require('./getMessage');

/*!
 * actual utility
 */

exports.getActual = require('./getActual');

/*!
 * Inspect util
 */

exports.inspect = require('./inspect');

/*!
 * Object Display util
 */

exports.objDisplay = require('./objDisplay');

/*!
 * Flag utility
 */

exports.flag = require('./flag');

/*!
 * Flag transferring utility
 */

exports.transferFlags = require('./transferFlags');

/*!
 * Deep equal utility
 */

exports.eql = require('deep-eql');

/*!
 * Deep path value
 */

exports.getPathValue = require('./getPathValue');

/*!
 * Deep path info
 */

exports.getPathInfo = require('./getPathInfo');

/*!
 * Check if a property exists
 */

exports.hasProperty = require('./hasProperty');

/*!
 * Function name
 */

exports.getName = require('./getName');

/*!
 * add Property
 */

exports.addProperty = require('./addProperty');

/*!
 * add Method
 */

exports.addMethod = require('./addMethod');

/*!
 * overwrite Property
 */

exports.overwriteProperty = require('./overwriteProperty');

/*!
 * overwrite Method
 */

exports.overwriteMethod = require('./overwriteMethod');

/*!
 * Add a chainable method
 */

exports.addChainableMethod = require('./addChainableMethod');

/*!
 * Overwrite chainable method
 */

exports.overwriteChainableMethod = require('./overwriteChainableMethod');


},{"./addChainableMethod":9,"./addMethod":10,"./addProperty":11,"./flag":12,"./getActual":13,"./getMessage":15,"./getName":16,"./getPathInfo":17,"./getPathValue":18,"./hasProperty":20,"./inspect":22,"./objDisplay":23,"./overwriteChainableMethod":24,"./overwriteMethod":25,"./overwriteProperty":26,"./test":27,"./transferFlags":28,"deep-eql":30,"type-detect":34}],22:[function(require,module,exports){
// This is (almost) directly from Node.js utils
// https://github.com/joyent/node/blob/f8c335d0caf47f16d31413f89aa28eda3878e3aa/lib/util.js

var getName = require('./getName');
var getProperties = require('./getProperties');
var getEnumerableProperties = require('./getEnumerableProperties');

module.exports = inspect;

/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Boolean} showHidden Flag that shows hidden (not enumerable)
 *    properties of objects.
 * @param {Number} depth Depth in which to descend in object. Default is 2.
 * @param {Boolean} colors Flag to turn on ANSI escape codes to color the
 *    output. Default is false (no coloring).
 */
function inspect(obj, showHidden, depth, colors) {
  var ctx = {
    showHidden: showHidden,
    seen: [],
    stylize: function (str) { return str; }
  };
  return formatValue(ctx, obj, (typeof depth === 'undefined' ? 2 : depth));
}

// Returns true if object is a DOM element.
var isDOMElement = function (object) {
  if (typeof HTMLElement === 'object') {
    return object instanceof HTMLElement;
  } else {
    return object &&
      typeof object === 'object' &&
      object.nodeType === 1 &&
      typeof object.nodeName === 'string';
  }
};

function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (value && typeof value.inspect === 'function' &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes);
    if (typeof ret !== 'string') {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // If this is a DOM element, try to get the outer HTML.
  if (isDOMElement(value)) {
    if ('outerHTML' in value) {
      return value.outerHTML;
      // This value does not have an outerHTML attribute,
      //   it could still be an XML element
    } else {
      // Attempt to serialize it
      try {
        if (document.xmlVersion) {
          var xmlSerializer = new XMLSerializer();
          return xmlSerializer.serializeToString(value);
        } else {
          // Firefox 11- do not support outerHTML
          //   It does, however, support innerHTML
          //   Use the following to render the element
          var ns = "http://www.w3.org/1999/xhtml";
          var container = document.createElementNS(ns, '_');

          container.appendChild(value.cloneNode(false));
          html = container.innerHTML
            .replace('><', '>' + value.innerHTML + '<');
          container.innerHTML = '';
          return html;
        }
      } catch (err) {
        // This could be a non-native DOM implementation,
        //   continue with the normal flow:
        //   printing the element as if it is an object.
      }
    }
  }

  // Look up the keys of the object.
  var visibleKeys = getEnumerableProperties(value);
  var keys = ctx.showHidden ? getProperties(value) : visibleKeys;

  // Some type of object without properties can be shortcutted.
  // In IE, errors have a single `stack` property, or if they are vanilla `Error`,
  // a `stack` plus `description` property; ignore those for consistency.
  if (keys.length === 0 || (isError(value) && (
      (keys.length === 1 && keys[0] === 'stack') ||
      (keys.length === 2 && keys[0] === 'description' && keys[1] === 'stack')
     ))) {
    if (typeof value === 'function') {
      var name = getName(value);
      var nameSuffix = name ? ': ' + name : '';
      return ctx.stylize('[Function' + nameSuffix + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toUTCString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (typeof value === 'function') {
    var name = getName(value);
    var nameSuffix = name ? ': ' + name : '';
    base = ' [Function' + nameSuffix + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    return formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  switch (typeof value) {
    case 'undefined':
      return ctx.stylize('undefined', 'undefined');

    case 'string':
      var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                               .replace(/'/g, "\\'")
                                               .replace(/\\"/g, '"') + '\'';
      return ctx.stylize(simple, 'string');

    case 'number':
      if (value === 0 && (1/value) === -Infinity) {
        return ctx.stylize('-0', 'number');
      }
      return ctx.stylize('' + value, 'number');

    case 'boolean':
      return ctx.stylize('' + value, 'boolean');
  }
  // For some reason typeof null is "object", so special case here.
  if (value === null) {
    return ctx.stylize('null', 'null');
  }
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (Object.prototype.hasOwnProperty.call(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str;
  if (value.__lookupGetter__) {
    if (value.__lookupGetter__(key)) {
      if (value.__lookupSetter__(key)) {
        str = ctx.stylize('[Getter/Setter]', 'special');
      } else {
        str = ctx.stylize('[Getter]', 'special');
      }
    } else {
      if (value.__lookupSetter__(key)) {
        str = ctx.stylize('[Setter]', 'special');
      }
    }
  }
  if (visibleKeys.indexOf(key) < 0) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(value[key]) < 0) {
      if (recurseTimes === null) {
        str = formatValue(ctx, value[key], null);
      } else {
        str = formatValue(ctx, value[key], recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (typeof name === 'undefined') {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}

function isArray(ar) {
  return Array.isArray(ar) ||
         (typeof ar === 'object' && objectToString(ar) === '[object Array]');
}

function isRegExp(re) {
  return typeof re === 'object' && objectToString(re) === '[object RegExp]';
}

function isDate(d) {
  return typeof d === 'object' && objectToString(d) === '[object Date]';
}

function isError(e) {
  return typeof e === 'object' && objectToString(e) === '[object Error]';
}

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

},{"./getEnumerableProperties":14,"./getName":16,"./getProperties":19}],23:[function(require,module,exports){
/*!
 * Chai - flag utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependancies
 */

var inspect = require('./inspect');
var config = require('../config');

/**
 * ### .objDisplay (object)
 *
 * Determines if an object or an array matches
 * criteria to be inspected in-line for error
 * messages or should be truncated.
 *
 * @param {Mixed} javascript object to inspect
 * @name objDisplay
 * @api public
 */

module.exports = function (obj) {
  var str = inspect(obj)
    , type = Object.prototype.toString.call(obj);

  if (config.truncateThreshold && str.length >= config.truncateThreshold) {
    if (type === '[object Function]') {
      return !obj.name || obj.name === ''
        ? '[Function]'
        : '[Function: ' + obj.name + ']';
    } else if (type === '[object Array]') {
      return '[ Array(' + obj.length + ') ]';
    } else if (type === '[object Object]') {
      var keys = Object.keys(obj)
        , kstr = keys.length > 2
          ? keys.splice(0, 2).join(', ') + ', ...'
          : keys.join(', ');
      return '{ Object (' + kstr + ') }';
    } else {
      return str;
    }
  } else {
    return str;
  }
};

},{"../config":4,"./inspect":22}],24:[function(require,module,exports){
/*!
 * Chai - overwriteChainableMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### overwriteChainableMethod (ctx, name, method, chainingBehavior)
 *
 * Overwites an already existing chainable method
 * and provides access to the previous function or
 * property.  Must return functions to be used for
 * name.
 *
 *     utils.overwriteChainableMethod(chai.Assertion.prototype, 'length',
 *       function (_super) {
 *       }
 *     , function (_super) {
 *       }
 *     );
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.overwriteChainableMethod('foo', fn, fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.have.length(3);
 *     expect(myFoo).to.have.length.above(3);
 *
 * @param {Object} ctx object whose method / property is to be overwritten
 * @param {String} name of method / property to overwrite
 * @param {Function} method function that returns a function to be used for name
 * @param {Function} chainingBehavior function that returns a function to be used for property
 * @name overwriteChainableMethod
 * @api public
 */

module.exports = function (ctx, name, method, chainingBehavior) {
  var chainableBehavior = ctx.__methods[name];

  var _chainingBehavior = chainableBehavior.chainingBehavior;
  chainableBehavior.chainingBehavior = function () {
    var result = chainingBehavior(_chainingBehavior).call(this);
    return result === undefined ? this : result;
  };

  var _method = chainableBehavior.method;
  chainableBehavior.method = function () {
    var result = method(_method).apply(this, arguments);
    return result === undefined ? this : result;
  };
};

},{}],25:[function(require,module,exports){
/*!
 * Chai - overwriteMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### overwriteMethod (ctx, name, fn)
 *
 * Overwites an already existing method and provides
 * access to previous function. Must return function
 * to be used for name.
 *
 *     utils.overwriteMethod(chai.Assertion.prototype, 'equal', function (_super) {
 *       return function (str) {
 *         var obj = utils.flag(this, 'object');
 *         if (obj instanceof Foo) {
 *           new chai.Assertion(obj.value).to.equal(str);
 *         } else {
 *           _super.apply(this, arguments);
 *         }
 *       }
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.overwriteMethod('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.equal('bar');
 *
 * @param {Object} ctx object whose method is to be overwritten
 * @param {String} name of method to overwrite
 * @param {Function} method function that returns a function to be used for name
 * @name overwriteMethod
 * @api public
 */

module.exports = function (ctx, name, method) {
  var _method = ctx[name]
    , _super = function () { return this; };

  if (_method && 'function' === typeof _method)
    _super = _method;

  ctx[name] = function () {
    var result = method(_super).apply(this, arguments);
    return result === undefined ? this : result;
  }
};

},{}],26:[function(require,module,exports){
/*!
 * Chai - overwriteProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### overwriteProperty (ctx, name, fn)
 *
 * Overwites an already existing property getter and provides
 * access to previous value. Must return function to use as getter.
 *
 *     utils.overwriteProperty(chai.Assertion.prototype, 'ok', function (_super) {
 *       return function () {
 *         var obj = utils.flag(this, 'object');
 *         if (obj instanceof Foo) {
 *           new chai.Assertion(obj.name).to.equal('bar');
 *         } else {
 *           _super.call(this);
 *         }
 *       }
 *     });
 *
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.overwriteProperty('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.be.ok;
 *
 * @param {Object} ctx object whose property is to be overwritten
 * @param {String} name of property to overwrite
 * @param {Function} getter function that returns a getter function to be used for name
 * @name overwriteProperty
 * @api public
 */

module.exports = function (ctx, name, getter) {
  var _get = Object.getOwnPropertyDescriptor(ctx, name)
    , _super = function () {};

  if (_get && 'function' === typeof _get.get)
    _super = _get.get

  Object.defineProperty(ctx, name,
    { get: function () {
        var result = getter(_super).call(this);
        return result === undefined ? this : result;
      }
    , configurable: true
  });
};

},{}],27:[function(require,module,exports){
/*!
 * Chai - test utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependancies
 */

var flag = require('./flag');

/**
 * # test(object, expression)
 *
 * Test and object for expression.
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 */

module.exports = function (obj, args) {
  var negate = flag(obj, 'negate')
    , expr = args[0];
  return negate ? !expr : expr;
};

},{"./flag":12}],28:[function(require,module,exports){
/*!
 * Chai - transferFlags utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### transferFlags(assertion, object, includeAll = true)
 *
 * Transfer all the flags for `assertion` to `object`. If
 * `includeAll` is set to `false`, then the base Chai
 * assertion flags (namely `object`, `ssfi`, and `message`)
 * will not be transferred.
 *
 *
 *     var newAssertion = new Assertion();
 *     utils.transferFlags(assertion, newAssertion);
 *
 *     var anotherAsseriton = new Assertion(myObj);
 *     utils.transferFlags(assertion, anotherAssertion, false);
 *
 * @param {Assertion} assertion the assertion to transfer the flags from
 * @param {Object} object the object to transfer the flags to; usually a new assertion
 * @param {Boolean} includeAll
 * @name transferFlags
 * @api private
 */

module.exports = function (assertion, object, includeAll) {
  var flags = assertion.__flags || (assertion.__flags = Object.create(null));

  if (!object.__flags) {
    object.__flags = Object.create(null);
  }

  includeAll = arguments.length === 3 ? includeAll : true;

  for (var flag in flags) {
    if (includeAll ||
        (flag !== 'object' && flag !== 'ssfi' && flag != 'message')) {
      object.__flags[flag] = flags[flag];
    }
  }
};

},{}],29:[function(require,module,exports){
/*!
 * assertion-error
 * Copyright(c) 2013 Jake Luer <jake@qualiancy.com>
 * MIT Licensed
 */

/*!
 * Return a function that will copy properties from
 * one object to another excluding any originally
 * listed. Returned function will create a new `{}`.
 *
 * @param {String} excluded properties ...
 * @return {Function}
 */

function exclude () {
  var excludes = [].slice.call(arguments);

  function excludeProps (res, obj) {
    Object.keys(obj).forEach(function (key) {
      if (!~excludes.indexOf(key)) res[key] = obj[key];
    });
  }

  return function extendExclude () {
    var args = [].slice.call(arguments)
      , i = 0
      , res = {};

    for (; i < args.length; i++) {
      excludeProps(res, args[i]);
    }

    return res;
  };
};

/*!
 * Primary Exports
 */

module.exports = AssertionError;

/**
 * ### AssertionError
 *
 * An extension of the JavaScript `Error` constructor for
 * assertion and validation scenarios.
 *
 * @param {String} message
 * @param {Object} properties to include (optional)
 * @param {callee} start stack function (optional)
 */

function AssertionError (message, _props, ssf) {
  var extend = exclude('name', 'message', 'stack', 'constructor', 'toJSON')
    , props = extend(_props || {});

  // default values
  this.message = message || 'Unspecified AssertionError';
  this.showDiff = false;

  // copy from properties
  for (var key in props) {
    this[key] = props[key];
  }

  // capture stack trace
  ssf = ssf || arguments.callee;
  if (ssf && Error.captureStackTrace) {
    Error.captureStackTrace(this, ssf);
  } else {
    this.stack = new Error().stack;
  }
}

/*!
 * Inherit from Error.prototype
 */

AssertionError.prototype = Object.create(Error.prototype);

/*!
 * Statically set name
 */

AssertionError.prototype.name = 'AssertionError';

/*!
 * Ensure correct constructor
 */

AssertionError.prototype.constructor = AssertionError;

/**
 * Allow errors to be converted to JSON for static transfer.
 *
 * @param {Boolean} include stack (default: `true`)
 * @return {Object} object that can be `JSON.stringify`
 */

AssertionError.prototype.toJSON = function (stack) {
  var extend = exclude('constructor', 'toJSON', 'stack')
    , props = extend({ name: this.name }, this);

  // include stack if exists and not turned off
  if (false !== stack && this.stack) {
    props.stack = this.stack;
  }

  return props;
};

},{}],30:[function(require,module,exports){
module.exports = require('./lib/eql');

},{"./lib/eql":31}],31:[function(require,module,exports){
/*!
 * deep-eql
 * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependencies
 */

var type = require('type-detect');

/*!
 * Buffer.isBuffer browser shim
 */

var Buffer;
try { Buffer = require('buffer').Buffer; }
catch(ex) {
  Buffer = {};
  Buffer.isBuffer = function() { return false; }
}

/*!
 * Primary Export
 */

module.exports = deepEqual;

/**
 * Assert super-strict (egal) equality between
 * two objects of any type.
 *
 * @param {Mixed} a
 * @param {Mixed} b
 * @param {Array} memoised (optional)
 * @return {Boolean} equal match
 */

function deepEqual(a, b, m) {
  if (sameValue(a, b)) {
    return true;
  } else if ('date' === type(a)) {
    return dateEqual(a, b);
  } else if ('regexp' === type(a)) {
    return regexpEqual(a, b);
  } else if (Buffer.isBuffer(a)) {
    return bufferEqual(a, b);
  } else if ('arguments' === type(a)) {
    return argumentsEqual(a, b, m);
  } else if (!typeEqual(a, b)) {
    return false;
  } else if (('object' !== type(a) && 'object' !== type(b))
  && ('array' !== type(a) && 'array' !== type(b))) {
    return sameValue(a, b);
  } else {
    return objectEqual(a, b, m);
  }
}

/*!
 * Strict (egal) equality test. Ensures that NaN always
 * equals NaN and `-0` does not equal `+0`.
 *
 * @param {Mixed} a
 * @param {Mixed} b
 * @return {Boolean} equal match
 */

function sameValue(a, b) {
  if (a === b) return a !== 0 || 1 / a === 1 / b;
  return a !== a && b !== b;
}

/*!
 * Compare the types of two given objects and
 * return if they are equal. Note that an Array
 * has a type of `array` (not `object`) and arguments
 * have a type of `arguments` (not `array`/`object`).
 *
 * @param {Mixed} a
 * @param {Mixed} b
 * @return {Boolean} result
 */

function typeEqual(a, b) {
  return type(a) === type(b);
}

/*!
 * Compare two Date objects by asserting that
 * the time values are equal using `saveValue`.
 *
 * @param {Date} a
 * @param {Date} b
 * @return {Boolean} result
 */

function dateEqual(a, b) {
  if ('date' !== type(b)) return false;
  return sameValue(a.getTime(), b.getTime());
}

/*!
 * Compare two regular expressions by converting them
 * to string and checking for `sameValue`.
 *
 * @param {RegExp} a
 * @param {RegExp} b
 * @return {Boolean} result
 */

function regexpEqual(a, b) {
  if ('regexp' !== type(b)) return false;
  return sameValue(a.toString(), b.toString());
}

/*!
 * Assert deep equality of two `arguments` objects.
 * Unfortunately, these must be sliced to arrays
 * prior to test to ensure no bad behavior.
 *
 * @param {Arguments} a
 * @param {Arguments} b
 * @param {Array} memoize (optional)
 * @return {Boolean} result
 */

function argumentsEqual(a, b, m) {
  if ('arguments' !== type(b)) return false;
  a = [].slice.call(a);
  b = [].slice.call(b);
  return deepEqual(a, b, m);
}

/*!
 * Get enumerable properties of a given object.
 *
 * @param {Object} a
 * @return {Array} property names
 */

function enumerable(a) {
  var res = [];
  for (var key in a) res.push(key);
  return res;
}

/*!
 * Simple equality for flat iterable objects
 * such as Arrays or Node.js buffers.
 *
 * @param {Iterable} a
 * @param {Iterable} b
 * @return {Boolean} result
 */

function iterableEqual(a, b) {
  if (a.length !==  b.length) return false;

  var i = 0;
  var match = true;

  for (; i < a.length; i++) {
    if (a[i] !== b[i]) {
      match = false;
      break;
    }
  }

  return match;
}

/*!
 * Extension to `iterableEqual` specifically
 * for Node.js Buffers.
 *
 * @param {Buffer} a
 * @param {Mixed} b
 * @return {Boolean} result
 */

function bufferEqual(a, b) {
  if (!Buffer.isBuffer(b)) return false;
  return iterableEqual(a, b);
}

/*!
 * Block for `objectEqual` ensuring non-existing
 * values don't get in.
 *
 * @param {Mixed} object
 * @return {Boolean} result
 */

function isValue(a) {
  return a !== null && a !== undefined;
}

/*!
 * Recursively check the equality of two objects.
 * Once basic sameness has been established it will
 * defer to `deepEqual` for each enumerable key
 * in the object.
 *
 * @param {Mixed} a
 * @param {Mixed} b
 * @return {Boolean} result
 */

function objectEqual(a, b, m) {
  if (!isValue(a) || !isValue(b)) {
    return false;
  }

  if (a.prototype !== b.prototype) {
    return false;
  }

  var i;
  if (m) {
    for (i = 0; i < m.length; i++) {
      if ((m[i][0] === a && m[i][1] === b)
      ||  (m[i][0] === b && m[i][1] === a)) {
        return true;
      }
    }
  } else {
    m = [];
  }

  try {
    var ka = enumerable(a);
    var kb = enumerable(b);
  } catch (ex) {
    return false;
  }

  ka.sort();
  kb.sort();

  if (!iterableEqual(ka, kb)) {
    return false;
  }

  m.push([ a, b ]);

  var key;
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!deepEqual(a[key], b[key], m)) {
      return false;
    }
  }

  return true;
}

},{"buffer":undefined,"type-detect":32}],32:[function(require,module,exports){
module.exports = require('./lib/type');

},{"./lib/type":33}],33:[function(require,module,exports){
/*!
 * type-detect
 * Copyright(c) 2013 jake luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Primary Exports
 */

var exports = module.exports = getType;

/*!
 * Detectable javascript natives
 */

var natives = {
    '[object Array]': 'array'
  , '[object RegExp]': 'regexp'
  , '[object Function]': 'function'
  , '[object Arguments]': 'arguments'
  , '[object Date]': 'date'
};

/**
 * ### typeOf (obj)
 *
 * Use several different techniques to determine
 * the type of object being tested.
 *
 *
 * @param {Mixed} object
 * @return {String} object type
 * @api public
 */

function getType (obj) {
  var str = Object.prototype.toString.call(obj);
  if (natives[str]) return natives[str];
  if (obj === null) return 'null';
  if (obj === undefined) return 'undefined';
  if (obj === Object(obj)) return 'object';
  return typeof obj;
}

exports.Library = Library;

/**
 * ### Library
 *
 * Create a repository for custom type detection.
 *
 * ```js
 * var lib = new type.Library;
 * ```
 *
 */

function Library () {
  this.tests = {};
}

/**
 * #### .of (obj)
 *
 * Expose replacement `typeof` detection to the library.
 *
 * ```js
 * if ('string' === lib.of('hello world')) {
 *   // ...
 * }
 * ```
 *
 * @param {Mixed} object to test
 * @return {String} type
 */

Library.prototype.of = getType;

/**
 * #### .define (type, test)
 *
 * Add a test to for the `.test()` assertion.
 *
 * Can be defined as a regular expression:
 *
 * ```js
 * lib.define('int', /^[0-9]+$/);
 * ```
 *
 * ... or as a function:
 *
 * ```js
 * lib.define('bln', function (obj) {
 *   if ('boolean' === lib.of(obj)) return true;
 *   var blns = [ 'yes', 'no', 'true', 'false', 1, 0 ];
 *   if ('string' === lib.of(obj)) obj = obj.toLowerCase();
 *   return !! ~blns.indexOf(obj);
 * });
 * ```
 *
 * @param {String} type
 * @param {RegExp|Function} test
 * @api public
 */

Library.prototype.define = function (type, test) {
  if (arguments.length === 1) return this.tests[type];
  this.tests[type] = test;
  return this;
};

/**
 * #### .test (obj, test)
 *
 * Assert that an object is of type. Will first
 * check natives, and if that does not pass it will
 * use the user defined custom tests.
 *
 * ```js
 * assert(lib.test('1', 'int'));
 * assert(lib.test('yes', 'bln'));
 * ```
 *
 * @param {Mixed} object
 * @param {String} type
 * @return {Boolean} result
 * @api public
 */

Library.prototype.test = function (obj, type) {
  if (type === getType(obj)) return true;
  var test = this.tests[type];

  if (test && 'regexp' === getType(test)) {
    return test.test(obj);
  } else if (test && 'function' === getType(test)) {
    return test(obj);
  } else {
    throw new ReferenceError('Type test "' + type + '" not defined or invalid.');
  }
};

},{}],34:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"./lib/type":35,"dup":32}],35:[function(require,module,exports){
/*!
 * type-detect
 * Copyright(c) 2013 jake luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Primary Exports
 */

var exports = module.exports = getType;

/**
 * ### typeOf (obj)
 *
 * Use several different techniques to determine
 * the type of object being tested.
 *
 *
 * @param {Mixed} object
 * @return {String} object type
 * @api public
 */
var objectTypeRegexp = /^\[object (.*)\]$/;

function getType(obj) {
  var type = Object.prototype.toString.call(obj).match(objectTypeRegexp)[1].toLowerCase();
  // Let "new String('')" return 'object'
  if (typeof Promise === 'function' && obj instanceof Promise) return 'promise';
  // PhantomJS has type "DOMWindow" for null
  if (obj === null) return 'null';
  // PhantomJS has type "DOMWindow" for undefined
  if (obj === undefined) return 'undefined';
  return type;
}

exports.Library = Library;

/**
 * ### Library
 *
 * Create a repository for custom type detection.
 *
 * ```js
 * var lib = new type.Library;
 * ```
 *
 */

function Library() {
  if (!(this instanceof Library)) return new Library();
  this.tests = {};
}

/**
 * #### .of (obj)
 *
 * Expose replacement `typeof` detection to the library.
 *
 * ```js
 * if ('string' === lib.of('hello world')) {
 *   // ...
 * }
 * ```
 *
 * @param {Mixed} object to test
 * @return {String} type
 */

Library.prototype.of = getType;

/**
 * #### .define (type, test)
 *
 * Add a test to for the `.test()` assertion.
 *
 * Can be defined as a regular expression:
 *
 * ```js
 * lib.define('int', /^[0-9]+$/);
 * ```
 *
 * ... or as a function:
 *
 * ```js
 * lib.define('bln', function (obj) {
 *   if ('boolean' === lib.of(obj)) return true;
 *   var blns = [ 'yes', 'no', 'true', 'false', 1, 0 ];
 *   if ('string' === lib.of(obj)) obj = obj.toLowerCase();
 *   return !! ~blns.indexOf(obj);
 * });
 * ```
 *
 * @param {String} type
 * @param {RegExp|Function} test
 * @api public
 */

Library.prototype.define = function(type, test) {
  if (arguments.length === 1) return this.tests[type];
  this.tests[type] = test;
  return this;
};

/**
 * #### .test (obj, test)
 *
 * Assert that an object is of type. Will first
 * check natives, and if that does not pass it will
 * use the user defined custom tests.
 *
 * ```js
 * assert(lib.test('1', 'int'));
 * assert(lib.test('yes', 'bln'));
 * ```
 *
 * @param {Mixed} object
 * @param {String} type
 * @return {Boolean} result
 * @api public
 */

Library.prototype.test = function(obj, type) {
  if (type === getType(obj)) return true;
  var test = this.tests[type];

  if (test && 'regexp' === getType(test)) {
    return test.test(obj);
  } else if (test && 'function' === getType(test)) {
    return test(obj);
  } else {
    throw new ReferenceError('Type test "' + type + '" not defined or invalid.');
  }
};

},{}]},{},[1])(1)
});
});
require.register("jonnor-chai/component.json", function(exports, require, module){
module.exports = JSON.parse('{"name":"chai","description":"Assertion framework","author":"","repo":"jonnor/chai","version":"3.2.0","main":"chai.js","keywords":[],"dependencies":{},"remotes":["https://raw.githubusercontent.com"],"scripts":["chai.js"],"json":["component.json"]}');
});
require.register("jonnor-jsonpath/lib/jsonpath.js", function(exports, require, module){
/*global module, exports, require*/
/*jslint vars:true, evil:true*/
/* JSONPath 0.8.0 - XPath for JSON
 *
 * Copyright (c) 2007 Stefan Goessner (goessner.net)
 * Licensed under the MIT (MIT-LICENSE.txt) licence.
 */

(function (require) {'use strict';

// Keep compatibility with old browsers
if (!Array.isArray) {
    Array.isArray = function (vArg) {
        return Object.prototype.toString.call(vArg) === '[object Array]';
    };
}

// Make sure to know if we are in real node or not (the `require` variable
// could actually be require.js, for example.
var isNode = typeof module !== 'undefined' && !!module.exports &&
    typeof process !== 'undefined' && process.execPath && process.execPath.match(/node|iojs/);

var vm = isNode ?
    require('vm') : {
        runInNewContext: function (expr, context) {
            return eval(Object.keys(context).reduce(function (s, vr) {
                return 'var ' + vr + '=' + JSON.stringify(context[vr]) + ';' + s;
            }, expr));
        }
    };

var cache = {};

function push (arr, elem) {arr = arr.slice(); arr.push(elem); return arr;}
function unshift (elem, arr) {arr = arr.slice(); arr.unshift(elem); return arr;}

function JSONPath (opts, obj, expr) {
    if (!(this instanceof JSONPath)) {
        try {
            return new JSONPath(opts, obj, expr);
        }
        catch (e) {
            if (!e.avoidNew) {
                throw e;
            }
            return e.value;
        }
    }

    opts = opts || {};
    var objArgs = opts.hasOwnProperty('json') && opts.hasOwnProperty('path');
    this.resultType = (opts.resultType && opts.resultType.toLowerCase()) || 'value';
    this.flatten = opts.flatten || false;
    this.wrap = opts.hasOwnProperty('wrap') ? opts.wrap : true;
    this.sandbox = opts.sandbox || {};

    if (opts.autostart !== false) {
        var ret = this.evaluate((objArgs ? opts.json : obj), (objArgs ? opts.path : expr));
        if (!ret || typeof reg !== 'object') {
            throw {avoidNew: true, value: ret, message: "JSONPath should not be called with 'new'"};
        }
    }
}

// PUBLIC METHODS

JSONPath.prototype.evaluate = function (obj, expr) {
    var self = this;
    this._obj = obj;
    if (expr && obj && (this.resultType === 'value' || this.resultType === 'path')) {
        var exprList = this._normalize(expr);
        if (exprList[0] === '$' && exprList.length > 1) {exprList.shift();}
        var result = this._trace(exprList, obj, ['$']);
        result = result.filter(function (ea) { return ea && !ea.isParentSelector; });
        if (!result.length) {return this.wrap ? [] : false;}
        if (result.length === 1 && !this.wrap && !Array.isArray(result[0].value)) {return result[0][this.resultType] || false;}
        return result.reduce(function (result, ea) {
            var valOrPath = ea[self.resultType];
            if (self.resultType === 'path') {valOrPath = self._asPath(valOrPath);}
            if (self.flatten && Array.isArray(valOrPath)) {
                result = result.concat(valOrPath);
            } else {
                result.push(valOrPath);
            }
            return result;
        }, []);
    }
};

// PRIVATE METHODS

JSONPath.prototype._normalize = function (expr) {
    if (cache[expr]) {return cache[expr];}
    var subx = [];
    var normalized = expr.replace(/[\['](\??\(.*?\))[\]']/g, function ($0, $1) {return '[#' + (subx.push($1) - 1) + ']';})
                    .replace(/'?\.'?|\['?/g, ';')
                    .replace(/(?:;)?(\^+)(?:;)?/g, function ($0, ups) {return ';' + ups.split('').join(';') + ';';})
                    .replace(/;;;|;;/g, ';..;')
                    .replace(/;$|'?\]|'$/g, '');
    var exprList = normalized.split(';').map(function (expr) {
        var match = expr.match(/#([0-9]+)/);
        return !match || !match[1] ? expr : subx[match[1]];
    });
    cache[expr] = exprList;
    return cache[expr];
};

JSONPath.prototype._asPath = function (path) {
    var i, n, x = path, p = '$';
    for (i = 1, n = x.length; i < n; i++) {
        p += /^[0-9*]+$/.test(x[i]) ? ('[' + x[i] + ']') : ("['" + x[i] + "']");
    }
    return p;
};

JSONPath.prototype._trace = function (expr, val, path) {
    // No expr to follow? return path and value as the result of this trace branch
    var self = this;
    if (!expr.length) {return [{path: path, value: val}];}

    var loc = expr[0], x = expr.slice(1);
    // The parent sel computation is handled in the frame above using the
    // ancestor object of val
    if (loc === '^') {return path.length ? [{path: path.slice(0, -1), expr: x, isParentSelector: true}] : [];}

    // We need to gather the return value of recursive trace calls in order to
    // do the parent sel computation.
    var ret = [];
    function addRet (elems) {ret = ret.concat(elems);}

    if (val && val.hasOwnProperty(loc)) { // simple case, directly follow property
        addRet(this._trace(x, val[loc], push(path, loc)));
    }
    else if (loc === '*') { // any property
        this._walk(loc, x, val, path, function (m, l, x, v, p) {
            addRet(self._trace(unshift(m, x), v, p));
        });
    }
    else if (loc === '..') { // all child properties
        addRet(this._trace(x, val, path));
        this._walk(loc, x, val, path, function (m, l, x, v, p) {
            if (typeof v[m] === 'object') {
                addRet(self._trace(unshift('..', x), v[m], push(p, m)));
            }
        });
    }
    else if (loc[0] === '(') { // [(expr)]
        addRet(this._trace(unshift(this._eval(loc, val, path[path.length], path), x), val, path));
    }
    else if (loc.indexOf('?(') === 0) { // [?(expr)]
        this._walk(loc, x, val, path, function (m, l, x, v, p) {
            if (self._eval(l.replace(/^\?\((.*?)\)$/, '$1'), v[m], m, path)) {
                addRet(self._trace(unshift(m, x), v, p));
            }
        });
    }
    else if (loc.indexOf(',') > -1) { // [name1,name2,...]
        var parts, i;
        for (parts = loc.split(','), i = 0; i < parts.length; i++) {
            addRet(this._trace(unshift(parts[i], x), val, path));
        }
    }
    else if (/^(-?[0-9]*):(-?[0-9]*):?([0-9]*)$/.test(loc)) { // [start:end:step]  Python slice syntax
        addRet(this._slice(loc, x, val, path));
    }

    // We check the resulting values for parent selections. For parent
    // selections we discard the value object and continue the trace with the
    // current val object
    return ret.reduce(function (all, ea) {
        return all.concat(ea.isParentSelector ? self._trace(ea.expr, val, ea.path) : [ea]);
    }, []);
};

JSONPath.prototype._walk = function (loc, expr, val, path, f) {
    var i, n, m;
    if (Array.isArray(val)) {
        for (i = 0, n = val.length; i < n; i++) {
            f(i, loc, expr, val, path);
        }
    }
    else if (typeof val === 'object') {
        for (m in val) {
            if (val.hasOwnProperty(m)) {
                f(m, loc, expr, val, path);
            }
        }
    }
};

JSONPath.prototype._slice = function (loc, expr, val, path) {
    if (!Array.isArray(val)) {return;}
    var i,
        len = val.length, parts = loc.split(':'),
        start = (parts[0] && parseInt(parts[0], 10)) || 0,
        end = (parts[1] && parseInt(parts[1], 10)) || len,
        step = (parts[2] && parseInt(parts[2], 10)) || 1;
    start = (start < 0) ? Math.max(0, start + len) : Math.min(len, start);
    end    = (end < 0)    ? Math.max(0, end + len) : Math.min(len, end);
    var ret = [];
    for (i = start; i < end; i += step) {
        ret = ret.concat(this._trace(unshift(i, expr), val, path));
    }
    return ret;
};

JSONPath.prototype._eval = function (code, _v, _vname, path) {
    if (!this._obj || !_v) {return false;}
    if (code.indexOf('@path') > -1) {
        this.sandbox._$_path = this._asPath(path.concat([_vname]));
        code = code.replace(/@path/g, '_$_path');
    }
    if (code.indexOf('@') > -1) {
        this.sandbox._$_v = _v;
        code = code.replace(/@/g, '_$_v');
    }
    try {
        return vm.runInNewContext(code, this.sandbox);
    }
    catch(e) {
        console.log(e);
        throw new Error('jsonPath: ' + e.message + ': ' + code);
    }
};

// For backward compatibility (deprecated)
JSONPath.eval = function (obj, expr, opts) {
    return JSONPath(opts, obj, expr);
};

if (typeof module === 'undefined') {
    window.jsonPath = { // Deprecated
        eval: JSONPath.eval
    };
    window.JSONPath = JSONPath;
}
else {
    module.exports = JSONPath;
}

}(typeof require === 'undefined' ? null : require));

});
require.register("jonnor-jsonpath/component.json", function(exports, require, module){
module.exports = JSON.parse('{"name":"JSONPath","description":"JSONPath for JavaScript","author":"","repo":"jonnor/JSONPaths","version":"0.11.0","main":"lib/jsonpath.js","keywords":[],"dependencies":{},"remotes":["https://raw.githubusercontent.com"],"scripts":["lib/jsonpath.js"],"json":["component.json"]}');
});
require.register("geraintluff-tv4/tv4.js", function(exports, require, module){
/*
Author: Geraint Luff and others
Year: 2013

This code is released into the "public domain" by its author(s).  Anybody may use, alter and distribute the code without restriction.  The author makes no guarantees, and takes no liability of any kind for use of this code.

If you find a bug or make an improvement, it would be courteous to let the author know, but it is not compulsory.
*/
(function (global, factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define([], factory);
  } else if (typeof module !== 'undefined' && module.exports){
    // CommonJS. Define export.
    module.exports = factory();
  } else {
    // Browser globals
    global.tv4 = factory();
  }
}(this, function () {

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FObject%2Fkeys
if (!Object.keys) {
	Object.keys = (function () {
		var hasOwnProperty = Object.prototype.hasOwnProperty,
			hasDontEnumBug = !({toString: null}).propertyIsEnumerable('toString'),
			dontEnums = [
				'toString',
				'toLocaleString',
				'valueOf',
				'hasOwnProperty',
				'isPrototypeOf',
				'propertyIsEnumerable',
				'constructor'
			],
			dontEnumsLength = dontEnums.length;

		return function (obj) {
			if (typeof obj !== 'object' && typeof obj !== 'function' || obj === null) {
				throw new TypeError('Object.keys called on non-object');
			}

			var result = [];

			for (var prop in obj) {
				if (hasOwnProperty.call(obj, prop)) {
					result.push(prop);
				}
			}

			if (hasDontEnumBug) {
				for (var i=0; i < dontEnumsLength; i++) {
					if (hasOwnProperty.call(obj, dontEnums[i])) {
						result.push(dontEnums[i]);
					}
				}
			}
			return result;
		};
	})();
}
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create
if (!Object.create) {
	Object.create = (function(){
		function F(){}

		return function(o){
			if (arguments.length !== 1) {
				throw new Error('Object.create implementation only accepts one parameter.');
			}
			F.prototype = o;
			return new F();
		};
	})();
}
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FArray%2FisArray
if(!Array.isArray) {
	Array.isArray = function (vArg) {
		return Object.prototype.toString.call(vArg) === "[object Array]";
	};
}
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FArray%2FindexOf
if (!Array.prototype.indexOf) {
	Array.prototype.indexOf = function (searchElement /*, fromIndex */ ) {
		if (this === null) {
			throw new TypeError();
		}
		var t = Object(this);
		var len = t.length >>> 0;

		if (len === 0) {
			return -1;
		}
		var n = 0;
		if (arguments.length > 1) {
			n = Number(arguments[1]);
			if (n !== n) { // shortcut for verifying if it's NaN
				n = 0;
			} else if (n !== 0 && n !== Infinity && n !== -Infinity) {
				n = (n > 0 || -1) * Math.floor(Math.abs(n));
			}
		}
		if (n >= len) {
			return -1;
		}
		var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);
		for (; k < len; k++) {
			if (k in t && t[k] === searchElement) {
				return k;
			}
		}
		return -1;
	};
}

// Grungey Object.isFrozen hack
if (!Object.isFrozen) {
	Object.isFrozen = function (obj) {
		var key = "tv4_test_frozen_key";
		while (obj.hasOwnProperty(key)) {
			key += Math.random();
		}
		try {
			obj[key] = true;
			delete obj[key];
			return false;
		} catch (e) {
			return true;
		}
	};
}
// Based on: https://github.com/geraintluff/uri-templates, but with all the de-substitution stuff removed

var uriTemplateGlobalModifiers = {
	"+": true,
	"#": true,
	".": true,
	"/": true,
	";": true,
	"?": true,
	"&": true
};
var uriTemplateSuffices = {
	"*": true
};

function notReallyPercentEncode(string) {
	return encodeURI(string).replace(/%25[0-9][0-9]/g, function (doubleEncoded) {
		return "%" + doubleEncoded.substring(3);
	});
}

function uriTemplateSubstitution(spec) {
	var modifier = "";
	if (uriTemplateGlobalModifiers[spec.charAt(0)]) {
		modifier = spec.charAt(0);
		spec = spec.substring(1);
	}
	var separator = "";
	var prefix = "";
	var shouldEscape = true;
	var showVariables = false;
	var trimEmptyString = false;
	if (modifier === '+') {
		shouldEscape = false;
	} else if (modifier === ".") {
		prefix = ".";
		separator = ".";
	} else if (modifier === "/") {
		prefix = "/";
		separator = "/";
	} else if (modifier === '#') {
		prefix = "#";
		shouldEscape = false;
	} else if (modifier === ';') {
		prefix = ";";
		separator = ";";
		showVariables = true;
		trimEmptyString = true;
	} else if (modifier === '?') {
		prefix = "?";
		separator = "&";
		showVariables = true;
	} else if (modifier === '&') {
		prefix = "&";
		separator = "&";
		showVariables = true;
	}

	var varNames = [];
	var varList = spec.split(",");
	var varSpecs = [];
	var varSpecMap = {};
	for (var i = 0; i < varList.length; i++) {
		var varName = varList[i];
		var truncate = null;
		if (varName.indexOf(":") !== -1) {
			var parts = varName.split(":");
			varName = parts[0];
			truncate = parseInt(parts[1], 10);
		}
		var suffices = {};
		while (uriTemplateSuffices[varName.charAt(varName.length - 1)]) {
			suffices[varName.charAt(varName.length - 1)] = true;
			varName = varName.substring(0, varName.length - 1);
		}
		var varSpec = {
			truncate: truncate,
			name: varName,
			suffices: suffices
		};
		varSpecs.push(varSpec);
		varSpecMap[varName] = varSpec;
		varNames.push(varName);
	}
	var subFunction = function (valueFunction) {
		var result = "";
		var startIndex = 0;
		for (var i = 0; i < varSpecs.length; i++) {
			var varSpec = varSpecs[i];
			var value = valueFunction(varSpec.name);
			if (value === null || value === undefined || (Array.isArray(value) && value.length === 0) || (typeof value === 'object' && Object.keys(value).length === 0)) {
				startIndex++;
				continue;
			}
			if (i === startIndex) {
				result += prefix;
			} else {
				result += (separator || ",");
			}
			if (Array.isArray(value)) {
				if (showVariables) {
					result += varSpec.name + "=";
				}
				for (var j = 0; j < value.length; j++) {
					if (j > 0) {
						result += varSpec.suffices['*'] ? (separator || ",") : ",";
						if (varSpec.suffices['*'] && showVariables) {
							result += varSpec.name + "=";
						}
					}
					result += shouldEscape ? encodeURIComponent(value[j]).replace(/!/g, "%21") : notReallyPercentEncode(value[j]);
				}
			} else if (typeof value === "object") {
				if (showVariables && !varSpec.suffices['*']) {
					result += varSpec.name + "=";
				}
				var first = true;
				for (var key in value) {
					if (!first) {
						result += varSpec.suffices['*'] ? (separator || ",") : ",";
					}
					first = false;
					result += shouldEscape ? encodeURIComponent(key).replace(/!/g, "%21") : notReallyPercentEncode(key);
					result += varSpec.suffices['*'] ? '=' : ",";
					result += shouldEscape ? encodeURIComponent(value[key]).replace(/!/g, "%21") : notReallyPercentEncode(value[key]);
				}
			} else {
				if (showVariables) {
					result += varSpec.name;
					if (!trimEmptyString || value !== "") {
						result += "=";
					}
				}
				if (varSpec.truncate != null) {
					value = value.substring(0, varSpec.truncate);
				}
				result += shouldEscape ? encodeURIComponent(value).replace(/!/g, "%21"): notReallyPercentEncode(value);
			}
		}
		return result;
	};
	subFunction.varNames = varNames;
	return {
		prefix: prefix,
		substitution: subFunction
	};
}

function UriTemplate(template) {
	if (!(this instanceof UriTemplate)) {
		return new UriTemplate(template);
	}
	var parts = template.split("{");
	var textParts = [parts.shift()];
	var prefixes = [];
	var substitutions = [];
	var varNames = [];
	while (parts.length > 0) {
		var part = parts.shift();
		var spec = part.split("}")[0];
		var remainder = part.substring(spec.length + 1);
		var funcs = uriTemplateSubstitution(spec);
		substitutions.push(funcs.substitution);
		prefixes.push(funcs.prefix);
		textParts.push(remainder);
		varNames = varNames.concat(funcs.substitution.varNames);
	}
	this.fill = function (valueFunction) {
		var result = textParts[0];
		for (var i = 0; i < substitutions.length; i++) {
			var substitution = substitutions[i];
			result += substitution(valueFunction);
			result += textParts[i + 1];
		}
		return result;
	};
	this.varNames = varNames;
	this.template = template;
}
UriTemplate.prototype = {
	toString: function () {
		return this.template;
	},
	fillFromObject: function (obj) {
		return this.fill(function (varName) {
			return obj[varName];
		});
	}
};
var ValidatorContext = function ValidatorContext(parent, collectMultiple, errorReporter, checkRecursive, trackUnknownProperties) {
	this.missing = [];
	this.missingMap = {};
	this.formatValidators = parent ? Object.create(parent.formatValidators) : {};
	this.schemas = parent ? Object.create(parent.schemas) : {};
	this.collectMultiple = collectMultiple;
	this.errors = [];
	this.handleError = collectMultiple ? this.collectError : this.returnError;
	if (checkRecursive) {
		this.checkRecursive = true;
		this.scanned = [];
		this.scannedFrozen = [];
		this.scannedFrozenSchemas = [];
		this.scannedFrozenValidationErrors = [];
		this.validatedSchemasKey = 'tv4_validation_id';
		this.validationErrorsKey = 'tv4_validation_errors_id';
	}
	if (trackUnknownProperties) {
		this.trackUnknownProperties = true;
		this.knownPropertyPaths = {};
		this.unknownPropertyPaths = {};
	}
	this.errorReporter = errorReporter || defaultErrorReporter('en');
	if (typeof this.errorReporter === 'string') {
		throw new Error('debug');
	}
	this.definedKeywords = {};
	if (parent) {
		for (var key in parent.definedKeywords) {
			this.definedKeywords[key] = parent.definedKeywords[key].slice(0);
		}
	}
};
ValidatorContext.prototype.defineKeyword = function (keyword, keywordFunction) {
	this.definedKeywords[keyword] = this.definedKeywords[keyword] || [];
	this.definedKeywords[keyword].push(keywordFunction);
};
ValidatorContext.prototype.createError = function (code, messageParams, dataPath, schemaPath, subErrors, data, schema) {
	var error = new ValidationError(code, messageParams, dataPath, schemaPath, subErrors);
	error.message = this.errorReporter(error, data, schema);
	return error;
};
ValidatorContext.prototype.returnError = function (error) {
	return error;
};
ValidatorContext.prototype.collectError = function (error) {
	if (error) {
		this.errors.push(error);
	}
	return null;
};
ValidatorContext.prototype.prefixErrors = function (startIndex, dataPath, schemaPath) {
	for (var i = startIndex; i < this.errors.length; i++) {
		this.errors[i] = this.errors[i].prefixWith(dataPath, schemaPath);
	}
	return this;
};
ValidatorContext.prototype.banUnknownProperties = function (data, schema) {
	for (var unknownPath in this.unknownPropertyPaths) {
		var error = this.createError(ErrorCodes.UNKNOWN_PROPERTY, {path: unknownPath}, unknownPath, "", null, data, schema);
		var result = this.handleError(error);
		if (result) {
			return result;
		}
	}
	return null;
};

ValidatorContext.prototype.addFormat = function (format, validator) {
	if (typeof format === 'object') {
		for (var key in format) {
			this.addFormat(key, format[key]);
		}
		return this;
	}
	this.formatValidators[format] = validator;
};
ValidatorContext.prototype.resolveRefs = function (schema, urlHistory) {
	if (schema['$ref'] !== undefined) {
		urlHistory = urlHistory || {};
		if (urlHistory[schema['$ref']]) {
			return this.createError(ErrorCodes.CIRCULAR_REFERENCE, {urls: Object.keys(urlHistory).join(', ')}, '', '', null, undefined, schema);
		}
		urlHistory[schema['$ref']] = true;
		schema = this.getSchema(schema['$ref'], urlHistory);
	}
	return schema;
};
ValidatorContext.prototype.getSchema = function (url, urlHistory) {
	var schema;
	if (this.schemas[url] !== undefined) {
		schema = this.schemas[url];
		return this.resolveRefs(schema, urlHistory);
	}
	var baseUrl = url;
	var fragment = "";
	if (url.indexOf('#') !== -1) {
		fragment = url.substring(url.indexOf("#") + 1);
		baseUrl = url.substring(0, url.indexOf("#"));
	}
	if (typeof this.schemas[baseUrl] === 'object') {
		schema = this.schemas[baseUrl];
		var pointerPath = decodeURIComponent(fragment);
		if (pointerPath === "") {
			return this.resolveRefs(schema, urlHistory);
		} else if (pointerPath.charAt(0) !== "/") {
			return undefined;
		}
		var parts = pointerPath.split("/").slice(1);
		for (var i = 0; i < parts.length; i++) {
			var component = parts[i].replace(/~1/g, "/").replace(/~0/g, "~");
			if (schema[component] === undefined) {
				schema = undefined;
				break;
			}
			schema = schema[component];
		}
		if (schema !== undefined) {
			return this.resolveRefs(schema, urlHistory);
		}
	}
	if (this.missing[baseUrl] === undefined) {
		this.missing.push(baseUrl);
		this.missing[baseUrl] = baseUrl;
		this.missingMap[baseUrl] = baseUrl;
	}
};
ValidatorContext.prototype.searchSchemas = function (schema, url) {
	if (Array.isArray(schema)) {
		for (var i = 0; i < schema.length; i++) {
			this.searchSchemas(schema[i], url);
		}
	} else if (schema && typeof schema === "object") {
		if (typeof schema.id === "string") {
			if (isTrustedUrl(url, schema.id)) {
				if (this.schemas[schema.id] === undefined) {
					this.schemas[schema.id] = schema;
				}
			}
		}
		for (var key in schema) {
			if (key !== "enum") {
				if (typeof schema[key] === "object") {
					this.searchSchemas(schema[key], url);
				} else if (key === "$ref") {
					var uri = getDocumentUri(schema[key]);
					if (uri && this.schemas[uri] === undefined && this.missingMap[uri] === undefined) {
						this.missingMap[uri] = uri;
					}
				}
			}
		}
	}
};
ValidatorContext.prototype.addSchema = function (url, schema) {
	//overload
	if (typeof url !== 'string' || typeof schema === 'undefined') {
		if (typeof url === 'object' && typeof url.id === 'string') {
			schema = url;
			url = schema.id;
		}
		else {
			return;
		}
	}
	if (url === getDocumentUri(url) + "#") {
		// Remove empty fragment
		url = getDocumentUri(url);
	}
	this.schemas[url] = schema;
	delete this.missingMap[url];
	normSchema(schema, url);
	this.searchSchemas(schema, url);
};

ValidatorContext.prototype.getSchemaMap = function () {
	var map = {};
	for (var key in this.schemas) {
		map[key] = this.schemas[key];
	}
	return map;
};

ValidatorContext.prototype.getSchemaUris = function (filterRegExp) {
	var list = [];
	for (var key in this.schemas) {
		if (!filterRegExp || filterRegExp.test(key)) {
			list.push(key);
		}
	}
	return list;
};

ValidatorContext.prototype.getMissingUris = function (filterRegExp) {
	var list = [];
	for (var key in this.missingMap) {
		if (!filterRegExp || filterRegExp.test(key)) {
			list.push(key);
		}
	}
	return list;
};

ValidatorContext.prototype.dropSchemas = function () {
	this.schemas = {};
	this.reset();
};
ValidatorContext.prototype.reset = function () {
	this.missing = [];
	this.missingMap = {};
	this.errors = [];
};

ValidatorContext.prototype.validateAll = function (data, schema, dataPathParts, schemaPathParts, dataPointerPath) {
	var topLevel;
	schema = this.resolveRefs(schema);
	if (!schema) {
		return null;
	} else if (schema instanceof ValidationError) {
		this.errors.push(schema);
		return schema;
	}

	var startErrorCount = this.errors.length;
	var frozenIndex, scannedFrozenSchemaIndex = null, scannedSchemasIndex = null;
	if (this.checkRecursive && data && typeof data === 'object') {
		topLevel = !this.scanned.length;
		if (data[this.validatedSchemasKey]) {
			var schemaIndex = data[this.validatedSchemasKey].indexOf(schema);
			if (schemaIndex !== -1) {
				this.errors = this.errors.concat(data[this.validationErrorsKey][schemaIndex]);
				return null;
			}
		}
		if (Object.isFrozen(data)) {
			frozenIndex = this.scannedFrozen.indexOf(data);
			if (frozenIndex !== -1) {
				var frozenSchemaIndex = this.scannedFrozenSchemas[frozenIndex].indexOf(schema);
				if (frozenSchemaIndex !== -1) {
					this.errors = this.errors.concat(this.scannedFrozenValidationErrors[frozenIndex][frozenSchemaIndex]);
					return null;
				}
			}
		}
		this.scanned.push(data);
		if (Object.isFrozen(data)) {
			if (frozenIndex === -1) {
				frozenIndex = this.scannedFrozen.length;
				this.scannedFrozen.push(data);
				this.scannedFrozenSchemas.push([]);
			}
			scannedFrozenSchemaIndex = this.scannedFrozenSchemas[frozenIndex].length;
			this.scannedFrozenSchemas[frozenIndex][scannedFrozenSchemaIndex] = schema;
			this.scannedFrozenValidationErrors[frozenIndex][scannedFrozenSchemaIndex] = [];
		} else {
			if (!data[this.validatedSchemasKey]) {
				try {
					Object.defineProperty(data, this.validatedSchemasKey, {
						value: [],
						configurable: true
					});
					Object.defineProperty(data, this.validationErrorsKey, {
						value: [],
						configurable: true
					});
				} catch (e) {
					//IE 7/8 workaround
					data[this.validatedSchemasKey] = [];
					data[this.validationErrorsKey] = [];
				}
			}
			scannedSchemasIndex = data[this.validatedSchemasKey].length;
			data[this.validatedSchemasKey][scannedSchemasIndex] = schema;
			data[this.validationErrorsKey][scannedSchemasIndex] = [];
		}
	}

	var errorCount = this.errors.length;
	var error = this.validateBasic(data, schema, dataPointerPath)
		|| this.validateNumeric(data, schema, dataPointerPath)
		|| this.validateString(data, schema, dataPointerPath)
		|| this.validateArray(data, schema, dataPointerPath)
		|| this.validateObject(data, schema, dataPointerPath)
		|| this.validateCombinations(data, schema, dataPointerPath)
		|| this.validateHypermedia(data, schema, dataPointerPath)
		|| this.validateFormat(data, schema, dataPointerPath)
		|| this.validateDefinedKeywords(data, schema, dataPointerPath)
		|| null;

	if (topLevel) {
		while (this.scanned.length) {
			var item = this.scanned.pop();
			delete item[this.validatedSchemasKey];
		}
		this.scannedFrozen = [];
		this.scannedFrozenSchemas = [];
	}

	if (error || errorCount !== this.errors.length) {
		while ((dataPathParts && dataPathParts.length) || (schemaPathParts && schemaPathParts.length)) {
			var dataPart = (dataPathParts && dataPathParts.length) ? "" + dataPathParts.pop() : null;
			var schemaPart = (schemaPathParts && schemaPathParts.length) ? "" + schemaPathParts.pop() : null;
			if (error) {
				error = error.prefixWith(dataPart, schemaPart);
			}
			this.prefixErrors(errorCount, dataPart, schemaPart);
		}
	}

	if (scannedFrozenSchemaIndex !== null) {
		this.scannedFrozenValidationErrors[frozenIndex][scannedFrozenSchemaIndex] = this.errors.slice(startErrorCount);
	} else if (scannedSchemasIndex !== null) {
		data[this.validationErrorsKey][scannedSchemasIndex] = this.errors.slice(startErrorCount);
	}

	return this.handleError(error);
};
ValidatorContext.prototype.validateFormat = function (data, schema) {
	if (typeof schema.format !== 'string' || !this.formatValidators[schema.format]) {
		return null;
	}
	var errorMessage = this.formatValidators[schema.format].call(null, data, schema);
	if (typeof errorMessage === 'string' || typeof errorMessage === 'number') {
		return this.createError(ErrorCodes.FORMAT_CUSTOM, {message: errorMessage}, '', '/format', null, data, schema);
	} else if (errorMessage && typeof errorMessage === 'object') {
		return this.createError(ErrorCodes.FORMAT_CUSTOM, {message: errorMessage.message || "?"}, errorMessage.dataPath || '', errorMessage.schemaPath || "/format", null, data, schema);
	}
	return null;
};
ValidatorContext.prototype.validateDefinedKeywords = function (data, schema, dataPointerPath) {
	for (var key in this.definedKeywords) {
		if (typeof schema[key] === 'undefined') {
			continue;
		}
		var validationFunctions = this.definedKeywords[key];
		for (var i = 0; i < validationFunctions.length; i++) {
			var func = validationFunctions[i];
			var result = func(data, schema[key], schema, dataPointerPath);
			if (typeof result === 'string' || typeof result === 'number') {
				return this.createError(ErrorCodes.KEYWORD_CUSTOM, {key: key, message: result}, '', '', null, data, schema).prefixWith(null, key);
			} else if (result && typeof result === 'object') {
				var code = result.code;
				if (typeof code === 'string') {
					if (!ErrorCodes[code]) {
						throw new Error('Undefined error code (use defineError): ' + code);
					}
					code = ErrorCodes[code];
				} else if (typeof code !== 'number') {
					code = ErrorCodes.KEYWORD_CUSTOM;
				}
				var messageParams = (typeof result.message === 'object') ? result.message : {key: key, message: result.message || "?"};
				var schemaPath = result.schemaPath || ("/" + key.replace(/~/g, '~0').replace(/\//g, '~1'));
				return this.createError(code, messageParams, result.dataPath || null, schemaPath, null, data, schema);
			}
		}
	}
	return null;
};

function recursiveCompare(A, B) {
	if (A === B) {
		return true;
	}
	if (A && B && typeof A === "object" && typeof B === "object") {
		if (Array.isArray(A) !== Array.isArray(B)) {
			return false;
		} else if (Array.isArray(A)) {
			if (A.length !== B.length) {
				return false;
			}
			for (var i = 0; i < A.length; i++) {
				if (!recursiveCompare(A[i], B[i])) {
					return false;
				}
			}
		} else {
			var key;
			for (key in A) {
				if (B[key] === undefined && A[key] !== undefined) {
					return false;
				}
			}
			for (key in B) {
				if (A[key] === undefined && B[key] !== undefined) {
					return false;
				}
			}
			for (key in A) {
				if (!recursiveCompare(A[key], B[key])) {
					return false;
				}
			}
		}
		return true;
	}
	return false;
}

ValidatorContext.prototype.validateBasic = function validateBasic(data, schema, dataPointerPath) {
	var error;
	if (error = this.validateType(data, schema, dataPointerPath)) {
		return error.prefixWith(null, "type");
	}
	if (error = this.validateEnum(data, schema, dataPointerPath)) {
		return error.prefixWith(null, "type");
	}
	return null;
};

ValidatorContext.prototype.validateType = function validateType(data, schema) {
	if (schema.type === undefined) {
		return null;
	}
	var dataType = typeof data;
	if (data === null) {
		dataType = "null";
	} else if (Array.isArray(data)) {
		dataType = "array";
	}
	var allowedTypes = schema.type;
	if (!Array.isArray(allowedTypes)) {
		allowedTypes = [allowedTypes];
	}

	for (var i = 0; i < allowedTypes.length; i++) {
		var type = allowedTypes[i];
		if (type === dataType || (type === "integer" && dataType === "number" && (data % 1 === 0))) {
			return null;
		}
	}
	return this.createError(ErrorCodes.INVALID_TYPE, {type: dataType, expected: allowedTypes.join("/")}, '', '', null, data, schema);
};

ValidatorContext.prototype.validateEnum = function validateEnum(data, schema) {
	if (schema["enum"] === undefined) {
		return null;
	}
	for (var i = 0; i < schema["enum"].length; i++) {
		var enumVal = schema["enum"][i];
		if (recursiveCompare(data, enumVal)) {
			return null;
		}
	}
	return this.createError(ErrorCodes.ENUM_MISMATCH, {value: (typeof JSON !== 'undefined') ? JSON.stringify(data) : data}, '', '', null, data, schema);
};

ValidatorContext.prototype.validateNumeric = function validateNumeric(data, schema, dataPointerPath) {
	return this.validateMultipleOf(data, schema, dataPointerPath)
		|| this.validateMinMax(data, schema, dataPointerPath)
		|| this.validateNaN(data, schema, dataPointerPath)
		|| null;
};

var CLOSE_ENOUGH_LOW = Math.pow(2, -51);
var CLOSE_ENOUGH_HIGH = 1 - CLOSE_ENOUGH_LOW;
ValidatorContext.prototype.validateMultipleOf = function validateMultipleOf(data, schema) {
	var multipleOf = schema.multipleOf || schema.divisibleBy;
	if (multipleOf === undefined) {
		return null;
	}
	if (typeof data === "number") {
		var remainder = (data/multipleOf)%1;
		if (remainder >= CLOSE_ENOUGH_LOW && remainder < CLOSE_ENOUGH_HIGH) {
			return this.createError(ErrorCodes.NUMBER_MULTIPLE_OF, {value: data, multipleOf: multipleOf}, '', '', null, data, schema);
		}
	}
	return null;
};

ValidatorContext.prototype.validateMinMax = function validateMinMax(data, schema) {
	if (typeof data !== "number") {
		return null;
	}
	if (schema.minimum !== undefined) {
		if (data < schema.minimum) {
			return this.createError(ErrorCodes.NUMBER_MINIMUM, {value: data, minimum: schema.minimum}, '', '/minimum', null, data, schema);
		}
		if (schema.exclusiveMinimum && data === schema.minimum) {
			return this.createError(ErrorCodes.NUMBER_MINIMUM_EXCLUSIVE, {value: data, minimum: schema.minimum}, '', '/exclusiveMinimum', null, data, schema);
		}
	}
	if (schema.maximum !== undefined) {
		if (data > schema.maximum) {
			return this.createError(ErrorCodes.NUMBER_MAXIMUM, {value: data, maximum: schema.maximum}, '', '/maximum', null, data, schema);
		}
		if (schema.exclusiveMaximum && data === schema.maximum) {
			return this.createError(ErrorCodes.NUMBER_MAXIMUM_EXCLUSIVE, {value: data, maximum: schema.maximum}, '', '/exclusiveMaximum', null, data, schema);
		}
	}
	return null;
};

ValidatorContext.prototype.validateNaN = function validateNaN(data, schema) {
	if (typeof data !== "number") {
		return null;
	}
	if (isNaN(data) === true || data === Infinity || data === -Infinity) {
		return this.createError(ErrorCodes.NUMBER_NOT_A_NUMBER, {value: data}, '', '/type', null, data, schema);
	}
	return null;
};

ValidatorContext.prototype.validateString = function validateString(data, schema, dataPointerPath) {
	return this.validateStringLength(data, schema, dataPointerPath)
		|| this.validateStringPattern(data, schema, dataPointerPath)
		|| null;
};

ValidatorContext.prototype.validateStringLength = function validateStringLength(data, schema) {
	if (typeof data !== "string") {
		return null;
	}
	if (schema.minLength !== undefined) {
		if (data.length < schema.minLength) {
			return this.createError(ErrorCodes.STRING_LENGTH_SHORT, {length: data.length, minimum: schema.minLength}, '', '/minLength', null, data, schema);
		}
	}
	if (schema.maxLength !== undefined) {
		if (data.length > schema.maxLength) {
			return this.createError(ErrorCodes.STRING_LENGTH_LONG, {length: data.length, maximum: schema.maxLength}, '', '/maxLength', null, data, schema);
		}
	}
	return null;
};

ValidatorContext.prototype.validateStringPattern = function validateStringPattern(data, schema) {
	if (typeof data !== "string" || (typeof schema.pattern !== "string" && !(schema.pattern instanceof RegExp))) {
		return null;
	}
	var regexp;
	if (schema.pattern instanceof RegExp) {
	  regexp = schema.pattern;
	}
	else {
	  var body, flags = '';
	  // Check for regular expression literals
	  // @see http://www.ecma-international.org/ecma-262/5.1/#sec-7.8.5
	  var literal = schema.pattern.match(/^\/(.+)\/([img]*)$/);
	  if (literal) {
	    body = literal[1];
	    flags = literal[2];
	  }
	  else {
	    body = schema.pattern;
	  }
	  regexp = new RegExp(body, flags);
	}
	if (!regexp.test(data)) {
		return this.createError(ErrorCodes.STRING_PATTERN, {pattern: schema.pattern}, '', '/pattern', null, data, schema);
	}
	return null;
};

ValidatorContext.prototype.validateArray = function validateArray(data, schema, dataPointerPath) {
	if (!Array.isArray(data)) {
		return null;
	}
	return this.validateArrayLength(data, schema, dataPointerPath)
		|| this.validateArrayUniqueItems(data, schema, dataPointerPath)
		|| this.validateArrayItems(data, schema, dataPointerPath)
		|| null;
};

ValidatorContext.prototype.validateArrayLength = function validateArrayLength(data, schema) {
	var error;
	if (schema.minItems !== undefined) {
		if (data.length < schema.minItems) {
			error = this.createError(ErrorCodes.ARRAY_LENGTH_SHORT, {length: data.length, minimum: schema.minItems}, '', '/minItems', null, data, schema);
			if (this.handleError(error)) {
				return error;
			}
		}
	}
	if (schema.maxItems !== undefined) {
		if (data.length > schema.maxItems) {
			error = this.createError(ErrorCodes.ARRAY_LENGTH_LONG, {length: data.length, maximum: schema.maxItems}, '', '/maxItems', null, data, schema);
			if (this.handleError(error)) {
				return error;
			}
		}
	}
	return null;
};

ValidatorContext.prototype.validateArrayUniqueItems = function validateArrayUniqueItems(data, schema) {
	if (schema.uniqueItems) {
		for (var i = 0; i < data.length; i++) {
			for (var j = i + 1; j < data.length; j++) {
				if (recursiveCompare(data[i], data[j])) {
					var error = this.createError(ErrorCodes.ARRAY_UNIQUE, {match1: i, match2: j}, '', '/uniqueItems', null, data, schema);
					if (this.handleError(error)) {
						return error;
					}
				}
			}
		}
	}
	return null;
};

ValidatorContext.prototype.validateArrayItems = function validateArrayItems(data, schema, dataPointerPath) {
	if (schema.items === undefined) {
		return null;
	}
	var error, i;
	if (Array.isArray(schema.items)) {
		for (i = 0; i < data.length; i++) {
			if (i < schema.items.length) {
				if (error = this.validateAll(data[i], schema.items[i], [i], ["items", i], dataPointerPath + "/" + i)) {
					return error;
				}
			} else if (schema.additionalItems !== undefined) {
				if (typeof schema.additionalItems === "boolean") {
					if (!schema.additionalItems) {
						error = (this.createError(ErrorCodes.ARRAY_ADDITIONAL_ITEMS, {}, '/' + i, '/additionalItems', null, data, schema));
						if (this.handleError(error)) {
							return error;
						}
					}
				} else if (error = this.validateAll(data[i], schema.additionalItems, [i], ["additionalItems"], dataPointerPath + "/" + i)) {
					return error;
				}
			}
		}
	} else {
		for (i = 0; i < data.length; i++) {
			if (error = this.validateAll(data[i], schema.items, [i], ["items"], dataPointerPath + "/" + i)) {
				return error;
			}
		}
	}
	return null;
};

ValidatorContext.prototype.validateObject = function validateObject(data, schema, dataPointerPath) {
	if (typeof data !== "object" || data === null || Array.isArray(data)) {
		return null;
	}
	return this.validateObjectMinMaxProperties(data, schema, dataPointerPath)
		|| this.validateObjectRequiredProperties(data, schema, dataPointerPath)
		|| this.validateObjectProperties(data, schema, dataPointerPath)
		|| this.validateObjectDependencies(data, schema, dataPointerPath)
		|| null;
};

ValidatorContext.prototype.validateObjectMinMaxProperties = function validateObjectMinMaxProperties(data, schema) {
	var keys = Object.keys(data);
	var error;
	if (schema.minProperties !== undefined) {
		if (keys.length < schema.minProperties) {
			error = this.createError(ErrorCodes.OBJECT_PROPERTIES_MINIMUM, {propertyCount: keys.length, minimum: schema.minProperties}, '', '/minProperties', null, data, schema);
			if (this.handleError(error)) {
				return error;
			}
		}
	}
	if (schema.maxProperties !== undefined) {
		if (keys.length > schema.maxProperties) {
			error = this.createError(ErrorCodes.OBJECT_PROPERTIES_MAXIMUM, {propertyCount: keys.length, maximum: schema.maxProperties}, '', '/maxProperties', null, data, schema);
			if (this.handleError(error)) {
				return error;
			}
		}
	}
	return null;
};

ValidatorContext.prototype.validateObjectRequiredProperties = function validateObjectRequiredProperties(data, schema) {
	if (schema.required !== undefined) {
		for (var i = 0; i < schema.required.length; i++) {
			var key = schema.required[i];
			if (data[key] === undefined) {
				var error = this.createError(ErrorCodes.OBJECT_REQUIRED, {key: key}, '', '/required/' + i, null, data, schema);
				if (this.handleError(error)) {
					return error;
				}
			}
		}
	}
	return null;
};

ValidatorContext.prototype.validateObjectProperties = function validateObjectProperties(data, schema, dataPointerPath) {
	var error;
	for (var key in data) {
		var keyPointerPath = dataPointerPath + "/" + key.replace(/~/g, '~0').replace(/\//g, '~1');
		var foundMatch = false;
		if (schema.properties !== undefined && schema.properties[key] !== undefined) {
			foundMatch = true;
			if (error = this.validateAll(data[key], schema.properties[key], [key], ["properties", key], keyPointerPath)) {
				return error;
			}
		}
		if (schema.patternProperties !== undefined) {
			for (var patternKey in schema.patternProperties) {
				var regexp = new RegExp(patternKey);
				if (regexp.test(key)) {
					foundMatch = true;
					if (error = this.validateAll(data[key], schema.patternProperties[patternKey], [key], ["patternProperties", patternKey], keyPointerPath)) {
						return error;
					}
				}
			}
		}
		if (!foundMatch) {
			if (schema.additionalProperties !== undefined) {
				if (this.trackUnknownProperties) {
					this.knownPropertyPaths[keyPointerPath] = true;
					delete this.unknownPropertyPaths[keyPointerPath];
				}
				if (typeof schema.additionalProperties === "boolean") {
					if (!schema.additionalProperties) {
						error = this.createError(ErrorCodes.OBJECT_ADDITIONAL_PROPERTIES, {key: key}, '', '/additionalProperties', null, data, schema).prefixWith(key, null);
						if (this.handleError(error)) {
							return error;
						}
					}
				} else {
					if (error = this.validateAll(data[key], schema.additionalProperties, [key], ["additionalProperties"], keyPointerPath)) {
						return error;
					}
				}
			} else if (this.trackUnknownProperties && !this.knownPropertyPaths[keyPointerPath]) {
				this.unknownPropertyPaths[keyPointerPath] = true;
			}
		} else if (this.trackUnknownProperties) {
			this.knownPropertyPaths[keyPointerPath] = true;
			delete this.unknownPropertyPaths[keyPointerPath];
		}
	}
	return null;
};

ValidatorContext.prototype.validateObjectDependencies = function validateObjectDependencies(data, schema, dataPointerPath) {
	var error;
	if (schema.dependencies !== undefined) {
		for (var depKey in schema.dependencies) {
			if (data[depKey] !== undefined) {
				var dep = schema.dependencies[depKey];
				if (typeof dep === "string") {
					if (data[dep] === undefined) {
						error = this.createError(ErrorCodes.OBJECT_DEPENDENCY_KEY, {key: depKey, missing: dep}, '', '', null, data, schema).prefixWith(null, depKey).prefixWith(null, "dependencies");
						if (this.handleError(error)) {
							return error;
						}
					}
				} else if (Array.isArray(dep)) {
					for (var i = 0; i < dep.length; i++) {
						var requiredKey = dep[i];
						if (data[requiredKey] === undefined) {
							error = this.createError(ErrorCodes.OBJECT_DEPENDENCY_KEY, {key: depKey, missing: requiredKey}, '', '/' + i, null, data, schema).prefixWith(null, depKey).prefixWith(null, "dependencies");
							if (this.handleError(error)) {
								return error;
							}
						}
					}
				} else {
					if (error = this.validateAll(data, dep, [], ["dependencies", depKey], dataPointerPath)) {
						return error;
					}
				}
			}
		}
	}
	return null;
};

ValidatorContext.prototype.validateCombinations = function validateCombinations(data, schema, dataPointerPath) {
	return this.validateAllOf(data, schema, dataPointerPath)
		|| this.validateAnyOf(data, schema, dataPointerPath)
		|| this.validateOneOf(data, schema, dataPointerPath)
		|| this.validateNot(data, schema, dataPointerPath)
		|| null;
};

ValidatorContext.prototype.validateAllOf = function validateAllOf(data, schema, dataPointerPath) {
	if (schema.allOf === undefined) {
		return null;
	}
	var error;
	for (var i = 0; i < schema.allOf.length; i++) {
		var subSchema = schema.allOf[i];
		if (error = this.validateAll(data, subSchema, [], ["allOf", i], dataPointerPath)) {
			return error;
		}
	}
	return null;
};

ValidatorContext.prototype.validateAnyOf = function validateAnyOf(data, schema, dataPointerPath) {
	if (schema.anyOf === undefined) {
		return null;
	}
	var errors = [];
	var startErrorCount = this.errors.length;
	var oldUnknownPropertyPaths, oldKnownPropertyPaths;
	if (this.trackUnknownProperties) {
		oldUnknownPropertyPaths = this.unknownPropertyPaths;
		oldKnownPropertyPaths = this.knownPropertyPaths;
	}
	var errorAtEnd = true;
	for (var i = 0; i < schema.anyOf.length; i++) {
		if (this.trackUnknownProperties) {
			this.unknownPropertyPaths = {};
			this.knownPropertyPaths = {};
		}
		var subSchema = schema.anyOf[i];

		var errorCount = this.errors.length;
		var error = this.validateAll(data, subSchema, [], ["anyOf", i], dataPointerPath);

		if (error === null && errorCount === this.errors.length) {
			this.errors = this.errors.slice(0, startErrorCount);

			if (this.trackUnknownProperties) {
				for (var knownKey in this.knownPropertyPaths) {
					oldKnownPropertyPaths[knownKey] = true;
					delete oldUnknownPropertyPaths[knownKey];
				}
				for (var unknownKey in this.unknownPropertyPaths) {
					if (!oldKnownPropertyPaths[unknownKey]) {
						oldUnknownPropertyPaths[unknownKey] = true;
					}
				}
				// We need to continue looping so we catch all the property definitions, but we don't want to return an error
				errorAtEnd = false;
				continue;
			}

			return null;
		}
		if (error) {
			errors.push(error.prefixWith(null, "" + i).prefixWith(null, "anyOf"));
		}
	}
	if (this.trackUnknownProperties) {
		this.unknownPropertyPaths = oldUnknownPropertyPaths;
		this.knownPropertyPaths = oldKnownPropertyPaths;
	}
	if (errorAtEnd) {
		errors = errors.concat(this.errors.slice(startErrorCount));
		this.errors = this.errors.slice(0, startErrorCount);
		return this.createError(ErrorCodes.ANY_OF_MISSING, {}, "", "/anyOf", errors, data, schema);
	}
};

ValidatorContext.prototype.validateOneOf = function validateOneOf(data, schema, dataPointerPath) {
	if (schema.oneOf === undefined) {
		return null;
	}
	var validIndex = null;
	var errors = [];
	var startErrorCount = this.errors.length;
	var oldUnknownPropertyPaths, oldKnownPropertyPaths;
	if (this.trackUnknownProperties) {
		oldUnknownPropertyPaths = this.unknownPropertyPaths;
		oldKnownPropertyPaths = this.knownPropertyPaths;
	}
	for (var i = 0; i < schema.oneOf.length; i++) {
		if (this.trackUnknownProperties) {
			this.unknownPropertyPaths = {};
			this.knownPropertyPaths = {};
		}
		var subSchema = schema.oneOf[i];

		var errorCount = this.errors.length;
		var error = this.validateAll(data, subSchema, [], ["oneOf", i], dataPointerPath);

		if (error === null && errorCount === this.errors.length) {
			if (validIndex === null) {
				validIndex = i;
			} else {
				this.errors = this.errors.slice(0, startErrorCount);
				return this.createError(ErrorCodes.ONE_OF_MULTIPLE, {index1: validIndex, index2: i}, "", "/oneOf", null, data, schema);
			}
			if (this.trackUnknownProperties) {
				for (var knownKey in this.knownPropertyPaths) {
					oldKnownPropertyPaths[knownKey] = true;
					delete oldUnknownPropertyPaths[knownKey];
				}
				for (var unknownKey in this.unknownPropertyPaths) {
					if (!oldKnownPropertyPaths[unknownKey]) {
						oldUnknownPropertyPaths[unknownKey] = true;
					}
				}
			}
		} else if (error) {
			errors.push(error);
		}
	}
	if (this.trackUnknownProperties) {
		this.unknownPropertyPaths = oldUnknownPropertyPaths;
		this.knownPropertyPaths = oldKnownPropertyPaths;
	}
	if (validIndex === null) {
		errors = errors.concat(this.errors.slice(startErrorCount));
		this.errors = this.errors.slice(0, startErrorCount);
		return this.createError(ErrorCodes.ONE_OF_MISSING, {}, "", "/oneOf", errors, data, schema);
	} else {
		this.errors = this.errors.slice(0, startErrorCount);
	}
	return null;
};

ValidatorContext.prototype.validateNot = function validateNot(data, schema, dataPointerPath) {
	if (schema.not === undefined) {
		return null;
	}
	var oldErrorCount = this.errors.length;
	var oldUnknownPropertyPaths, oldKnownPropertyPaths;
	if (this.trackUnknownProperties) {
		oldUnknownPropertyPaths = this.unknownPropertyPaths;
		oldKnownPropertyPaths = this.knownPropertyPaths;
		this.unknownPropertyPaths = {};
		this.knownPropertyPaths = {};
	}
	var error = this.validateAll(data, schema.not, null, null, dataPointerPath);
	var notErrors = this.errors.slice(oldErrorCount);
	this.errors = this.errors.slice(0, oldErrorCount);
	if (this.trackUnknownProperties) {
		this.unknownPropertyPaths = oldUnknownPropertyPaths;
		this.knownPropertyPaths = oldKnownPropertyPaths;
	}
	if (error === null && notErrors.length === 0) {
		return this.createError(ErrorCodes.NOT_PASSED, {}, "", "/not", null, data, schema);
	}
	return null;
};

ValidatorContext.prototype.validateHypermedia = function validateCombinations(data, schema, dataPointerPath) {
	if (!schema.links) {
		return null;
	}
	var error;
	for (var i = 0; i < schema.links.length; i++) {
		var ldo = schema.links[i];
		if (ldo.rel === "describedby") {
			var template = new UriTemplate(ldo.href);
			var allPresent = true;
			for (var j = 0; j < template.varNames.length; j++) {
				if (!(template.varNames[j] in data)) {
					allPresent = false;
					break;
				}
			}
			if (allPresent) {
				var schemaUrl = template.fillFromObject(data);
				var subSchema = {"$ref": schemaUrl};
				if (error = this.validateAll(data, subSchema, [], ["links", i], dataPointerPath)) {
					return error;
				}
			}
		}
	}
};

// parseURI() and resolveUrl() are from https://gist.github.com/1088850
//   -  released as public domain by author ("Yaffle") - see comments on gist

function parseURI(url) {
	var m = String(url).replace(/^\s+|\s+$/g, '').match(/^([^:\/?#]+:)?(\/\/(?:[^:@]*(?::[^:@]*)?@)?(([^:\/?#]*)(?::(\d*))?))?([^?#]*)(\?[^#]*)?(#[\s\S]*)?/);
	// authority = '//' + user + ':' + pass '@' + hostname + ':' port
	return (m ? {
		href     : m[0] || '',
		protocol : m[1] || '',
		authority: m[2] || '',
		host     : m[3] || '',
		hostname : m[4] || '',
		port     : m[5] || '',
		pathname : m[6] || '',
		search   : m[7] || '',
		hash     : m[8] || ''
	} : null);
}

function resolveUrl(base, href) {// RFC 3986

	function removeDotSegments(input) {
		var output = [];
		input.replace(/^(\.\.?(\/|$))+/, '')
			.replace(/\/(\.(\/|$))+/g, '/')
			.replace(/\/\.\.$/, '/../')
			.replace(/\/?[^\/]*/g, function (p) {
				if (p === '/..') {
					output.pop();
				} else {
					output.push(p);
				}
		});
		return output.join('').replace(/^\//, input.charAt(0) === '/' ? '/' : '');
	}

	href = parseURI(href || '');
	base = parseURI(base || '');

	return !href || !base ? null : (href.protocol || base.protocol) +
		(href.protocol || href.authority ? href.authority : base.authority) +
		removeDotSegments(href.protocol || href.authority || href.pathname.charAt(0) === '/' ? href.pathname : (href.pathname ? ((base.authority && !base.pathname ? '/' : '') + base.pathname.slice(0, base.pathname.lastIndexOf('/') + 1) + href.pathname) : base.pathname)) +
		(href.protocol || href.authority || href.pathname ? href.search : (href.search || base.search)) +
		href.hash;
}

function getDocumentUri(uri) {
	return uri.split('#')[0];
}
function normSchema(schema, baseUri) {
	if (schema && typeof schema === "object") {
		if (baseUri === undefined) {
			baseUri = schema.id;
		} else if (typeof schema.id === "string") {
			baseUri = resolveUrl(baseUri, schema.id);
			schema.id = baseUri;
		}
		if (Array.isArray(schema)) {
			for (var i = 0; i < schema.length; i++) {
				normSchema(schema[i], baseUri);
			}
		} else {
			if (typeof schema['$ref'] === "string") {
				schema['$ref'] = resolveUrl(baseUri, schema['$ref']);
			}
			for (var key in schema) {
				if (key !== "enum") {
					normSchema(schema[key], baseUri);
				}
			}
		}
	}
}

function defaultErrorReporter(language) {
	language = language || 'en';

	var errorMessages = languages[language];

	return function (error) {
		var messageTemplate = errorMessages[error.code] || ErrorMessagesDefault[error.code];
		if (typeof messageTemplate !== 'string') {
			return "Unknown error code " + error.code + ": " + JSON.stringify(error.messageParams);
		}
		var messageParams = error.params;
		// Adapted from Crockford's supplant()
		return messageTemplate.replace(/\{([^{}]*)\}/g, function (whole, varName) {
			var subValue = messageParams[varName];
			return typeof subValue === 'string' || typeof subValue === 'number' ? subValue : whole;
		});
	};
}

var ErrorCodes = {
	INVALID_TYPE: 0,
	ENUM_MISMATCH: 1,
	ANY_OF_MISSING: 10,
	ONE_OF_MISSING: 11,
	ONE_OF_MULTIPLE: 12,
	NOT_PASSED: 13,
	// Numeric errors
	NUMBER_MULTIPLE_OF: 100,
	NUMBER_MINIMUM: 101,
	NUMBER_MINIMUM_EXCLUSIVE: 102,
	NUMBER_MAXIMUM: 103,
	NUMBER_MAXIMUM_EXCLUSIVE: 104,
	NUMBER_NOT_A_NUMBER: 105,
	// String errors
	STRING_LENGTH_SHORT: 200,
	STRING_LENGTH_LONG: 201,
	STRING_PATTERN: 202,
	// Object errors
	OBJECT_PROPERTIES_MINIMUM: 300,
	OBJECT_PROPERTIES_MAXIMUM: 301,
	OBJECT_REQUIRED: 302,
	OBJECT_ADDITIONAL_PROPERTIES: 303,
	OBJECT_DEPENDENCY_KEY: 304,
	// Array errors
	ARRAY_LENGTH_SHORT: 400,
	ARRAY_LENGTH_LONG: 401,
	ARRAY_UNIQUE: 402,
	ARRAY_ADDITIONAL_ITEMS: 403,
	// Custom/user-defined errors
	FORMAT_CUSTOM: 500,
	KEYWORD_CUSTOM: 501,
	// Schema structure
	CIRCULAR_REFERENCE: 600,
	// Non-standard validation options
	UNKNOWN_PROPERTY: 1000
};
var ErrorCodeLookup = {};
for (var key in ErrorCodes) {
	ErrorCodeLookup[ErrorCodes[key]] = key;
}
var ErrorMessagesDefault = {
	INVALID_TYPE: "Invalid type: {type} (expected {expected})",
	ENUM_MISMATCH: "No enum match for: {value}",
	ANY_OF_MISSING: "Data does not match any schemas from \"anyOf\"",
	ONE_OF_MISSING: "Data does not match any schemas from \"oneOf\"",
	ONE_OF_MULTIPLE: "Data is valid against more than one schema from \"oneOf\": indices {index1} and {index2}",
	NOT_PASSED: "Data matches schema from \"not\"",
	// Numeric errors
	NUMBER_MULTIPLE_OF: "Value {value} is not a multiple of {multipleOf}",
	NUMBER_MINIMUM: "Value {value} is less than minimum {minimum}",
	NUMBER_MINIMUM_EXCLUSIVE: "Value {value} is equal to exclusive minimum {minimum}",
	NUMBER_MAXIMUM: "Value {value} is greater than maximum {maximum}",
	NUMBER_MAXIMUM_EXCLUSIVE: "Value {value} is equal to exclusive maximum {maximum}",
	NUMBER_NOT_A_NUMBER: "Value {value} is not a valid number",
	// String errors
	STRING_LENGTH_SHORT: "String is too short ({length} chars), minimum {minimum}",
	STRING_LENGTH_LONG: "String is too long ({length} chars), maximum {maximum}",
	STRING_PATTERN: "String does not match pattern: {pattern}",
	// Object errors
	OBJECT_PROPERTIES_MINIMUM: "Too few properties defined ({propertyCount}), minimum {minimum}",
	OBJECT_PROPERTIES_MAXIMUM: "Too many properties defined ({propertyCount}), maximum {maximum}",
	OBJECT_REQUIRED: "Missing required property: {key}",
	OBJECT_ADDITIONAL_PROPERTIES: "Additional properties not allowed",
	OBJECT_DEPENDENCY_KEY: "Dependency failed - key must exist: {missing} (due to key: {key})",
	// Array errors
	ARRAY_LENGTH_SHORT: "Array is too short ({length}), minimum {minimum}",
	ARRAY_LENGTH_LONG: "Array is too long ({length}), maximum {maximum}",
	ARRAY_UNIQUE: "Array items are not unique (indices {match1} and {match2})",
	ARRAY_ADDITIONAL_ITEMS: "Additional items not allowed",
	// Format errors
	FORMAT_CUSTOM: "Format validation failed ({message})",
	KEYWORD_CUSTOM: "Keyword failed: {key} ({message})",
	// Schema structure
	CIRCULAR_REFERENCE: "Circular $refs: {urls}",
	// Non-standard validation options
	UNKNOWN_PROPERTY: "Unknown property (not in schema)"
};

function ValidationError(code, params, dataPath, schemaPath, subErrors) {
	Error.call(this);
	if (code === undefined) {
		throw new Error ("No error code supplied: " + schemaPath);
	}
	this.message = '';
	this.params = params;
	this.code = code;
	this.dataPath = dataPath || "";
	this.schemaPath = schemaPath || "";
	this.subErrors = subErrors || null;

	var err = new Error(this.message);
	this.stack = err.stack || err.stacktrace;
	if (!this.stack) {
		try {
			throw err;
		}
		catch(err) {
			this.stack = err.stack || err.stacktrace;
		}
	}
}
ValidationError.prototype = Object.create(Error.prototype);
ValidationError.prototype.constructor = ValidationError;
ValidationError.prototype.name = 'ValidationError';

ValidationError.prototype.prefixWith = function (dataPrefix, schemaPrefix) {
	if (dataPrefix !== null) {
		dataPrefix = dataPrefix.replace(/~/g, "~0").replace(/\//g, "~1");
		this.dataPath = "/" + dataPrefix + this.dataPath;
	}
	if (schemaPrefix !== null) {
		schemaPrefix = schemaPrefix.replace(/~/g, "~0").replace(/\//g, "~1");
		this.schemaPath = "/" + schemaPrefix + this.schemaPath;
	}
	if (this.subErrors !== null) {
		for (var i = 0; i < this.subErrors.length; i++) {
			this.subErrors[i].prefixWith(dataPrefix, schemaPrefix);
		}
	}
	return this;
};

function isTrustedUrl(baseUrl, testUrl) {
	if(testUrl.substring(0, baseUrl.length) === baseUrl){
		var remainder = testUrl.substring(baseUrl.length);
		if ((testUrl.length > 0 && testUrl.charAt(baseUrl.length - 1) === "/")
			|| remainder.charAt(0) === "#"
			|| remainder.charAt(0) === "?") {
			return true;
		}
	}
	return false;
}

var languages = {};
function createApi(language) {
	var globalContext = new ValidatorContext();
	var currentLanguage;
	var customErrorReporter;
	var api = {
		setErrorReporter: function (reporter) {
			if (typeof reporter === 'string') {
				return this.language(reporter);
			}
			customErrorReporter = reporter;
			return true;
		},
		addFormat: function () {
			globalContext.addFormat.apply(globalContext, arguments);
		},
		language: function (code) {
			if (!code) {
				return currentLanguage;
			}
			if (!languages[code]) {
				code = code.split('-')[0]; // fall back to base language
			}
			if (languages[code]) {
				currentLanguage = code;
				return code; // so you can tell if fall-back has happened
			}
			return false;
		},
		addLanguage: function (code, messageMap) {
			var key;
			for (key in ErrorCodes) {
				if (messageMap[key] && !messageMap[ErrorCodes[key]]) {
					messageMap[ErrorCodes[key]] = messageMap[key];
				}
			}
			var rootCode = code.split('-')[0];
			if (!languages[rootCode]) { // use for base language if not yet defined
				languages[code] = messageMap;
				languages[rootCode] = messageMap;
			} else {
				languages[code] = Object.create(languages[rootCode]);
				for (key in messageMap) {
					if (typeof languages[rootCode][key] === 'undefined') {
						languages[rootCode][key] = messageMap[key];
					}
					languages[code][key] = messageMap[key];
				}
			}
			return this;
		},
		freshApi: function (language) {
			var result = createApi();
			if (language) {
				result.language(language);
			}
			return result;
		},
		validate: function (data, schema, checkRecursive, banUnknownProperties) {
			var def = defaultErrorReporter(currentLanguage);
			var errorReporter = customErrorReporter ? function (error, data, schema) {
				return customErrorReporter(error, data, schema) || def(error, data, schema);
			} : def;
			var context = new ValidatorContext(globalContext, false, errorReporter, checkRecursive, banUnknownProperties);
			if (typeof schema === "string") {
				schema = {"$ref": schema};
			}
			context.addSchema("", schema);
			var error = context.validateAll(data, schema, null, null, "");
			if (!error && banUnknownProperties) {
				error = context.banUnknownProperties(data, schema);
			}
			this.error = error;
			this.missing = context.missing;
			this.valid = (error === null);
			return this.valid;
		},
		validateResult: function () {
			var result = {};
			this.validate.apply(result, arguments);
			return result;
		},
		validateMultiple: function (data, schema, checkRecursive, banUnknownProperties) {
			var def = defaultErrorReporter(currentLanguage);
			var errorReporter = customErrorReporter ? function (error, data, schema) {
				return customErrorReporter(error, data, schema) || def(error, data, schema);
			} : def;
			var context = new ValidatorContext(globalContext, true, errorReporter, checkRecursive, banUnknownProperties);
			if (typeof schema === "string") {
				schema = {"$ref": schema};
			}
			context.addSchema("", schema);
			context.validateAll(data, schema, null, null, "");
			if (banUnknownProperties) {
				context.banUnknownProperties(data, schema);
			}
			var result = {};
			result.errors = context.errors;
			result.missing = context.missing;
			result.valid = (result.errors.length === 0);
			return result;
		},
		addSchema: function () {
			return globalContext.addSchema.apply(globalContext, arguments);
		},
		getSchema: function () {
			return globalContext.getSchema.apply(globalContext, arguments);
		},
		getSchemaMap: function () {
			return globalContext.getSchemaMap.apply(globalContext, arguments);
		},
		getSchemaUris: function () {
			return globalContext.getSchemaUris.apply(globalContext, arguments);
		},
		getMissingUris: function () {
			return globalContext.getMissingUris.apply(globalContext, arguments);
		},
		dropSchemas: function () {
			globalContext.dropSchemas.apply(globalContext, arguments);
		},
		defineKeyword: function () {
			globalContext.defineKeyword.apply(globalContext, arguments);
		},
		defineError: function (codeName, codeNumber, defaultMessage) {
			if (typeof codeName !== 'string' || !/^[A-Z]+(_[A-Z]+)*$/.test(codeName)) {
				throw new Error('Code name must be a string in UPPER_CASE_WITH_UNDERSCORES');
			}
			if (typeof codeNumber !== 'number' || codeNumber%1 !== 0 || codeNumber < 10000) {
				throw new Error('Code number must be an integer > 10000');
			}
			if (typeof ErrorCodes[codeName] !== 'undefined') {
				throw new Error('Error already defined: ' + codeName + ' as ' + ErrorCodes[codeName]);
			}
			if (typeof ErrorCodeLookup[codeNumber] !== 'undefined') {
				throw new Error('Error code already used: ' + ErrorCodeLookup[codeNumber] + ' as ' + codeNumber);
			}
			ErrorCodes[codeName] = codeNumber;
			ErrorCodeLookup[codeNumber] = codeName;
			ErrorMessagesDefault[codeName] = ErrorMessagesDefault[codeNumber] = defaultMessage;
			for (var langCode in languages) {
				var language = languages[langCode];
				if (language[codeName]) {
					language[codeNumber] = language[codeNumber] || language[codeName];
				}
			}
		},
		reset: function () {
			globalContext.reset();
			this.error = null;
			this.missing = [];
			this.valid = true;
		},
		missing: [],
		error: null,
		valid: true,
		normSchema: normSchema,
		resolveUrl: resolveUrl,
		getDocumentUri: getDocumentUri,
		errorCodes: ErrorCodes
	};
	api.language(language || 'en');
	return api;
}

var tv4 = createApi();
tv4.addLanguage('en-gb', ErrorMessagesDefault);

//legacy property
tv4.tv4 = tv4;

return tv4; // used by _header.js to globalise.

}));
});
require.register("geraintluff-tv4/lang/de.js", function(exports, require, module){
(function (global) {
	var lang = {
		INVALID_TYPE: "Ungültiger Typ: {type} (erwartet wurde: {expected})",
		ENUM_MISMATCH: "Keine Übereinstimmung mit der Aufzählung (enum) für: {value}",
		ANY_OF_MISSING: "Daten stimmen nicht überein mit einem der Schemas von \"anyOf\"",
		ONE_OF_MISSING: "Daten stimmen nicht überein mit einem der Schemas von \"oneOf\"",
		ONE_OF_MULTIPLE: "Daten sind valid in Bezug auf mehreren Schemas von \"oneOf\": index {index1} und {index2}",
		NOT_PASSED: "Daten stimmen mit dem \"not\" Schema überein",
		// Numeric errors
		NUMBER_MULTIPLE_OF: "Wert {value} ist kein Vielfaches von {multipleOf}",
		NUMBER_MINIMUM: "Wert {value} ist kleiner als das Minimum {minimum}",
		NUMBER_MINIMUM_EXCLUSIVE: "Wert {value} ist gleich dem Exklusiven Minimum {minimum}",
		NUMBER_MAXIMUM: "Wert {value} ist größer als das Maximum {maximum}",
		NUMBER_MAXIMUM_EXCLUSIVE: "Wert {value} ist gleich dem Exklusiven Maximum {maximum}",
		// String errors
		STRING_LENGTH_SHORT: "Zeichenkette zu kurz ({length} chars), minimum {minimum}",
		STRING_LENGTH_LONG: "Zeichenkette zu lang ({length} chars), maximum {maximum}",
		STRING_PATTERN: "Zeichenkette entspricht nicht dem Muster: {pattern}",
		// Object errors
		OBJECT_PROPERTIES_MINIMUM: "Zu wenige Attribute definiert ({propertyCount}), minimum {minimum}",
		OBJECT_PROPERTIES_MAXIMUM: "Zu viele Attribute definiert ({propertyCount}), maximum {maximum}",
		OBJECT_REQUIRED: "Notwendiges Attribut fehlt: {key}",
		OBJECT_ADDITIONAL_PROPERTIES: "Zusätzliche Attribute nicht erlaubt",
		OBJECT_DEPENDENCY_KEY: "Abhängigkeit fehlt - Schlüssel nicht vorhanden: {missing} (wegen Schlüssel: {key})",
		// Array errors
		ARRAY_LENGTH_SHORT: "Array zu kurz ({length}), minimum {minimum}",
		ARRAY_LENGTH_LONG: "Array zu lang ({length}), maximum {maximum}",
		ARRAY_UNIQUE: "Array Einträge nicht eindeutig (Index {match1} und {match2})",
		ARRAY_ADDITIONAL_ITEMS: "Zusätzliche Einträge nicht erlaubt"
	};

	if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['../tv4'], function(tv4) {
			tv4.addLanguage('de', lang);
			return tv4;
		});
	} else if (typeof module !== 'undefined' && module.exports){
		// CommonJS. Define export.
		var tv4 = require('../tv4');
		tv4.addLanguage('de', lang);
		module.exports = tv4;
	} else {
		// Browser globals
		global.tv4.addLanguage('de', lang);
	}
})(this);

});
require.register("geraintluff-tv4/lang/fr.js", function(exports, require, module){
(function (global) {
	var lang = {
		INVALID_TYPE: "Type invalide: {type} ({expected} attendu)",
		ENUM_MISMATCH: "Aucune valeur correspondante (enum) pour: {value}",
		ANY_OF_MISSING: "La donnée ne correspond à aucun schema de \"anyOf\"",
		ONE_OF_MISSING: "La donnée ne correspond à aucun schema de  \"oneOf\"",
		ONE_OF_MULTIPLE: "La donnée est valide pour plus d'un schema de \"oneOf\": indices {index1} et {index2}",
		NOT_PASSED: "La donnée correspond au schema de \"not\"",
		// Numeric errors
		NUMBER_MULTIPLE_OF: "La valeur {value} n'est pas un multiple de {multipleOf}",
		NUMBER_MINIMUM: "La valeur {value} est inférieure au minimum {minimum}",
		NUMBER_MINIMUM_EXCLUSIVE: "La valeur {value} est égale au minimum exclusif {minimum}",
		NUMBER_MAXIMUM: "La valeur {value} est supérieure au maximum {maximum}",
		NUMBER_MAXIMUM_EXCLUSIVE: "La valeur {value} est égale au maximum exclusif {maximum}",
		NUMBER_NOT_A_NUMBER: "La valeur {value} n'est pas un nombre valide",
		// String errors
		STRING_LENGTH_SHORT: "Le texte est trop court ({length} carac.), minimum {minimum}",
		STRING_LENGTH_LONG: "Le texte est trop long ({length} carac.), maximum {maximum}",
		STRING_PATTERN: "Le texte ne correspond pas au motif: {pattern}",
		// Object errors
		OBJECT_PROPERTIES_MINIMUM: "Pas assez de propriétés définies ({propertyCount}), minimum {minimum}",
		OBJECT_PROPERTIES_MAXIMUM: "Trop de propriétés définies ({propertyCount}), maximum {maximum}",
		OBJECT_REQUIRED: "Propriété requise manquante: {key}",
		OBJECT_ADDITIONAL_PROPERTIES: "Propriétés additionnelles non autorisées",
		OBJECT_DEPENDENCY_KEY: "Echec de dépendance - la clé doit exister: {missing} (du à la clé: {key})",
		// Array errors
		ARRAY_LENGTH_SHORT: "Le tableau est trop court ({length}), minimum {minimum}",
		ARRAY_LENGTH_LONG: "Le tableau est trop long ({length}), maximum {maximum}",
		ARRAY_UNIQUE: "Des éléments du tableau ne sont pas uniques (indices {match1} et {match2})",
		ARRAY_ADDITIONAL_ITEMS: "Éléments additionnels non autorisés",
		// Format errors
		FORMAT_CUSTOM: "Échec de validation du format ({message})",
		KEYWORD_CUSTOM: "Échec de mot-clé: {key} ({message})",
		// Schema structure
		CIRCULAR_REFERENCE: "Références ($refs) circulaires: {urls}",
		// Non-standard validation options
		UNKNOWN_PROPERTY: "Propriété inconnue (n'existe pas dans le schema)"
	};

	if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['../tv4'], function(tv4) {
			tv4.addLanguage('fr', lang);
			return tv4;
		});
	} else if (typeof module !== 'undefined' && module.exports){
		// CommonJS. Define export.
		var tv4 = require('../tv4');
		tv4.addLanguage('fr', lang);
		module.exports = tv4;
	} else {
		// Browser globals
		global.tv4.addLanguage('fr', lang);
	}
})(this);

});
require.register("geraintluff-tv4/lang/nb.js", function(exports, require, module){
(function (global) {
	var lang = {
		INVALID_TYPE: "Ugyldig type: {type} (forventet {expected})",
		ENUM_MISMATCH: "Ingen samsvarende enum verdi for: {value}",
		ANY_OF_MISSING: "Data samsvarer ikke med noe skjema fra \"anyOf\"",
		ONE_OF_MISSING: "Data samsvarer ikke med noe skjema fra \"oneOf\"",
		ONE_OF_MULTIPLE: "Data samsvarer med mer enn ett skjema fra \"oneOf\": indeks {index1} og {index2}",
		NOT_PASSED: "Data samsvarer med skjema fra \"not\"",
		// Numeric errors
		NUMBER_MULTIPLE_OF: "Verdien {value} er ikke et multiplum av {multipleOf}",
		NUMBER_MINIMUM: "Verdien {value} er mindre enn minsteverdi {minimum}",
		NUMBER_MINIMUM_EXCLUSIVE: "Verdien {value} er lik eksklusiv minsteverdi {minimum}",
		NUMBER_MAXIMUM: "Verdien {value} er større enn maksimalverdi {maximum}",
		NUMBER_MAXIMUM_EXCLUSIVE: "Verdien {value} er lik eksklusiv maksimalverdi {maximum}",
		NUMBER_NOT_A_NUMBER: "Verdien {value} er ikke et gyldig tall",
		// String errors
		STRING_LENGTH_SHORT: "Strengen er for kort ({length} tegn), minst {minimum}",
		STRING_LENGTH_LONG: "Strengen er for lang ({length} tegn), maksimalt {maximum}",
		STRING_PATTERN: "Strengen samsvarer ikke med regulært uttrykk: {pattern}",
		// Object errors
		OBJECT_PROPERTIES_MINIMUM: "For få variabler definert ({propertyCount}), minst {minimum} er forventet",
		OBJECT_PROPERTIES_MAXIMUM: "For mange variabler definert ({propertyCount}), makismalt {maximum} er tillatt",
		OBJECT_REQUIRED: "Mangler obligatorisk variabel: {key}",
		OBJECT_ADDITIONAL_PROPERTIES: "Tilleggsvariabler er ikke tillatt",
		OBJECT_DEPENDENCY_KEY: "Variabelen {missing} må være definert (på grunn av følgende variabel: {key})",
		// Array errors
		ARRAY_LENGTH_SHORT: "Listen er for kort ({length} elementer), minst {minimum}",
		ARRAY_LENGTH_LONG: "Listen er for lang ({length} elementer), maksimalt {maximum}",
		ARRAY_UNIQUE: "Elementene er ikke unike (indeks {match1} og {match2} er like)",
		ARRAY_ADDITIONAL_ITEMS: "Tillegselementer er ikke tillatt",
		// Format errors
		FORMAT_CUSTOM: "Formatteringen stemmer ikke ({message})",
		KEYWORD_CUSTOM: "Nøkkelen stemmer ikke: {key} ({message})",
		// Schema structure
		CIRCULAR_REFERENCE: "Sirkulære referanser ($refs): {urls}",
		// Non-standard validation options
		UNKNOWN_PROPERTY: "Ukjent variabel (eksisterer ikke i skjemaet)"
	};
	
	if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['../tv4'], function(tv4) {
			tv4.addLanguage('nb', lang);
			return tv4;
		});
	} else if (typeof module !== 'undefined' && module.exports) {
		// CommonJS. Define export.
		var tv4 = require('../tv4');
		tv4.addLanguage('nb', lang);
		module.exports = tv4;
	} else {
		// Browser globals
		global.tv4.addLanguage('nb', lang);
	}
})(this);


});
require.register("geraintluff-tv4/lang/pl-PL.js", function(exports, require, module){
(function (global) {
	var lang = {
        INVALID_TYPE: "Niepoprawny typ: {type} (spodziewany {expected})",
        ENUM_MISMATCH: "Żadna predefiniowana wartośc nie pasuje do: {value}",
        ANY_OF_MISSING: "Dane nie pasują do żadnego wzoru z sekcji \"anyOf\"",
        ONE_OF_MISSING: "Dane nie pasują do żadnego wzoru z sekcji \"oneOf\"",
        ONE_OF_MULTIPLE: "Dane są prawidłowe dla więcej niż jednego schematu z \"oneOf\": indeksy {index1} i {index2}",
        NOT_PASSED: "Dane pasują do wzoru z sekcji \"not\"",
        // Numeric errors
        NUMBER_MULTIPLE_OF: "Wartość {value} nie jest wielokrotnością {multipleOf}",
        NUMBER_MINIMUM: "Wartość {value} jest mniejsza niż {minimum}",
        NUMBER_MINIMUM_EXCLUSIVE: "Wartość {value} jest równa wyłączonemu minimum {minimum}",
        NUMBER_MAXIMUM: "Wartość {value} jest większa niż {maximum}",
        NUMBER_MAXIMUM_EXCLUSIVE: "Wartość {value} jest równa wyłączonemu maksimum {maximum}",
        NUMBER_NOT_A_NUMBER: "Wartość {value} nie jest poprawną liczbą",
        // String errors
        STRING_LENGTH_SHORT: "Napis jest za krótki ({length} znaków), minimum {minimum}",
        STRING_LENGTH_LONG: "Napis jest za długi ({length} )znaków, maksimum {maximum}",
        STRING_PATTERN: "Napis nie pasuje do wzoru: {pattern}",
        // Object errors
        OBJECT_PROPERTIES_MINIMUM: "Za mało zdefiniowanych pól ({propertyCount}), minimum {minimum}",
        OBJECT_PROPERTIES_MAXIMUM: "Za dużo zdefiniowanych pól ({propertyCount}), maksimum {maximum}",
        OBJECT_REQUIRED: "Brakuje wymaganego pola: {key}",
        OBJECT_ADDITIONAL_PROPERTIES: "Dodatkowe pola są niedozwolone",
        OBJECT_DEPENDENCY_KEY: "Błąd zależności - klucz musi istnieć: {missing} (wzgledem klucza: {key})",
        // Array errors
        ARRAY_LENGTH_SHORT: "Tablica ma za mało elementów ({length}), minimum {minimum}",
        ARRAY_LENGTH_LONG: "Tablica ma za dużo elementów ({length}), maximum {maximum}",
        ARRAY_UNIQUE: "Elementy tablicy nie są unikalne (indeks {match1} i {match2})",
        ARRAY_ADDITIONAL_ITEMS: "Dodatkowe elementy są niedozwolone",
        // Format errors
        FORMAT_CUSTOM: "Błąd zgodności z formatem ({message})",
        KEYWORD_CUSTOM: "Błąd słowa kluczowego: {key} ({message})",
        // Schema structure
        CIRCULAR_REFERENCE: "Cykliczna referencja $refs: {urls}",
        // Non-standard validation options
        UNKNOWN_PROPERTY: "Nie znane pole (brak we wzorze(schema))"
	};
	
	if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['../tv4'], function(tv4) {
			tv4.addLanguage('pl-PL', lang);
			return tv4;
		});
	} else if (typeof module !== 'undefined' && module.exports) {
		// CommonJS. Define export.
		var tv4 = require('../tv4');
		tv4.addLanguage('pl-PL', lang);
		module.exports = tv4;
	} else {
		// Browser globals
		global.tv4.addLanguage('pl-PL', lang);
	}
})(this);

});
require.register("geraintluff-tv4/lang/pt-PT.js", function(exports, require, module){
(function (global) {
	var lang = {
		INVALID_TYPE: "Tipo inválido: {type} (esperava {expected})",
		ENUM_MISMATCH: "Nenhuma correspondência 'enum' para: {value}",
		ANY_OF_MISSING: "Os dados não correspondem a nenhum esquema de \"anyOf\"",
		ONE_OF_MISSING: "Os dados não correspondem a nenhum esquema de \"oneOf\"",
		ONE_OF_MULTIPLE: "Os dados são válidos quando comparados com mais de um esquema de \"oneOf\": índices {index1} e {index2}",
		NOT_PASSED: "Os dados correspondem a um esquema de \"not\"",
		// Numeric errors
		NUMBER_MULTIPLE_OF: "O valor {value} não é um múltiplo de {multipleOf}",
		NUMBER_MINIMUM: "O valor {value} é menor que o mínimo {minimum}",
		NUMBER_MINIMUM_EXCLUSIVE: "O valor {value} é igual ao mínimo exclusivo {minimum}",
		NUMBER_MAXIMUM: "O valor {value} é maior que o máximo {maximum}",
		NUMBER_MAXIMUM_EXCLUSIVE: "O valor {value} é igual ao máximo exclusivo {maximum}",
		NUMBER_NOT_A_NUMBER: "O valor {value} não é um número válido",
		// String errors
		STRING_LENGTH_SHORT: "A 'string' é muito curta ({length} caracteres), mínimo {minimum}",
		STRING_LENGTH_LONG: "A 'string' é muito longa ({length} caracteres), máximo {maximum}",
		STRING_PATTERN: "A 'string' não corresponde ao modelo: {pattern}",
		// Object errors
		OBJECT_PROPERTIES_MINIMUM: "Poucas propriedades definidas ({propertyCount}), mínimo {minimum}",
		OBJECT_PROPERTIES_MAXIMUM: "Muitas propriedades definidas ({propertyCount}), máximo {maximum}",
		OBJECT_REQUIRED: "Propriedade necessária em falta: {key}",
		OBJECT_ADDITIONAL_PROPERTIES: "Não são permitidas propriedades adicionais",
		OBJECT_DEPENDENCY_KEY: "Uma dependência falhou - tem de existir uma chave: {missing} (devido à chave: {key})",
		// Array errors
		ARRAY_LENGTH_SHORT: "A 'array' é muito curta ({length}), mínimo {minimum}",
		ARRAY_LENGTH_LONG: "A 'array' é muito longa ({length}), máximo {maximum}",
		ARRAY_UNIQUE: "Os itens da 'array' não são únicos (índices {match1} e {match2})",
		ARRAY_ADDITIONAL_ITEMS: "Não são permitidos itens adicionais",
		// Format errors
		FORMAT_CUSTOM: "A validação do formato falhou ({message})",
		KEYWORD_CUSTOM: "A 'keyword' falhou: {key} ({message})",
		// Schema structure
		CIRCULAR_REFERENCE: "$refs circular: {urls}",
		// Non-standard validation options
		UNKNOWN_PROPERTY: "Propriedade desconhecida (não está em 'schema')"
	};
	
	if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['../tv4'], function(tv4) {
			tv4.addLanguage('pt-PT', lang);
			return tv4;
		});
	} else if (typeof module !== 'undefined' && module.exports) {
		// CommonJS. Define export.
		var tv4 = require('../tv4');
		tv4.addLanguage('pt-PT', lang);
		module.exports = tv4;
	} else {
		// Browser globals
		global.tv4.addLanguage('pt-PT', lang);
	}
})(this);

});
require.register("geraintluff-tv4/lang/sv-SE.js", function(exports, require, module){
(function (global) {
	var lang = {
  	INVALID_TYPE: "Otillåten typ: {type} (skall vara {expected})",
  	ENUM_MISMATCH: "Otillåtet värde: {value}",
  	ANY_OF_MISSING: "Värdet matchar inget av schemana \"anyOf\"",
  	ONE_OF_MISSING: "Värdet matchar inget av schemana \"oneOf\"",
  	ONE_OF_MULTIPLE: "Värdet matchar flera scheman \"oneOf\": index {index1} och {index2}",
  	NOT_PASSED: "Värdet matchar schemat från \"not\"",
  	// Numeric errors
  	NUMBER_MULTIPLE_OF: "Värdet {value} är inte en multipel av {multipleOf}",
  	NUMBER_MINIMUM: "Värdet {value} får inte vara mindre än {minimum}",
  	NUMBER_MINIMUM_EXCLUSIVE: "Värdet {value} måste vara större än {minimum}",
  	NUMBER_MAXIMUM: "Värdet {value} får inte vara större än {maximum}",
  	NUMBER_MAXIMUM_EXCLUSIVE: "Värdet {value} måste vara mindre än {maximum}",
  	NUMBER_NOT_A_NUMBER: "Värdet {value} är inte ett giltigt tal",
  	// String errors
  	STRING_LENGTH_SHORT: "Texten är för kort ({length} tecken), ska vara minst {minimum} tecken",
  	STRING_LENGTH_LONG: "Texten är för lång ({length} tecken), ska vara högst {maximum}",
  	STRING_PATTERN: "Texten har fel format: {pattern}",
  	// Object errors
  	OBJECT_PROPERTIES_MINIMUM: "För få parametrar ({propertyCount}), ska minst vara {minimum}",
  	OBJECT_PROPERTIES_MAXIMUM: "För många parametrar ({propertyCount}), får högst vara {maximum}",
  	OBJECT_REQUIRED: "Egenskap saknas: {key}",
  	OBJECT_ADDITIONAL_PROPERTIES: "Extra parametrar är inte tillåtna",
  	OBJECT_DEPENDENCY_KEY: "Saknar beroende - saknad nyckel: {missing} (beroende nyckel: {key})",
  	// Array errors
  	ARRAY_LENGTH_SHORT: "Listan är för kort ({length}), ska minst vara {minimum}",
  	ARRAY_LENGTH_LONG: "Listan är för lång ({length}), ska högst vara {maximum}",
  	ARRAY_UNIQUE: "Listvärden är inte unika (index {match1} och {match2})",
  	ARRAY_ADDITIONAL_ITEMS: "Extra värden är inte tillåtna",
  	// Format errors
  	FORMAT_CUSTOM: "Misslyckad validering ({message})",
  	KEYWORD_CUSTOM: "Misslyckat nyckelord: {key} ({message})",
  	// Schema structure
  	CIRCULAR_REFERENCE: "Cirkulär $refs: {urls}",
  	// Non-standard validation options
  	UNKNOWN_PROPERTY: "Okänd egenskap (finns ej i schema)"
	};
	
	if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['../tv4'], function(tv4) {
			tv4.addLanguage('sv-SE', lang);
			return tv4;
		});
	} else if (typeof module !== 'undefined' && module.exports) {
		// CommonJS. Define export.
		var tv4 = require('../tv4');
		tv4.addLanguage('sv-SE', lang);
		module.exports = tv4;
	} else {
		// Browser globals
		global.tv4.addLanguage('sv-SE', lang);
	}
})(this);

});
require.register("geraintluff-tv4/lang/zh-CN.js", function(exports, require, module){
(function (global) {
	var lang = {
		INVALID_TYPE: "当前类型 {type} 不符合期望的类型 {expected}",
		ENUM_MISMATCH: "{value} 不是有效的枚举类型取值",
		ANY_OF_MISSING: "数据不符合以下任何一个模式 (\"anyOf\")",
		ONE_OF_MISSING: "数据不符合以下任何一个模式 (\"oneOf\")",
		ONE_OF_MULTIPLE: "数据同时符合多个模式 (\"oneOf\"): 下标 {index1} 和 {index2}",
		NOT_PASSED: "数据不应匹配以下模式 (\"not\")",
		// Numeric errors
		NUMBER_MULTIPLE_OF: "数值 {value} 不是 {multipleOf} 的倍数",
		NUMBER_MINIMUM: "数值 {value} 小于最小值 {minimum}",
		NUMBER_MINIMUM_EXCLUSIVE: "数值 {value} 等于排除的最小值 {minimum}",
		NUMBER_MAXIMUM: "数值 {value} is greater 大于最大值 {maximum}",
		NUMBER_MAXIMUM_EXCLUSIVE: "数值 {value} 等于排除的最大值 {maximum}",
		NUMBER_NOT_A_NUMBER: "数值 {value} 不是有效的数字",
		// String errors
		STRING_LENGTH_SHORT: "字符串太短 ({length} 个字符), 最少 {minimum} 个",
		STRING_LENGTH_LONG: "字符串太长 ({length} 个字符), 最多 {maximum} 个",
		STRING_PATTERN: "字符串不匹配模式: {pattern}",
		// Object errors
		OBJECT_PROPERTIES_MINIMUM: "字段数过少 ({propertyCount}), 最少 {minimum} 个",
		OBJECT_PROPERTIES_MAXIMUM: "字段数过多 ({propertyCount}), 最多 {maximum} 个",
		OBJECT_REQUIRED: "缺少必要字段: {key}",
		OBJECT_ADDITIONAL_PROPERTIES: "不允许多余的字段",
		OBJECT_DEPENDENCY_KEY: "依赖失败 - 缺少键 {missing} (来自键: {key})",
		// Array errors
		ARRAY_LENGTH_SHORT: "数组长度太短 ({length}), 最小长度 {minimum}",
		ARRAY_LENGTH_LONG: "数组长度太长 ({length}), 最大长度 {maximum}",
		ARRAY_UNIQUE: "数组元素不唯一 (下标 {match1} 和 {match2})",
		ARRAY_ADDITIONAL_ITEMS: "不允许多余的元素",
		// Format errors
		FORMAT_CUSTOM: "格式校验失败 ({message})",
		KEYWORD_CUSTOM: "关键字 {key} 校验失败: ({message})",
		// Schema structure
		CIRCULAR_REFERENCE: "循环引用 ($refs): {urls}",
		// Non-standard validation options
		UNKNOWN_PROPERTY: "未知字段 (不在 schema 中)"
	};

	if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['../tv4'], function(tv4) {
			tv4.addLanguage('zh-CN', lang);
			return tv4;
		});
	} else if (typeof module !== 'undefined' && module.exports){
		// CommonJS. Define export.
		var tv4 = require('../tv4');
		tv4.addLanguage('zh-CN', lang);
		module.exports = tv4;
	} else {
		// Browser globals
		global.tv4.addLanguage('zh-CN', lang);
	}
})(this);

});
require.register("rauchg-ms.js/index.js", function(exports, require, module){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} options
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options){
  options = options || {};
  if ('string' == typeof val) return parse(val);
  return options.long
    ? long(val)
    : short(val);
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = '' + str;
  if (str.length > 10000) return;
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
  if (!match) return;
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function short(ms) {
  if (ms >= d) return Math.round(ms / d) + 'd';
  if (ms >= h) return Math.round(ms / h) + 'h';
  if (ms >= m) return Math.round(ms / m) + 'm';
  if (ms >= s) return Math.round(ms / s) + 's';
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function long(ms) {
  return plural(ms, d, 'day')
    || plural(ms, h, 'hour')
    || plural(ms, m, 'minute')
    || plural(ms, s, 'second')
    || ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) return;
  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
  return Math.ceil(ms / n) + ' ' + name + 's';
}

});
require.register("visionmedia-debug/browser.js", function(exports, require, module){

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = require('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // is webkit? http://stackoverflow.com/a/16459606/376773
  return ('WebkitAppearance' in document.documentElement.style) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (window.console && (console.firebug || (console.exception && console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  return JSON.stringify(v);
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs() {
  var args = arguments;
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return args;

  var c = 'color: ' + this.color;
  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
  return args;
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}
  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage(){
  try {
    return window.localStorage;
  } catch (e) {}
}

});
require.register("visionmedia-debug/debug.js", function(exports, require, module){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug.debug = debug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require('ms');

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lowercased letter, i.e. "n".
 */

exports.formatters = {};

/**
 * Previously assigned color.
 */

var prevColor = 0;

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 *
 * @return {Number}
 * @api private
 */

function selectColor() {
  return exports.colors[prevColor++ % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function debug(namespace) {

  // define the `disabled` version
  function disabled() {
  }
  disabled.enabled = false;

  // define the `enabled` version
  function enabled() {

    var self = enabled;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // add the `color` if not set
    if (null == self.useColors) self.useColors = exports.useColors();
    if (null == self.color && self.useColors) self.color = selectColor();

    var args = Array.prototype.slice.call(arguments);

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %o
      args = ['%o'].concat(args);
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    if ('function' === typeof exports.formatArgs) {
      args = exports.formatArgs.apply(self, args);
    }
    var logFn = enabled.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }
  enabled.enabled = true;

  var fn = exports.enabled(namespace) ? enabled : disabled;

  fn.namespace = namespace;

  return fn;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  var split = (namespaces || '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

});
require.register("fbp-spec/index.js", function(exports, require, module){
require('coffee-script/register');
module.exports = require('./src/index');

});
require.register("fbp-spec/schema/base.json", function(exports, require, module){
module.exports = JSON.parse('{"id":"base.json","$schema":"http://json-schema.org/draft-04/schema","title":"Base definitions","definitions":{"JsonPath":{"type":"string","description":"JsonPath, see http://goessner.net/articles/JsonPath/","format":"jsonpath","example":"products.book[2]"}}}');
});
require.register("fbp-spec/schema/expectation.json", function(exports, require, module){
module.exports = JSON.parse('{"id":"expectation.json","$schema":"http://json-schema.org/draft-04/schema","title":"Expectation","description":"An expectation on data.","type":"object","properties":{"path":{"$ref":"base.json#/definitions/JsonPath","description":"JSONPath to run messages data through. Result is passed to assertion predicate."},"equals":{"description":"Strict equality"},"above":{"description":"Greater than (>)","type":"number"},"below":{"description":"Less than than (<)","type":"number"},"type":{"description":"JSON type","type":"string"},"haveKeys":{"description":"Object has only these keys","type":"array","items":{"type":"string"}},"includeKeys":{"description":"Object has at least these keys","type":"array","items":{"type":"string"}},"contains":{"description":"String or array contains substring/item"}},"required":[]}');
});
require.register("fbp-spec/schema/expectations.json", function(exports, require, module){
module.exports = JSON.parse('{"id":"testsuites.json","$schema":"http://json-schema.org/draft-04/schema","title":"Expectation list","description":"Array of Expectation","type":"array","items":{"$ref":"expectation.json"}}');
});
require.register("fbp-spec/schema/testcase.json", function(exports, require, module){
module.exports = JSON.parse('{"id":"testcase.json","$schema":"http://json-schema.org/draft-04/schema","title":"Testcase","description":"A single test case","type":"object","properties":{"name":{"type":"string","description":"Name of this testcase/scenario"},"assertion":{"type":"string","description":"Description of what this testcase asserts"},"inputs":{"description":"The inputs send to the fixture input ports, or a sequence of such inputs","oneOf":[{"type":"object"},{"type":"array","items":{"type":"object"}}]},"expect":{"description":"Expected data on fixture output ports.\\nCan either be an object, or a sequence of such objects.\\n","oneOf":[{"$ref":"outputdata.json"},{"type":"array","items":[{"$ref":"outputdata.json"}]}]},"timeout":{"type":"number","description":"Timeout (in milliseconds). Overrides that set in the suite","default":2000},"skip":{"type":"string","description":"Flag to skip testcase.\\nShould be a description of the reason for skipping.\\n"}},"required":["name","assertion","inputs","expect"]}');
});
require.register("fbp-spec/schema/testsuite.json", function(exports, require, module){
module.exports = JSON.parse('{"id":"testsuite.json","$schema":"http://json-schema.org/draft-04/schema","title":"Test suite","description":"A collection of test cases","type":["object"],"properties":{"topic":{"type":"string","description":"The component/graph under test","example":"MyComponent3"},"name":{"type":"string","description":"Name of this test suite. Topic is used if no name is provided.","default":""},"fixture":{"type":"object","description":"The graph fixture to run for each test case"},"cases":{"type":"array","description":"The test cases","items":{"$ref":"testcase.json"},"default":[]},"timeout":{"type":"number","description":"Timeout (in milliseconds) for setup and default for each test case.","default":2000},"skip":{"type":"string","description":"Flag to skip test suite (and all containing test cases).\\nShould be a description of the reason for skipping.\\n"}},"required":["topic"]}');
});
require.register("fbp-spec/schema/testsuites.json", function(exports, require, module){
module.exports = JSON.parse('{"id":"testsuites.json","$schema":"http://json-schema.org/draft-04/schema","title":"TestSuite list","description":"Array of TestSuite","type":"array","items":{"$ref":"testsuite.json"}}');
});
require.register("fbp-spec/schema/testsfile.json", function(exports, require, module){
module.exports = JSON.parse('{"id":"testsfile.json","$schema":"http://json-schema.org/draft-04/schema","title":"Tests file","description":"One or more suites","oneOf":[{"$ref":"testsuites.json"},{"$ref":"testsuite.json"}]}');
});
require.register("fbp-spec/component.json", function(exports, require, module){
module.exports = JSON.parse('{"name":"fbp-spec","description":"Data-driven BDD tests for FBP runtimes","author":"Jon Nordby <jononor@gmail.com>","repo":"flowbased/fbp-spec","version":"0.1.8","main":"src/index.js","keywords":[],"dependencies":{"flowbased/fbp-protocol-client":"*","flowbased/fbp":"*","jonnor/js-yaml":"*","jonnor/chai":"*","jonnor/JSONPath":"*","geraintluff/tv4":"*","visionmedia/debug":"*"},"remotes":["https://raw.githubusercontent.com"],"scripts":["src/protocol.js","src/runner.js","src/testsuite.js","src/subprocess.js","src/mocha.js","src/common.js","src/expectation.js","src/index.js","schema/index.js","ui/widgets.js","index.js"],"json":["schema/base.json","schema/expectation.json","schema/expectations.json","schema/testcase.json","schema/testsuite.json","schema/testsuites.json","schema/testsfile.json","component.json"]}');
});
require.register("fbp-spec/src/protocol.js", function(exports, require, module){
var common, debug, getComponents;

common = require('./common');

debug = require('debug')('fbp-spec:protocol');

exports.sendGraph = function(runtime, graph, callback) {
  var connection, graphId, i, iip, len, main, name, pendingPorts, priv, process, pub, ref, ref1, ref2, ref3, waitForPorts;
  main = false;
  graphId = graph.name || graph.properties.id;
  if (!graphId) {
    graphId = "fixture." + (common.randomString(10));
  }
  pendingPorts = {
    "in": [],
    out: []
  };
  runtime.sendGraph('clear', {
    id: graphId,
    name: graph.name,
    main: main,
    library: graph.properties.project || '',
    icon: graph.properties.icon || '',
    description: graph.properties.description || ''
  });
  ref = graph.processes;
  for (name in ref) {
    process = ref[name];
    debug('adding node', name, process.component);
    runtime.sendGraph('addnode', {
      id: name,
      component: process.component,
      metadata: process.metadata,
      graph: graphId
    });
  }
  ref1 = graph.connections;
  for (i = 0, len = ref1.length; i < len; i++) {
    connection = ref1[i];
    if (connection.src != null) {
      debug('connecting edge', connection);
      runtime.sendGraph('addedge', {
        src: {
          node: connection.src.process,
          port: connection.src.port
        },
        tgt: {
          node: connection.tgt.process,
          port: connection.tgt.port
        },
        metadata: connection.metadata != null,
        graph: graphId
      });
    } else {
      iip = connection;
      debug('adding IIP', iip);
      runtime.sendGraph('addinitial', {
        src: {
          data: iip.data
        },
        tgt: {
          node: iip.tgt.process,
          port: iip.tgt.port
        },
        metadata: iip.metadata,
        graph: graphId
      });
    }
  }
  if (graph.inports) {
    ref2 = graph.inports;
    for (pub in ref2) {
      priv = ref2[pub];
      debug('exporting inport', pub);
      runtime.sendGraph('addinport', {
        "public": pub,
        node: priv.process,
        port: priv.port,
        graph: graphId
      });
      pendingPorts["in"].push(pub);
    }
  }
  if (graph.outports) {
    ref3 = graph.outports;
    for (pub in ref3) {
      priv = ref3[pub];
      debug('exporting outport', pub);
      runtime.sendGraph('addoutport', {
        "public": pub,
        node: priv.process,
        port: priv.port,
        graph: graphId
      });
      pendingPorts.out.push(pub);
    }
  }
  waitForPorts = function(arg) {
    var collection, command, payload;
    command = arg.command, payload = arg.payload;
    if (command !== 'addinport' && command !== 'addoutport') {
      return;
    }
    debug('received port', payload["public"]);
    if (command === 'addinport') {
      collection = pendingPorts["in"];
    } else {
      collection = pendingPorts.out;
    }
    if (collection.indexOf(payload["public"]) === -1) {
      debug('received unknown port', payload["public"]);
      return;
    }
    collection.splice(collection.indexOf(payload["public"]), 1);
    if (pendingPorts["in"].length || pendingPorts.out.length) {
      return;
    }
    runtime.removeListener('graph', waitForPorts);
    return callback(null, graphId);
  };
  return runtime.on('graph', waitForPorts);
};

exports.startNetwork = function(runtime, graphId, callback) {
  var waitForStarted;
  debug('startnetwork', graphId);
  waitForStarted = function(status) {
    debug('start: runtime status change', status);
    if (status.started) {
      runtime.removeListener('execution', waitForStarted);
      return callback(null);
    }
  };
  runtime.on('execution', waitForStarted);
  return runtime.sendNetwork('start', {
    graph: graphId
  });
};

exports.stopNetwork = function(runtime, graphId, callback) {
  var waitForStopped;
  debug('stopnetwork', graphId);
  waitForStopped = function(status) {
    debug('stop: runtime status change', status);
    if (!status.running) {
      runtime.removeListener('execution', waitForStopped);
      return callback(null);
    }
  };
  runtime.on('execution', waitForStopped);
  return runtime.sendNetwork('stop', {
    graph: graphId
  });
};

exports.sendPackets = function(client, graphId, packets, callback) {
  var payload, port;
  debug('sendpackets', graphId, packets);
  for (port in packets) {
    payload = packets[port];
    client.sendRuntime('packet', {
      event: 'data',
      port: port,
      payload: payload,
      graph: graphId
    });
  }
  return callback(null);
};

exports.getComponents = getComponents = function(client, callback) {
  var components, gotComponent;
  debug('get components');
  components = {};
  gotComponent = function(msg) {
    var command, payload;
    command = msg.command, payload = msg.payload;
    debug('got component?', command);
    if (command === 'component') {
      return components[payload.name] = payload;
    } else if (command === 'componentsready') {
      client.removeListener('component', gotComponent);
      return callback(null, components);
    }
  };
  client.on('component', gotComponent);
  return client.sendComponent('list', {});
};

exports.getCapabilities = function(client, callback) {
  var def, onCapabilities, ref;
  def = client.definition;
  if (def != null ? (ref = def.capabilities) != null ? ref.length : void 0 : void 0) {
    return callback(null, def.capabilities);
  }
  onCapabilities = function(capabilities) {
    client.removeListener('capabilities', onCapabilities);
    return callback(null, capabilities, def);
  };
  return client.on('capabilities', onCapabilities);
};

exports.getComponentTests = function(client, callback) {
  var complete, expectResponses, gotComponent, responses, tests;
  debug('get component tests');
  responses = 0;
  expectResponses = 0;
  tests = {};
  gotComponent = function(msg) {
    var command, payload;
    command = msg.command, payload = msg.payload;
    responses += 1;
    debug('got component source?', command, payload.name, payload.tests != null, responses, expectResponses);
    if (command !== 'source') {
      return;
    }
    if (payload.tests != null) {
      tests[payload.name] = payload.tests;
    }
    if (responses === expectResponses) {
      debug('got all component sources', Object.keys(tests).length);
      return complete(null, tests);
    }
  };
  complete = function(err, tests) {
    client.removeListener('component', gotComponent);
    return callback(err, tests);
  };
  return getComponents(client, function(err, components) {
    var componentNames, i, len, name, results;
    if (err) {
      return complete(err);
    }
    componentNames = Object.keys(components);
    expectResponses = componentNames.length;
    if (expectResponses === 0) {
      return complete(null, tests);
    }
    debug('retrieving sources for', expectResponses);
    client.on('component', gotComponent);
    results = [];
    for (i = 0, len = componentNames.length; i < len; i++) {
      name = componentNames[i];
      results.push(client.sendComponent('getsource', {
        name: name
      }));
    }
    return results;
  });
};

});
require.register("fbp-spec/src/runner.js", function(exports, require, module){
var Runner, checkResults, common, debug, debugReceivedMessages, expectation, fbp, fbpClient, getFixtureGraph, loadComponentSuites, protocol, runAll, runSuite, runTestAndCheck, sendMessageAndWait, synthesizeTopicFixture, testsuite,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

common = require('./common');

protocol = require('./protocol');

testsuite = require('./testsuite');

expectation = require('./expectation');

fbp = require('fbp');

fbpClient = require('fbp-protocol-client');

debug = require('debug')('fbp-spec:runner');

debugReceivedMessages = function(client) {
  var debugReceived;
  debugReceived = require('debug')('fbp-spec:runner:received');
  client.on('graph', function(arg) {
    var command, payload;
    command = arg.command, payload = arg.payload;
    return debugReceived('graph', command, payload);
  });
  client.on('network', function(arg) {
    var command, payload;
    command = arg.command, payload = arg.payload;
    return debugReceived('network', command, payload);
  });
  client.on('runtime', function(arg) {
    var command, payload;
    command = arg.command, payload = arg.payload;
    return debugReceived('runtime', command, payload);
  });
  client.on('component', function(arg) {
    var command, payload;
    command = arg.command, payload = arg.payload;
    return debugReceived('component', command, payload);
  });
  return client.on('execution', function(status) {
    return debugReceived('execution', status);
  });
};

synthesizeTopicFixture = function(topic, components, callback) {
  var component, graph, j, k, len, len1, port, portName, processName, ref, ref1;
  debug('synthesizing fixture', topic);
  component = components[topic];
  if (!component) {
    return callback(new Error("Could not find component for topic: " + topic));
  }
  graph = {
    properties: {},
    inports: {},
    outports: {},
    processes: {},
    connections: []
  };
  processName = 'testee';
  graph.processes[processName] = {
    component: topic
  };
  ref = component.inPorts;
  for (j = 0, len = ref.length; j < len; j++) {
    port = ref[j];
    portName = port.id;
    graph.inports[portName] = {
      process: processName,
      port: portName
    };
  }
  ref1 = component.outPorts;
  for (k = 0, len1 = ref1.length; k < len1; k++) {
    port = ref1[k];
    portName = port.id;
    graph.outports[portName] = {
      process: processName,
      port: portName
    };
  }
  return callback(null, graph);
};

getFixtureGraph = function(context, suite, callback) {
  var hasComponents, updateComponents;
  hasComponents = function(s) {
    return (s.components != null) && typeof s.components === 'object' && Object.keys(s.components).length;
  };
  updateComponents = function(cb) {
    if (hasComponents(context)) {
      return cb(null);
    }
    return protocol.getComponents(context.client, function(err, components) {
      if (err) {
        return cb(err);
      }
      context.components = components;
      return cb(null);
    });
  };
  return updateComponents(function(err) {
    var e, error1, error2, graph;
    if (err) {
      return callback(err);
    }
    if (suite.fixture == null) {
      return synthesizeTopicFixture(suite.topic, context.components, callback);
    } else if (suite.fixture.type === 'json') {
      try {
        graph = JSON.parse(suite.fixture.data);
      } catch (error1) {
        e = error1;
        return callback(e);
      }
      return callback(null, graph);
    } else if (suite.fixture.type === 'fbp') {
      try {
        graph = fbp.parse(suite.fixture.data);
      } catch (error2) {
        return callback(e);
      }
      if (!graph.properties) {
        graph.properties = {};
      }
      return callback(null, graph);
    } else {
      return callback(new Error("Unknown fixture type " + suite.fixture.type));
    }
  });
};

sendMessageAndWait = function(client, currentGraph, inputData, expectData, callback) {
  var checkPacket, onReceived, received;
  received = {};
  onReceived = (function(_this) {
    return function(port, data) {
      var nExpected;
      debug('runtest got output on', port);
      received[port] = data;
      nExpected = Object.keys(expectData).length;
      if (Object.keys(received).length === nExpected) {
        client.removeListener('runtime', checkPacket);
        return callback(null, received);
      }
    };
  })(this);
  checkPacket = (function(_this) {
    return function(msg) {
      var d;
      d = msg.payload;
      if (msg.command === 'packet' && d.event === 'data') {
        return onReceived(d.port, d.payload);
      } else if (msg.command === 'packet' && ['begingroup', 'endgroup', 'connect', 'disconnect'].indexOf(d.event) !== -1) {

      } else {
        return debug('unknown runtime message', msg);
      }
    };
  })(this);
  client.on('runtime', checkPacket);
  return protocol.sendPackets(client, currentGraph, inputData, (function(_this) {
    return function(err) {
      if (err) {
        return callback(err);
      }
    };
  })(this));
};

Runner = (function() {
  function Runner(client1) {
    var Transport;
    this.client = client1;
    if ((this.client.protocol != null) && (this.client.address != null)) {
      Transport = fbpClient.getTransport(this.client.protocol);
      this.client = new Transport(this.client);
    }
    this.currentGraphId = null;
    this.components = {};
  }

  Runner.prototype.connect = function(callback) {
    var onStatus;
    debug('connect');
    onStatus = (function(_this) {
      return function(status) {
        if (!status.online) {
          return;
        }
        _this.client.removeListener('status', onStatus);
        debug('connected', status);
        return callback(null);
      };
    })(this);
    this.client.on('status', onStatus);
    this.client.connect();
    this.client.on('network', function(arg) {
      var command, payload;
      command = arg.command, payload = arg.payload;
      if (command === 'output' && payload.message) {
        return console.log(payload.message);
      }
    });
    return debugReceivedMessages(this.client);
  };

  Runner.prototype.disconnect = function(callback) {
    var onStatus;
    debug('disconnect');
    onStatus = (function(_this) {
      return function(status) {
        var err;
        err = !status.online ? null : new Error('Runtime online after disconnect()');
        _this.client.removeListener('status', onStatus);
        debug('disconnected', err);
        return callback(err);
      };
    })(this);
    this.client.on('status', onStatus);
    return this.client.disconnect();
  };

  Runner.prototype.setupSuite = function(suite, callback) {
    debug('setup suite', "\"" + suite.name + "\"");
    return getFixtureGraph(this, suite, (function(_this) {
      return function(err, graph) {
        if (err) {
          return callback(err);
        }
        return protocol.sendGraph(_this.client, graph, function(err, graphId) {
          _this.currentGraphId = graphId;
          if (err) {
            return callback(err);
          }
          return protocol.startNetwork(_this.client, graphId, function(err) {
            return callback(err);
          });
        });
      };
    })(this));
  };

  Runner.prototype.teardownSuite = function(suite, callback) {
    debug('teardown suite', "\"" + suite.name + "\"");
    return protocol.stopNetwork(this.client, this.currentGraphId, (function(_this) {
      return function(err) {
        return callback(err);
      };
    })(this));
  };

  Runner.prototype.runTest = function(testcase, callback) {
    var expects, i, inputs, j, ref, sendWait, sequence;
    debug('runtest', "\"" + testcase.name + "\"");
    inputs = common.isArray(testcase.inputs) ? testcase.inputs : [testcase.inputs];
    expects = common.isArray(testcase.expect) ? testcase.expect : [testcase.expect];
    sequence = [];
    for (i = j = 0, ref = inputs.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      sequence.push({
        inputs: inputs[i],
        expect: expects[i]
      });
    }
    sendWait = (function(_this) {
      return function(data, cb) {
        return sendMessageAndWait(_this.client, _this.currentGraphId, data.inputs, data.expect, cb);
      };
    })(this);
    return common.asyncSeries(sequence, sendWait, function(err, actuals) {
      actuals.forEach(function(r, idx) {
        return sequence[idx].actual = r;
      });
      return callback(err, sequence);
    });
  };

  return Runner;

})();

checkResults = function(results) {
  var actuals, errors, expects, failed, failures, index, result;
  actuals = results.filter(function(r) {
    return r.actual != null;
  });
  expects = results.filter(function(r) {
    return r.expect != null;
  });
  if (actuals.length < expects.length) {
    return callback(null, {
      passed: false,
      error: new Error("Only got " + actual.length + " output messages out of " + expect.length)
    });
  }
  results = results.map(function(res) {
    var e, error1;
    res.error = null;
    try {
      expectation.expect(res.expect, res.actual);
    } catch (error1) {
      e = error1;
      res.error = e;
    }
    return res;
  });
  failures = results.filter(function(r) {
    return r.error;
  });
  if (failures.length === 0) {
    result = {
      passed: true
    };
  } else {
    if (expects.length === 1) {
      result = {
        error: failures[0].error
      };
    } else if (expects.length > 1 && failures.length === 1) {
      index = results.findIndex(function(r) {
        return r.error;
      });
      failed = results[index];
      result = {
        error: new Error("Expectation " + index + " of sequence failed: " + failed.error.message)
      };
    } else {
      errors = results.map(function(r) {
        var ref;
        return ((ref = r.error) != null ? ref.message : void 0) || '';
      });
      result = {
        error: new Error("Multiple failures in sequence: " + errors)
      };
    }
  }
  return result;
};

runTestAndCheck = function(runner, testcase, callback) {
  var expects, inputs;
  if (testcase.skip) {
    return callback(null, {
      passed: true
    });
  }
  inputs = common.isArray(testcase.inputs) ? testcase.inputs : [testcase.inputs];
  expects = common.isArray(testcase.expect) ? testcase.expect : [testcase.expect];
  if (inputs.length !== expects.length) {
    return callback(null, {
      passed: false,
      error: new Error("Test sequence length mismatch. Got " + inputs.length + " inputs and " + expects.length + " expectations")
    });
  }
  return runner.runTest(testcase, function(err, results) {
    var result;
    if (err) {
      return callback(err, null);
    }
    result = checkResults(results);
    if (result.error) {
      result.passed = false;
    }
    return callback(null, result);
  });
};

runSuite = function(runner, suite, runTest, callback) {
  return runner.setupSuite(suite, function(err) {
    debug('setup suite', err);
    if (err) {
      return callback(err, suite);
    }
    return common.asyncSeries(suite.cases, runTest, function(err) {
      debug('testrun complete', err);
      return runner.teardownSuite(suite, function(err) {
        debug('teardown suite', err);
        return callback(err, suite);
      });
    });
  });
};

exports.getComponentSuites = function(runner, callback) {
  return protocol.getCapabilities(runner.client, function(err, caps) {
    if (err) {
      return callback(err);
    }
    if (indexOf.call(caps, 'component:getsource') < 0) {
      return callback(null, []);
    }
    return protocol.getComponentTests(runner.client, function(err, tests) {
      var suites;
      if (err) {
        return callback(err);
      }
      suites = loadComponentSuites(tests);
      debug('get component suites', tests.length, suites.length);
      return callback(null, suites);
    });
  });
};

loadComponentSuites = function(componentTests) {
  var e, error1, name, ss, suites, tests;
  suites = [];
  for (name in componentTests) {
    tests = componentTests[name];
    try {
      ss = testsuite.loadYAML(tests);
      suites = suites.concat(ss);
    } catch (error1) {
      e = error1;
      continue;
    }
  }
  return suites;
};

runAll = function(runner, suites, updateCallback, doneCallback) {
  var runOneSuite, runTest, s;
  runTest = function(testcase, callback) {
    var done;
    done = function(error) {
      updateCallback(suites);
      return callback(error);
    };
    return runTestAndCheck(runner, testcase, function(err, results) {
      var key, val;
      for (key in results) {
        val = results[key];
        testcase[key] = val;
      }
      if (testcase.error) {
        testcase.error = testcase.error.message;
      }
      debug('ran test', '"testcase.name"', testcase.passed, err);
      return done(null);
    });
  };
  runOneSuite = function(suite, cb) {
    return runSuite(runner, suite, runTest, cb);
  };
  debug('running suites', (function() {
    var j, len, results1;
    results1 = [];
    for (j = 0, len = suites.length; j < len; j++) {
      s = suites[j];
      results1.push(s.name);
    }
    return results1;
  })());
  return common.asyncSeries(suites, runOneSuite, function(err) {
    return doneCallback(err);
  });
};

exports.Runner = Runner;

exports.runAll = runAll;

exports.runTestAndCheck = runTestAndCheck;

});
require.register("fbp-spec/src/testsuite.js", function(exports, require, module){
var common, getFileSync, getSuitesSync, jsyaml, loadHTTP, loadYAML, normalize, schemas, validate;

if ((typeof window !== "undefined" && window !== null ? window.jsyaml : void 0) != null) {
  jsyaml = window.jsyaml;
}

if (!jsyaml) {
  jsyaml = require('js-yaml');
}

common = require('./common');

schemas = require('../schema');

exports.validate = validate = function(obj) {
  var name, results, schema, tv4;
  tv4 = typeof window !== "undefined" && window !== null ? window.tv4 : void 0;
  if (!tv4) {
    tv4 = require('tv4');
  }
  tv4.reset();
  for (name in schemas) {
    schema = schemas[name];
    tv4.addSchema(schema.id, schema);
  }
  results = tv4.validateMultiple(obj, 'testsfile.json');
  if (results.missing.length) {
    results.passed = false;
  }
  return results;
};

normalize = function(suite) {
  if (!suite.name) {
    suite.name = suite.topic;
  }
  if (!suite.cases) {
    suite.cases = [];
  }
  return suite;
};

exports.create = function(base) {
  return normalize(base);
};

exports.loadYAML = loadYAML = function(data) {
  var suite, suites;
  suites = [];
  suite = jsyaml.safeLoadAll(data, function(doc) {
    return suites.push(normalize(doc));
  });
  return suites;
};

loadHTTP = function(url, callback) {
  var req;
  if (common.isBrowser()) {
    req = new XMLHttpRequest();
    req.addEventListener('load', function() {
      var suites;
      suites = loadYAML(this.responseText);
      return callback(null, suites);
    });
    req.addEventListener('error', function() {
      return callback(new Error("Failed to load " + url + ": " + this.statusText));
    });
    req.open("get", url, true);
    return req.send();
  } else {
    throw new Error('fbpspec.testsuite: Loading over HTTP not supported on node.js');
  }
};

getFileSync = function(test, callback) {
  var c, f, files, fs, path, stat;
  fs = require('fs');
  path = require('path');
  stat = fs.statSync(test);
  if (stat.isDirectory()) {
    files = (function() {
      var i, len, ref, results1;
      ref = fs.readdirSync(test);
      results1 = [];
      for (i = 0, len = ref.length; i < len; i++) {
        f = ref[i];
        if (f.indexOf('.yaml') !== -1) {
          results1.push(path.join(test, f));
        }
      }
      return results1;
    })();
    return getSuitesSync(files);
  } else {
    c = fs.readFileSync(test);
    return loadYAML(c);
  }
};

exports.getSuitesSync = getSuitesSync = function(tests) {
  var i, len, suites, test;
  if (!Array.isArray(tests)) {
    tests = [tests];
  }
  suites = [];
  for (i = 0, len = tests.length; i < len; i++) {
    test = tests[i];
    suites = suites.concat(getFileSync(test));
  }
  return suites;
};

exports.getSuites = function(tests, callback) {
  var loadTest;
  if (!Array.isArray(tests)) {
    tests = [tests];
  }
  loadTest = (function(_this) {
    return function(test, cb) {
      if (common.startsWith(test, 'http://' || common.startsWith('https://'))) {
        return loadHTTP(test, cb);
      } else {
        return cb(null, getFileSync(test));
      }
    };
  })(this);
  return common.asyncSeries(tests, loadTest, function(err, suitesList) {
    var i, j, len, len1, s, ss, suites;
    if (err) {
      return callback(err);
    }
    suites = [];
    for (i = 0, len = suitesList.length; i < len; i++) {
      ss = suitesList[i];
      for (j = 0, len1 = ss.length; j < len1; j++) {
        s = ss[j];
        suites.push(s);
      }
    }
    return callback(null, suites);
  });
};

});
require.register("fbp-spec/src/subprocess.js", function(exports, require, module){
var child_process, common, debug, err, error;

try {
  child_process = require('child_process');
} catch (error) {
  err = error;
  return;
}

common = require('./common');

debug = require('debug')('fbp-spec:subprocess');

exports.start = function(command, options, callback) {
  var args, child, prog, started, stderr, stdout;
  if (options.timeout == null) {
    options.timeout = 4000;
  }
  started = false;
  stderr = "";
  stdout = "";
  prog = 'sh';
  args = ['-c', command];
  child = child_process.spawn(prog, args);
  debug('spawned', "'" + prog + " " + (args.join(' ')) + "'");
  debug('waiting for output');
  child.on('error', function(err) {
    return callback(err);
  });
  child.stdout.on('data', function(data) {
    data = data.toString();
    stdout += data;
    debug('sub stdout', data);
    if (!started) {
      debug('got output, transitioning to started');
      started = true;
      return setTimeout(callback, 100);
    }
  });
  child.stderr.on('data', function(data) {
    data = data.toString();
    stderr += data;
    debug('sub stderr', data);
    if (!started) {
      debug('got stderr, failing');
      started = true;
      return callback(new Error("Subprocess wrote on stderr: '" + stderr + "'"));
    }
  });
  setTimeout(function() {
    if (!started) {
      debug('timeout waiting for output, assuming started');
      started = true;
      return callback(null);
    }
  }, options.timeout);
  return child;
};

});
require.register("fbp-spec/src/mocha.js", function(exports, require, module){
var Runner, debug, expectation, runSuite, runnerModule, subprocess, testsuite;

runnerModule = require('./runner');

Runner = runnerModule.Runner;

testsuite = require('./testsuite');

expectation = require('./expectation');

subprocess = require('./subprocess');

debug = require('debug')('fbp-spec:mocha');

runSuite = function(runner, suite) {
  var suiteDescribe;
  suiteDescribe = suite.skip ? describe.skip : describe;
  return suiteDescribe("" + suite.name, function() {
    beforeEach(function(done) {
      if (suite.timeout != null) {
        this.timeout(suite.timeout);
      }
      return runner.setupSuite(suite, done);
    });
    afterEach(function(done) {
      return runner.teardownSuite(suite, done);
    });
    return suite.cases.forEach(function(testcase) {
      var caseDescribe;
      caseDescribe = testcase.skip ? describe.skip : describe;
      return caseDescribe(testcase.name, function() {
        return it(testcase.assertion, function(done) {
          if (suite.timeout != null) {
            this.timeout(suite.timeout);
          }
          if (testcase.timeout != null) {
            this.timeout(testcase.timeout);
          }
          return runnerModule.runTestAndCheck(runner, testcase, function(err, result) {
            if (err) {
              return done(err);
            }
            return done(result.error);
          });
        });
      });
    });
  });
};

exports.run = function(rt, tests, options) {
  var e, error, i, len, process, results, runner, start, stop, suite, suites;
  if (options.starttimeout == null) {
    options.starttimeout = 5000;
  }
  if (options.fixturetimeout == null) {
    options.fixturetimeout = 2000;
  }
  runner = new Runner(rt);
  try {
    suites = testsuite.getSuitesSync(tests);
  } catch (error) {
    e = error;
    console.log('Unable to get suites:', e);
    throw e;
  }
  process = null;
  start = function(callback) {
    var subprocessOptions;
    if (!rt.command) {
      return callback(null);
    }
    subprocessOptions = {
      timeout: options.starttimeout
    };
    return process = subprocess.start(rt.command, subprocessOptions, callback);
  };
  stop = function(callback) {
    if (process) {
      process.kill();
    }
    return callback(null);
  };
  before(function(done) {
    this.timeout(options.starttimeout + 500);
    return start(function(err) {
      debug('started', err);
      expectation.noError(err);
      return runner.connect(done);
    });
  });
  after(function(done) {
    return stop(function(err) {
      debug('stopped', err);
      expectation.noError(err);
      return runner.disconnect(done);
    });
  });
  results = [];
  for (i = 0, len = suites.length; i < len; i++) {
    suite = suites[i];
    if (suite.timeout == null) {
      suite.timeout = options.fixturetimeout;
    }
    results.push(runSuite(runner, suite));
  }
  return results;
};

});
require.register("fbp-spec/src/common.js", function(exports, require, module){
exports.isBrowser = function() {
  if (typeof process !== 'undefined' && process.execPath && process.execPath.match(/node|iojs/)) {
    return false;
  }
  return true;
};

exports.randomString = function(n) {
  var i, idx, j, possible, ref, text;
  text = "";
  possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  for (i = j = 0, ref = n; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
    idx = Math.floor(Math.random() * possible.length);
    text += possible.charAt(idx);
  }
  return text;
};

exports.asyncSeries = function(items, func, callback) {
  var next, results;
  items = items.slice(0);
  results = [];
  next = function() {
    var item;
    if (items.length === 0) {
      return callback(null, results);
    }
    item = items.shift();
    return func(item, function(err, result) {
      if (err) {
        return callback(err);
      }
      results.push(result);
      return next();
    });
  };
  return next();
};

exports.isArray = Array.isArray || function(value) {
  return {}.toString.call(value) === '[object Array]';
};

exports.startsWith = function(str, sub) {
  return str.indexOf(sub) === 0;
};

});
require.register("fbp-spec/src/expectation.js", function(exports, require, module){
var JSONPath, chai, common, debug, extractMatches, findOperator, operators;

debug = require('debug')('fbp-spec:expectation');

chai = require('chai');

JSONPath = require('JSONPath');

common = require('./common');

operators = {
  'type': function(actual, expected) {
    return chai.expect(actual).to.be.a(expected);
  },
  'equals': function(actual, expected) {
    return chai.expect(actual).to.eql(expected);
  },
  'above': function(actual, expected) {
    return chai.expect(actual).to.be.above(expected);
  },
  'below': function(actual, expected) {
    return chai.expect(actual).to.be.below(expected);
  },
  'haveKeys': function(actual, expected) {
    return chai.expect(actual).to.have.keys(expected);
  },
  'includeKeys': function(actual, expected) {
    return chai.expect(actual).to.include.keys(expected);
  },
  'contains': function(actual, expected) {
    return chai.expect(actual).to.contain(expected);
  },
  'noterror': function(actual, expected) {
    if (actual != null ? actual.message : void 0) {
      throw actual;
    }
  }
};

findOperator = function(expectation) {
  var expectValue, op, opname, predicate;
  for (opname in expectation) {
    expectValue = expectation[opname];
    if (opname === 'path') {
      continue;
    }
    op = operators[opname];
    if (op) {
      predicate = function(data) {
        return op(data, expectValue);
      };
      predicate.toString = function() {
        return opname + " " + expectValue;
      };
      return predicate;
    }
  }
  throw new Error("fbp-spec: No operator matching " + (Object.keys(expectation)) + ". Available: " + (Object.keys(operators)));
};

extractMatches = function(expectation, data) {
  var matches, options;
  options = {
    flatten: true
  };
  if (expectation.path) {
    debug('extracting JSONPath from', expectation.path, data);
    matches = JSONPath["eval"](data, expectation.path, options);
    if (!matches.length) {
      throw new Error("expected JSONPath '" + expectation.path + "' to match data in " + (JSON.stringify(data)));
    }
  } else {
    matches = [data];
  }
  debug('matching against', matches);
  return matches;
};

exports.expect = function(expects, portsdata) {
  var data, e, exp, expectation, expectations, i, len, m, matches, port, predicate, results;
  if (!common.isArray(expects)) {
    expects = [expects];
  }
  results = [];
  for (i = 0, len = expects.length; i < len; i++) {
    e = expects[i];
    results.push((function() {
      var results1;
      results1 = [];
      for (port in e) {
        exp = e[port];
        expectations = exp;
        if (!common.isArray(expectations)) {
          expectations = [expectations];
        }
        results1.push((function() {
          var j, len1, results2;
          results2 = [];
          for (j = 0, len1 = expectations.length; j < len1; j++) {
            expectation = expectations[j];
            debug('checking port for expectation', port, expectation);
            data = portsdata[port];
            predicate = findOperator(expectation);
            matches = extractMatches(expectation, data);
            results2.push((function() {
              var k, len2, results3;
              results3 = [];
              for (k = 0, len2 = matches.length; k < len2; k++) {
                m = matches[k];
                debug('checking against predicate', m, predicate.toString());
                results3.push(predicate(m));
              }
              return results3;
            })());
          }
          return results2;
        })());
      }
      return results1;
    })());
  }
  return results;
};

exports.noError = function(maybeErr) {
  return chai.expect(maybeErr).to.not.exist;
};

});
require.register("fbp-spec/src/index.js", function(exports, require, module){
var getSchema;

getSchema = function(id) {
  var schema;
  id = id.replace('.json', '');
  schema = module.exports.schema[id];
  return schema;
};

module.exports = {
  runner: require('./runner'),
  subprocess: require('./subprocess'),
  mocha: require('./mocha'),
  testsuite: require('./testsuite'),
  schema: require('../schema'),
  getSchema: getSchema,
  ui: {
    widgets: require('../ui/widgets')
  }
};

});
require.register("fbp-spec/schema/index.js", function(exports, require, module){
var e, error, i, len, name, schemas;

schemas = ['base', 'testcase', 'testsuite', 'testsuites', 'expectations', 'testsfile'];

try {
  for (i = 0, len = schemas.length; i < len; i++) {
    name = schemas[i];
    module.exports[name] = require("./" + name);
  }
} catch (error) {
  e = error;
  console.log('fbp-spec: Failed to load schemas', e);
}

});
require.register("fbp-spec/ui/widgets.js", function(exports, require, module){
var React, SuiteHeader, SuiteHeaderClass, TestCaseListing, TestCaseListingClass, TestStatus, TestStatusClass, TestsListing, TestsListingClass, countCases, div, label, li, ref, ref1, span, ul;

if ((typeof window !== "undefined" && window !== null ? window.React : void 0) == null) {
  React = {
    DOM: {},
    createFactory: function() {}
  };
} else {
  React = window.React;
}

ref = React.DOM, div = ref.div, label = ref.label, span = ref.span;

SuiteHeaderClass = (function() {
  function SuiteHeaderClass() {}

  SuiteHeaderClass.prototype.render = function() {
    return div({
      className: 'suite-header'
    }, [
      label({
        className: 'name'
      }, this.props.name), label({
        className: 'topic'
      }, this.props.topic)
    ]);
  };

  return SuiteHeaderClass;

})();

SuiteHeader = React.createFactory(SuiteHeaderClass);

TestCaseListingClass = (function() {
  function TestCaseListingClass() {}

  TestCaseListingClass.prototype.render = function() {
    return div({
      className: "testcase"
    }, [
      label({
        className: 'name'
      }, this.props.name), label({
        className: 'assertion'
      }, this.props.assertion), label({
        className: 'error'
      }, this.props.error || '')
    ]);
  };

  return TestCaseListingClass;

})();

TestCaseListing = React.createFactory(TestCaseListingClass);

ref1 = React.DOM, ul = ref1.ul, li = ref1.li;

TestsListingClass = (function() {
  function TestsListingClass() {}

  TestsListingClass.prototype.render = function() {
    var createCase, createSuite;
    createCase = function(testcase) {
      var c;
      c = testcase.passed ? 'pass' : 'fail';
      if (testcase.skip) {
        c = 'skip';
      }
      if (testcase.passed == null) {
        c = 'pending';
      }
      return li({
        className: c
      }, [TestCaseListing(testcase)]);
    };
    createSuite = function(suite) {
      return li({
        className: "testsuite"
      }, [SuiteHeader(suite), ul({}, [suite.cases.map(createCase)])]);
    };
    return ul({}, [this.props.suites.map(createSuite)]);
  };

  return TestsListingClass;

})();

TestsListing = React.createFactory(TestsListingClass);

countCases = function(suites, predicate) {
  var count, i, j, len, len1, ref2, suite, testcase;
  count = 0;
  for (i = 0, len = suites.length; i < len; i++) {
    suite = suites[i];
    ref2 = suite.cases;
    for (j = 0, len1 = ref2.length; j < len1; j++) {
      testcase = ref2[j];
      if (predicate(testcase, suite)) {
        count += 1;
      }
    }
  }
  return count;
};

TestStatusClass = (function() {
  function TestStatusClass() {}

  TestStatusClass.prototype.render = function() {
    var failing, passing, skipped, total;
    total = countCases(this.props.suites, function() {
      return true;
    });
    passing = countCases(this.props.suites, function(c) {
      return (c.passed != null) && c.passed;
    });
    failing = countCases(this.props.suites, function(c) {
      return (c.passed != null) && !c.passed;
    });
    skipped = countCases(this.props.suites, function(c, s) {
      return (c.skip != null) || (s.skip != null);
    });
    return ul({
      className: 'test-status'
    }, [
      li({
        className: 'pass'
      }, passing), li({
        className: 'fail'
      }, failing), li({
        className: 'skip'
      }, skipped), li({
        className: 'total'
      }, total)
    ]);
  };

  return TestStatusClass;

})();

TestStatus = React.createFactory(TestStatusClass);

module.exports = {
  TestStatus: TestStatus,
  TestsListing: TestsListing
};

});


require.register("noflo-noflo/component.json", function(exports, require, module){
module.exports = {
  "name": "noflo",
  "description": "Flow-Based Programming environment for JavaScript",
  "keywords": [
    "fbp",
    "workflow",
    "flow"
  ],
  "repo": "noflo/noflo",
  "version": "0.5.22",
  "dependencies": {
    "bergie/emitter": "*",
    "jashkenas/underscore": "1.8.3",
    "flowbased/fbp": "*"
  },
  "remotes": [
    "https://raw.githubusercontent.com"
  ],
  "development": {},
  "license": "MIT",
  "main": "src/lib/NoFlo.js",
  "scripts": [
    "src/lib/Graph.js",
    "src/lib/InternalSocket.js",
    "src/lib/IP.js",
    "src/lib/BasePort.js",
    "src/lib/InPort.js",
    "src/lib/OutPort.js",
    "src/lib/Ports.js",
    "src/lib/Port.js",
    "src/lib/ArrayPort.js",
    "src/lib/Component.js",
    "src/lib/AsyncComponent.js",
    "src/lib/ComponentLoader.js",
    "src/lib/NoFlo.js",
    "src/lib/Network.js",
    "src/lib/Platform.js",
    "src/lib/Journal.js",
    "src/lib/Utils.js",
    "src/lib/Helpers.js",
    "src/lib/Streams.js",
    "src/components/Graph.js"
  ],
  "json": [
    "component.json"
  ],
  "noflo": {
    "components": {
      "Graph": "src/components/Graph.js"
    }
  }
}

});




require.register("microflo-microflo/component.json", function(exports, require, module){
module.exports = {
  "name": "microflo",
  "description": "MicroFlo host functionality for browser",
  "author": "Jon Nordby <jononor@gmail.com>",
  "repo": "microflo/microflo",
  "version": "0.3.29",
  "keywords": [
    "FBP"
  ],
  "dependencies": {
    "component/emitter": "*",
    "the-grid/flowhub-registry": "*",
    "noflo/fbp": "*",
    "jonnor/buffer": "*"
  },
  "main": "lib/microflo.js",
  "scripts": [
    "lib/commandformat.js",
    "lib/commandstream.js",
    "lib/componentlib.js",
    "lib/generate.js",
    "lib/microflo.js",
    "lib/serial.js",
    "lib/simulator.js",
    "lib/util.js",
    "lib/devicecommunication.js",
    "lib/flash.js",
    "lib/definition.js",
    "lib/runtime.js"
  ],
  "json": [
    "component.json",
    "microflo/commandformat.json"
  ],
  "remotes": [
    "https://raw.githubusercontent.com"
  ],
  "styles": [],
  "files": [
  ]
}

});
require.register("microflo-microflo/microflo/commandformat.json", function(exports, require, module){
module.exports = {
    "magicString": "uC/Flo01",
    "commandSize": 8,
    "commands": {
        "Reset": {"id": 10},
        "CreateComponent": {"id": 11},
        "ConnectNodes": {"id": 12},
        "SendPacket": {"id": 13},
        "End": {"id": 14},
        "ConfigureDebug": {"id": 15},
        "SubscribeToPort": {"id": 16},
        "ConnectSubgraphPort": {"id": 17},
        "Ping": {"id": 18},
        "CommunicationOpen": {"id": 19},
        "StartNetwork": {"id": 20},
        "SetIoValue": {"id": 21},

        "NetworkStopped": {"id": 100},
        "NodeAdded": {"id": 101},
        "NodesConnected": {"id": 102},
        "PacketSent": {"id": 103},
        "NetworkStarted": {"id": 104},
        "DebugChanged": {"id": 105},
        "DebugMessage": {"id": 106},
        "PortSubscriptionChanged": {"id": 107},
        "SubgraphPortConnected": {"id": 108},
        "Pong": {"id": 109},
        "PacketDelivered": {"id": 110},
        "TransmissionEnded": {"id": 111},
        "SetIoValueCompleted":  {"id": 112},
        "IoValueChanged":  {"id": 113},
        "SendPacketDone":  {"id": 114},

        "Invalid": { },
        "Max": { "id": 255 }
    },
    "packetTypes": {
        "Invalid": { "id": 0 },
        "Setup": { "id": 1 },
        "Tick": { "id": 2 },

        "Void": { "id": 3,
            "description": "No data payload, can be used like a 'bang' in other flow-based systems" },
        "Byte": { "id": 4 },
        "Boolean": { "id": 6 },
        "Integer": { "id": 7 },
        "Float": { "id": 8 },
        "BracketStart": { "id": 9 },
        "BracketEnd": { "id": 10 },

        "MaxDefined": { },
        "Max": { "id": 255 }
    },
    "debugPoints": {
        "Invalid": { "id": 0 },

        "ProgramStart": {"id":1 },
        "ComponentCreateStart": {"id":2},
        "ComponentCreateEnd": {"id":3},
        "ParserInvalidState": {"id":4},
        "ParserUnknownState": {"id":5},
        "ParseHeader": {"id":6},
        "ParseCommand": {"id":7},
        "ParseByte": {"id":8},
        "ParserUnknownCommand": {"id":9},
        "ParserInvalidCommand": {"id":10},
        "ParserUnknownPacketType": {"id":11},
        "NetworkConnectInvalidNodes": {"id":12},
        "ConnectNodesStart": {"id": 13},
        "ReadByte": {"id": 14},
        "AddNodeInvalidInstance": {"id": 15},
        "ComponentSendInvalidPort": {"id": 16},
        "ParseLookForHeader": {"id":17},
        "MagicMismatch": {"id": 18},
        "NotImplemented": {"id": 19},
        "SubGraphConnectNotASubgraph": {"id": 20},
        "SubGraphConnectInvalidNodes": {"id": 21},
        "SubGraphReceivedNormalMessage": {"id": 22},
        "SendMessageInvalidNode": {"id": 23},
        "AddNodeInvalidParent": {"id": 24},
        "SubscribePortInvalidNode": {"id": 25},
        "IoOperationNotImplemented": {"id": 26},
        "InvalidComponentUsed": {"id": 27},
        "IoFailure": {"id": 28},
        "DeliverMessagesInvalidMessageId": {"id": 29},
        "NotSupported": {"id": 30},
        "MagicMatched": {"id": 31},
        "EndOfTransmission": {"id": 32},
        "IoInvalidValueSet": {"id": 33},
        "UnknownIoType": {"id": 34},
        "SubscribePortInvalidPort": {"id": 35},

        "User1": {"id": 100},
        "User2": {"id": 101},
        "User3": {"id": 102},
        "User4": {"id": 103},
        "User5": {"id": 104},
        "User6": {"id": 105},

        "Max": { "id": 255 }
    },
    "debugLevels": {
        "Invalid": {"id": 0},

        "Error": {"id": 1},
        "Info": {"id": 2},
        "Detailed": {"id": 3},
        "VeryDetailed": {"id": 4},

        "Max": {"id": 255}
    },
    "ioTypes": {
        "Invalid": {"id": 0},

        "Analog": {"id": 1},
        "Digital": {"id": 2},
        "TimeMs": {"id": 3},
        "PinMode": {"id": 4},

        "Max": {"id": 255}
    }
}

});
require.register("microflo-microflo-emscripten/componentlib-map.json", function(exports, require, module){
module.exports = {"components":{"AnalogRead":{"name":"AnalogRead","description":"Read analog value from pin. Value=[0-1023]","inports":null,"outports":null,"filename":"/home/jon/contrib/code/microflo/node_modules/microflo-core/components/AnalogRead.hpp","id":1,"inPorts":{"trigger":{"type":"all","description":"","id":0},"pin":{"type":"all","description":"","id":1}},"outPorts":{"out":{"type":"all","description":"","id":0}}},"ArduinoUno":{"name":"ArduinoUno","description":"Convenient definition of pins available on Arduino Uno","inports":null,"outports":null,"filename":"/home/jon/contrib/code/microflo/node_modules/microflo-core/components/ArduinoUno.hpp","id":2,"inPorts":{},"outPorts":{"pin0":{"type":"all","description":"","id":0},"pin1":{"type":"all","description":"","id":1},"pin2":{"type":"all","description":"","id":2},"pin3":{"type":"all","description":"","id":3},"pin4":{"type":"all","description":"","id":4},"pin5":{"type":"all","description":"","id":5},"pin6":{"type":"all","description":"","id":6},"pin7":{"type":"all","description":"","id":7},"pin8":{"type":"all","description":"","id":8},"pin9":{"type":"all","description":"","id":9},"pin10":{"type":"all","description":"","id":10},"pin11":{"type":"all","description":"","id":11},"pin12":{"type":"all","description":"","id":12},"pin13":{"type":"all","description":"","id":13},"pina0":{"type":"all","description":"","id":14},"pina1":{"type":"all","description":"","id":15},"pina2":{"type":"all","description":"","id":16},"pina3":{"type":"all","description":"","id":17},"pina4":{"type":"all","description":"","id":18},"pina5":{"type":"all","description":"","id":19}}},"BooleanAnd":{"name":"BooleanAnd","description":"Emits true if @a AND @b is true, else false","inports":null,"outports":null,"type":"pure2","filename":"/home/jon/contrib/code/microflo/node_modules/microflo-core/components/BooleanAnd.hpp","id":3,"inPorts":{"a":{"ctype":"bool","type":"all","description":"","id":0,"name":"a"},"b":{"ctype":"bool","type":"all","description":"","id":1}},"outPorts":{"out":{"type":"all","description":"","id":0}}},"BooleanOr":{"name":"BooleanOr","description":"Emits true if either @a OR @b is true, else false","inports":null,"outports":null,"type":"pure2","filename":"/home/jon/contrib/code/microflo/node_modules/microflo-core/components/BooleanOr.hpp","id":4,"inPorts":{"a":{"ctype":"bool","type":"all","description":"","id":0,"name":"a"},"b":{"ctype":"bool","type":"all","description":"","id":1}},"outPorts":{"out":{"type":"all","description":"","id":0}}},"BreakBeforeMake":{"name":"BreakBeforeMake","description":"Break-before-make switch logic. Monitor ports must be connected to form a feedback loop from what outputs are connected to","inports":null,"outports":null,"filename":"/home/jon/contrib/code/microflo/node_modules/microflo-core/components/BreakBeforeMake.hpp","id":5,"inPorts":{"in":{"type":"all","description":"","id":0},"monitor1":{"type":"all","description":"","id":1},"monitor2":{"type":"all","description":"","id":2}},"outPorts":{"out1":{"type":"all","description":"","id":0},"out2":{"type":"all","description":"","id":1}}},"Constrain":{"name":"Constrain","description":"Constraina a number within a the range [@lower,@upper]","inports":null,"outports":null,"filename":"/home/jon/contrib/code/microflo/node_modules/microflo-core/components/Constrain.hpp","id":6,"inPorts":{"in":{"type":"all","description":"","id":0},"lower":{"type":"all","description":"","id":1},"upper":{"type":"all","description":"","id":2}},"outPorts":{"out":{"type":"all","description":"","id":0}}},"Count":{"name":"Count","description":"Count upwards from 0, with step 1","inports":null,"outports":null,"filename":"/home/jon/contrib/code/microflo/node_modules/microflo-core/components/Count.hpp","id":7,"inPorts":{"in":{"type":"all","description":"","id":0},"reset":{"type":"all","description":"","id":1}},"outPorts":{"out":{"type":"all","description":"","id":0}}},"DigitalRead":{"name":"DigitalRead","description":"Read a boolean value from pin. Value is read on @trigger","inports":null,"outports":null,"filename":"/home/jon/contrib/code/microflo/node_modules/microflo-core/components/DigitalRead.hpp","id":8,"inPorts":{"trigger":{"type":"all","description":"","id":0},"pin":{"type":"all","description":"","id":1},"pullup":{"type":"all","description":"","id":2}},"outPorts":{"out":{"type":"all","description":"","id":0}}},"DigitalWrite":{"name":"DigitalWrite","description":"Write a boolean value to pin","inports":null,"outports":null,"filename":"/home/jon/contrib/code/microflo/node_modules/microflo-core/components/DigitalWrite.hpp","id":9,"inPorts":{"in":{"type":"all","description":"","id":0},"pin":{"type":"all","description":"","id":1}},"outPorts":{"out":{"type":"all","description":"","id":0}}},"Forward":{"name":"Forward","description":"Forward a packet from input to output","inports":null,"outports":null,"filename":"/home/jon/contrib/code/microflo/node_modules/microflo-core/components/Forward.hpp","id":10,"inPorts":{"in":{"type":"all","description":"","id":0}},"outPorts":{"out":{"type":"all","description":"","id":0}}},"Gate":{"name":"Gate","description":"Pass packets from @in to @out only if @enable is true","inports":null,"outports":null,"filename":"/home/jon/contrib/code/microflo/node_modules/microflo-core/components/Gate.hpp","id":11,"inPorts":{"in":{"type":"all","description":"","id":0},"enable":{"type":"all","description":"","id":1}},"outPorts":{"out":{"type":"all","description":"","id":0}}},"HysteresisLatch":{"name":"HysteresisLatch","description":"Emit true if @in < @highthreshold, false if @in < @lowthreshold, else keep previous state","inports":null,"outports":null,"filename":"/home/jon/contrib/code/microflo/node_modules/microflo-core/components/HysteresisLatch.hpp","id":12,"inPorts":{"in":{"type":"all","description":"","id":0},"lowthreshold":{"type":"all","description":"","id":1},"highthreshold":{"type":"all","description":"","id":2}},"outPorts":{"out":{"type":"all","description":"","id":0}}},"InvertBoolean":{"name":"InvertBoolean","description":"Invert incoming boolean value. Logical equivalent: NOT","inports":null,"outports":null,"filename":"/home/jon/contrib/code/microflo/node_modules/microflo-core/components/InvertBoolean.hpp","id":13,"inPorts":{"in":{"type":"all","description":"","id":0}},"outPorts":{"out":{"type":"all","description":"","id":0}}},"LedMatrixMax":{"name":"LedMatrixMax","description":"Set characters on MAX7219 display","inports":null,"outports":null,"filename":"/home/jon/contrib/code/microflo/node_modules/microflo-core/components/LedMatrixMax.hpp","id":14,"inPorts":{"in":{"type":"all","description":"","id":0},"pincs":{"type":"all","description":"","id":1},"pindin":{"type":"all","description":"","id":2},"pinclk":{"type":"all","description":"","id":3}},"outPorts":{"out":{"type":"all","description":"","id":0}}},"MapLinear":{"name":"MapLinear","description":"Map the integer @in from range [@inmin,@inmax] to [@outmin,@outmax]","inports":null,"outports":null,"filename":"/home/jon/contrib/code/microflo/node_modules/microflo-core/components/MapLinear.hpp","id":15,"inPorts":{"in":{"type":"all","description":"","id":0},"inmin":{"type":"all","description":"","id":1},"inmax":{"type":"all","description":"","id":2},"outmin":{"type":"all","description":"","id":3},"outmax":{"type":"all","description":"","id":4}},"outPorts":{"out":{"type":"all","description":"","id":0}}},"Max":{"name":"Max","description":"Emits maximum value of @in and @threshold","inports":null,"outports":null,"type":"pure2","filename":"/home/jon/contrib/code/microflo/node_modules/microflo-core/components/Max.hpp","id":16,"inPorts":{"in":{"ctype":"long","type":"all","description":"","id":0,"name":"in"},"threshold":{"ctype":"long","type":"all","description":"","id":1}},"outPorts":{"out":{"type":"all","description":"","id":0}}},"Min":{"name":"Min","description":"Emits minimum value of @in and @threshold","inports":null,"outports":null,"type":"pure2","filename":"/home/jon/contrib/code/microflo/node_modules/microflo-core/components/Min.hpp","id":17,"inPorts":{"in":{"ctype":"long","type":"all","description":"","id":0,"name":"in"},"threshold":{"ctype":"long","type":"all","description":"","id":1}},"outPorts":{"out":{"type":"all","description":"","id":0}}},"MonitorPin":{"name":"MonitorPin","description":"Emit a boolean value each time a pin changes state. Note: only pin 2/3 on Arduino Uno/Nano supported.","inports":null,"outports":null,"filename":"/home/jon/contrib/code/microflo/node_modules/microflo-core/components/MonitorPin.hpp","id":18,"inPorts":{"pin":{"type":"all","description":"","id":0}},"outPorts":{"out":{"type":"all","description":"","id":0}}},"NumberEquals":{"name":"NumberEquals","description":"Emits true if @a EQUALS @b is true, else false","inports":null,"outports":null,"type":"pure2","filename":"/home/jon/contrib/code/microflo/node_modules/microflo-core/components/NumberEquals.hpp","id":19,"inPorts":{"a":{"ctype":"long","type":"all","description":"","id":0,"name":"a"},"b":{"ctype":"long","type":"all","description":"","id":1}},"outPorts":{"out":{"type":"all","description":"","id":0}}},"PwmWrite":{"name":"PwmWrite","description":"Set duty cycle [0-100%] of PWM pin","inports":null,"outports":null,"filename":"/home/jon/contrib/code/microflo/node_modules/microflo-core/components/PwmWrite.hpp","id":20,"inPorts":{"dutycycle":{"type":"all","description":"","id":0},"pin":{"type":"all","description":"","id":1}},"outPorts":{"out":{"type":"all","description":"","id":0}}},"ReadCapacitivePin":{"name":"ReadCapacitivePin","description":"Emits true if measured capacitance (in iterations) on @pin exceeds @threshold","inports":null,"outports":null,"filename":"/home/jon/contrib/code/microflo/node_modules/microflo-core/components/ReadCapacitivePin.hpp","id":21,"inPorts":{"trigger":{"type":"all","description":"","id":0},"pin":{"type":"all","description":"","id":1},"threshold":{"type":"all","description":"","id":2}},"outPorts":{"out":{"type":"all","description":"","id":0}}},"Route":{"name":"Route","description":"Pass packets to @out from input port number @port","inports":null,"outports":null,"filename":"/home/jon/contrib/code/microflo/node_modules/microflo-core/components/Route.hpp","id":22,"inPorts":{"port":{"type":"all","description":"","id":0},"in1":{"type":"all","description":"","id":1},"in2":{"type":"all","description":"","id":2},"in3":{"type":"all","description":"","id":3},"in4":{"type":"all","description":"","id":4},"in5":{"type":"all","description":"","id":5},"in6":{"type":"all","description":"","id":6},"in7":{"type":"all","description":"","id":7},"in8":{"type":"all","description":"","id":8},"in9":{"type":"all","description":"","id":9}},"outPorts":{"out":{"type":"all","description":"","id":0}}},"SerialIn":{"name":"SerialIn","description":"Emit packets read from serial port (0). Warning: may interfere with MicroFlo UI usage","inports":null,"outports":null,"filename":"/home/jon/contrib/code/microflo/node_modules/microflo-core/components/SerialIn.hpp","id":23,"inPorts":{"in":{"type":"all","description":"","id":0}},"outPorts":{"out":{"type":"all","description":"","id":0}}},"SerialOut":{"name":"SerialOut","description":"Write input packets to serial port (0). Warning: may interfere with MicroFlo UI usage","inports":null,"outports":null,"filename":"/home/jon/contrib/code/microflo/node_modules/microflo-core/components/SerialOut.hpp","id":24,"inPorts":{"in":{"type":"all","description":"","id":0}},"outPorts":{"out":{"type":"all","description":"","id":0}}},"Split":{"name":"Split","description":"Emit incoming packets on all output ports","inports":null,"outports":null,"filename":"/home/jon/contrib/code/microflo/node_modules/microflo-core/components/Split.hpp","id":25,"inPorts":{"in":{"type":"all","description":"","id":0}},"outPorts":{"out1":{"type":"all","description":"","id":0},"out2":{"type":"all","description":"","id":1},"out3":{"type":"all","description":"","id":2},"out4":{"type":"all","description":"","id":3},"out5":{"type":"all","description":"","id":4},"out6":{"type":"all","description":"","id":5},"out7":{"type":"all","description":"","id":6},"out8":{"type":"all","description":"","id":7},"out9":{"type":"all","description":"","id":8}}},"SubGraph":{"name":"SubGraph","description":"Not for normal use. Used internally for handling subgraphs","inports":null,"outports":null,"filename":"/home/jon/contrib/code/microflo/node_modules/microflo-core/components/SubGraph.hpp","id":26,"inPorts":{},"outPorts":{}},"Timer":{"name":"Timer","description":"Emit a packet every @interval milliseconds","inports":null,"outports":null,"filename":"/home/jon/contrib/code/microflo/node_modules/microflo-core/components/Timer.hpp","id":27,"inPorts":{"interval":{"type":"all","description":"","id":0},"reset":{"type":"all","description":"","id":1}},"outPorts":{"out":{"type":"all","description":"","id":0}}},"ToggleBoolean":{"name":"ToggleBoolean","description":"Invert output packet everytime an input packet arrives. Output defaults to false","inports":null,"outports":null,"filename":"/home/jon/contrib/code/microflo/node_modules/microflo-core/components/ToggleBoolean.hpp","id":28,"inPorts":{"in":{"type":"all","description":"","id":0},"reset":{"type":"all","description":"","id":1}},"outPorts":{"out":{"type":"all","description":"","id":0}}},"BoolToInt":{"name":"BoolToInt","description":"Convert boolean input to integer. true->1, false->0","inports":null,"outports":null,"filename":"/home/jon/contrib/code/microflo/node_modules/microflo-core/components/BoolToInt.hpp","id":29,"inPorts":{"in":{"type":"all","description":"","id":0}},"outPorts":{"out":{"type":"all","description":"","id":0}}}}}
});

require.register("flowbased-fbp-protocol-client/component.json", function(exports, require, module){
module.exports = {
  "name": "fbp-protocol-client",
  "description": "Client library for the FBP protocol",
  "author": "Henri Bergius <henri.bergius@iki.fi>",
  "repo": "flowbased/fbp-protocol-client",
  "version": "0.1.2",
  "keywords": [],
  "dependencies": {
    "noflo/noflo": "*",
    "microflo/microflo": "*",
    "microflo/microflo-emscripten": "*",
    "component/emitter": "*"
  },
  "remotes": [
    "https://raw.githubusercontent.com"
  ],
  "scripts": [
    "helpers/platform.js",
    "helpers/connection.js",
    "src/base.js",
    "src/iframe.js",
    "src/websocket.js",
    "src/microflo.js",
    "src/webrtc.js",
    "index.js"
  ],
  "json": [
    "component.json"
  ]
}

});

require.register("jonnor-js-yaml/component.json", function(exports, require, module){
module.exports = {
  "name": "js-yaml",
  "description": "YAML parser",
  "author": "",
  "repo": "jonnor/js-yaml",
  "version": "3.3.1",
  "main": "dist/js-yaml.js",
  "keywords": [],
  "dependencies": {
  },
  "remotes": [
    "https://raw.githubusercontent.com"
  ],
  "scripts": [
    "dist/js-yaml.js"
  ],
  "json": [
    "component.json"
  ]
}

});
require.register("jonnor-chai/component.json", function(exports, require, module){
module.exports = {
  "name": "chai",
  "description": "Assertion framework",
  "author": "",
  "repo": "jonnor/chai",
  "version": "3.2.0",
  "main": "chai.js",
  "keywords": [],
  "dependencies": {
  },
  "remotes": [
    "https://raw.githubusercontent.com"
  ],
  "scripts": [
    "chai.js"
  ],
  "json": [
    "component.json"
  ]
}

});
require.register("jonnor-jsonpath/component.json", function(exports, require, module){
module.exports = {
  "name": "JSONPath",
  "description": "JSONPath for JavaScript",
  "author": "",
  "repo": "jonnor/JSONPaths",
  "version": "0.11.0",
  "main": "lib/jsonpath.js",
  "keywords": [],
  "dependencies": {
  },
  "remotes": [
    "https://raw.githubusercontent.com"
  ],
  "scripts": [
    "lib/jsonpath.js"
  ],
  "json": [
    "component.json"
  ]
}

});
















require.alias("flowbased-fbp-protocol-client/helpers/platform.js", "fbp-spec/deps/fbp-protocol-client/helpers/platform.js");
require.alias("flowbased-fbp-protocol-client/helpers/connection.js", "fbp-spec/deps/fbp-protocol-client/helpers/connection.js");
require.alias("flowbased-fbp-protocol-client/src/base.js", "fbp-spec/deps/fbp-protocol-client/src/base.js");
require.alias("flowbased-fbp-protocol-client/src/iframe.js", "fbp-spec/deps/fbp-protocol-client/src/iframe.js");
require.alias("flowbased-fbp-protocol-client/src/websocket.js", "fbp-spec/deps/fbp-protocol-client/src/websocket.js");
require.alias("flowbased-fbp-protocol-client/src/microflo.js", "fbp-spec/deps/fbp-protocol-client/src/microflo.js");
require.alias("flowbased-fbp-protocol-client/src/webrtc.js", "fbp-spec/deps/fbp-protocol-client/src/webrtc.js");
require.alias("flowbased-fbp-protocol-client/index.js", "fbp-spec/deps/fbp-protocol-client/index.js");
require.alias("flowbased-fbp-protocol-client/index.js", "fbp-protocol-client/index.js");
require.alias("noflo-noflo/src/lib/Graph.js", "flowbased-fbp-protocol-client/deps/noflo/src/lib/Graph.js");
require.alias("noflo-noflo/src/lib/InternalSocket.js", "flowbased-fbp-protocol-client/deps/noflo/src/lib/InternalSocket.js");
require.alias("noflo-noflo/src/lib/IP.js", "flowbased-fbp-protocol-client/deps/noflo/src/lib/IP.js");
require.alias("noflo-noflo/src/lib/BasePort.js", "flowbased-fbp-protocol-client/deps/noflo/src/lib/BasePort.js");
require.alias("noflo-noflo/src/lib/InPort.js", "flowbased-fbp-protocol-client/deps/noflo/src/lib/InPort.js");
require.alias("noflo-noflo/src/lib/OutPort.js", "flowbased-fbp-protocol-client/deps/noflo/src/lib/OutPort.js");
require.alias("noflo-noflo/src/lib/Ports.js", "flowbased-fbp-protocol-client/deps/noflo/src/lib/Ports.js");
require.alias("noflo-noflo/src/lib/Port.js", "flowbased-fbp-protocol-client/deps/noflo/src/lib/Port.js");
require.alias("noflo-noflo/src/lib/ArrayPort.js", "flowbased-fbp-protocol-client/deps/noflo/src/lib/ArrayPort.js");
require.alias("noflo-noflo/src/lib/Component.js", "flowbased-fbp-protocol-client/deps/noflo/src/lib/Component.js");
require.alias("noflo-noflo/src/lib/AsyncComponent.js", "flowbased-fbp-protocol-client/deps/noflo/src/lib/AsyncComponent.js");
require.alias("noflo-noflo/src/lib/ComponentLoader.js", "flowbased-fbp-protocol-client/deps/noflo/src/lib/ComponentLoader.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "flowbased-fbp-protocol-client/deps/noflo/src/lib/NoFlo.js");
require.alias("noflo-noflo/src/lib/Network.js", "flowbased-fbp-protocol-client/deps/noflo/src/lib/Network.js");
require.alias("noflo-noflo/src/lib/Platform.js", "flowbased-fbp-protocol-client/deps/noflo/src/lib/Platform.js");
require.alias("noflo-noflo/src/lib/Journal.js", "flowbased-fbp-protocol-client/deps/noflo/src/lib/Journal.js");
require.alias("noflo-noflo/src/lib/Utils.js", "flowbased-fbp-protocol-client/deps/noflo/src/lib/Utils.js");
require.alias("noflo-noflo/src/lib/Helpers.js", "flowbased-fbp-protocol-client/deps/noflo/src/lib/Helpers.js");
require.alias("noflo-noflo/src/lib/Streams.js", "flowbased-fbp-protocol-client/deps/noflo/src/lib/Streams.js");
require.alias("noflo-noflo/src/components/Graph.js", "flowbased-fbp-protocol-client/deps/noflo/src/components/Graph.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "flowbased-fbp-protocol-client/deps/noflo/index.js");
require.alias("bergie-emitter/index.js", "noflo-noflo/deps/events/index.js");

require.alias("jashkenas-underscore/underscore.js", "noflo-noflo/deps/underscore/underscore.js");
require.alias("jashkenas-underscore/underscore.js", "noflo-noflo/deps/underscore/index.js");
require.alias("jashkenas-underscore/underscore.js", "jashkenas-underscore/index.js");
require.alias("flowbased-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/lib/fbp.js");
require.alias("flowbased-fbp/lib/fbp.js", "noflo-noflo/deps/fbp/index.js");
require.alias("flowbased-fbp/lib/fbp.js", "flowbased-fbp/index.js");
require.alias("noflo-noflo/src/lib/NoFlo.js", "noflo-noflo/index.js");
require.alias("microflo-microflo/lib/commandformat.js", "flowbased-fbp-protocol-client/deps/microflo/lib/commandformat.js");
require.alias("microflo-microflo/lib/commandstream.js", "flowbased-fbp-protocol-client/deps/microflo/lib/commandstream.js");
require.alias("microflo-microflo/lib/componentlib.js", "flowbased-fbp-protocol-client/deps/microflo/lib/componentlib.js");
require.alias("microflo-microflo/lib/generate.js", "flowbased-fbp-protocol-client/deps/microflo/lib/generate.js");
require.alias("microflo-microflo/lib/microflo.js", "flowbased-fbp-protocol-client/deps/microflo/lib/microflo.js");
require.alias("microflo-microflo/lib/serial.js", "flowbased-fbp-protocol-client/deps/microflo/lib/serial.js");
require.alias("microflo-microflo/lib/simulator.js", "flowbased-fbp-protocol-client/deps/microflo/lib/simulator.js");
require.alias("microflo-microflo/lib/util.js", "flowbased-fbp-protocol-client/deps/microflo/lib/util.js");
require.alias("microflo-microflo/lib/devicecommunication.js", "flowbased-fbp-protocol-client/deps/microflo/lib/devicecommunication.js");
require.alias("microflo-microflo/lib/flash.js", "flowbased-fbp-protocol-client/deps/microflo/lib/flash.js");
require.alias("microflo-microflo/lib/definition.js", "flowbased-fbp-protocol-client/deps/microflo/lib/definition.js");
require.alias("microflo-microflo/lib/runtime.js", "flowbased-fbp-protocol-client/deps/microflo/lib/runtime.js");
require.alias("microflo-microflo/lib/microflo.js", "flowbased-fbp-protocol-client/deps/microflo/index.js");
require.alias("component-emitter/index.js", "microflo-microflo/deps/emitter/index.js");

require.alias("the-grid-flowhub-registry/index.js", "microflo-microflo/deps/flowhub-registry/index.js");
require.alias("visionmedia-superagent/lib/client.js", "the-grid-flowhub-registry/deps/superagent/lib/client.js");
require.alias("visionmedia-superagent/lib/client.js", "the-grid-flowhub-registry/deps/superagent/index.js");
require.alias("component-emitter/index.js", "visionmedia-superagent/deps/emitter/index.js");

require.alias("component-reduce/index.js", "visionmedia-superagent/deps/reduce/index.js");

require.alias("visionmedia-superagent/lib/client.js", "visionmedia-superagent/index.js");
require.alias("noflo-fbp/lib/fbp.js", "microflo-microflo/deps/fbp/lib/fbp.js");
require.alias("noflo-fbp/lib/fbp.js", "microflo-microflo/deps/fbp/index.js");
require.alias("noflo-fbp/lib/fbp.js", "noflo-fbp/index.js");
require.alias("jonnor-buffer/index.js", "microflo-microflo/deps/buffer/index.js");
require.alias("jonnor-buffer/index.js", "microflo-microflo/deps/buffer/index.js");
require.alias("jonnor-ieee754/index.js", "jonnor-buffer/deps/ieee754/index.js");
require.alias("jonnor-ieee754/index.js", "jonnor-buffer/deps/ieee754/index.js");
require.alias("jonnor-ieee754/index.js", "jonnor-ieee754/index.js");
require.alias("jonnor-base64-js/lib/b64.js", "jonnor-buffer/deps/base64-js/lib/b64.js");
require.alias("jonnor-base64-js/lib/b64.js", "jonnor-buffer/deps/base64-js/index.js");
require.alias("jonnor-base64-js/lib/b64.js", "jonnor-base64-js/index.js");
require.alias("jonnor-buffer/index.js", "jonnor-buffer/index.js");
require.alias("microflo-microflo/lib/microflo.js", "microflo-microflo/index.js");
require.alias("microflo-microflo-emscripten/microflo-runtime.js", "flowbased-fbp-protocol-client/deps/microflo-emscripten/microflo-runtime.js");
require.alias("microflo-microflo-emscripten/index.js", "flowbased-fbp-protocol-client/deps/microflo-emscripten/index.js");

require.alias("component-emitter/index.js", "flowbased-fbp-protocol-client/deps/emitter/index.js");

require.alias("flowbased-fbp/lib/fbp.js", "fbp-spec/deps/fbp/lib/fbp.js");
require.alias("flowbased-fbp/lib/fbp.js", "fbp-spec/deps/fbp/index.js");
require.alias("flowbased-fbp/lib/fbp.js", "fbp/index.js");
require.alias("flowbased-fbp/lib/fbp.js", "flowbased-fbp/index.js");
require.alias("jonnor-js-yaml/dist/js-yaml.js", "fbp-spec/deps/js-yaml/dist/js-yaml.js");
require.alias("jonnor-js-yaml/dist/js-yaml.js", "fbp-spec/deps/js-yaml/index.js");
require.alias("jonnor-js-yaml/dist/js-yaml.js", "js-yaml/index.js");
require.alias("jonnor-js-yaml/dist/js-yaml.js", "jonnor-js-yaml/index.js");
require.alias("jonnor-chai/chai.js", "fbp-spec/deps/chai/chai.js");
require.alias("jonnor-chai/chai.js", "fbp-spec/deps/chai/index.js");
require.alias("jonnor-chai/chai.js", "chai/index.js");
require.alias("jonnor-chai/chai.js", "jonnor-chai/index.js");
require.alias("jonnor-jsonpath/lib/jsonpath.js", "fbp-spec/deps/JSONPath/lib/jsonpath.js");
require.alias("jonnor-jsonpath/lib/jsonpath.js", "fbp-spec/deps/JSONPath/index.js");
require.alias("jonnor-jsonpath/lib/jsonpath.js", "JSONPath/index.js");
require.alias("jonnor-jsonpath/lib/jsonpath.js", "jonnor-jsonpath/index.js");
require.alias("geraintluff-tv4/tv4.js", "fbp-spec/deps/tv4/tv4.js");
require.alias("geraintluff-tv4/lang/de.js", "fbp-spec/deps/tv4/lang/de.js");
require.alias("geraintluff-tv4/lang/fr.js", "fbp-spec/deps/tv4/lang/fr.js");
require.alias("geraintluff-tv4/lang/nb.js", "fbp-spec/deps/tv4/lang/nb.js");
require.alias("geraintluff-tv4/lang/pl-PL.js", "fbp-spec/deps/tv4/lang/pl-PL.js");
require.alias("geraintluff-tv4/lang/pt-PT.js", "fbp-spec/deps/tv4/lang/pt-PT.js");
require.alias("geraintluff-tv4/lang/sv-SE.js", "fbp-spec/deps/tv4/lang/sv-SE.js");
require.alias("geraintluff-tv4/lang/zh-CN.js", "fbp-spec/deps/tv4/lang/zh-CN.js");
require.alias("geraintluff-tv4/tv4.js", "fbp-spec/deps/tv4/index.js");
require.alias("geraintluff-tv4/tv4.js", "tv4/index.js");
require.alias("geraintluff-tv4/tv4.js", "geraintluff-tv4/index.js");
require.alias("visionmedia-debug/browser.js", "fbp-spec/deps/debug/browser.js");
require.alias("visionmedia-debug/debug.js", "fbp-spec/deps/debug/debug.js");
require.alias("visionmedia-debug/browser.js", "fbp-spec/deps/debug/index.js");
require.alias("visionmedia-debug/browser.js", "debug/index.js");
require.alias("rauchg-ms.js/index.js", "visionmedia-debug/deps/ms/index.js");

require.alias("visionmedia-debug/browser.js", "visionmedia-debug/index.js");
require.alias("fbp-spec/src/index.js", "fbp-spec/index.js");